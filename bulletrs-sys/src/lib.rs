/* automatically generated by rust-bindgen */

pub const SHARED_MEMORY_KEY: ::std::os::raw::c_uint = 12347;
pub const SHARED_MEMORY_MAGIC_NUMBER: ::std::os::raw::c_uint = 201708270;
pub const MAX_VR_BUTTONS: ::std::os::raw::c_uint = 64;
pub const MAX_VR_CONTROLLERS: ::std::os::raw::c_uint = 8;
pub const MAX_RAY_INTERSECTION_BATCH_SIZE: ::std::os::raw::c_uint = 256;
pub const MAX_RAY_HITS: ::std::os::raw::c_uint = 256;
pub const MAX_KEYBOARD_EVENTS: ::std::os::raw::c_uint = 256;
pub const MAX_MOUSE_EVENTS: ::std::os::raw::c_uint = 256;
pub const VISUAL_SHAPE_MAX_PATH_LEN: ::std::os::raw::c_uint = 1024;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum EnumSharedMemoryClientCommand {
    CMD_LOAD_SDF = 0,
    CMD_LOAD_URDF = 1,
    CMD_LOAD_BULLET = 2,
    CMD_SAVE_BULLET = 3,
    CMD_LOAD_MJCF = 4,
    CMD_LOAD_BUNNY = 5,
    CMD_SEND_BULLET_DATA_STREAM = 6,
    CMD_CREATE_BOX_COLLISION_SHAPE = 7,
    CMD_CREATE_RIGID_BODY = 8,
    CMD_DELETE_RIGID_BODY = 9,
    CMD_CREATE_SENSOR = 10,
    CMD_INIT_POSE = 11,
    CMD_SEND_PHYSICS_SIMULATION_PARAMETERS = 12,
    CMD_SEND_DESIRED_STATE = 13,
    CMD_REQUEST_ACTUAL_STATE = 14,
    CMD_REQUEST_DEBUG_LINES = 15,
    CMD_REQUEST_BODY_INFO = 16,
    CMD_REQUEST_INTERNAL_DATA = 17,
    CMD_STEP_FORWARD_SIMULATION = 18,
    CMD_RESET_SIMULATION = 19,
    CMD_PICK_BODY = 20,
    CMD_MOVE_PICKED_BODY = 21,
    CMD_REMOVE_PICKING_CONSTRAINT_BODY = 22,
    CMD_REQUEST_CAMERA_IMAGE_DATA = 23,
    CMD_APPLY_EXTERNAL_FORCE = 24,
    CMD_CALCULATE_INVERSE_DYNAMICS = 25,
    CMD_CALCULATE_INVERSE_KINEMATICS = 26,
    CMD_CALCULATE_JACOBIAN = 27,
    CMD_USER_CONSTRAINT = 28,
    CMD_REQUEST_CONTACT_POINT_INFORMATION = 29,
    CMD_REQUEST_RAY_CAST_INTERSECTIONS = 30,
    CMD_REQUEST_AABB_OVERLAP = 31,
    CMD_SAVE_WORLD = 32,
    CMD_REQUEST_VISUAL_SHAPE_INFO = 33,
    CMD_UPDATE_VISUAL_SHAPE = 34,
    CMD_LOAD_TEXTURE = 35,
    CMD_SET_SHADOW = 36,
    CMD_USER_DEBUG_DRAW = 37,
    CMD_REQUEST_VR_EVENTS_DATA = 38,
    CMD_SET_VR_CAMERA_STATE = 39,
    CMD_SYNC_BODY_INFO = 40,
    CMD_STATE_LOGGING = 41,
    CMD_CONFIGURE_OPENGL_VISUALIZER = 42,
    CMD_REQUEST_KEYBOARD_EVENTS_DATA = 43,
    CMD_REQUEST_OPENGL_VISUALIZER_CAMERA = 44,
    CMD_REMOVE_BODY = 45,
    CMD_CHANGE_DYNAMICS_INFO = 46,
    CMD_GET_DYNAMICS_INFO = 47,
    CMD_PROFILE_TIMING = 48,
    CMD_CREATE_COLLISION_SHAPE = 49,
    CMD_CREATE_VISUAL_SHAPE = 50,
    CMD_CREATE_MULTI_BODY = 51,
    CMD_REQUEST_COLLISION_INFO = 52,
    CMD_REQUEST_MOUSE_EVENTS_DATA = 53,
    CMD_CHANGE_TEXTURE = 54,
    CMD_SET_ADDITIONAL_SEARCH_PATH = 55,
    CMD_MAX_CLIENT_COMMANDS = 56,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum EnumSharedMemoryServerStatus {
    CMD_SHARED_MEMORY_NOT_INITIALIZED = 0,
    CMD_WAITING_FOR_CLIENT_COMMAND = 1,
    CMD_CLIENT_COMMAND_COMPLETED = 2,
    CMD_UNKNOWN_COMMAND_FLUSHED = 3,
    CMD_SDF_LOADING_COMPLETED = 4,
    CMD_SDF_LOADING_FAILED = 5,
    CMD_URDF_LOADING_COMPLETED = 6,
    CMD_URDF_LOADING_FAILED = 7,
    CMD_BULLET_LOADING_COMPLETED = 8,
    CMD_BULLET_LOADING_FAILED = 9,
    CMD_BULLET_SAVING_COMPLETED = 10,
    CMD_BULLET_SAVING_FAILED = 11,
    CMD_MJCF_LOADING_COMPLETED = 12,
    CMD_MJCF_LOADING_FAILED = 13,
    CMD_REQUEST_INTERNAL_DATA_COMPLETED = 14,
    CMD_REQUEST_INTERNAL_DATA_FAILED = 15,
    CMD_BULLET_DATA_STREAM_RECEIVED_COMPLETED = 16,
    CMD_BULLET_DATA_STREAM_RECEIVED_FAILED = 17,
    CMD_BOX_COLLISION_SHAPE_CREATION_COMPLETED = 18,
    CMD_RIGID_BODY_CREATION_COMPLETED = 19,
    CMD_SET_JOINT_FEEDBACK_COMPLETED = 20,
    CMD_ACTUAL_STATE_UPDATE_COMPLETED = 21,
    CMD_ACTUAL_STATE_UPDATE_FAILED = 22,
    CMD_DEBUG_LINES_COMPLETED = 23,
    CMD_DEBUG_LINES_OVERFLOW_FAILED = 24,
    CMD_DESIRED_STATE_RECEIVED_COMPLETED = 25,
    CMD_STEP_FORWARD_SIMULATION_COMPLETED = 26,
    CMD_RESET_SIMULATION_COMPLETED = 27,
    CMD_CAMERA_IMAGE_COMPLETED = 28,
    CMD_CAMERA_IMAGE_FAILED = 29,
    CMD_BODY_INFO_COMPLETED = 30,
    CMD_BODY_INFO_FAILED = 31,
    CMD_INVALID_STATUS = 32,
    CMD_CALCULATED_INVERSE_DYNAMICS_COMPLETED = 33,
    CMD_CALCULATED_INVERSE_DYNAMICS_FAILED = 34,
    CMD_CALCULATED_JACOBIAN_COMPLETED = 35,
    CMD_CALCULATED_JACOBIAN_FAILED = 36,
    CMD_CONTACT_POINT_INFORMATION_COMPLETED = 37,
    CMD_CONTACT_POINT_INFORMATION_FAILED = 38,
    CMD_REQUEST_AABB_OVERLAP_COMPLETED = 39,
    CMD_REQUEST_AABB_OVERLAP_FAILED = 40,
    CMD_CALCULATE_INVERSE_KINEMATICS_COMPLETED = 41,
    CMD_CALCULATE_INVERSE_KINEMATICS_FAILED = 42,
    CMD_SAVE_WORLD_COMPLETED = 43,
    CMD_SAVE_WORLD_FAILED = 44,
    CMD_VISUAL_SHAPE_INFO_COMPLETED = 45,
    CMD_VISUAL_SHAPE_INFO_FAILED = 46,
    CMD_VISUAL_SHAPE_UPDATE_COMPLETED = 47,
    CMD_VISUAL_SHAPE_UPDATE_FAILED = 48,
    CMD_LOAD_TEXTURE_COMPLETED = 49,
    CMD_LOAD_TEXTURE_FAILED = 50,
    CMD_USER_DEBUG_DRAW_COMPLETED = 51,
    CMD_USER_DEBUG_DRAW_PARAMETER_COMPLETED = 52,
    CMD_USER_DEBUG_DRAW_FAILED = 53,
    CMD_USER_CONSTRAINT_COMPLETED = 54,
    CMD_USER_CONSTRAINT_INFO_COMPLETED = 55,
    CMD_REMOVE_USER_CONSTRAINT_COMPLETED = 56,
    CMD_CHANGE_USER_CONSTRAINT_COMPLETED = 57,
    CMD_REMOVE_USER_CONSTRAINT_FAILED = 58,
    CMD_CHANGE_USER_CONSTRAINT_FAILED = 59,
    CMD_USER_CONSTRAINT_FAILED = 60,
    CMD_REQUEST_VR_EVENTS_DATA_COMPLETED = 61,
    CMD_REQUEST_RAY_CAST_INTERSECTIONS_COMPLETED = 62,
    CMD_SYNC_BODY_INFO_COMPLETED = 63,
    CMD_SYNC_BODY_INFO_FAILED = 64,
    CMD_STATE_LOGGING_COMPLETED = 65,
    CMD_STATE_LOGGING_START_COMPLETED = 66,
    CMD_STATE_LOGGING_FAILED = 67,
    CMD_REQUEST_KEYBOARD_EVENTS_DATA_COMPLETED = 68,
    CMD_REQUEST_KEYBOARD_EVENTS_DATA_FAILED = 69,
    CMD_REQUEST_OPENGL_VISUALIZER_CAMERA_FAILED = 70,
    CMD_REQUEST_OPENGL_VISUALIZER_CAMERA_COMPLETED = 71,
    CMD_REMOVE_BODY_COMPLETED = 72,
    CMD_REMOVE_BODY_FAILED = 73,
    CMD_GET_DYNAMICS_INFO_COMPLETED = 74,
    CMD_GET_DYNAMICS_INFO_FAILED = 75,
    CMD_CREATE_COLLISION_SHAPE_FAILED = 76,
    CMD_CREATE_COLLISION_SHAPE_COMPLETED = 77,
    CMD_CREATE_VISUAL_SHAPE_FAILED = 78,
    CMD_CREATE_VISUAL_SHAPE_COMPLETED = 79,
    CMD_CREATE_MULTI_BODY_FAILED = 80,
    CMD_CREATE_MULTI_BODY_COMPLETED = 81,
    CMD_REQUEST_COLLISION_INFO_COMPLETED = 82,
    CMD_REQUEST_COLLISION_INFO_FAILED = 83,
    CMD_REQUEST_MOUSE_EVENTS_DATA_COMPLETED = 84,
    CMD_CHANGE_TEXTURE_COMMAND_FAILED = 85,
    CMD_MAX_SERVER_COMMANDS = 86,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum JointInfoFlags { JOINT_HAS_MOTORIZED_POWER = 1, }
pub const COLLISION_SHAPE_TYPE_BOX: _bindgen_ty_1 =
    _bindgen_ty_1::COLLISION_SHAPE_TYPE_BOX;
pub const COLLISION_SHAPE_TYPE_CYLINDER_X: _bindgen_ty_1 =
    _bindgen_ty_1::COLLISION_SHAPE_TYPE_CYLINDER_X;
pub const COLLISION_SHAPE_TYPE_CYLINDER_Y: _bindgen_ty_1 =
    _bindgen_ty_1::COLLISION_SHAPE_TYPE_CYLINDER_Y;
pub const COLLISION_SHAPE_TYPE_CYLINDER_Z: _bindgen_ty_1 =
    _bindgen_ty_1::COLLISION_SHAPE_TYPE_CYLINDER_Z;
pub const COLLISION_SHAPE_TYPE_CAPSULE_X: _bindgen_ty_1 =
    _bindgen_ty_1::COLLISION_SHAPE_TYPE_CAPSULE_X;
pub const COLLISION_SHAPE_TYPE_CAPSULE_Y: _bindgen_ty_1 =
    _bindgen_ty_1::COLLISION_SHAPE_TYPE_CAPSULE_Y;
pub const COLLISION_SHAPE_TYPE_CAPSULE_Z: _bindgen_ty_1 =
    _bindgen_ty_1::COLLISION_SHAPE_TYPE_CAPSULE_Z;
pub const COLLISION_SHAPE_TYPE_SPHERE: _bindgen_ty_1 =
    _bindgen_ty_1::COLLISION_SHAPE_TYPE_SPHERE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    COLLISION_SHAPE_TYPE_BOX = 1,
    COLLISION_SHAPE_TYPE_CYLINDER_X = 2,
    COLLISION_SHAPE_TYPE_CYLINDER_Y = 3,
    COLLISION_SHAPE_TYPE_CYLINDER_Z = 4,
    COLLISION_SHAPE_TYPE_CAPSULE_X = 5,
    COLLISION_SHAPE_TYPE_CAPSULE_Y = 6,
    COLLISION_SHAPE_TYPE_CAPSULE_Z = 7,
    COLLISION_SHAPE_TYPE_SPHERE = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum JointType {
    eRevoluteType = 0,
    ePrismaticType = 1,
    eSphericalType = 2,
    ePlanarType = 3,
    eFixedType = 4,
    ePoint2PointType = 5,
    eGearType = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum b3JointInfoFlags {
    eJointChangeMaxForce = 1,
    eJointChangeChildFramePosition = 2,
    eJointChangeChildFrameOrientation = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3JointInfo {
    pub m_linkName: *mut ::std::os::raw::c_char,
    pub m_jointName: *mut ::std::os::raw::c_char,
    pub m_jointType: ::std::os::raw::c_int,
    pub m_qIndex: ::std::os::raw::c_int,
    pub m_uIndex: ::std::os::raw::c_int,
    pub m_jointIndex: ::std::os::raw::c_int,
    pub m_flags: ::std::os::raw::c_int,
    pub m_jointDamping: f64,
    pub m_jointFriction: f64,
    pub m_jointLowerLimit: f64,
    pub m_jointUpperLimit: f64,
    pub m_jointMaxForce: f64,
    pub m_jointMaxVelocity: f64,
    pub m_parentFrame: [f64; 7usize],
    pub m_childFrame: [f64; 7usize],
    pub m_jointAxis: [f64; 3usize],
}
#[test]
fn bindgen_test_layout_b3JointInfo() {
    assert_eq!(::std::mem::size_of::<b3JointInfo>() , 224usize , concat ! (
               "Size of: " , stringify ! ( b3JointInfo ) ));
    assert_eq! (::std::mem::align_of::<b3JointInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( b3JointInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_linkName as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_linkName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_jointName as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_jointName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_jointType as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_jointType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_qIndex as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_qIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_uIndex as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_uIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_jointIndex as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_jointIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_flags as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_jointDamping as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_jointDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_jointFriction as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_jointFriction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_jointLowerLimit as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_jointLowerLimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_jointUpperLimit as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_jointUpperLimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_jointMaxForce as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_jointMaxForce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_jointMaxVelocity as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_jointMaxVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_parentFrame as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_parentFrame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_childFrame as * const
                _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_childFrame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointInfo ) ) . m_jointAxis as * const
                _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointInfo ) , "::" ,
                stringify ! ( m_jointAxis ) ));
}
impl Clone for b3JointInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3UserConstraint {
    pub m_parentBodyIndex: ::std::os::raw::c_int,
    pub m_parentJointIndex: ::std::os::raw::c_int,
    pub m_childBodyIndex: ::std::os::raw::c_int,
    pub m_childJointIndex: ::std::os::raw::c_int,
    pub m_parentFrame: [f64; 7usize],
    pub m_childFrame: [f64; 7usize],
    pub m_jointAxis: [f64; 3usize],
    pub m_jointType: ::std::os::raw::c_int,
    pub m_maxAppliedForce: f64,
    pub m_userConstraintUniqueId: ::std::os::raw::c_int,
    pub m_gearRatio: f64,
    pub m_gearAuxLink: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3UserConstraint() {
    assert_eq!(::std::mem::size_of::<b3UserConstraint>() , 192usize , concat !
               ( "Size of: " , stringify ! ( b3UserConstraint ) ));
    assert_eq! (::std::mem::align_of::<b3UserConstraint>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( b3UserConstraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3UserConstraint ) ) . m_parentBodyIndex
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3UserConstraint ) ,
                "::" , stringify ! ( m_parentBodyIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3UserConstraint ) ) . m_parentJointIndex
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( b3UserConstraint ) ,
                "::" , stringify ! ( m_parentJointIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3UserConstraint ) ) . m_childBodyIndex
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( b3UserConstraint ) ,
                "::" , stringify ! ( m_childBodyIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3UserConstraint ) ) . m_childJointIndex
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( b3UserConstraint ) ,
                "::" , stringify ! ( m_childJointIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3UserConstraint ) ) . m_parentFrame as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( b3UserConstraint ) ,
                "::" , stringify ! ( m_parentFrame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3UserConstraint ) ) . m_childFrame as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( b3UserConstraint ) ,
                "::" , stringify ! ( m_childFrame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3UserConstraint ) ) . m_jointAxis as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( b3UserConstraint ) ,
                "::" , stringify ! ( m_jointAxis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3UserConstraint ) ) . m_jointType as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( b3UserConstraint ) ,
                "::" , stringify ! ( m_jointType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3UserConstraint ) ) . m_maxAppliedForce
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( b3UserConstraint ) ,
                "::" , stringify ! ( m_maxAppliedForce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3UserConstraint ) ) .
                m_userConstraintUniqueId as * const _ as usize } , 168usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( b3UserConstraint ) ,
                "::" , stringify ! ( m_userConstraintUniqueId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3UserConstraint ) ) . m_gearRatio as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( b3UserConstraint ) ,
                "::" , stringify ! ( m_gearRatio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3UserConstraint ) ) . m_gearAuxLink as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( b3UserConstraint ) ,
                "::" , stringify ! ( m_gearAuxLink ) ));
}
impl Clone for b3UserConstraint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3BodyInfo {
    pub m_baseName: *const ::std::os::raw::c_char,
    pub m_bodyName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_b3BodyInfo() {
    assert_eq!(::std::mem::size_of::<b3BodyInfo>() , 16usize , concat ! (
               "Size of: " , stringify ! ( b3BodyInfo ) ));
    assert_eq! (::std::mem::align_of::<b3BodyInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( b3BodyInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3BodyInfo ) ) . m_baseName as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3BodyInfo ) , "::" ,
                stringify ! ( m_baseName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3BodyInfo ) ) . m_bodyName as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( b3BodyInfo ) , "::" ,
                stringify ! ( m_bodyName ) ));
}
impl Clone for b3BodyInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3DynamicsInfo {
    pub m_mass: f64,
    pub m_localInertialPosition: [f64; 3usize],
    pub m_lateralFrictionCoeff: f64,
}
#[test]
fn bindgen_test_layout_b3DynamicsInfo() {
    assert_eq!(::std::mem::size_of::<b3DynamicsInfo>() , 40usize , concat ! (
               "Size of: " , stringify ! ( b3DynamicsInfo ) ));
    assert_eq! (::std::mem::align_of::<b3DynamicsInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( b3DynamicsInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3DynamicsInfo ) ) . m_mass as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3DynamicsInfo ) , "::"
                , stringify ! ( m_mass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3DynamicsInfo ) ) .
                m_localInertialPosition as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( b3DynamicsInfo ) , "::"
                , stringify ! ( m_localInertialPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3DynamicsInfo ) ) .
                m_lateralFrictionCoeff as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( b3DynamicsInfo ) , "::"
                , stringify ! ( m_lateralFrictionCoeff ) ));
}
impl Clone for b3DynamicsInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SensorType { eSensorForceTorqueType = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3JointSensorState {
    pub m_jointPosition: f64,
    pub m_jointVelocity: f64,
    pub m_jointForceTorque: [f64; 6usize],
    pub m_jointMotorTorque: f64,
}
#[test]
fn bindgen_test_layout_b3JointSensorState() {
    assert_eq!(::std::mem::size_of::<b3JointSensorState>() , 72usize , concat
               ! ( "Size of: " , stringify ! ( b3JointSensorState ) ));
    assert_eq! (::std::mem::align_of::<b3JointSensorState>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( b3JointSensorState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointSensorState ) ) . m_jointPosition
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointSensorState ) ,
                "::" , stringify ! ( m_jointPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointSensorState ) ) . m_jointVelocity
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( b3JointSensorState ) ,
                "::" , stringify ! ( m_jointVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointSensorState ) ) .
                m_jointForceTorque as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! ( b3JointSensorState ) ,
                "::" , stringify ! ( m_jointForceTorque ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3JointSensorState ) ) .
                m_jointMotorTorque as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! ( b3JointSensorState ) ,
                "::" , stringify ! ( m_jointMotorTorque ) ));
}
impl Clone for b3JointSensorState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3DebugLines {
    pub m_numDebugLines: ::std::os::raw::c_int,
    pub m_linesFrom: *const f32,
    pub m_linesTo: *const f32,
    pub m_linesColor: *const f32,
}
#[test]
fn bindgen_test_layout_b3DebugLines() {
    assert_eq!(::std::mem::size_of::<b3DebugLines>() , 32usize , concat ! (
               "Size of: " , stringify ! ( b3DebugLines ) ));
    assert_eq! (::std::mem::align_of::<b3DebugLines>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( b3DebugLines ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3DebugLines ) ) . m_numDebugLines as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3DebugLines ) , "::" ,
                stringify ! ( m_numDebugLines ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3DebugLines ) ) . m_linesFrom as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( b3DebugLines ) , "::" ,
                stringify ! ( m_linesFrom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3DebugLines ) ) . m_linesTo as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( b3DebugLines ) , "::" ,
                stringify ! ( m_linesTo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3DebugLines ) ) . m_linesColor as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( b3DebugLines ) , "::" ,
                stringify ! ( m_linesColor ) ));
}
impl Clone for b3DebugLines {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3OverlappingObject {
    pub m_objectUniqueId: ::std::os::raw::c_int,
    pub m_linkIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3OverlappingObject() {
    assert_eq!(::std::mem::size_of::<b3OverlappingObject>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( b3OverlappingObject ) ));
    assert_eq! (::std::mem::align_of::<b3OverlappingObject>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( b3OverlappingObject ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3OverlappingObject ) ) .
                m_objectUniqueId as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3OverlappingObject ) ,
                "::" , stringify ! ( m_objectUniqueId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3OverlappingObject ) ) . m_linkIndex as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( b3OverlappingObject ) ,
                "::" , stringify ! ( m_linkIndex ) ));
}
impl Clone for b3OverlappingObject {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3AABBOverlapData {
    pub m_numOverlappingObjects: ::std::os::raw::c_int,
    pub m_overlappingObjects: *mut b3OverlappingObject,
}
#[test]
fn bindgen_test_layout_b3AABBOverlapData() {
    assert_eq!(::std::mem::size_of::<b3AABBOverlapData>() , 16usize , concat !
               ( "Size of: " , stringify ! ( b3AABBOverlapData ) ));
    assert_eq! (::std::mem::align_of::<b3AABBOverlapData>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( b3AABBOverlapData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3AABBOverlapData ) ) .
                m_numOverlappingObjects as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( b3AABBOverlapData ) ,
                "::" , stringify ! ( m_numOverlappingObjects ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3AABBOverlapData ) ) .
                m_overlappingObjects as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! ( b3AABBOverlapData ) ,
                "::" , stringify ! ( m_overlappingObjects ) ));
}
impl Clone for b3AABBOverlapData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3CameraImageData {
    pub m_pixelWidth: ::std::os::raw::c_int,
    pub m_pixelHeight: ::std::os::raw::c_int,
    pub m_rgbColorData: *const ::std::os::raw::c_uchar,
    pub m_depthValues: *const f32,
    pub m_segmentationMaskValues: *const ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3CameraImageData() {
    assert_eq!(::std::mem::size_of::<b3CameraImageData>() , 32usize , concat !
               ( "Size of: " , stringify ! ( b3CameraImageData ) ));
    assert_eq! (::std::mem::align_of::<b3CameraImageData>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( b3CameraImageData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3CameraImageData ) ) . m_pixelWidth as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3CameraImageData ) ,
                "::" , stringify ! ( m_pixelWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3CameraImageData ) ) . m_pixelHeight as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( b3CameraImageData ) ,
                "::" , stringify ! ( m_pixelHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3CameraImageData ) ) . m_rgbColorData as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( b3CameraImageData ) ,
                "::" , stringify ! ( m_rgbColorData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3CameraImageData ) ) . m_depthValues as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( b3CameraImageData ) ,
                "::" , stringify ! ( m_depthValues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3CameraImageData ) ) .
                m_segmentationMaskValues as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( b3CameraImageData ) ,
                "::" , stringify ! ( m_segmentationMaskValues ) ));
}
impl Clone for b3CameraImageData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3OpenGLVisualizerCameraInfo {
    pub m_width: ::std::os::raw::c_int,
    pub m_height: ::std::os::raw::c_int,
    pub m_viewMatrix: [f32; 16usize],
    pub m_projectionMatrix: [f32; 16usize],
    pub m_camUp: [f32; 3usize],
    pub m_camForward: [f32; 3usize],
    pub m_horizontal: [f32; 3usize],
    pub m_vertical: [f32; 3usize],
    pub m_yaw: f32,
    pub m_pitch: f32,
    pub m_dist: f32,
    pub m_target: [f32; 3usize],
}
#[test]
fn bindgen_test_layout_b3OpenGLVisualizerCameraInfo() {
    assert_eq!(::std::mem::size_of::<b3OpenGLVisualizerCameraInfo>() ,
               208usize , concat ! (
               "Size of: " , stringify ! ( b3OpenGLVisualizerCameraInfo ) ));
    assert_eq! (::std::mem::align_of::<b3OpenGLVisualizerCameraInfo>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( b3OpenGLVisualizerCameraInfo )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3OpenGLVisualizerCameraInfo ) ) .
                m_width as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                b3OpenGLVisualizerCameraInfo ) , "::" , stringify ! ( m_width
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3OpenGLVisualizerCameraInfo ) ) .
                m_height as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                b3OpenGLVisualizerCameraInfo ) , "::" , stringify ! ( m_height
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3OpenGLVisualizerCameraInfo ) ) .
                m_viewMatrix as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                b3OpenGLVisualizerCameraInfo ) , "::" , stringify ! (
                m_viewMatrix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3OpenGLVisualizerCameraInfo ) ) .
                m_projectionMatrix as * const _ as usize } , 72usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                b3OpenGLVisualizerCameraInfo ) , "::" , stringify ! (
                m_projectionMatrix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3OpenGLVisualizerCameraInfo ) ) .
                m_camUp as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                b3OpenGLVisualizerCameraInfo ) , "::" , stringify ! ( m_camUp
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3OpenGLVisualizerCameraInfo ) ) .
                m_camForward as * const _ as usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! (
                b3OpenGLVisualizerCameraInfo ) , "::" , stringify ! (
                m_camForward ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3OpenGLVisualizerCameraInfo ) ) .
                m_horizontal as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! (
                b3OpenGLVisualizerCameraInfo ) , "::" , stringify ! (
                m_horizontal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3OpenGLVisualizerCameraInfo ) ) .
                m_vertical as * const _ as usize } , 172usize , concat ! (
                "Alignment of field: " , stringify ! (
                b3OpenGLVisualizerCameraInfo ) , "::" , stringify ! (
                m_vertical ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3OpenGLVisualizerCameraInfo ) ) . m_yaw
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                b3OpenGLVisualizerCameraInfo ) , "::" , stringify ! ( m_yaw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3OpenGLVisualizerCameraInfo ) ) .
                m_pitch as * const _ as usize } , 188usize , concat ! (
                "Alignment of field: " , stringify ! (
                b3OpenGLVisualizerCameraInfo ) , "::" , stringify ! ( m_pitch
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3OpenGLVisualizerCameraInfo ) ) . m_dist
                as * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! (
                b3OpenGLVisualizerCameraInfo ) , "::" , stringify ! ( m_dist )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3OpenGLVisualizerCameraInfo ) ) .
                m_target as * const _ as usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! (
                b3OpenGLVisualizerCameraInfo ) , "::" , stringify ! ( m_target
                ) ));
}
impl Clone for b3OpenGLVisualizerCameraInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum b3VREventType {
    VR_CONTROLLER_MOVE_EVENT = 1,
    VR_CONTROLLER_BUTTON_EVENT = 2,
    VR_HMD_MOVE_EVENT = 4,
    VR_GENERIC_TRACKER_MOVE_EVENT = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum b3VRButtonInfo {
    eButtonIsDown = 1,
    eButtonTriggered = 2,
    eButtonReleased = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eVRDeviceTypeEnums {
    VR_DEVICE_CONTROLLER = 1,
    VR_DEVICE_HMD = 2,
    VR_DEVICE_GENERIC_TRACKER = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum EVRCameraFlags { VR_CAMERA_TRACK_OBJECT_ORIENTATION = 1, }
#[repr(C)]
#[derive(Copy)]
pub struct b3VRControllerEvent {
    pub m_controllerId: ::std::os::raw::c_int,
    pub m_deviceType: ::std::os::raw::c_int,
    pub m_numMoveEvents: ::std::os::raw::c_int,
    pub m_numButtonEvents: ::std::os::raw::c_int,
    pub m_pos: [f32; 4usize],
    pub m_orn: [f32; 4usize],
    pub m_analogAxis: f32,
    pub m_buttons: [::std::os::raw::c_int; 64usize],
}
#[test]
fn bindgen_test_layout_b3VRControllerEvent() {
    assert_eq!(::std::mem::size_of::<b3VRControllerEvent>() , 308usize ,
               concat ! ( "Size of: " , stringify ! ( b3VRControllerEvent )
               ));
    assert_eq! (::std::mem::align_of::<b3VRControllerEvent>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( b3VRControllerEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VRControllerEvent ) ) . m_controllerId
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3VRControllerEvent ) ,
                "::" , stringify ! ( m_controllerId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VRControllerEvent ) ) . m_deviceType as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( b3VRControllerEvent ) ,
                "::" , stringify ! ( m_deviceType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VRControllerEvent ) ) . m_numMoveEvents
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( b3VRControllerEvent ) ,
                "::" , stringify ! ( m_numMoveEvents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VRControllerEvent ) ) .
                m_numButtonEvents as * const _ as usize } , 12usize , concat !
                (
                "Alignment of field: " , stringify ! ( b3VRControllerEvent ) ,
                "::" , stringify ! ( m_numButtonEvents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VRControllerEvent ) ) . m_pos as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( b3VRControllerEvent ) ,
                "::" , stringify ! ( m_pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VRControllerEvent ) ) . m_orn as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( b3VRControllerEvent ) ,
                "::" , stringify ! ( m_orn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VRControllerEvent ) ) . m_analogAxis as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( b3VRControllerEvent ) ,
                "::" , stringify ! ( m_analogAxis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VRControllerEvent ) ) . m_buttons as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( b3VRControllerEvent ) ,
                "::" , stringify ! ( m_buttons ) ));
}
impl Clone for b3VRControllerEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3VREventsData {
    pub m_numControllerEvents: ::std::os::raw::c_int,
    pub m_controllerEvents: *mut b3VRControllerEvent,
}
#[test]
fn bindgen_test_layout_b3VREventsData() {
    assert_eq!(::std::mem::size_of::<b3VREventsData>() , 16usize , concat ! (
               "Size of: " , stringify ! ( b3VREventsData ) ));
    assert_eq! (::std::mem::align_of::<b3VREventsData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( b3VREventsData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VREventsData ) ) .
                m_numControllerEvents as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( b3VREventsData ) , "::"
                , stringify ! ( m_numControllerEvents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VREventsData ) ) . m_controllerEvents
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( b3VREventsData ) , "::"
                , stringify ! ( m_controllerEvents ) ));
}
impl Clone for b3VREventsData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3KeyboardEvent {
    pub m_keyCode: ::std::os::raw::c_int,
    pub m_keyState: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3KeyboardEvent() {
    assert_eq!(::std::mem::size_of::<b3KeyboardEvent>() , 8usize , concat ! (
               "Size of: " , stringify ! ( b3KeyboardEvent ) ));
    assert_eq! (::std::mem::align_of::<b3KeyboardEvent>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( b3KeyboardEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3KeyboardEvent ) ) . m_keyCode as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3KeyboardEvent ) ,
                "::" , stringify ! ( m_keyCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3KeyboardEvent ) ) . m_keyState as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( b3KeyboardEvent ) ,
                "::" , stringify ! ( m_keyState ) ));
}
impl Clone for b3KeyboardEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3KeyboardEventsData {
    pub m_numKeyboardEvents: ::std::os::raw::c_int,
    pub m_keyboardEvents: *mut b3KeyboardEvent,
}
#[test]
fn bindgen_test_layout_b3KeyboardEventsData() {
    assert_eq!(::std::mem::size_of::<b3KeyboardEventsData>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( b3KeyboardEventsData )
               ));
    assert_eq! (::std::mem::align_of::<b3KeyboardEventsData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( b3KeyboardEventsData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3KeyboardEventsData ) ) .
                m_numKeyboardEvents as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! ( b3KeyboardEventsData )
                , "::" , stringify ! ( m_numKeyboardEvents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3KeyboardEventsData ) ) .
                m_keyboardEvents as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( b3KeyboardEventsData )
                , "::" , stringify ! ( m_keyboardEvents ) ));
}
impl Clone for b3KeyboardEventsData {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eMouseEventTypeEnums {
    MOUSE_MOVE_EVENT = 1,
    MOUSE_BUTTON_EVENT = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3MouseEvent {
    pub m_eventType: ::std::os::raw::c_int,
    pub m_mousePosX: f32,
    pub m_mousePosY: f32,
    pub m_buttonIndex: ::std::os::raw::c_int,
    pub m_buttonState: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3MouseEvent() {
    assert_eq!(::std::mem::size_of::<b3MouseEvent>() , 20usize , concat ! (
               "Size of: " , stringify ! ( b3MouseEvent ) ));
    assert_eq! (::std::mem::align_of::<b3MouseEvent>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( b3MouseEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3MouseEvent ) ) . m_eventType as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3MouseEvent ) , "::" ,
                stringify ! ( m_eventType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3MouseEvent ) ) . m_mousePosX as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( b3MouseEvent ) , "::" ,
                stringify ! ( m_mousePosX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3MouseEvent ) ) . m_mousePosY as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( b3MouseEvent ) , "::" ,
                stringify ! ( m_mousePosY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3MouseEvent ) ) . m_buttonIndex as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( b3MouseEvent ) , "::" ,
                stringify ! ( m_buttonIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3MouseEvent ) ) . m_buttonState as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( b3MouseEvent ) , "::" ,
                stringify ! ( m_buttonState ) ));
}
impl Clone for b3MouseEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3MouseEventsData {
    pub m_numMouseEvents: ::std::os::raw::c_int,
    pub m_mouseEvents: *mut b3MouseEvent,
}
#[test]
fn bindgen_test_layout_b3MouseEventsData() {
    assert_eq!(::std::mem::size_of::<b3MouseEventsData>() , 16usize , concat !
               ( "Size of: " , stringify ! ( b3MouseEventsData ) ));
    assert_eq! (::std::mem::align_of::<b3MouseEventsData>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( b3MouseEventsData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3MouseEventsData ) ) . m_numMouseEvents
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3MouseEventsData ) ,
                "::" , stringify ! ( m_numMouseEvents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3MouseEventsData ) ) . m_mouseEvents as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( b3MouseEventsData ) ,
                "::" , stringify ! ( m_mouseEvents ) ));
}
impl Clone for b3MouseEventsData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3ContactPointData {
    pub m_contactFlags: ::std::os::raw::c_int,
    pub m_bodyUniqueIdA: ::std::os::raw::c_int,
    pub m_bodyUniqueIdB: ::std::os::raw::c_int,
    pub m_linkIndexA: ::std::os::raw::c_int,
    pub m_linkIndexB: ::std::os::raw::c_int,
    pub m_positionOnAInWS: [f64; 3usize],
    pub m_positionOnBInWS: [f64; 3usize],
    pub m_contactNormalOnBInWS: [f64; 3usize],
    pub m_contactDistance: f64,
    pub m_normalForce: f64,
}
#[test]
fn bindgen_test_layout_b3ContactPointData() {
    assert_eq!(::std::mem::size_of::<b3ContactPointData>() , 112usize , concat
               ! ( "Size of: " , stringify ! ( b3ContactPointData ) ));
    assert_eq! (::std::mem::align_of::<b3ContactPointData>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( b3ContactPointData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3ContactPointData ) ) . m_contactFlags
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3ContactPointData ) ,
                "::" , stringify ! ( m_contactFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3ContactPointData ) ) . m_bodyUniqueIdA
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( b3ContactPointData ) ,
                "::" , stringify ! ( m_bodyUniqueIdA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3ContactPointData ) ) . m_bodyUniqueIdB
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( b3ContactPointData ) ,
                "::" , stringify ! ( m_bodyUniqueIdB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3ContactPointData ) ) . m_linkIndexA as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( b3ContactPointData ) ,
                "::" , stringify ! ( m_linkIndexA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3ContactPointData ) ) . m_linkIndexB as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( b3ContactPointData ) ,
                "::" , stringify ! ( m_linkIndexB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3ContactPointData ) ) .
                m_positionOnAInWS as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! ( b3ContactPointData ) ,
                "::" , stringify ! ( m_positionOnAInWS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3ContactPointData ) ) .
                m_positionOnBInWS as * const _ as usize } , 48usize , concat !
                (
                "Alignment of field: " , stringify ! ( b3ContactPointData ) ,
                "::" , stringify ! ( m_positionOnBInWS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3ContactPointData ) ) .
                m_contactNormalOnBInWS as * const _ as usize } , 72usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( b3ContactPointData ) ,
                "::" , stringify ! ( m_contactNormalOnBInWS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3ContactPointData ) ) .
                m_contactDistance as * const _ as usize } , 96usize , concat !
                (
                "Alignment of field: " , stringify ! ( b3ContactPointData ) ,
                "::" , stringify ! ( m_contactDistance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3ContactPointData ) ) . m_normalForce as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( b3ContactPointData ) ,
                "::" , stringify ! ( m_normalForce ) ));
}
impl Clone for b3ContactPointData {
    fn clone(&self) -> Self { *self }
}
pub const CONTACT_QUERY_MODE_REPORT_EXISTING_CONTACT_POINTS: _bindgen_ty_2 =
    _bindgen_ty_2::CONTACT_QUERY_MODE_REPORT_EXISTING_CONTACT_POINTS;
pub const CONTACT_QUERY_MODE_COMPUTE_CLOSEST_POINTS: _bindgen_ty_2 =
    _bindgen_ty_2::CONTACT_QUERY_MODE_COMPUTE_CLOSEST_POINTS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    CONTACT_QUERY_MODE_REPORT_EXISTING_CONTACT_POINTS = 0,
    CONTACT_QUERY_MODE_COMPUTE_CLOSEST_POINTS = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum b3StateLoggingType {
    STATE_LOGGING_MINITAUR = 0,
    STATE_LOGGING_GENERIC_ROBOT = 1,
    STATE_LOGGING_VR_CONTROLLERS = 2,
    STATE_LOGGING_VIDEO_MP4 = 3,
    STATE_LOGGING_COMMANDS = 4,
    STATE_LOGGING_CONTACT_POINTS = 5,
    STATE_LOGGING_PROFILE_TIMINGS = 6,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3ContactInformation {
    pub m_numContactPoints: ::std::os::raw::c_int,
    pub m_contactPointData: *mut b3ContactPointData,
}
#[test]
fn bindgen_test_layout_b3ContactInformation() {
    assert_eq!(::std::mem::size_of::<b3ContactInformation>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( b3ContactInformation )
               ));
    assert_eq! (::std::mem::align_of::<b3ContactInformation>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( b3ContactInformation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3ContactInformation ) ) .
                m_numContactPoints as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( b3ContactInformation )
                , "::" , stringify ! ( m_numContactPoints ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3ContactInformation ) ) .
                m_contactPointData as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( b3ContactInformation )
                , "::" , stringify ! ( m_contactPointData ) ));
}
impl Clone for b3ContactInformation {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3RayHitInfo {
    pub m_hitFraction: f64,
    pub m_hitObjectUniqueId: ::std::os::raw::c_int,
    pub m_hitObjectLinkIndex: ::std::os::raw::c_int,
    pub m_hitPositionWorld: [f64; 3usize],
    pub m_hitNormalWorld: [f64; 3usize],
}
#[test]
fn bindgen_test_layout_b3RayHitInfo() {
    assert_eq!(::std::mem::size_of::<b3RayHitInfo>() , 64usize , concat ! (
               "Size of: " , stringify ! ( b3RayHitInfo ) ));
    assert_eq! (::std::mem::align_of::<b3RayHitInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( b3RayHitInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3RayHitInfo ) ) . m_hitFraction as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3RayHitInfo ) , "::" ,
                stringify ! ( m_hitFraction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3RayHitInfo ) ) . m_hitObjectUniqueId as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( b3RayHitInfo ) , "::" ,
                stringify ! ( m_hitObjectUniqueId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3RayHitInfo ) ) . m_hitObjectLinkIndex
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( b3RayHitInfo ) , "::" ,
                stringify ! ( m_hitObjectLinkIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3RayHitInfo ) ) . m_hitPositionWorld as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( b3RayHitInfo ) , "::" ,
                stringify ! ( m_hitPositionWorld ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3RayHitInfo ) ) . m_hitNormalWorld as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( b3RayHitInfo ) , "::" ,
                stringify ! ( m_hitNormalWorld ) ));
}
impl Clone for b3RayHitInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3RaycastInformation {
    pub m_numRayHits: ::std::os::raw::c_int,
    pub m_rayHits: *mut b3RayHitInfo,
}
#[test]
fn bindgen_test_layout_b3RaycastInformation() {
    assert_eq!(::std::mem::size_of::<b3RaycastInformation>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( b3RaycastInformation )
               ));
    assert_eq! (::std::mem::align_of::<b3RaycastInformation>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( b3RaycastInformation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3RaycastInformation ) ) . m_numRayHits
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3RaycastInformation )
                , "::" , stringify ! ( m_numRayHits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3RaycastInformation ) ) . m_rayHits as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( b3RaycastInformation )
                , "::" , stringify ! ( m_rayHits ) ));
}
impl Clone for b3RaycastInformation {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct b3VisualShapeData {
    pub m_objectUniqueId: ::std::os::raw::c_int,
    pub m_linkIndex: ::std::os::raw::c_int,
    pub m_visualGeometryType: ::std::os::raw::c_int,
    pub m_dimensions: [f64; 3usize],
    pub m_meshAssetFileName: [::std::os::raw::c_char; 1024usize],
    pub m_localVisualFrame: [f64; 7usize],
    pub m_rgbaColor: [f64; 4usize],
}
#[test]
fn bindgen_test_layout_b3VisualShapeData() {
    assert_eq!(::std::mem::size_of::<b3VisualShapeData>() , 1152usize , concat
               ! ( "Size of: " , stringify ! ( b3VisualShapeData ) ));
    assert_eq! (::std::mem::align_of::<b3VisualShapeData>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( b3VisualShapeData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VisualShapeData ) ) . m_objectUniqueId
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3VisualShapeData ) ,
                "::" , stringify ! ( m_objectUniqueId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VisualShapeData ) ) . m_linkIndex as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( b3VisualShapeData ) ,
                "::" , stringify ! ( m_linkIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VisualShapeData ) ) .
                m_visualGeometryType as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! ( b3VisualShapeData ) ,
                "::" , stringify ! ( m_visualGeometryType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VisualShapeData ) ) . m_dimensions as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( b3VisualShapeData ) ,
                "::" , stringify ! ( m_dimensions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VisualShapeData ) ) .
                m_meshAssetFileName as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! ( b3VisualShapeData ) ,
                "::" , stringify ! ( m_meshAssetFileName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VisualShapeData ) ) .
                m_localVisualFrame as * const _ as usize } , 1064usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( b3VisualShapeData ) ,
                "::" , stringify ! ( m_localVisualFrame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VisualShapeData ) ) . m_rgbaColor as *
                const _ as usize } , 1120usize , concat ! (
                "Alignment of field: " , stringify ! ( b3VisualShapeData ) ,
                "::" , stringify ! ( m_rgbaColor ) ));
}
impl Clone for b3VisualShapeData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3VisualShapeInformation {
    pub m_numVisualShapes: ::std::os::raw::c_int,
    pub m_visualShapeData: *mut b3VisualShapeData,
}
#[test]
fn bindgen_test_layout_b3VisualShapeInformation() {
    assert_eq!(::std::mem::size_of::<b3VisualShapeInformation>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( b3VisualShapeInformation ) ));
    assert_eq! (::std::mem::align_of::<b3VisualShapeInformation>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( b3VisualShapeInformation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VisualShapeInformation ) ) .
                m_numVisualShapes as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                b3VisualShapeInformation ) , "::" , stringify ! (
                m_numVisualShapes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3VisualShapeInformation ) ) .
                m_visualShapeData as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                b3VisualShapeInformation ) , "::" , stringify ! (
                m_visualShapeData ) ));
}
impl Clone for b3VisualShapeInformation {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eLinkStateFlags { ACTUAL_STATE_COMPUTE_LINKVELOCITY = 1, }
/// b3LinkState provides extra information such as the Cartesian world coordinates
/// center of mass (COM) of the link, relative to the world reference frame.
/// Orientation is a quaternion x,y,z,w
/// Note: to compute the URDF link frame (which equals the joint frame at joint position 0)
/// use URDF link frame = link COM frame * inertiaFrame.inverse()
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3LinkState {
    pub m_worldPosition: [f64; 3usize],
    pub m_worldOrientation: [f64; 4usize],
    pub m_localInertialPosition: [f64; 3usize],
    pub m_localInertialOrientation: [f64; 4usize],
    /// world position and orientation of the (URDF) link frame
    pub m_worldLinkFramePosition: [f64; 3usize],
    pub m_worldLinkFrameOrientation: [f64; 4usize],
    pub m_worldLinearVelocity: [f64; 3usize],
    pub m_worldAngularVelocity: [f64; 3usize],
    pub m_worldAABBMin: [f64; 3usize],
    pub m_worldAABBMax: [f64; 3usize],
}
#[test]
fn bindgen_test_layout_b3LinkState() {
    assert_eq!(::std::mem::size_of::<b3LinkState>() , 264usize , concat ! (
               "Size of: " , stringify ! ( b3LinkState ) ));
    assert_eq! (::std::mem::align_of::<b3LinkState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( b3LinkState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3LinkState ) ) . m_worldPosition as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3LinkState ) , "::" ,
                stringify ! ( m_worldPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3LinkState ) ) . m_worldOrientation as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( b3LinkState ) , "::" ,
                stringify ! ( m_worldOrientation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3LinkState ) ) . m_localInertialPosition
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( b3LinkState ) , "::" ,
                stringify ! ( m_localInertialPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3LinkState ) ) .
                m_localInertialOrientation as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( b3LinkState ) , "::" ,
                stringify ! ( m_localInertialOrientation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3LinkState ) ) .
                m_worldLinkFramePosition as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( b3LinkState ) , "::" ,
                stringify ! ( m_worldLinkFramePosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3LinkState ) ) .
                m_worldLinkFrameOrientation as * const _ as usize } , 136usize
                , concat ! (
                "Alignment of field: " , stringify ! ( b3LinkState ) , "::" ,
                stringify ! ( m_worldLinkFrameOrientation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3LinkState ) ) . m_worldLinearVelocity
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( b3LinkState ) , "::" ,
                stringify ! ( m_worldLinearVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3LinkState ) ) . m_worldAngularVelocity
                as * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( b3LinkState ) , "::" ,
                stringify ! ( m_worldAngularVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3LinkState ) ) . m_worldAABBMin as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( b3LinkState ) , "::" ,
                stringify ! ( m_worldAABBMin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3LinkState ) ) . m_worldAABBMax as *
                const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( b3LinkState ) , "::" ,
                stringify ! ( m_worldAABBMax ) ));
}
impl Clone for b3LinkState {
    fn clone(&self) -> Self { *self }
}
pub const CONTROL_MODE_VELOCITY: _bindgen_ty_3 =
    _bindgen_ty_3::CONTROL_MODE_VELOCITY;
pub const CONTROL_MODE_TORQUE: _bindgen_ty_3 =
    _bindgen_ty_3::CONTROL_MODE_TORQUE;
pub const CONTROL_MODE_POSITION_VELOCITY_PD: _bindgen_ty_3 =
    _bindgen_ty_3::CONTROL_MODE_POSITION_VELOCITY_PD;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    CONTROL_MODE_VELOCITY = 0,
    CONTROL_MODE_TORQUE = 1,
    CONTROL_MODE_POSITION_VELOCITY_PD = 2,
}
#[repr(u32)]
/// flags for b3ApplyExternalTorque and b3ApplyExternalForce
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum EnumExternalForceFlags { EF_LINK_FRAME = 1, EF_WORLD_FRAME = 2, }
#[repr(u32)]
/// flags to pick the renderer for synthetic camera
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum EnumRenderer {
    ER_TINY_RENDERER = 65536,
    ER_BULLET_HARDWARE_OPENGL = 131072,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum b3ConfigureDebugVisualizerEnum {
    COV_ENABLE_GUI = 1,
    COV_ENABLE_SHADOWS = 2,
    COV_ENABLE_WIREFRAME = 3,
    COV_ENABLE_VR_TELEPORTING = 4,
    COV_ENABLE_VR_PICKING = 5,
    COV_ENABLE_VR_RENDER_CONTROLLERS = 6,
    COV_ENABLE_RENDERING = 7,
    COV_ENABLE_SYNC_RENDERING_INTERNAL = 8,
    COV_ENABLE_KEYBOARD_SHORTCUTS = 9,
    COV_ENABLE_MOUSE_PICKING = 10,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum b3AddUserDebugItemEnum {
    DEB_DEBUG_TEXT_USE_ORIENTATION = 1,
    DEB_DEBUG_TEXT_USE_TRUE_TYPE_FONTS = 2,
    DEB_DEBUG_TEXT_HAS_TRACKING_OBJECT = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eCONNECT_METHOD {
    eCONNECT_GUI = 1,
    eCONNECT_DIRECT = 2,
    eCONNECT_SHARED_MEMORY = 3,
    eCONNECT_UDP = 4,
    eCONNECT_TCP = 5,
    eCONNECT_EXISTING_EXAMPLE_BROWSER = 6,
    eCONNECT_GUI_SERVER = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eURDF_Flags {
    URDF_USE_INERTIA_FROM_FILE = 2,
    URDF_USE_SELF_COLLISION = 8,
    URDF_USE_SELF_COLLISION_EXCLUDE_PARENT = 16,
    URDF_USE_SELF_COLLISION_EXCLUDE_ALL_PARENTS = 32,
    URDF_RESERVED = 64,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eUrdfGeomTypes {
    GEOM_SPHERE = 2,
    GEOM_BOX = 3,
    GEOM_CYLINDER = 4,
    GEOM_MESH = 5,
    GEOM_PLANE = 6,
    GEOM_CAPSULE = 7,
    GEOM_UNKNOWN = 8,
    GEOM_TRIMESH = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eUrdfCollisionFlags { GEOM_FORCE_CONCAVE_TRIMESH = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eStateLoggingFlags {
    STATE_LOG_JOINT_MOTOR_TORQUES = 1,
    STATE_LOG_JOINT_USER_TORQUES = 2,
    STATE_LOG_JOINT_TORQUES = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3PhysicsClientHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3PhysicsClientHandle__() {
    assert_eq!(::std::mem::size_of::<b3PhysicsClientHandle__>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( b3PhysicsClientHandle__ ) ));
    assert_eq! (::std::mem::align_of::<b3PhysicsClientHandle__>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( b3PhysicsClientHandle__ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3PhysicsClientHandle__ ) ) . unused as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( b3PhysicsClientHandle__
                ) , "::" , stringify ! ( unused ) ));
}
impl Clone for b3PhysicsClientHandle__ {
    fn clone(&self) -> Self { *self }
}
pub type b3PhysicsClientHandle = *mut b3PhysicsClientHandle__;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3SharedMemoryCommandHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3SharedMemoryCommandHandle__() {
    assert_eq!(::std::mem::size_of::<b3SharedMemoryCommandHandle__>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( b3SharedMemoryCommandHandle__ ) ));
    assert_eq! (::std::mem::align_of::<b3SharedMemoryCommandHandle__>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( b3SharedMemoryCommandHandle__
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3SharedMemoryCommandHandle__ ) ) .
                unused as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                b3SharedMemoryCommandHandle__ ) , "::" , stringify ! ( unused
                ) ));
}
impl Clone for b3SharedMemoryCommandHandle__ {
    fn clone(&self) -> Self { *self }
}
pub type b3SharedMemoryCommandHandle = *mut b3SharedMemoryCommandHandle__;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct b3SharedMemoryStatusHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3SharedMemoryStatusHandle__() {
    assert_eq!(::std::mem::size_of::<b3SharedMemoryStatusHandle__>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( b3SharedMemoryStatusHandle__ ) ));
    assert_eq! (::std::mem::align_of::<b3SharedMemoryStatusHandle__>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( b3SharedMemoryStatusHandle__ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const b3SharedMemoryStatusHandle__ ) ) . unused
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                b3SharedMemoryStatusHandle__ ) , "::" , stringify ! ( unused )
                ));
}
impl Clone for b3SharedMemoryStatusHandle__ {
    fn clone(&self) -> Self { *self }
}
pub type b3SharedMemoryStatusHandle = *mut b3SharedMemoryStatusHandle__;
extern "C" {
    pub fn b3ConnectSharedMemory(key: ::std::os::raw::c_int)
     -> b3PhysicsClientHandle;
}
extern "C" {
    pub fn b3ConnectSharedMemory2(key: ::std::os::raw::c_int)
     -> b3PhysicsClientHandle;
}
extern "C" {
    /// think more about naming. Directly execute commands without transport (no shared memory, UDP, socket, grpc etc)
    pub fn b3ConnectPhysicsDirect() -> b3PhysicsClientHandle;
}
extern "C" {
    /// think more about naming. The b3ConnectPhysicsLoopback
    pub fn b3CreateInProcessPhysicsServerAndConnect(argc:
                                                        ::std::os::raw::c_int,
                                                    argv:
                                                        *mut *mut ::std::os::raw::c_char)
     -> b3PhysicsClientHandle;
}
extern "C" {
    pub fn b3CreateInProcessPhysicsServerAndConnectSharedMemory(argc:
                                                                    ::std::os::raw::c_int,
                                                                argv:
                                                                    *mut *mut ::std::os::raw::c_char)
     -> b3PhysicsClientHandle;
}
extern "C" {
    pub fn b3CreateInProcessPhysicsServerAndConnectMainThread(argc:
                                                                  ::std::os::raw::c_int,
                                                              argv:
                                                                  *mut *mut ::std::os::raw::c_char)
     -> b3PhysicsClientHandle;
}
extern "C" {
    pub fn b3CreateInProcessPhysicsServerAndConnectMainThreadSharedMemory(argc:
                                                                              ::std::os::raw::c_int,
                                                                          argv:
                                                                              *mut *mut ::std::os::raw::c_char)
     -> b3PhysicsClientHandle;
}
extern "C" {
    pub fn b3CreateInProcessPhysicsServerFromExistingExampleBrowserAndConnect(guiHelperPtr:
                                                                                  *mut ::std::os::raw::c_void)
     -> b3PhysicsClientHandle;
}
extern "C" {
    /// ignore the following APIs, they are for internal use for example browser
    pub fn b3InProcessRenderSceneInternal(clientHandle:
                                              b3PhysicsClientHandle);
}
extern "C" {
    pub fn b3InProcessDebugDrawInternal(clientHandle: b3PhysicsClientHandle,
                                        debugDrawMode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3InProcessMouseMoveCallback(clientHandle: b3PhysicsClientHandle,
                                        x: f32, y: f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InProcessMouseButtonCallback(clientHandle: b3PhysicsClientHandle,
                                          button: ::std::os::raw::c_int,
                                          state: ::std::os::raw::c_int,
                                          x: f32, y: f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// b3DisconnectSharedMemory will disconnect the client from the server and cleanup memory.
    pub fn b3DisconnectSharedMemory(physClient: b3PhysicsClientHandle);
}
extern "C" {
    /// There can only be 1 outstanding command. Check if a command can be send.
    pub fn b3CanSubmitCommand(physClient: b3PhysicsClientHandle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// blocking submit command and wait for status
    pub fn b3SubmitClientCommandAndWaitStatus(physClient:
                                                  b3PhysicsClientHandle,
                                              commandHandle:
                                                  b3SharedMemoryCommandHandle)
     -> b3SharedMemoryStatusHandle;
}
extern "C" {
    /// In general it is better to use b3SubmitClientCommandAndWaitStatus. b3SubmitClientCommand is a non-blocking submit
/// command, which requires checking for the status manually, using b3ProcessServerStatus. Also, before sending the
/// next command, make sure to check if you can send a command using 'b3CanSubmitCommand'.
    pub fn b3SubmitClientCommand(physClient: b3PhysicsClientHandle,
                                 commandHandle: b3SharedMemoryCommandHandle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// non-blocking check status
    pub fn b3ProcessServerStatus(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryStatusHandle;
}
extern "C" {
    /// Get the physics server return status type. See EnumSharedMemoryServerStatus in SharedMemoryPublic.h for error codes.
    pub fn b3GetStatusType(statusHandle: b3SharedMemoryStatusHandle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetStatusBodyIndices(statusHandle: b3SharedMemoryStatusHandle,
                                  bodyIndicesOut: *mut ::std::os::raw::c_int,
                                  bodyIndicesCapacity: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetStatusBodyIndex(statusHandle: b3SharedMemoryStatusHandle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetStatusActualState(statusHandle: b3SharedMemoryStatusHandle,
                                  bodyUniqueId: *mut ::std::os::raw::c_int,
                                  numDegreeOfFreedomQ:
                                      *mut ::std::os::raw::c_int,
                                  numDegreeOfFreedomU:
                                      *mut ::std::os::raw::c_int,
                                  rootLocalInertialFrame: *mut *const f64,
                                  actualStateQ: *mut *const f64,
                                  actualStateQdot: *mut *const f64,
                                  jointReactionForces: *mut *const f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3RequestCollisionInfoCommandInit(physClient:
                                                 b3PhysicsClientHandle,
                                             bodyUniqueId:
                                                 ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusAABB(statusHandle: b3SharedMemoryStatusHandle,
                           linkIndex: ::std::os::raw::c_int,
                           aabbMin: *mut f64, aabbMax: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// If you re-connected to an existing server, or server changed otherwise, sync the body info and user constraints etc.
    pub fn b3InitSyncBodyInfoCommand(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitRemoveBodyCommand(physClient: b3PhysicsClientHandle,
                                   bodyUniqueId: ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    /// return the total number of bodies in the simulation
    pub fn b3GetNumBodies(physClient: b3PhysicsClientHandle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// return the body unique id, given the index in range [0 , b3GetNumBodies() )
    pub fn b3GetBodyUniqueId(physClient: b3PhysicsClientHandle,
                             serialIndex: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// given a body unique id, return the body information. See b3BodyInfo in SharedMemoryPublic.h
    pub fn b3GetBodyInfo(physClient: b3PhysicsClientHandle,
                         bodyUniqueId: ::std::os::raw::c_int,
                         info: *mut b3BodyInfo) -> ::std::os::raw::c_int;
}
extern "C" {
    /// give a unique body index (after loading the body) return the number of joints.
    pub fn b3GetNumJoints(physClient: b3PhysicsClientHandle,
                          bodyIndex: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// given a body and joint index, return the joint information. See b3JointInfo in SharedMemoryPublic.h
    pub fn b3GetJointInfo(physClient: b3PhysicsClientHandle,
                          bodyIndex: ::std::os::raw::c_int,
                          jointIndex: ::std::os::raw::c_int,
                          info: *mut b3JointInfo) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetDynamicsInfoCommandInit(physClient: b3PhysicsClientHandle,
                                        bodyUniqueId: ::std::os::raw::c_int,
                                        linkIndex: ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    /// given a body unique id and link index, return the dynamics information. See b3DynamicsInfo in SharedMemoryPublic.h
    pub fn b3GetDynamicsInfo(statusHandle: b3SharedMemoryStatusHandle,
                             info: *mut b3DynamicsInfo)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitChangeDynamicsInfo(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetMass(commandHandle:
                                           b3SharedMemoryCommandHandle,
                                       bodyUniqueId: ::std::os::raw::c_int,
                                       linkIndex: ::std::os::raw::c_int,
                                       mass: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetLateralFriction(commandHandle:
                                                      b3SharedMemoryCommandHandle,
                                                  bodyUniqueId:
                                                      ::std::os::raw::c_int,
                                                  linkIndex:
                                                      ::std::os::raw::c_int,
                                                  lateralFriction: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetSpinningFriction(commandHandle:
                                                       b3SharedMemoryCommandHandle,
                                                   bodyUniqueId:
                                                       ::std::os::raw::c_int,
                                                   linkIndex:
                                                       ::std::os::raw::c_int,
                                                   friction: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetRollingFriction(commandHandle:
                                                      b3SharedMemoryCommandHandle,
                                                  bodyUniqueId:
                                                      ::std::os::raw::c_int,
                                                  linkIndex:
                                                      ::std::os::raw::c_int,
                                                  friction: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetRestitution(commandHandle:
                                                  b3SharedMemoryCommandHandle,
                                              bodyUniqueId:
                                                  ::std::os::raw::c_int,
                                              linkIndex:
                                                  ::std::os::raw::c_int,
                                              restitution: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetLinearDamping(commandHandle:
                                                    b3SharedMemoryCommandHandle,
                                                bodyUniqueId:
                                                    ::std::os::raw::c_int,
                                                linearDamping: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetAngularDamping(commandHandle:
                                                     b3SharedMemoryCommandHandle,
                                                 bodyUniqueId:
                                                     ::std::os::raw::c_int,
                                                 angularDamping: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetContactStiffnessAndDamping(commandHandle:
                                                                 b3SharedMemoryCommandHandle,
                                                             bodyUniqueId:
                                                                 ::std::os::raw::c_int,
                                                             linkIndex:
                                                                 ::std::os::raw::c_int,
                                                             contactStiffness:
                                                                 f64,
                                                             contactDamping:
                                                                 f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetFrictionAnchor(commandHandle:
                                                     b3SharedMemoryCommandHandle,
                                                 bodyUniqueId:
                                                     ::std::os::raw::c_int,
                                                 linkIndex:
                                                     ::std::os::raw::c_int,
                                                 frictionAnchor:
                                                     ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitCreateUserConstraintCommand(physClient:
                                                 b3PhysicsClientHandle,
                                             parentBodyIndex:
                                                 ::std::os::raw::c_int,
                                             parentJointIndex:
                                                 ::std::os::raw::c_int,
                                             childBodyIndex:
                                                 ::std::os::raw::c_int,
                                             childJointIndex:
                                                 ::std::os::raw::c_int,
                                             info: *mut b3JointInfo)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    /// return a unique id for the user constraint, after successful creation, or -1 for an invalid constraint id
    pub fn b3GetStatusUserConstraintUniqueId(statusHandle:
                                                 b3SharedMemoryStatusHandle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// change parameters of an existing user constraint
    pub fn b3InitChangeUserConstraintCommand(physClient:
                                                 b3PhysicsClientHandle,
                                             userConstraintUniqueId:
                                                 ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitChangeUserConstraintSetPivotInB(commandHandle:
                                                     b3SharedMemoryCommandHandle,
                                                 jointChildPivot: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitChangeUserConstraintSetFrameInB(commandHandle:
                                                     b3SharedMemoryCommandHandle,
                                                 jointChildFrameOrn: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitChangeUserConstraintSetMaxForce(commandHandle:
                                                     b3SharedMemoryCommandHandle,
                                                 maxAppliedForce: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitChangeUserConstraintSetGearRatio(commandHandle:
                                                      b3SharedMemoryCommandHandle,
                                                  gearRatio: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitChangeUserConstraintSetGearAuxLink(commandHandle:
                                                        b3SharedMemoryCommandHandle,
                                                    gearAuxLink:
                                                        ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitRemoveUserConstraintCommand(physClient:
                                                 b3PhysicsClientHandle,
                                             userConstraintUniqueId:
                                                 ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetNumUserConstraints(physClient: b3PhysicsClientHandle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetUserConstraintInfo(physClient: b3PhysicsClientHandle,
                                   constraintUniqueId: ::std::os::raw::c_int,
                                   info: *mut b3UserConstraint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// return the user constraint id, given the index in range [0 , b3GetNumUserConstraints() )
    pub fn b3GetUserConstraintId(physClient: b3PhysicsClientHandle,
                                 serialIndex: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Request physics debug lines for debug visualization. The flags in debugMode are the same as used in Bullet
/// See btIDebugDraw::DebugDrawModes in Bullet/src/LinearMath/btIDebugDraw.h
    pub fn b3InitRequestDebugLinesCommand(physClient: b3PhysicsClientHandle,
                                          debugMode: ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    /// Get the pointers to the physics debug line information, after b3InitRequestDebugLinesCommand returns
/// status CMD_DEBUG_LINES_COMPLETED
    pub fn b3GetDebugLines(physClient: b3PhysicsClientHandle,
                           lines: *mut b3DebugLines);
}
extern "C" {
    /// configure the 3D OpenGL debug visualizer (enable/disable GUI widgets, shadows, position camera etc)
    pub fn b3InitConfigureOpenGLVisualizer(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3ConfigureOpenGLVisualizerSetVisualizationFlags(commandHandle:
                                                                b3SharedMemoryCommandHandle,
                                                            flag:
                                                                ::std::os::raw::c_int,
                                                            enabled:
                                                                ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3ConfigureOpenGLVisualizerSetViewMatrix(commandHandle:
                                                        b3SharedMemoryCommandHandle,
                                                    cameraDistance: f32,
                                                    cameraPitch: f32,
                                                    cameraYaw: f32,
                                                    cameraTargetPosition:
                                                        *const f32);
}
extern "C" {
    pub fn b3InitRequestOpenGLVisualizerCameraCommand(physClient:
                                                          b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusOpenGLVisualizerCamera(statusHandle:
                                                 b3SharedMemoryStatusHandle,
                                             camera:
                                                 *mut b3OpenGLVisualizerCameraInfo)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add/remove user-specific debug lines and debug text messages
    pub fn b3InitUserDebugDrawAddLine3D(physClient: b3PhysicsClientHandle,
                                        fromXYZ: *mut f64, toXYZ: *mut f64,
                                        colorRGB: *mut f64, lineWidth: f64,
                                        lifeTime: f64)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitUserDebugDrawAddText3D(physClient: b3PhysicsClientHandle,
                                        txt: *const ::std::os::raw::c_char,
                                        positionXYZ: *mut f64,
                                        colorRGB: *mut f64, textSize: f64,
                                        lifeTime: f64)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3UserDebugTextSetOptionFlags(commandHandle:
                                             b3SharedMemoryCommandHandle,
                                         optionFlags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3UserDebugTextSetOrientation(commandHandle:
                                             b3SharedMemoryCommandHandle,
                                         orientation: *mut f64);
}
extern "C" {
    pub fn b3UserDebugItemSetParentObject(commandHandle:
                                              b3SharedMemoryCommandHandle,
                                          objectUniqueId:
                                              ::std::os::raw::c_int,
                                          linkIndex: ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3InitUserDebugAddParameter(physClient: b3PhysicsClientHandle,
                                       txt: *const ::std::os::raw::c_char,
                                       rangeMin: f64, rangeMax: f64,
                                       startValue: f64)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitUserDebugReadParameter(physClient: b3PhysicsClientHandle,
                                        debugItemUniqueId:
                                            ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusDebugParameterValue(statusHandle:
                                              b3SharedMemoryStatusHandle,
                                          paramValue: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitUserDebugDrawRemove(physClient: b3PhysicsClientHandle,
                                     debugItemUniqueId: ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitUserDebugDrawRemoveAll(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitDebugDrawingCommand(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3SetDebugObjectColor(commandHandle: b3SharedMemoryCommandHandle,
                                 objectUniqueId: ::std::os::raw::c_int,
                                 linkIndex: ::std::os::raw::c_int,
                                 objectColorRGB: *mut f64);
}
extern "C" {
    pub fn b3RemoveDebugObjectColor(commandHandle:
                                        b3SharedMemoryCommandHandle,
                                    objectUniqueId: ::std::os::raw::c_int,
                                    linkIndex: ::std::os::raw::c_int);
}
extern "C" {
    /// All debug items unique Ids are positive: a negative unique Id means failure.
    pub fn b3GetDebugItemUniqueId(statusHandle: b3SharedMemoryStatusHandle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// request an image from a simulated camera, using a software renderer.
    pub fn b3InitRequestCameraImage(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3RequestCameraImageSetCameraMatrices(command:
                                                     b3SharedMemoryCommandHandle,
                                                 viewMatrix: *mut f32,
                                                 projectionMatrix: *mut f32);
}
extern "C" {
    pub fn b3RequestCameraImageSetPixelResolution(command:
                                                      b3SharedMemoryCommandHandle,
                                                  width:
                                                      ::std::os::raw::c_int,
                                                  height:
                                                      ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3RequestCameraImageSetLightDirection(commandHandle:
                                                     b3SharedMemoryCommandHandle,
                                                 lightDirection: *const f32);
}
extern "C" {
    pub fn b3RequestCameraImageSetLightColor(commandHandle:
                                                 b3SharedMemoryCommandHandle,
                                             lightColor: *const f32);
}
extern "C" {
    pub fn b3RequestCameraImageSetLightDistance(commandHandle:
                                                    b3SharedMemoryCommandHandle,
                                                lightDistance: f32);
}
extern "C" {
    pub fn b3RequestCameraImageSetLightAmbientCoeff(commandHandle:
                                                        b3SharedMemoryCommandHandle,
                                                    lightAmbientCoeff: f32);
}
extern "C" {
    pub fn b3RequestCameraImageSetLightDiffuseCoeff(commandHandle:
                                                        b3SharedMemoryCommandHandle,
                                                    lightDiffuseCoeff: f32);
}
extern "C" {
    pub fn b3RequestCameraImageSetLightSpecularCoeff(commandHandle:
                                                         b3SharedMemoryCommandHandle,
                                                     lightSpecularCoeff: f32);
}
extern "C" {
    pub fn b3RequestCameraImageSetShadow(commandHandle:
                                             b3SharedMemoryCommandHandle,
                                         hasShadow: ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3RequestCameraImageSelectRenderer(commandHandle:
                                                  b3SharedMemoryCommandHandle,
                                              renderer:
                                                  ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3GetCameraImageData(physClient: b3PhysicsClientHandle,
                                imageData: *mut b3CameraImageData);
}
extern "C" {
    /// compute a view matrix, helper function for b3RequestCameraImageSetCameraMatrices
    pub fn b3ComputeViewMatrixFromPositions(cameraPosition: *const f32,
                                            cameraTargetPosition: *const f32,
                                            cameraUp: *const f32,
                                            viewMatrix: *mut f32);
}
extern "C" {
    pub fn b3ComputeViewMatrixFromYawPitchRoll(cameraTargetPosition:
                                                   *const f32, distance: f32,
                                               yaw: f32, pitch: f32,
                                               roll: f32,
                                               upAxis: ::std::os::raw::c_int,
                                               viewMatrix: *mut f32);
}
extern "C" {
    pub fn b3ComputePositionFromViewMatrix(viewMatrix: *const f32,
                                           cameraPosition: *mut f32,
                                           cameraTargetPosition: *mut f32,
                                           cameraUp: *mut f32);
}
extern "C" {
    /// compute a projection matrix, helper function for b3RequestCameraImageSetCameraMatrices
    pub fn b3ComputeProjectionMatrix(left: f32, right: f32, bottom: f32,
                                     top: f32, nearVal: f32, farVal: f32,
                                     projectionMatrix: *mut f32);
}
extern "C" {
    pub fn b3ComputeProjectionMatrixFOV(fov: f32, aspect: f32, nearVal: f32,
                                        farVal: f32,
                                        projectionMatrix: *mut f32);
}
extern "C" {
    pub fn b3RequestCameraImageSetViewMatrix(command:
                                                 b3SharedMemoryCommandHandle,
                                             cameraPosition: *const f32,
                                             cameraTargetPosition: *const f32,
                                             cameraUp: *const f32);
}
extern "C" {
    pub fn b3RequestCameraImageSetViewMatrix2(commandHandle:
                                                  b3SharedMemoryCommandHandle,
                                              cameraTargetPosition:
                                                  *const f32, distance: f32,
                                              yaw: f32, pitch: f32, roll: f32,
                                              upAxis: ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3RequestCameraImageSetProjectionMatrix(command:
                                                       b3SharedMemoryCommandHandle,
                                                   left: f32, right: f32,
                                                   bottom: f32, top: f32,
                                                   nearVal: f32, farVal: f32);
}
extern "C" {
    pub fn b3RequestCameraImageSetFOVProjectionMatrix(command:
                                                          b3SharedMemoryCommandHandle,
                                                      fov: f32, aspect: f32,
                                                      nearVal: f32,
                                                      farVal: f32);
}
extern "C" {
    /// request an contact point information
    pub fn b3InitRequestContactPointInformation(physClient:
                                                    b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3SetContactFilterBodyA(commandHandle: b3SharedMemoryCommandHandle,
                                   bodyUniqueIdA: ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3SetContactFilterBodyB(commandHandle: b3SharedMemoryCommandHandle,
                                   bodyUniqueIdB: ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3SetContactFilterLinkA(commandHandle: b3SharedMemoryCommandHandle,
                                   linkIndexA: ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3SetContactFilterLinkB(commandHandle: b3SharedMemoryCommandHandle,
                                   linkIndexB: ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3GetContactPointInformation(physClient: b3PhysicsClientHandle,
                                        contactPointInfo:
                                            *mut b3ContactInformation);
}
extern "C" {
    /// compute the closest points between two bodies
    pub fn b3InitClosestDistanceQuery(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3SetClosestDistanceFilterBodyA(commandHandle:
                                               b3SharedMemoryCommandHandle,
                                           bodyUniqueIdA:
                                               ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3SetClosestDistanceFilterLinkA(commandHandle:
                                               b3SharedMemoryCommandHandle,
                                           linkIndexA: ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3SetClosestDistanceFilterBodyB(commandHandle:
                                               b3SharedMemoryCommandHandle,
                                           bodyUniqueIdB:
                                               ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3SetClosestDistanceFilterLinkB(commandHandle:
                                               b3SharedMemoryCommandHandle,
                                           linkIndexB: ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3SetClosestDistanceThreshold(commandHandle:
                                             b3SharedMemoryCommandHandle,
                                         distance: f64);
}
extern "C" {
    pub fn b3GetClosestPointInformation(physClient: b3PhysicsClientHandle,
                                        contactPointInfo:
                                            *mut b3ContactInformation);
}
extern "C" {
    /// get all the bodies that touch a given axis aligned bounding box specified in world space (min and max coordinates)
    pub fn b3InitAABBOverlapQuery(physClient: b3PhysicsClientHandle,
                                  aabbMin: *const f64, aabbMax: *const f64)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetAABBOverlapResults(physClient: b3PhysicsClientHandle,
                                   data: *mut b3AABBOverlapData);
}
extern "C" {
    pub fn b3InitRequestVisualShapeInformation(physClient:
                                                   b3PhysicsClientHandle,
                                               bodyUniqueIdA:
                                                   ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetVisualShapeInformation(physClient: b3PhysicsClientHandle,
                                       visualShapeInfo:
                                           *mut b3VisualShapeInformation);
}
extern "C" {
    pub fn b3InitLoadTexture(physClient: b3PhysicsClientHandle,
                             filename: *const ::std::os::raw::c_char)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusTextureUniqueId(statusHandle:
                                          b3SharedMemoryStatusHandle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateChangeTextureCommandInit(physClient: b3PhysicsClientHandle,
                                            textureUniqueId:
                                                ::std::os::raw::c_int,
                                            width: ::std::os::raw::c_int,
                                            height: ::std::os::raw::c_int,
                                            rgbPixels:
                                                *const ::std::os::raw::c_char)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitUpdateVisualShape(physClient: b3PhysicsClientHandle,
                                   bodyUniqueId: ::std::os::raw::c_int,
                                   jointIndex: ::std::os::raw::c_int,
                                   shapeIndex: ::std::os::raw::c_int,
                                   textureUniqueId: ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3UpdateVisualShapeRGBAColor(commandHandle:
                                            b3SharedMemoryCommandHandle,
                                        rgbaColor: *mut f64);
}
extern "C" {
    pub fn b3UpdateVisualShapeSpecularColor(commandHandle:
                                                b3SharedMemoryCommandHandle,
                                            specularColor: *mut f64);
}
extern "C" {
    pub fn b3InitPhysicsParamCommand(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3PhysicsParamSetGravity(commandHandle:
                                        b3SharedMemoryCommandHandle,
                                    gravx: f64, gravy: f64, gravz: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetTimeStep(commandHandle:
                                         b3SharedMemoryCommandHandle,
                                     timeStep: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetDefaultContactERP(commandHandle:
                                                  b3SharedMemoryCommandHandle,
                                              defaultContactERP: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetDefaultNonContactERP(commandHandle:
                                                     b3SharedMemoryCommandHandle,
                                                 defaultNonContactERP: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetDefaultFrictionERP(commandHandle:
                                                   b3SharedMemoryCommandHandle,
                                               frictionERP: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetNumSubSteps(commandHandle:
                                            b3SharedMemoryCommandHandle,
                                        numSubSteps: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetRealTimeSimulation(commandHandle:
                                                   b3SharedMemoryCommandHandle,
                                               enableRealTimeSimulation:
                                                   ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetNumSolverIterations(commandHandle:
                                                    b3SharedMemoryCommandHandle,
                                                numSolverIterations:
                                                    ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetCollisionFilterMode(commandHandle:
                                                    b3SharedMemoryCommandHandle,
                                                filterMode:
                                                    ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetUseSplitImpulse(commandHandle:
                                                b3SharedMemoryCommandHandle,
                                            useSplitImpulse:
                                                ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetSplitImpulsePenetrationThreshold(commandHandle:
                                                                 b3SharedMemoryCommandHandle,
                                                             splitImpulsePenetrationThreshold:
                                                                 f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetContactBreakingThreshold(commandHandle:
                                                         b3SharedMemoryCommandHandle,
                                                     contactBreakingThreshold:
                                                         f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetMaxNumCommandsPer1ms(commandHandle:
                                                     b3SharedMemoryCommandHandle,
                                                 maxNumCmdPer1ms:
                                                     ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetEnableFileCaching(commandHandle:
                                                  b3SharedMemoryCommandHandle,
                                              enableFileCaching:
                                                  ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetRestitutionVelocityThreshold(commandHandle:
                                                             b3SharedMemoryCommandHandle,
                                                         restitutionVelocityThreshold:
                                                             f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetInternalSimFlags(commandHandle:
                                                 b3SharedMemoryCommandHandle,
                                             flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitStepSimulationCommand(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitResetSimulationCommand(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    /// Load a robot from a URDF file. Status type will CMD_URDF_LOADING_COMPLETED.
/// Access the robot from the unique body index, through b3GetStatusBodyIndex(statusHandle);
    pub fn b3LoadUrdfCommandInit(physClient: b3PhysicsClientHandle,
                                 urdfFileName: *const ::std::os::raw::c_char)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3LoadUrdfCommandSetStartPosition(commandHandle:
                                                 b3SharedMemoryCommandHandle,
                                             startPosX: f64, startPosY: f64,
                                             startPosZ: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadUrdfCommandSetStartOrientation(commandHandle:
                                                    b3SharedMemoryCommandHandle,
                                                startOrnX: f64,
                                                startOrnY: f64,
                                                startOrnZ: f64,
                                                startOrnW: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadUrdfCommandSetUseMultiBody(commandHandle:
                                                b3SharedMemoryCommandHandle,
                                            useMultiBody:
                                                ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadUrdfCommandSetUseFixedBase(commandHandle:
                                                b3SharedMemoryCommandHandle,
                                            useFixedBase:
                                                ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadUrdfCommandSetFlags(commandHandle:
                                         b3SharedMemoryCommandHandle,
                                     flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadUrdfCommandSetGlobalScaling(commandHandle:
                                                 b3SharedMemoryCommandHandle,
                                             globalScaling: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadBulletCommandInit(physClient: b3PhysicsClientHandle,
                                   fileName: *const ::std::os::raw::c_char)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3SaveBulletCommandInit(physClient: b3PhysicsClientHandle,
                                   fileName: *const ::std::os::raw::c_char)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3LoadMJCFCommandInit(physClient: b3PhysicsClientHandle,
                                 fileName: *const ::std::os::raw::c_char)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3LoadMJCFCommandSetFlags(commandHandle:
                                         b3SharedMemoryCommandHandle,
                                     flags: ::std::os::raw::c_int);
}
extern "C" {
    /// compute the forces to achieve an acceleration, given a state q and qdot using inverse dynamics
    pub fn b3CalculateInverseDynamicsCommandInit(physClient:
                                                     b3PhysicsClientHandle,
                                                 bodyIndex:
                                                     ::std::os::raw::c_int,
                                                 jointPositionsQ: *const f64,
                                                 jointVelocitiesQdot:
                                                     *const f64,
                                                 jointAccelerations:
                                                     *const f64)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusInverseDynamicsJointForces(statusHandle:
                                                     b3SharedMemoryStatusHandle,
                                                 bodyUniqueId:
                                                     *mut ::std::os::raw::c_int,
                                                 dofCount:
                                                     *mut ::std::os::raw::c_int,
                                                 jointForces: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CalculateJacobianCommandInit(physClient: b3PhysicsClientHandle,
                                          bodyIndex: ::std::os::raw::c_int,
                                          linkIndex: ::std::os::raw::c_int,
                                          localPosition: *const f64,
                                          jointPositionsQ: *const f64,
                                          jointVelocitiesQdot: *const f64,
                                          jointAccelerations: *const f64)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusJacobian(statusHandle: b3SharedMemoryStatusHandle,
                               linearJacobian: *mut f64,
                               angularJacobian: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// compute the joint positions to move the end effector to a desired target using inverse kinematics
    pub fn b3CalculateInverseKinematicsCommandInit(physClient:
                                                       b3PhysicsClientHandle,
                                                   bodyIndex:
                                                       ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CalculateInverseKinematicsAddTargetPurePosition(commandHandle:
                                                                 b3SharedMemoryCommandHandle,
                                                             endEffectorLinkIndex:
                                                                 ::std::os::raw::c_int,
                                                             targetPosition:
                                                                 *const f64);
}
extern "C" {
    pub fn b3CalculateInverseKinematicsAddTargetPositionWithOrientation(commandHandle:
                                                                            b3SharedMemoryCommandHandle,
                                                                        endEffectorLinkIndex:
                                                                            ::std::os::raw::c_int,
                                                                        targetPosition:
                                                                            *const f64,
                                                                        targetOrientation:
                                                                            *const f64);
}
extern "C" {
    pub fn b3CalculateInverseKinematicsPosWithNullSpaceVel(commandHandle:
                                                               b3SharedMemoryCommandHandle,
                                                           numDof:
                                                               ::std::os::raw::c_int,
                                                           endEffectorLinkIndex:
                                                               ::std::os::raw::c_int,
                                                           targetPosition:
                                                               *const f64,
                                                           lowerLimit:
                                                               *const f64,
                                                           upperLimit:
                                                               *const f64,
                                                           jointRange:
                                                               *const f64,
                                                           restPose:
                                                               *const f64);
}
extern "C" {
    pub fn b3CalculateInverseKinematicsPosOrnWithNullSpaceVel(commandHandle:
                                                                  b3SharedMemoryCommandHandle,
                                                              numDof:
                                                                  ::std::os::raw::c_int,
                                                              endEffectorLinkIndex:
                                                                  ::std::os::raw::c_int,
                                                              targetPosition:
                                                                  *const f64,
                                                              targetOrientation:
                                                                  *const f64,
                                                              lowerLimit:
                                                                  *const f64,
                                                              upperLimit:
                                                                  *const f64,
                                                              jointRange:
                                                                  *const f64,
                                                              restPose:
                                                                  *const f64);
}
extern "C" {
    pub fn b3CalculateInverseKinematicsSetJointDamping(commandHandle:
                                                           b3SharedMemoryCommandHandle,
                                                       numDof:
                                                           ::std::os::raw::c_int,
                                                       jointDampingCoeff:
                                                           *const f64);
}
extern "C" {
    pub fn b3GetStatusInverseKinematicsJointPositions(statusHandle:
                                                          b3SharedMemoryStatusHandle,
                                                      bodyUniqueId:
                                                          *mut ::std::os::raw::c_int,
                                                      dofCount:
                                                          *mut ::std::os::raw::c_int,
                                                      jointPositions:
                                                          *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSdfCommandInit(physClient: b3PhysicsClientHandle,
                                sdfFileName: *const ::std::os::raw::c_char)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3LoadSdfCommandSetUseMultiBody(commandHandle:
                                               b3SharedMemoryCommandHandle,
                                           useMultiBody:
                                               ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSdfCommandSetUseGlobalScaling(commandHandle:
                                                   b3SharedMemoryCommandHandle,
                                               globalScaling: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3SaveWorldCommandInit(physClient: b3PhysicsClientHandle,
                                  sdfFileName: *const ::std::os::raw::c_char)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    /// The b3JointControlCommandInit method is obsolete, use b3JointControlCommandInit2 instead
    pub fn b3JointControlCommandInit(physClient: b3PhysicsClientHandle,
                                     controlMode: ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    /// Set joint motor control variables such as desired position/angle, desired velocity,
/// applied joint forces, dependent on the control mode (CONTROL_MODE_VELOCITY or CONTROL_MODE_TORQUE)
    pub fn b3JointControlCommandInit2(physClient: b3PhysicsClientHandle,
                                      bodyUniqueId: ::std::os::raw::c_int,
                                      controlMode: ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    /// Only use when controlMode is CONTROL_MODE_POSITION_VELOCITY_PD
    pub fn b3JointControlSetDesiredPosition(commandHandle:
                                                b3SharedMemoryCommandHandle,
                                            qIndex: ::std::os::raw::c_int,
                                            value: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetKp(commandHandle: b3SharedMemoryCommandHandle,
                               dofIndex: ::std::os::raw::c_int, value: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetKd(commandHandle: b3SharedMemoryCommandHandle,
                               dofIndex: ::std::os::raw::c_int, value: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Only use when controlMode is CONTROL_MODE_VELOCITY
    pub fn b3JointControlSetDesiredVelocity(commandHandle:
                                                b3SharedMemoryCommandHandle,
                                            dofIndex: ::std::os::raw::c_int,
                                            value: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetMaximumForce(commandHandle:
                                             b3SharedMemoryCommandHandle,
                                         dofIndex: ::std::os::raw::c_int,
                                         value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Only use if when controlMode is CONTROL_MODE_TORQUE,
    pub fn b3JointControlSetDesiredForceTorque(commandHandle:
                                                   b3SharedMemoryCommandHandle,
                                               dofIndex:
                                                   ::std::os::raw::c_int,
                                               value: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// the creation of collision shapes and rigid bodies etc is likely going to change,
/// but good to have a b3CreateBoxShapeCommandInit for now
    pub fn b3CreateCollisionShapeCommandInit(physClient:
                                                 b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddSphere(commandHandle:
                                               b3SharedMemoryCommandHandle,
                                           radius: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddBox(commandHandle:
                                            b3SharedMemoryCommandHandle,
                                        halfExtents: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddCapsule(commandHandle:
                                                b3SharedMemoryCommandHandle,
                                            radius: f64, height: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddCylinder(commandHandle:
                                                 b3SharedMemoryCommandHandle,
                                             radius: f64, height: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddPlane(commandHandle:
                                              b3SharedMemoryCommandHandle,
                                          planeNormal: *mut f64,
                                          planeConstant: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddMesh(commandHandle:
                                             b3SharedMemoryCommandHandle,
                                         fileName:
                                             *const ::std::os::raw::c_char,
                                         meshScale: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddTriMesh(commandHandle:
                                                b3SharedMemoryCommandHandle,
                                            numVertices: ::std::os::raw::c_int,
                                            data: *mut f64,
                                            meshScale: *mut f64)
     -> ::std::os::raw::c_int;
}

extern "C" {
    pub fn b3CreateCollisionSetFlag(commandHandle:
                                        b3SharedMemoryCommandHandle,
                                    shapeIndex: ::std::os::raw::c_int,
                                    flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3CreateCollisionShapeSetChildTransform(commandHandle:
                                                       b3SharedMemoryCommandHandle,
                                                   shapeIndex:
                                                       ::std::os::raw::c_int,
                                                   childPosition: *mut f64,
                                                   childOrientation:
                                                       *mut f64);
}
extern "C" {
    pub fn b3GetStatusCollisionShapeUniqueId(statusHandle:
                                                 b3SharedMemoryStatusHandle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateVisualShapeCommandInit(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusVisualShapeUniqueId(statusHandle:
                                              b3SharedMemoryStatusHandle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateMultiBodyCommandInit(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreateMultiBodyBase(commandHandle: b3SharedMemoryCommandHandle,
                                 mass: f64,
                                 collisionShapeUnique: ::std::os::raw::c_int,
                                 visualShapeUniqueId: ::std::os::raw::c_int,
                                 basePosition: *mut f64,
                                 baseOrientation: *mut f64,
                                 baseInertialFramePosition: *mut f64,
                                 baseInertialFrameOrientation: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateMultiBodyLink(commandHandle: b3SharedMemoryCommandHandle,
                                 linkMass: f64, linkCollisionShapeIndex: f64,
                                 linkVisualShapeIndex: f64,
                                 linkPosition: *mut f64,
                                 linkOrientation: *mut f64,
                                 linkInertialFramePosition: *mut f64,
                                 linkInertialFrameOrientation: *mut f64,
                                 linkParentIndex: ::std::os::raw::c_int,
                                 linkJointType: ::std::os::raw::c_int,
                                 linkJointAxis: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateMultiBodyUseMaximalCoordinates(commandHandle:
                                                      b3SharedMemoryCommandHandle);
}
extern "C" {
    /// create a box of size (1,1,1) at world origin (0,0,0) at orientation quat (0,0,0,1)
/// after that, you can optionally adjust the initial position, orientation and size
    pub fn b3CreateBoxShapeCommandInit(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreateBoxCommandSetStartPosition(commandHandle:
                                                  b3SharedMemoryCommandHandle,
                                              startPosX: f64, startPosY: f64,
                                              startPosZ: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateBoxCommandSetStartOrientation(commandHandle:
                                                     b3SharedMemoryCommandHandle,
                                                 startOrnX: f64,
                                                 startOrnY: f64,
                                                 startOrnZ: f64,
                                                 startOrnW: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateBoxCommandSetHalfExtents(commandHandle:
                                                b3SharedMemoryCommandHandle,
                                            halfExtentsX: f64,
                                            halfExtentsY: f64,
                                            halfExtentsZ: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateBoxCommandSetMass(commandHandle:
                                         b3SharedMemoryCommandHandle,
                                     mass: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateBoxCommandSetCollisionShapeType(commandHandle:
                                                       b3SharedMemoryCommandHandle,
                                                   collisionShapeType:
                                                       ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateBoxCommandSetColorRGBA(commandHandle:
                                              b3SharedMemoryCommandHandle,
                                          red: f64, green: f64, blue: f64,
                                          alpha: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// b3CreatePoseCommandInit will initialize (teleport) the pose of a body/robot. You can individually set the base position,
/// base orientation and joint angles. This will set all velocities of base and joints to zero.
/// This is not a robot control command using actuators/joint motors, but manual repositioning the robot.
    pub fn b3CreatePoseCommandInit(physClient: b3PhysicsClientHandle,
                                   bodyIndex: ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreatePoseCommandSetBasePosition(commandHandle:
                                                  b3SharedMemoryCommandHandle,
                                              startPosX: f64, startPosY: f64,
                                              startPosZ: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetBaseOrientation(commandHandle:
                                                     b3SharedMemoryCommandHandle,
                                                 startOrnX: f64,
                                                 startOrnY: f64,
                                                 startOrnZ: f64,
                                                 startOrnW: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetBaseLinearVelocity(commandHandle:
                                                        b3SharedMemoryCommandHandle,
                                                    linVel: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetBaseAngularVelocity(commandHandle:
                                                         b3SharedMemoryCommandHandle,
                                                     angVel: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetJointPositions(commandHandle:
                                                    b3SharedMemoryCommandHandle,
                                                numJointPositions:
                                                    ::std::os::raw::c_int,
                                                jointPositions: *const f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetJointPosition(physClient:
                                                   b3PhysicsClientHandle,
                                               commandHandle:
                                                   b3SharedMemoryCommandHandle,
                                               jointIndex:
                                                   ::std::os::raw::c_int,
                                               jointPosition: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetJointVelocities(physClient:
                                                     b3PhysicsClientHandle,
                                                 commandHandle:
                                                     b3SharedMemoryCommandHandle,
                                                 numJointVelocities:
                                                     ::std::os::raw::c_int,
                                                 jointVelocities: *const f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetJointVelocity(physClient:
                                                   b3PhysicsClientHandle,
                                               commandHandle:
                                                   b3SharedMemoryCommandHandle,
                                               jointIndex:
                                                   ::std::os::raw::c_int,
                                               jointVelocity: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// We are currently not reading the sensor information from the URDF file, and programmatically assign sensors.
/// This is rather inconsistent, to mix programmatical creation with loading from file.
    pub fn b3CreateSensorCommandInit(physClient: b3PhysicsClientHandle,
                                     bodyUniqueId: ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreateSensorEnable6DofJointForceTorqueSensor(commandHandle:
                                                              b3SharedMemoryCommandHandle,
                                                          jointIndex:
                                                              ::std::os::raw::c_int,
                                                          enable:
                                                              ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// b3CreateSensorEnableIMUForLink is not implemented yet.
/// For now, if the IMU is located in the root link, use the root world transform to mimic an IMU.
    pub fn b3CreateSensorEnableIMUForLink(commandHandle:
                                              b3SharedMemoryCommandHandle,
                                          linkIndex: ::std::os::raw::c_int,
                                          enable: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3RequestActualStateCommandInit(physClient: b3PhysicsClientHandle,
                                           bodyUniqueId:
                                               ::std::os::raw::c_int)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3RequestActualStateCommandComputeLinkVelocity(commandHandle:
                                                              b3SharedMemoryCommandHandle,
                                                          computeLinkVelocity:
                                                              ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetJointState(physClient: b3PhysicsClientHandle,
                           statusHandle: b3SharedMemoryStatusHandle,
                           jointIndex: ::std::os::raw::c_int,
                           state: *mut b3JointSensorState)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetLinkState(physClient: b3PhysicsClientHandle,
                          statusHandle: b3SharedMemoryStatusHandle,
                          linkIndex: ::std::os::raw::c_int,
                          state: *mut b3LinkState) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PickBody(physClient: b3PhysicsClientHandle, rayFromWorldX: f64,
                      rayFromWorldY: f64, rayFromWorldZ: f64,
                      rayToWorldX: f64, rayToWorldY: f64, rayToWorldZ: f64)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3MovePickedBody(physClient: b3PhysicsClientHandle,
                            rayFromWorldX: f64, rayFromWorldY: f64,
                            rayFromWorldZ: f64, rayToWorldX: f64,
                            rayToWorldY: f64, rayToWorldZ: f64)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3RemovePickingConstraint(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreateRaycastCommandInit(physClient: b3PhysicsClientHandle,
                                      rayFromWorldX: f64, rayFromWorldY: f64,
                                      rayFromWorldZ: f64, rayToWorldX: f64,
                                      rayToWorldY: f64, rayToWorldZ: f64)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreateRaycastBatchCommandInit(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3RaycastBatchAddRay(commandHandle: b3SharedMemoryCommandHandle,
                                rayFromWorld: *const f64,
                                rayToWorld: *const f64);
}
extern "C" {
    pub fn b3GetRaycastInformation(physClient: b3PhysicsClientHandle,
                                   raycastInfo: *mut b3RaycastInformation);
}
extern "C" {
    /// Apply external force at the body (or link) center of mass, in world space/Cartesian coordinates.
    pub fn b3ApplyExternalForceCommandInit(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3ApplyExternalForce(commandHandle: b3SharedMemoryCommandHandle,
                                bodyUniqueId: ::std::os::raw::c_int,
                                linkId: ::std::os::raw::c_int,
                                force: *const f64, position: *const f64,
                                flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3ApplyExternalTorque(commandHandle: b3SharedMemoryCommandHandle,
                                 bodyUniqueId: ::std::os::raw::c_int,
                                 linkId: ::std::os::raw::c_int,
                                 torque: *const f64,
                                 flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3InitSetAngularFactorCommand(physClient: b3PhysicsClientHandle,
                                         bodyUniqueId: ::std::os::raw::c_int,
                                         factor: *const f64) -> b3SharedMemoryCommandHandle;
}

extern "C" {
    pub fn b3InitApplyCentralImpulseCommand(physClient: b3PhysicsClientHandle,
                                            bodyUniqueId: ::std::os::raw::c_int,
                                            impulse: *const f64) -> b3SharedMemoryCommandHandle;
}

extern "C" {
    pub fn b3CreateRigidBodyCommandInit(
        physClient : b3PhysicsClientHandle,
        shapeUniqueId : ::std::os::raw::c_int,
        is_dynamic : ::std::os::raw::c_int,
        mass : f64,
        position : *const f64,
        orientation : *const f64) -> b3SharedMemoryCommandHandle;
}

extern "C" {
    pub fn b3InitSetUserPointerCommand(physClient: b3PhysicsClientHandle,
                                       bodyUniqueId : ::std::os::raw::c_int,
                                       pointer: *mut ::std::os::raw::c_void) -> b3SharedMemoryCommandHandle;
}

extern "C" {
    pub fn b3InitGetUserPointerCommand(physClient: b3PhysicsClientHandle,
                                       bodyUniqueId : ::std::os::raw::c_int) -> b3SharedMemoryCommandHandle;
}

extern "C" {
    pub fn b3GetUserPointer(statusHandle: b3SharedMemoryStatusHandle,
                            pointer : *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}


extern "C" {
    /// experiments of robots interacting with non-rigid objects (such as btSoftBody)
    pub fn b3LoadBunnyCommandInit(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3LoadBunnySetScale(commandHandle: b3SharedMemoryCommandHandle,
                               scale: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadBunnySetMass(commandHandle: b3SharedMemoryCommandHandle,
                              mass: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadBunnySetCollisionMargin(commandHandle:
                                             b3SharedMemoryCommandHandle,
                                         collisionMargin: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3RequestVREventsCommandInit(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3VREventsSetDeviceTypeFilter(commandHandle:
                                             b3SharedMemoryCommandHandle,
                                         deviceTypeFilter:
                                             ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3GetVREventsData(physClient: b3PhysicsClientHandle,
                             vrEventsData: *mut b3VREventsData);
}
extern "C" {
    pub fn b3SetVRCameraStateCommandInit(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3SetVRCameraRootPosition(commandHandle:
                                         b3SharedMemoryCommandHandle,
                                     rootPos: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3SetVRCameraRootOrientation(commandHandle:
                                            b3SharedMemoryCommandHandle,
                                        rootOrn: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3SetVRCameraTrackingObject(commandHandle:
                                           b3SharedMemoryCommandHandle,
                                       objectUniqueId: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3SetVRCameraTrackingObjectFlag(commandHandle:
                                               b3SharedMemoryCommandHandle,
                                           flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3RequestKeyboardEventsCommandInit(physClient:
                                                  b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetKeyboardEventsData(physClient: b3PhysicsClientHandle,
                                   keyboardEventsData:
                                       *mut b3KeyboardEventsData);
}
extern "C" {
    pub fn b3RequestMouseEventsCommandInit(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetMouseEventsData(physClient: b3PhysicsClientHandle,
                                mouseEventsData: *mut b3MouseEventsData);
}
extern "C" {
    pub fn b3StateLoggingCommandInit(physClient: b3PhysicsClientHandle)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3StateLoggingStart(commandHandle: b3SharedMemoryCommandHandle,
                               loggingType: ::std::os::raw::c_int,
                               fileName: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingAddLoggingObjectUniqueId(commandHandle:
                                                      b3SharedMemoryCommandHandle,
                                                  objectUniqueId:
                                                      ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingSetMaxLogDof(commandHandle:
                                          b3SharedMemoryCommandHandle,
                                      maxLogDof: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingSetLinkIndexA(commandHandle:
                                           b3SharedMemoryCommandHandle,
                                       linkIndexA: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingSetLinkIndexB(commandHandle:
                                           b3SharedMemoryCommandHandle,
                                       linkIndexB: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingSetBodyAUniqueId(commandHandle:
                                              b3SharedMemoryCommandHandle,
                                          bodyAUniqueId:
                                              ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingSetBodyBUniqueId(commandHandle:
                                              b3SharedMemoryCommandHandle,
                                          bodyBUniqueId:
                                              ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingSetDeviceTypeFilter(commandHandle:
                                                 b3SharedMemoryCommandHandle,
                                             deviceTypeFilter:
                                                 ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingSetLogFlags(commandHandle:
                                         b3SharedMemoryCommandHandle,
                                     logFlags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetStatusLoggingUniqueId(statusHandle:
                                          b3SharedMemoryStatusHandle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingStop(commandHandle: b3SharedMemoryCommandHandle,
                              loggingUniqueId: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ProfileTimingCommandInit(physClient: b3PhysicsClientHandle,
                                      name: *const ::std::os::raw::c_char)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3SetProfileTimingDuractionInMicroSeconds(commandHandle:
                                                         b3SharedMemoryCommandHandle,
                                                     duration:
                                                         ::std::os::raw::c_int);
}
extern "C" {
    pub fn b3SetTimeOut(physClient: b3PhysicsClientHandle,
                        timeOutInSeconds: f64);
}
extern "C" {
    pub fn b3GetTimeOut(physClient: b3PhysicsClientHandle) -> f64;
}
extern "C" {
    pub fn b3SetAdditionalSearchPath(physClient: b3PhysicsClientHandle,
                                     path: *mut ::std::os::raw::c_char)
     -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3MultiplyTransforms(posA: *const f64, ornA: *const f64,
                                posB: *const f64, ornB: *const f64,
                                outPos: *mut f64, outOrn: *mut f64);
}
extern "C" {
    pub fn b3InvertTransform(pos: *const f64, orn: *const f64,
                             outPos: *mut f64, outOrn: *mut f64);
}
