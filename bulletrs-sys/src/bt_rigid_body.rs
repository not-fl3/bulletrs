/* automatically generated by rust-bindgen */

pub const _GLIBCXX_MATH_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_CXX_CONFIG_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_RELEASE: ::std::os::raw::c_uint = 7;
pub const __GLIBCXX__: ::std::os::raw::c_uint = 20170630;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_DEPRECATED: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_DUAL_ABI: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_CXX11_ABI: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_INLINE_VERSION: ::std::os::raw::c_uint = 0;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_OS_DEFINES: ::std::os::raw::c_uint = 1;
pub const __NO_CTYPE: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _ISOC95_SOURCE: ::std::os::raw::c_uint = 1;
pub const _ISOC99_SOURCE: ::std::os::raw::c_uint = 1;
pub const _ISOC11_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const _XOPEN_SOURCE: ::std::os::raw::c_uint = 700;
pub const _XOPEN_SOURCE_EXTENDED: ::std::os::raw::c_uint = 1;
pub const _LARGEFILE64_SOURCE: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN_EXTENDED: ::std::os::raw::c_uint = 1;
pub const __USE_UNIX98: ::std::os::raw::c_uint = 1;
pub const _LARGEFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8XSI: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2KXSI: ::std::os::raw::c_uint = 1;
pub const __USE_LARGEFILE: ::std::os::raw::c_uint = 1;
pub const __USE_LARGEFILE64: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_GNU: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 25;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _GLIBCXX_CPU_DEFINES: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_FAST_MATH: ::std::os::raw::c_uint = 0;
pub const _GLIBCXX_HAVE_ACOSF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ACOSL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ALIGNED_ALLOC: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ASINF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ASINL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ATAN2F: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ATAN2L: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ATANF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ATANL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_AT_QUICK_EXIT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_CEILF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_CEILL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_COSF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_COSHF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_COSHL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_COSL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_DIRENT_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_DLFCN_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EBADMSG: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ECANCELED: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ECHILD: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EIDRM: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENODATA: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENOLINK: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENOSPC: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENOSR: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENOSTR: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENOTRECOVERABLE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENOTSUP: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EOVERFLOW: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EOWNERDEAD: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EPERM: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EPROTO: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ETIME: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ETIMEDOUT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ETXTBSY: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EWOULDBLOCK: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EXECINFO_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EXPF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EXPL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FABSF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FABSL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FENV_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FINITE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FINITEF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FINITEL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FLOORF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FLOORL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FMODF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FMODL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FREXPF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FREXPL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_GETS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_HYPOT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_HYPOTF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_HYPOTL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ICONV: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_INT64_T: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_INT64_T_LONG: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ISINFF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ISINFL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ISNANF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ISNANL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LC_MESSAGES: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LDEXPF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LDEXPL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LIBINTL_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LIMIT_AS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LIMIT_DATA: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LIMIT_FSIZE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LIMIT_RSS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LIMIT_VMEM: ::std::os::raw::c_uint = 0;
pub const _GLIBCXX_HAVE_LINUX_FUTEX: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LOCALE_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LOG10F: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LOG10L: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LOGF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LOGL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_MEMALIGN: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_MODF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_MODFF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_MODFL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_POLL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_POSIX_MEMALIGN: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_POWF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_POWL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_QUICK_EXIT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SETENV: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SINCOS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SINCOSF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SINCOSL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SINF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SINHF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SINHL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SINL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SQRTF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SQRTL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STDINT_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRERROR_L: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRERROR_R: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRING_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRTOF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRTOLD: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRXFRM_L: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT:
          ::std::os::raw::c_uint =
    1;
pub const _GLIBCXX_HAVE_SYS_IOCTL_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_IPC_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_RESOURCE_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_SEM_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_STATVFS_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_SYSINFO_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_UIO_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_S_ISREG: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_TANF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_TANHF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_TANHL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_TANL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_TLS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_UCHAR_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_UTIME_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_VWSCANF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_WCSTOF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_WRITEV: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL: ::std::os::raw::c_uint = 1;
pub const LT_OBJDIR: &'static [u8; 7usize] = b".libs/\x00";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &'static [u8; 1usize] = b"\x00";
pub const _GLIBCXX_PACKAGE_NAME: &'static [u8; 15usize] =
    b"package-unused\x00";
pub const _GLIBCXX_PACKAGE_STRING: &'static [u8; 30usize] =
    b"package-unused version-unused\x00";
pub const _GLIBCXX_PACKAGE_TARNAME: &'static [u8; 10usize] = b"libstdc++\x00";
pub const _GLIBCXX_PACKAGE_URL: &'static [u8; 1usize] = b"\x00";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &'static [u8; 15usize] =
    b"version-unused\x00";
pub const STDC_HEADERS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX11_USE_C99_COMPLEX: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX11_USE_C99_MATH: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX11_USE_C99_STDIO: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX98_USE_C99_MATH: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX98_USE_C99_STDIO: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_ATOMIC_BUILTINS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: ::std::os::raw::c_uint = 0;
pub const _GLIBCXX_HAS_GTHREADS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HOSTED: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_RES_LIMITS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_STDIO_EOF: ::std::os::raw::c_int = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_STDIO_SEEK_END: ::std::os::raw::c_uint = 2;
pub const _GLIBCXX_SYMVER: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_SYMVER_GNU: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C11_UCHAR_CXX11: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99_FENV_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_CLOCK_MONOTONIC: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_CLOCK_REALTIME: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_DECIMAL_FLOAT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_FCHMOD: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_FCHMODAT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_FLOAT128: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_GET_NPROCS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_INT128: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_LFS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_LONG_LONG: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_NANOSLEEP: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_NLS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_RANDOM_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_REALPATH: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_SCHED_YIELD: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_SC_NPROCESSORS_ONLN: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_SENDFILE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_ST_MTIM: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_TMPNAM: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_UTIMENSAT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_WCHAR_T: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_VERBOSE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_X86_RDRAND: ::std::os::raw::c_uint = 1;
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: ::std::os::raw::c_uint = 1;
pub const _CPP_TYPE_TRAITS_H: ::std::os::raw::c_uint = 1;
pub const _EXT_TYPE_TRAITS: ::std::os::raw::c_uint = 1;
pub const _MATH_H: ::std::os::raw::c_uint = 1;
pub const __GLIBC_USE_LIB_EXT2: ::std::os::raw::c_uint = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::std::os::raw::c_uint = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: ::std::os::raw::c_uint = 1;
pub const __FP_LOGB0_IS_MIN: ::std::os::raw::c_uint = 1;
pub const __FP_LOGBNAN_IS_MIN: ::std::os::raw::c_uint = 1;
pub const FP_ILOGB0: ::std::os::raw::c_int = -2147483648;
pub const FP_ILOGBNAN: ::std::os::raw::c_int = -2147483648;
pub const __FP_LONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const FP_LLOGB0: ::std::os::raw::c_longlong = -9223372036854775808;
pub const FP_LLOGBNAN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const FP_INT_UPWARD: ::std::os::raw::c_uint = 0;
pub const FP_INT_DOWNWARD: ::std::os::raw::c_uint = 1;
pub const FP_INT_TOWARDZERO: ::std::os::raw::c_uint = 2;
pub const FP_INT_TONEARESTFROMZERO: ::std::os::raw::c_uint = 3;
pub const FP_INT_TONEAREST: ::std::os::raw::c_uint = 4;
pub const __MATH_DECLARING_DOUBLE: ::std::os::raw::c_uint = 1;
pub const __MATH_DECLARE_LDOUBLE: ::std::os::raw::c_uint = 1;
pub const FP_NAN: ::std::os::raw::c_uint = 0;
pub const FP_INFINITE: ::std::os::raw::c_uint = 1;
pub const FP_ZERO: ::std::os::raw::c_uint = 2;
pub const FP_SUBNORMAL: ::std::os::raw::c_uint = 3;
pub const FP_NORMAL: ::std::os::raw::c_uint = 4;
pub const MATH_ERRNO: ::std::os::raw::c_uint = 1;
pub const MATH_ERREXCEPT: ::std::os::raw::c_uint = 2;
pub const math_errhandling: ::std::os::raw::c_uint = 3;
pub const DOMAIN: ::std::os::raw::c_uint = 1;
pub const SING: ::std::os::raw::c_uint = 2;
pub const OVERFLOW: ::std::os::raw::c_uint = 3;
pub const UNDERFLOW: ::std::os::raw::c_uint = 4;
pub const TLOSS: ::std::os::raw::c_uint = 5;
pub const PLOSS: ::std::os::raw::c_uint = 6;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_El: f64 = 2.718281828459045;
pub const M_LOG2El: f64 = 1.4426950408889634;
pub const M_LOG10El: f64 = 0.4342944819032518;
pub const M_LN2l: f64 = 0.6931471805599453;
pub const M_LN10l: f64 = 2.302585092994046;
pub const M_PIl: f64 = 3.141592653589793;
pub const M_PI_2l: f64 = 1.5707963267948966;
pub const M_PI_4l: f64 = 0.7853981633974483;
pub const M_1_PIl: f64 = 0.3183098861837907;
pub const M_2_PIl: f64 = 0.6366197723675814;
pub const M_2_SQRTPIl: f64 = 1.1283791670955126;
pub const M_SQRT2l: f64 = 1.4142135623730951;
pub const M_SQRT1_2l: f64 = 0.7071067811865476;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const __lldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _BITS_UINTN_IDENTITY_H: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const __timeval_defined: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_CMATH: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_STDLIB_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_CSTDLIB: ::std::os::raw::c_uint = 1;
pub const BT_BULLET_VERSION: ::std::os::raw::c_uint = 287;
pub const _ASSERT_H: ::std::os::raw::c_uint = 1;
pub const BT_LARGE_FLOAT: f64 = 1000000000000000000000000000000.;
pub const BT_ONE: f64 = 1.;
pub const BT_ZERO: f64 = 0.;
pub const BT_TWO: f64 = 2.;
pub const BT_HALF: f64 = 0.5;
pub const BT_USE_PLACEMENT_NEW: ::std::os::raw::c_uint = 1;
pub const __EXCEPTION_H: ::std::os::raw::c_uint = 1;
pub const __cpp_lib_uncaught_exceptions: ::std::os::raw::c_uint = 201411;
pub const btVector3DataName: &'static [u8; 20usize] =
    b"btVector3DoubleData\x00";
pub const btQuaternionDataName: &'static [u8; 23usize] =
    b"btQuaternionDoubleData\x00";
pub const _STDIO_H: ::std::os::raw::c_uint = 1;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const _G_config_h: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MMAP: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MREMAP: ::std::os::raw::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::std::os::raw::c_uint = 131073;
pub const _G_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const _IO_UNIFIED_JUMPTABLES: ::std::os::raw::c_uint = 1;
pub const EOF: ::std::os::raw::c_int = -1;
pub const _IOS_INPUT: ::std::os::raw::c_uint = 1;
pub const _IOS_OUTPUT: ::std::os::raw::c_uint = 2;
pub const _IOS_ATEND: ::std::os::raw::c_uint = 4;
pub const _IOS_APPEND: ::std::os::raw::c_uint = 8;
pub const _IOS_TRUNC: ::std::os::raw::c_uint = 16;
pub const _IOS_NOCREATE: ::std::os::raw::c_uint = 32;
pub const _IOS_NOREPLACE: ::std::os::raw::c_uint = 64;
pub const _IOS_BIN: ::std::os::raw::c_uint = 128;
pub const _IO_MAGIC: ::std::os::raw::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::std::os::raw::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::std::os::raw::c_uint = 4294901760;
pub const _IO_USER_BUF: ::std::os::raw::c_uint = 1;
pub const _IO_UNBUFFERED: ::std::os::raw::c_uint = 2;
pub const _IO_NO_READS: ::std::os::raw::c_uint = 4;
pub const _IO_NO_WRITES: ::std::os::raw::c_uint = 8;
pub const _IO_EOF_SEEN: ::std::os::raw::c_uint = 16;
pub const _IO_ERR_SEEN: ::std::os::raw::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::std::os::raw::c_uint = 64;
pub const _IO_LINKED: ::std::os::raw::c_uint = 128;
pub const _IO_IN_BACKUP: ::std::os::raw::c_uint = 256;
pub const _IO_LINE_BUF: ::std::os::raw::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::std::os::raw::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::std::os::raw::c_uint = 2048;
pub const _IO_IS_APPENDING: ::std::os::raw::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_BAD_SEEN: ::std::os::raw::c_uint = 16384;
pub const _IO_USER_LOCK: ::std::os::raw::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::std::os::raw::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::std::os::raw::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::std::os::raw::c_uint = 8;
pub const _IO_SKIPWS: ::std::os::raw::c_uint = 1;
pub const _IO_LEFT: ::std::os::raw::c_uint = 2;
pub const _IO_RIGHT: ::std::os::raw::c_uint = 4;
pub const _IO_INTERNAL: ::std::os::raw::c_uint = 8;
pub const _IO_DEC: ::std::os::raw::c_uint = 16;
pub const _IO_OCT: ::std::os::raw::c_uint = 32;
pub const _IO_HEX: ::std::os::raw::c_uint = 64;
pub const _IO_SHOWBASE: ::std::os::raw::c_uint = 128;
pub const _IO_SHOWPOINT: ::std::os::raw::c_uint = 256;
pub const _IO_UPPERCASE: ::std::os::raw::c_uint = 512;
pub const _IO_SHOWPOS: ::std::os::raw::c_uint = 1024;
pub const _IO_SCIENTIFIC: ::std::os::raw::c_uint = 2048;
pub const _IO_FIXED: ::std::os::raw::c_uint = 4096;
pub const _IO_UNITBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_STDIO: ::std::os::raw::c_uint = 16384;
pub const _IO_DONT_CLOSE: ::std::os::raw::c_uint = 32768;
pub const _IO_BOOLALPHA: ::std::os::raw::c_uint = 65536;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const SEEK_DATA: ::std::os::raw::c_uint = 3;
pub const SEEK_HOLE: ::std::os::raw::c_uint = 4;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 20;
pub const TMP_MAX: ::std::os::raw::c_uint = 238328;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 4096;
pub const L_ctermid: ::std::os::raw::c_uint = 9;
pub const L_cuserid: ::std::os::raw::c_uint = 9;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 16;
pub const ACTIVE_TAG: ::std::os::raw::c_uint = 1;
pub const ISLAND_SLEEPING: ::std::os::raw::c_uint = 2;
pub const WANTS_DEACTIVATION: ::std::os::raw::c_uint = 3;
pub const DISABLE_DEACTIVATION: ::std::os::raw::c_uint = 4;
pub const DISABLE_SIMULATION: ::std::os::raw::c_uint = 5;
pub const btCollisionObjectDataName: &'static [u8; 28usize] =
    b"btCollisionObjectDoubleData\x00";
pub const btRigidBodyDataName: &'static [u8; 22usize] =
    b"btRigidBodyDoubleData\x00";
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___true_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___true_type() {
    assert_eq!(::std::mem::size_of::<std___true_type>() , 1usize , concat ! (
               "Size of: " , stringify ! ( std___true_type ) ));
    assert_eq! (::std::mem::align_of::<std___true_type>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( std___true_type ) ));
}
impl Clone for std___true_type {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std___false_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___false_type() {
    assert_eq!(::std::mem::size_of::<std___false_type>() , 1usize , concat ! (
               "Size of: " , stringify ! ( std___false_type ) ));
    assert_eq! (::std::mem::align_of::<std___false_type>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( std___false_type ) ));
}
impl Clone for std___false_type {
    fn clone(&self) -> Self { *self }
}
pub type std___truth_type___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___traitor {
    pub _address: u8,
}
pub const std___traitor___value: std___traitor__bindgen_ty_1 =
    std___traitor__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___traitor__bindgen_ty_1 { __value = 0, }
pub type std___traitor___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___are_same {
    pub _address: u8,
}
pub const std___are_same___value: std___are_same__bindgen_ty_1 =
    std___are_same__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___are_same__bindgen_ty_1 { __value = 0, }
pub type std___are_same___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_void {
    pub _address: u8,
}
pub const std___is_void___value: std___is_void__bindgen_ty_1 =
    std___is_void__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_void__bindgen_ty_1 { __value = 0, }
pub type std___is_void___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_void_open0_void_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_void>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_void ) ));
    assert_eq!(::std::mem::align_of::<std___is_void>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_void ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integer {
    pub _address: u8,
}
pub const std___is_integer___value: std___is_integer__bindgen_ty_1 =
    std___is_integer__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_integer__bindgen_ty_1 { __value = 0, }
pub type std___is_integer___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_integer_open0_bool__close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_char_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_signed_char_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_char_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_wchar_t_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_short_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_short_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_int_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_int_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_long_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_long_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_long_long_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0___int128_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_integer>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_integer ) ));
    assert_eq!(::std::mem::align_of::<std___is_integer>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_integer ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating {
    pub _address: u8,
}
pub const std___is_floating___value: std___is_floating__bindgen_ty_1 =
    std___is_floating__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_floating__bindgen_ty_1 { __value = 0, }
pub type std___is_floating___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_floating_open0_float_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_floating>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___is_floating ) ));
    assert_eq!(::std::mem::align_of::<std___is_floating>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_floating ) ));
}
#[test]
fn __bindgen_test_layout_std___is_floating_open0_double_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_floating>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___is_floating ) ));
    assert_eq!(::std::mem::align_of::<std___is_floating>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_floating ) ));
}
#[test]
fn __bindgen_test_layout_std___is_floating_open0_long_double_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_floating>() , 1usize , concat !
               (
               "Size of template specialization: " , stringify ! (
               std___is_floating ) ));
    assert_eq!(::std::mem::align_of::<std___is_floating>() , 1usize , concat !
               (
               "Alignment of template specialization: " , stringify ! (
               std___is_floating ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer {
    pub _address: u8,
}
pub const std___is_pointer___value: std___is_pointer__bindgen_ty_1 =
    std___is_pointer__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_pointer__bindgen_ty_1 { __value = 0, }
pub type std___is_pointer___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_char {
    pub _address: u8,
}
pub const std___is_char___value: std___is_char__bindgen_ty_1 =
    std___is_char__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_char__bindgen_ty_1 { __value = 0, }
pub type std___is_char___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_char_open0_char_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_char>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_char ) ));
    assert_eq!(::std::mem::align_of::<std___is_char>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_char ) ));
}
#[test]
fn __bindgen_test_layout_std___is_char_open0_wchar_t_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_char>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_char ) ));
    assert_eq!(::std::mem::align_of::<std___is_char>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_char ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_byte {
    pub _address: u8,
}
pub const std___is_byte___value: std___is_byte__bindgen_ty_1 =
    std___is_byte__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_byte__bindgen_ty_1 { __value = 0, }
pub type std___is_byte___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_byte_open0_char_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_byte>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_byte ) ));
    assert_eq!(::std::mem::align_of::<std___is_byte>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_byte ) ));
}
#[test]
fn __bindgen_test_layout_std___is_byte_open0_signed_char_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_byte>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_byte ) ));
    assert_eq!(::std::mem::align_of::<std___is_byte>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_byte ) ));
}
#[test]
fn __bindgen_test_layout_std___is_byte_open0_unsigned_char_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<std___is_byte>() , 1usize , concat ! (
               "Size of template specialization: " , stringify ! (
               std___is_byte ) ));
    assert_eq!(::std::mem::align_of::<std___is_byte>() , 1usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               std___is_byte ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_move_iterator {
    pub _address: u8,
}
pub const std___is_move_iterator___value: std___is_move_iterator__bindgen_ty_1
          =
    std___is_move_iterator__bindgen_ty_1::__value;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum std___is_move_iterator__bindgen_ty_1 { __value = 0, }
pub type std___is_move_iterator___type = std___false_type;
#[repr(C)]
pub struct std_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_exception {
    pub vtable_: *const std_exception__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_std_exception() {
    assert_eq!(::std::mem::size_of::<std_exception>() , 8usize , concat ! (
               "Size of: " , stringify ! ( std_exception ) ));
    assert_eq! (::std::mem::align_of::<std_exception>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( std_exception ) ));
}
extern "C" {
    #[link_name = "_ZNSt9exceptionD0Ev"]
    pub fn std_exception_exception_destructor(this: *mut std_exception);
}
extern "C" {
    #[link_name = "_ZNKSt9exception4whatEv"]
    pub fn std_exception_what(this: *mut ::std::os::raw::c_void)
     -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_exception {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_exception() {
    assert_eq!(::std::mem::size_of::<std_bad_exception>() , 8usize , concat !
               ( "Size of: " , stringify ! ( std_bad_exception ) ));
    assert_eq! (::std::mem::align_of::<std_bad_exception>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( std_bad_exception ) ));
}
extern "C" {
    #[link_name = "_ZNSt13bad_exceptionD0Ev"]
    pub fn std_bad_exception_bad_exception_destructor(this:
                                                          *mut std_bad_exception);
}
extern "C" {
    #[link_name = "_ZNKSt13bad_exception4whatEv"]
    pub fn std_bad_exception_what(this: *mut ::std::os::raw::c_void)
     -> *const ::std::os::raw::c_char;
}
pub type std_terminate_handler =
    ::std::option::Option<unsafe extern "C" fn()>;
pub type std_unexpected_handler =
    ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "_ZSt13set_terminatePFvvE"]
    pub fn std_set_terminate(arg1: std_terminate_handler)
     -> std_terminate_handler;
}
extern "C" {
    #[link_name = "_ZSt9terminatev"]
    pub fn std_terminate();
}
extern "C" {
    #[link_name = "_ZSt14set_unexpectedPFvvE"]
    pub fn std_set_unexpected(arg1: std_unexpected_handler)
     -> std_unexpected_handler;
}
extern "C" {
    #[link_name = "_ZSt10unexpectedv"]
    pub fn std_unexpected();
}
extern "C" {
    #[link_name = "_ZSt18uncaught_exceptionv"]
    pub fn std_uncaught_exception() -> bool;
}
extern "C" {
    #[link_name = "_ZSt19uncaught_exceptionsv"]
    pub fn std_uncaught_exceptions() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_alloc {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_alloc() {
    assert_eq!(::std::mem::size_of::<std_bad_alloc>() , 8usize , concat ! (
               "Size of: " , stringify ! ( std_bad_alloc ) ));
    assert_eq! (::std::mem::align_of::<std_bad_alloc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( std_bad_alloc ) ));
}
extern "C" {
    #[link_name = "_ZNSt9bad_allocD0Ev"]
    pub fn std_bad_alloc_bad_alloc_destructor(this: *mut std_bad_alloc);
}
extern "C" {
    #[link_name = "_ZNKSt9bad_alloc4whatEv"]
    pub fn std_bad_alloc_what(this: *mut ::std::os::raw::c_void)
     -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct std_nothrow_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_nothrow_t() {
    assert_eq!(::std::mem::size_of::<std_nothrow_t>() , 1usize , concat ! (
               "Size of: " , stringify ! ( std_nothrow_t ) ));
    assert_eq! (::std::mem::align_of::<std_nothrow_t>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( std_nothrow_t ) ));
}
impl Clone for std_nothrow_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_ZSt7nothrow"]
    pub static std_nothrow: std_nothrow_t;
}
pub type std_new_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "_ZSt15set_new_handlerPFvvE"]
    pub fn std_set_new_handler(arg1: std_new_handler) -> std_new_handler;
}
pub type __gnu_cxx___conditional_type___type<_Iftrue> = _Iftrue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___add_unsigned {
    pub _address: u8,
}
pub type __gnu_cxx___add_unsigned___if_type = u8;
pub type __gnu_cxx___add_unsigned___type = __gnu_cxx___add_unsigned___if_type;
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_char_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_signed_char_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_short_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_int_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_long_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_long_long_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___add_unsigned>() , 1usize ,
               concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___add_unsigned ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___remove_unsigned {
    pub _address: u8,
}
pub type __gnu_cxx___remove_unsigned___if_type = u8;
pub type __gnu_cxx___remove_unsigned___type =
    __gnu_cxx___remove_unsigned___if_type;
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_char_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___remove_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___remove_unsigned>() , 1usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_char_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___remove_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___remove_unsigned>() , 1usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_short_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___remove_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___remove_unsigned>() , 1usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_int_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___remove_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___remove_unsigned>() , 1usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_long_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___remove_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___remove_unsigned>() , 1usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<__gnu_cxx___remove_unsigned>() , 1usize ,
               concat ! (
               "Size of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
    assert_eq!(::std::mem::align_of::<__gnu_cxx___remove_unsigned>() , 1usize
               , concat ! (
               "Alignment of template specialization: " , stringify ! (
               __gnu_cxx___remove_unsigned ) ));
}
pub type __gnu_cxx___promote___type = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_2 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_2___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_3 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_3___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_4 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_4___type<_Tp2> = _Tp2;
extern "C" {
    #[link_name = "_ZN9__gnu_cxx27__verbose_terminate_handlerEv"]
    pub fn __gnu_cxx___verbose_terminate_handler();
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type float_t = f32;
pub type double_t = f64;

extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn sincos(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
extern "C" {
    pub fn __sincos(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn exp10(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp10(__x: f64) -> f64;
}
extern "C" {
    pub fn pow10(__x: f64) -> f64;
}
extern "C" {
    pub fn __pow10(__x: f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nextdown(__x: f64) -> f64;
}
extern "C" {
    pub fn __nextdown(__x: f64) -> f64;
}
extern "C" {
    pub fn nextup(__x: f64) -> f64;
}
extern "C" {
    pub fn __nextup(__x: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llogb(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __llogb(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn roundeven(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundeven(__x: f64) -> f64;
}
extern "C" {
    pub fn fromfp(__x: f64, __round: ::std::os::raw::c_int,
                  __width: ::std::os::raw::c_uint) -> __intmax_t;
}
extern "C" {
    pub fn __fromfp(__x: f64, __round: ::std::os::raw::c_int,
                    __width: ::std::os::raw::c_uint) -> __intmax_t;
}
extern "C" {
    pub fn ufromfp(__x: f64, __round: ::std::os::raw::c_int,
                   __width: ::std::os::raw::c_uint) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfp(__x: f64, __round: ::std::os::raw::c_int,
                     __width: ::std::os::raw::c_uint) -> __uintmax_t;
}
extern "C" {
    pub fn fromfpx(__x: f64, __round: ::std::os::raw::c_int,
                   __width: ::std::os::raw::c_uint) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpx(__x: f64, __round: ::std::os::raw::c_int,
                     __width: ::std::os::raw::c_uint) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpx(__x: f64, __round: ::std::os::raw::c_int,
                    __width: ::std::os::raw::c_uint) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpx(__x: f64, __round: ::std::os::raw::c_int,
                      __width: ::std::os::raw::c_uint) -> __uintmax_t;
}
extern "C" {
    pub fn fmaxmag(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxmag(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminmag(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminmag(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalorder(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalordermag(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canonicalize(__cx: *mut f64, __x: *const f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpayload(__x: *const f64) -> f64;
}
extern "C" {
    pub fn __getpayload(__x: *const f64) -> f64;
}
extern "C" {
    pub fn setpayload(__x: *mut f64, __payload: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpayloadsig(__x: *mut f64, __payload: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn sincosf(__x: f32, __sinx: *mut f32, __cosx: *mut f32);
}
extern "C" {
    pub fn __sincosf(__x: f32, __sinx: *mut f32, __cosx: *mut f32);
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn exp10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp10f(__x: f32) -> f32;
}
extern "C" {
    pub fn pow10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __pow10f(__x: f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn nextdownf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nextdownf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextupf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nextupf(__x: f32) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llogbf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __llogbf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn roundevenf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundevenf(__x: f32) -> f32;
}
extern "C" {
    pub fn fromfpf(__x: f32, __round: ::std::os::raw::c_int,
                   __width: ::std::os::raw::c_uint) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpf(__x: f32, __round: ::std::os::raw::c_int,
                     __width: ::std::os::raw::c_uint) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpf(__x: f32, __round: ::std::os::raw::c_int,
                    __width: ::std::os::raw::c_uint) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpf(__x: f32, __round: ::std::os::raw::c_int,
                      __width: ::std::os::raw::c_uint) -> __uintmax_t;
}
extern "C" {
    pub fn fromfpxf(__x: f32, __round: ::std::os::raw::c_int,
                    __width: ::std::os::raw::c_uint) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpxf(__x: f32, __round: ::std::os::raw::c_int,
                      __width: ::std::os::raw::c_uint) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpxf(__x: f32, __round: ::std::os::raw::c_int,
                     __width: ::std::os::raw::c_uint) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpxf(__x: f32, __round: ::std::os::raw::c_int,
                       __width: ::std::os::raw::c_uint) -> __uintmax_t;
}
extern "C" {
    pub fn fmaxmagf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxmagf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminmagf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminmagf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalorderf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalordermagf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canonicalizef(__cx: *mut f32, __x: *const f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpayloadf(__x: *const f32) -> f32;
}
extern "C" {
    pub fn __getpayloadf(__x: *const f32) -> f32;
}
extern "C" {
    pub fn setpayloadf(__x: *mut f32, __payload: f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpayloadsigf(__x: *mut f32, __payload: f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn sincosl(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
extern "C" {
    pub fn __sincosl(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
extern "C" {
    pub fn acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn expl(__x: f64) -> f64;
}
extern "C" {
    pub fn __expl(__x: f64) -> f64;
}
extern "C" {
    pub fn frexpl(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexpl(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexpl(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn logl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logl(__x: f64) -> f64;
}
extern "C" {
    pub fn log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn exp10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp10l(__x: f64) -> f64;
}
extern "C" {
    pub fn pow10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __pow10l(__x: f64) -> f64;
}
extern "C" {
    pub fn expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn __floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinfl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinfl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn __significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __isnanl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnanl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn __lgammal_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nextdownl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nextdownl(__x: f64) -> f64;
}
extern "C" {
    pub fn nextupl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nextupl(__x: f64) -> f64;
}
extern "C" {
    pub fn remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbnl(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbl(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llogbl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __llogbl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scalblnl(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalblnl(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn __truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn remquol(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn __remquol(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn lrintl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn roundevenl(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundevenl(__x: f64) -> f64;
}
extern "C" {
    pub fn fromfpl(__x: f64, __round: ::std::os::raw::c_int,
                   __width: ::std::os::raw::c_uint) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpl(__x: f64, __round: ::std::os::raw::c_int,
                     __width: ::std::os::raw::c_uint) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpl(__x: f64, __round: ::std::os::raw::c_int,
                    __width: ::std::os::raw::c_uint) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpl(__x: f64, __round: ::std::os::raw::c_int,
                      __width: ::std::os::raw::c_uint) -> __uintmax_t;
}
extern "C" {
    pub fn fromfpxl(__x: f64, __round: ::std::os::raw::c_int,
                    __width: ::std::os::raw::c_uint) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpxl(__x: f64, __round: ::std::os::raw::c_int,
                      __width: ::std::os::raw::c_uint) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpxl(__x: f64, __round: ::std::os::raw::c_int,
                     __width: ::std::os::raw::c_uint) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpxl(__x: f64, __round: ::std::os::raw::c_int,
                       __width: ::std::os::raw::c_uint) -> __uintmax_t;
}
extern "C" {
    pub fn fmaxmagl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxmagl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminmagl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminmagl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __iseqsigl(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalorderl(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalordermagl(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canonicalizel(__cx: *mut f64, __x: *const f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpayloadl(__x: *const f64) -> f64;
}
extern "C" {
    pub fn __getpayloadl(__x: *const f64) -> f64;
}
extern "C" {
    pub fn setpayloadl(__x: *mut f64, __payload: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpayloadsigl(__x: *mut f64, __payload: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    #[link_name = "signgam"]
    pub static mut signgam: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iscanonicall(__x: f64) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _LIB_VERSION_TYPE {
    _IEEE_ = -1,
    _SVID_ = 0,
    _XOPEN_ = 1,
    _POSIX_ = 2,
    _ISOC_ = 3,
}
extern "C" {
    #[link_name = "_LIB_VERSION"]
    pub static mut _LIB_VERSION: _LIB_VERSION_TYPE;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout___exception() {
    assert_eq!(::std::mem::size_of::<__exception>() , 40usize , concat ! (
               "Size of: " , stringify ! ( __exception ) ));
    assert_eq! (::std::mem::align_of::<__exception>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __exception ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __exception ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __exception ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __exception ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __exception ) ) . arg1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __exception ) , "::" ,
                stringify ! ( arg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __exception ) ) . arg2 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __exception ) , "::" ,
                stringify ! ( arg2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __exception ) ) . retval as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __exception ) , "::" ,
                stringify ! ( retval ) ));
}
impl Clone for __exception {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn matherr(__exc: *mut __exception) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strfromd(__dest: *mut ::std::os::raw::c_char, __size: usize,
                    __format: *const ::std::os::raw::c_char, __f: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf(__dest: *mut ::std::os::raw::c_char, __size: usize,
                    __format: *const ::std::os::raw::c_char, __f: f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfroml(__dest: *mut ::std::os::raw::c_char, __size: usize,
                    __format: *const ::std::os::raw::c_char, __f: f64)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
               ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __locales as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __names as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strtol_l(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int, __loc: __locale_t)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul_l(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int, __loc: __locale_t)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoll_l(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int, __loc: __locale_t)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull_l(__nptr: *const ::std::os::raw::c_char,
                      __endptr: *mut *mut ::std::os::raw::c_char,
                      __base: ::std::os::raw::c_int, __loc: __locale_t)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtod_l(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __loc: __locale_t) -> f64;
}
extern "C" {
    pub fn strtof_l(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __loc: __locale_t) -> f32;
}
extern "C" {
    pub fn strtold_l(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __loc: __locale_t) -> f64;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint) -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __bindgen_anon_1: pthread_cond_t__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: pthread_cond_t__bindgen_ty_1__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_cond_t__bindgen_ty_1__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ) .
                __low as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( __low ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ) .
                __high as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( __high ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_1 )
                ) . __wseq as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( __wseq ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_1 )
                ) . __wseq32 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( __wseq32 ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_cond_t__bindgen_ty_1__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ) .
                __low as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ,
                "::" , stringify ! ( __low ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ) .
                __high as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ,
                "::" , stringify ! ( __high ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_2 )
                ) . __g1_start as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( __g1_start ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_2 )
                ) . __g1_start32 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( __g1_start32 ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g_refs as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __g_refs
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g_size as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __g_size
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g1_orig_size as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __g1_orig_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wrefs as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __wrefs
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g_signals as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __g_signals ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __wrphase_futex as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wrphase_futex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writers_futex as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writers_futex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad3 as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad4 as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __cur_writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __cur_writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::std::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::std::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn secure_getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp64(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps64(__template: *mut ::std::os::raw::c_char,
                      __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkostemp(__template: *mut ::std::os::raw::c_char,
                    __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp64(__template: *mut ::std::os::raw::c_char,
                      __flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(__template: *mut ::std::os::raw::c_char,
                     __suffixlen: ::std::os::raw::c_int,
                     __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps64(__template: *mut ::std::os::raw::c_char,
                       __suffixlen: ::std::os::raw::c_int,
                       __flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canonicalize_file_name(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void,
                                               arg3:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn qsort_r(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_d_fn_t,
                   __arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut u16, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut u16, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const u16,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(__key: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn posix_openpt(__oflag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlockpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(__fd: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(__fd: ::std::os::raw::c_int,
                     __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpt() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type btScalar = f64;
#[repr(C)]
#[derive(Copy)]
pub struct btInfMaskConverter {
    pub __bindgen_anon_1: btInfMaskConverter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union btInfMaskConverter__bindgen_ty_1 {
    pub mask: f32,
    pub intmask: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_btInfMaskConverter__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<btInfMaskConverter__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( btInfMaskConverter__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<btInfMaskConverter__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                btInfMaskConverter__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btInfMaskConverter__bindgen_ty_1 ) ) .
                mask as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                btInfMaskConverter__bindgen_ty_1 ) , "::" , stringify ! ( mask
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btInfMaskConverter__bindgen_ty_1 ) ) .
                intmask as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                btInfMaskConverter__bindgen_ty_1 ) , "::" , stringify ! (
                intmask ) ));
}
impl Clone for btInfMaskConverter__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_btInfMaskConverter() {
    assert_eq!(::std::mem::size_of::<btInfMaskConverter>() , 4usize , concat !
               ( "Size of: " , stringify ! ( btInfMaskConverter ) ));
    assert_eq! (::std::mem::align_of::<btInfMaskConverter>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( btInfMaskConverter ) ));
}
impl Clone for btInfMaskConverter {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_ZL14btInfinityMask"]
    pub static mut btInfinityMask: btInfMaskConverter;
}
/// rudimentary class to provide type info
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btTypedObject {
    pub m_objectType: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btTypedObject() {
    assert_eq!(::std::mem::size_of::<btTypedObject>() , 4usize , concat ! (
               "Size of: " , stringify ! ( btTypedObject ) ));
    assert_eq! (::std::mem::align_of::<btTypedObject>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( btTypedObject ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btTypedObject ) ) . m_objectType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btTypedObject ) , "::"
                , stringify ! ( m_objectType ) ));
}
impl Clone for btTypedObject {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_Z22btAlignedAllocInternalmi"]
    pub fn btAlignedAllocInternal(size: usize,
                                  alignment: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "_Z21btAlignedFreeInternalPv"]
    pub fn btAlignedFreeInternal(ptr: *mut ::std::os::raw::c_void);
}
pub type size_type = ::std::os::raw::c_int;
pub type btAlignedAllocFunc =
    ::std::option::Option<unsafe extern "C" fn(size: usize,
                                               alignment:
                                                   ::std::os::raw::c_int)
                              -> *mut ::std::os::raw::c_void>;
pub type btAlignedFreeFunc =
    ::std::option::Option<unsafe extern "C" fn(memblock:
                                                   *mut ::std::os::raw::c_void)>;
pub type btAllocFunc =
    ::std::option::Option<unsafe extern "C" fn(size: usize)
                              -> *mut ::std::os::raw::c_void>;
pub type btFreeFunc =
    ::std::option::Option<unsafe extern "C" fn(memblock:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    /// The developer can let all Bullet memory allocations go through a custom memory allocator, using btAlignedAllocSetCustom
    #[link_name = "_Z23btAlignedAllocSetCustomPFPvmEPFvS_E"]
    pub fn btAlignedAllocSetCustom(allocFunc: btAllocFunc,
                                   freeFunc: btFreeFunc);
}
extern "C" {
    /// If the developer has already an custom aligned allocator, then btAlignedAllocSetCustomAligned can be used. The default aligned allocator pre-allocates extra memory using the non-aligned allocator, and instruments it.
    #[link_name = "_Z30btAlignedAllocSetCustomAlignedPFPvmiEPFvS_E"]
    pub fn btAlignedAllocSetCustomAligned(allocFunc: btAlignedAllocFunc,
                                          freeFunc: btAlignedFreeFunc);
}
pub type btAlignedAllocator_self_type = u8;
pub type btAlignedAllocator_const_pointer<T> = *mut T;
pub type btAlignedAllocator_const_reference<T> = *mut T;
pub type btAlignedAllocator_pointer<T> = *mut T;
pub type btAlignedAllocator_reference<T> = *mut T;
pub type btAlignedAllocator_value_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btAlignedAllocator_rebind {
    pub _address: u8,
}
pub type btAlignedAllocator_rebind_other = u8;
/// The btAlignedObjectArray template class uses a subset of the stl::vector interface for its methods
/// It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data
#[repr(C)]
#[derive(Debug)]
pub struct btAlignedObjectArray<T> {
    pub m_allocator: u8,
    pub m_size: ::std::os::raw::c_int,
    pub m_capacity: ::std::os::raw::c_int,
    pub m_data: *mut T,
    pub m_ownsMemory: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btAlignedObjectArray_less {
    pub _address: u8,
}
/// @brief btVector3 can be used to represent 3D points and vectors.
/// It has an un-used w component to suit 16-byte alignment when btVector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
/// Ideally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btVector3 {
    pub m_floats: [btScalar; 4usize],
}
#[test]
fn bindgen_test_layout_btVector3() {
    assert_eq!(::std::mem::size_of::<btVector3>() , 32usize , concat ! (
               "Size of: " , stringify ! ( btVector3 ) ));
    assert_eq! (::std::mem::align_of::<btVector3>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( btVector3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btVector3 ) ) . m_floats as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btVector3 ) , "::" ,
                stringify ! ( m_floats ) ));
}
impl Clone for btVector3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btVector4 {
    pub _base: btVector3,
}
#[test]
fn bindgen_test_layout_btVector4() {
    assert_eq!(::std::mem::size_of::<btVector4>() , 32usize , concat ! (
               "Size of: " , stringify ! ( btVector4 ) ));
    assert_eq! (::std::mem::align_of::<btVector4>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( btVector4 ) ));
}
impl Clone for btVector4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btVector3FloatData {
    pub m_floats: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_btVector3FloatData() {
    assert_eq!(::std::mem::size_of::<btVector3FloatData>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( btVector3FloatData ) ));
    assert_eq! (::std::mem::align_of::<btVector3FloatData>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( btVector3FloatData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btVector3FloatData ) ) . m_floats as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btVector3FloatData ) ,
                "::" , stringify ! ( m_floats ) ));
}
impl Clone for btVector3FloatData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btVector3DoubleData {
    pub m_floats: [f64; 4usize],
}
#[test]
fn bindgen_test_layout_btVector3DoubleData() {
    assert_eq!(::std::mem::size_of::<btVector3DoubleData>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( btVector3DoubleData ) ));
    assert_eq! (::std::mem::align_of::<btVector3DoubleData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( btVector3DoubleData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btVector3DoubleData ) ) . m_floats as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btVector3DoubleData ) ,
                "::" , stringify ! ( m_floats ) ));
}
impl Clone for btVector3DoubleData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btQuadWord {
    pub m_floats: [btScalar; 4usize],
}
#[test]
fn bindgen_test_layout_btQuadWord() {
    assert_eq!(::std::mem::size_of::<btQuadWord>() , 32usize , concat ! (
               "Size of: " , stringify ! ( btQuadWord ) ));
    assert_eq! (::std::mem::align_of::<btQuadWord>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( btQuadWord ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btQuadWord ) ) . m_floats as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btQuadWord ) , "::" ,
                stringify ! ( m_floats ) ));
}
impl Clone for btQuadWord {
    fn clone(&self) -> Self { *self }
}
/// @brief The btQuaternion implements quaternion to perform linear algebra rotations in combination with btMatrix3x3, btVector3 and btTransform.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btQuaternion {
    pub _base: btQuadWord,
}
#[test]
fn bindgen_test_layout_btQuaternion() {
    assert_eq!(::std::mem::size_of::<btQuaternion>() , 32usize , concat ! (
               "Size of: " , stringify ! ( btQuaternion ) ));
    assert_eq! (::std::mem::align_of::<btQuaternion>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( btQuaternion ) ));
}
impl Clone for btQuaternion {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btQuaternionFloatData {
    pub m_floats: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_btQuaternionFloatData() {
    assert_eq!(::std::mem::size_of::<btQuaternionFloatData>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( btQuaternionFloatData )
               ));
    assert_eq! (::std::mem::align_of::<btQuaternionFloatData>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( btQuaternionFloatData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btQuaternionFloatData ) ) . m_floats as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btQuaternionFloatData )
                , "::" , stringify ! ( m_floats ) ));
}
impl Clone for btQuaternionFloatData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btQuaternionDoubleData {
    pub m_floats: [f64; 4usize],
}
#[test]
fn bindgen_test_layout_btQuaternionDoubleData() {
    assert_eq!(::std::mem::size_of::<btQuaternionDoubleData>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( btQuaternionDoubleData )
               ));
    assert_eq! (::std::mem::align_of::<btQuaternionDoubleData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( btQuaternionDoubleData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btQuaternionDoubleData ) ) . m_floats as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btQuaternionDoubleData
                ) , "::" , stringify ! ( m_floats ) ));
}
impl Clone for btQuaternionDoubleData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize , concat ! (
               "Size of: " , stringify ! ( _IO_FILE ) ));
    assert_eq! (::std::mem::align_of::<_IO_FILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_FILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_backup_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _markers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _chain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _fileno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _old_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _cur_column ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const
                _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _vtable_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as
                usize } , 131usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _shortbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as
                usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _unused2 ) ));
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos64_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos64_t {
    fn clone(&self) -> Self { *self }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _IO_marker ) ));
    assert_eq! (::std::mem::align_of::<_IO_marker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _pos ) ));
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *mut ::std::os::raw::c_char,
                                               __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *const ::std::os::raw::c_char,
                                               __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __pos: *mut __off64_t,
                                               __w: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type __io_close_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type cookie_read_function_t = __io_read_fn;
pub type cookie_write_function_t = __io_write_fn;
pub type cookie_seek_function_t = __io_seek_fn;
pub type cookie_close_function_t = __io_close_fn;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_cookie_io_functions_t {
    pub read: __io_read_fn,
    pub write: __io_write_fn,
    pub seek: __io_seek_fn,
    pub close: __io_close_fn,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    assert_eq!(::std::mem::size_of::<_IO_cookie_io_functions_t>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( _IO_cookie_io_functions_t ) ));
    assert_eq! (::std::mem::align_of::<_IO_cookie_io_functions_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _IO_cookie_io_functions_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_cookie_io_functions_t ) ) . read as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _IO_cookie_io_functions_t ) , "::" , stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_cookie_io_functions_t ) ) . write as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _IO_cookie_io_functions_t ) , "::" , stringify ! ( write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_cookie_io_functions_t ) ) . seek as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _IO_cookie_io_functions_t ) , "::" , stringify ! ( seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_cookie_io_functions_t ) ) . close as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _IO_cookie_io_functions_t ) , "::" , stringify ! ( close ) ));
}
impl Clone for _IO_cookie_io_functions_t {
    fn clone(&self) -> Self { *self }
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_file {
    _unused: [u8; 0],
}
extern "C" {
    pub fn _IO_cookie_init(__cfile: *mut _IO_cookie_file,
                           __read_write: ::std::os::raw::c_int,
                           __cookie: *mut ::std::os::raw::c_void,
                           __fns: _IO_cookie_io_functions_t);
}
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *mut __va_list_tag,
                       arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type fpos_t = _G_fpos_t;
pub type fpos64_t = _G_fpos64_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fopen64(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen64(__filename: *const ::std::os::raw::c_char,
                     __modes: *const ::std::os::raw::c_char,
                     __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(__magic_cookie: *mut ::std::os::raw::c_void,
                       __modes: *const ::std::os::raw::c_char,
                       __io_funcs: _IO_cookie_io_functions_t) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: usize,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                     __format: *const ::std::os::raw::c_char,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(__ptr: *mut *mut ::std::os::raw::c_char,
                     __f: *const ::std::os::raw::c_char,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(__ptr: *mut *mut ::std::os::raw::c_char,
                      __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(__ptr: *mut *mut ::std::os::raw::c_char,
                    __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gets(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgets_unlocked(__s: *mut ::std::os::raw::c_char,
                          __n: ::std::os::raw::c_int, __stream: *mut FILE)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __n: usize, __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fputs_unlocked(__s: *const ::std::os::raw::c_char,
                          __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: usize, __n: usize, __stream: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko64(__stream: *mut FILE, __off: __off64_t,
                    __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
}
extern "C" {
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos64(__stream: *mut FILE, __pos: *const fpos64_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "_sys_nerr"]
    pub static mut _sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_sys_errlist"]
    pub static mut _sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cuserid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
extern "C" {
    pub fn obstack_printf(__obstack: *mut obstack,
                          __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obstack_vprintf(__obstack: *mut obstack,
                           __format: *const ::std::os::raw::c_char,
                           __args: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
/// @brief The btMatrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with btQuaternion, btTransform and btVector3.
/// Make sure to only include a pure orthogonal matrix without scaling.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btMatrix3x3 {
    /// Data storage for the matrix, each vector is a row of the matrix
    pub m_el: [btVector3; 3usize],
}
#[test]
fn bindgen_test_layout_btMatrix3x3() {
    assert_eq!(::std::mem::size_of::<btMatrix3x3>() , 96usize , concat ! (
               "Size of: " , stringify ! ( btMatrix3x3 ) ));
    assert_eq! (::std::mem::align_of::<btMatrix3x3>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( btMatrix3x3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btMatrix3x3 ) ) . m_el as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btMatrix3x3 ) , "::" ,
                stringify ! ( m_el ) ));
}
extern "C" {
    /// @brief Return the determinant of the matrix
    #[link_name = "_ZNK11btMatrix3x311determinantEv"]
    pub fn btMatrix3x3_determinant(this: *const btMatrix3x3) -> btScalar;
}
extern "C" {
    /// @brief Return the adjoint of the matrix
    #[link_name = "_ZNK11btMatrix3x37adjointEv"]
    pub fn btMatrix3x3_adjoint(this: *const btMatrix3x3) -> btMatrix3x3;
}
extern "C" {
    /// @brief Return the matrix with all values non negative
    #[link_name = "_ZNK11btMatrix3x38absoluteEv"]
    pub fn btMatrix3x3_absolute(this: *const btMatrix3x3) -> btMatrix3x3;
}
extern "C" {
    /// @brief Return the transpose of the matrix
    #[link_name = "_ZNK11btMatrix3x39transposeEv"]
    pub fn btMatrix3x3_transpose(this: *const btMatrix3x3) -> btMatrix3x3;
}
extern "C" {
    /// @brief Return the inverse of the matrix
    #[link_name = "_ZNK11btMatrix3x37inverseEv"]
    pub fn btMatrix3x3_inverse(this: *const btMatrix3x3) -> btMatrix3x3;
}
extern "C" {
    #[link_name = "_ZNK11btMatrix3x314transposeTimesERKS_"]
    pub fn btMatrix3x3_transposeTimes(this: *const btMatrix3x3,
                                      m: *const btMatrix3x3) -> btMatrix3x3;
}
extern "C" {
    #[link_name = "_ZNK11btMatrix3x314timesTransposeERKS_"]
    pub fn btMatrix3x3_timesTranspose(this: *const btMatrix3x3,
                                      m: *const btMatrix3x3) -> btMatrix3x3;
}
extern "C" {
    #[link_name = "_ZNK11btMatrix3x39serializeER21btMatrix3x3DoubleData"]
    pub fn btMatrix3x3_serialize(this: *const btMatrix3x3,
                                 dataOut: *mut btMatrix3x3DoubleData);
}
extern "C" {
    #[link_name = "_ZNK11btMatrix3x314serializeFloatER20btMatrix3x3FloatData"]
    pub fn btMatrix3x3_serializeFloat(this: *const btMatrix3x3,
                                      dataOut: *mut btMatrix3x3FloatData);
}
extern "C" {
    #[link_name = "_ZN11btMatrix3x311deSerializeERK21btMatrix3x3DoubleData"]
    pub fn btMatrix3x3_deSerialize(this: *mut btMatrix3x3,
                                   dataIn: *const btMatrix3x3DoubleData);
}
extern "C" {
    #[link_name =
          "_ZN11btMatrix3x316deSerializeFloatERK20btMatrix3x3FloatData"]
    pub fn btMatrix3x3_deSerializeFloat(this: *mut btMatrix3x3,
                                        dataIn: *const btMatrix3x3FloatData);
}
extern "C" {
    #[link_name =
          "_ZN11btMatrix3x317deSerializeDoubleERK21btMatrix3x3DoubleData"]
    pub fn btMatrix3x3_deSerializeDouble(this: *mut btMatrix3x3,
                                         dataIn:
                                             *const btMatrix3x3DoubleData);
}
impl Clone for btMatrix3x3 {
    fn clone(&self) -> Self { *self }
}
impl btMatrix3x3 {
    #[inline]
    pub unsafe fn determinant(&self) -> btScalar {
        btMatrix3x3_determinant(self)
    }
    #[inline]
    pub unsafe fn adjoint(&self) -> btMatrix3x3 { btMatrix3x3_adjoint(self) }
    #[inline]
    pub unsafe fn absolute(&self) -> btMatrix3x3 {
        btMatrix3x3_absolute(self)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> btMatrix3x3 {
        btMatrix3x3_transpose(self)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> btMatrix3x3 { btMatrix3x3_inverse(self) }
    #[inline]
    pub unsafe fn transposeTimes(&self, m: *const btMatrix3x3)
     -> btMatrix3x3 {
        btMatrix3x3_transposeTimes(self, m)
    }
    #[inline]
    pub unsafe fn timesTranspose(&self, m: *const btMatrix3x3)
     -> btMatrix3x3 {
        btMatrix3x3_timesTranspose(self, m)
    }
    #[inline]
    pub unsafe fn serialize(&self, dataOut: *mut btMatrix3x3DoubleData) {
        btMatrix3x3_serialize(self, dataOut)
    }
    #[inline]
    pub unsafe fn serializeFloat(&self, dataOut: *mut btMatrix3x3FloatData) {
        btMatrix3x3_serializeFloat(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerialize(&mut self,
                              dataIn: *const btMatrix3x3DoubleData) {
        btMatrix3x3_deSerialize(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeFloat(&mut self,
                                   dataIn: *const btMatrix3x3FloatData) {
        btMatrix3x3_deSerializeFloat(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeDouble(&mut self,
                                    dataIn: *const btMatrix3x3DoubleData) {
        btMatrix3x3_deSerializeDouble(self, dataIn)
    }
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btMatrix3x3FloatData {
    pub m_el: [btVector3FloatData; 3usize],
}
#[test]
fn bindgen_test_layout_btMatrix3x3FloatData() {
    assert_eq!(::std::mem::size_of::<btMatrix3x3FloatData>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( btMatrix3x3FloatData )
               ));
    assert_eq! (::std::mem::align_of::<btMatrix3x3FloatData>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( btMatrix3x3FloatData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btMatrix3x3FloatData ) ) . m_el as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btMatrix3x3FloatData )
                , "::" , stringify ! ( m_el ) ));
}
impl Clone for btMatrix3x3FloatData {
    fn clone(&self) -> Self { *self }
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btMatrix3x3DoubleData {
    pub m_el: [btVector3DoubleData; 3usize],
}
#[test]
fn bindgen_test_layout_btMatrix3x3DoubleData() {
    assert_eq!(::std::mem::size_of::<btMatrix3x3DoubleData>() , 96usize ,
               concat ! ( "Size of: " , stringify ! ( btMatrix3x3DoubleData )
               ));
    assert_eq! (::std::mem::align_of::<btMatrix3x3DoubleData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( btMatrix3x3DoubleData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btMatrix3x3DoubleData ) ) . m_el as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btMatrix3x3DoubleData )
                , "::" , stringify ! ( m_el ) ));
}
impl Clone for btMatrix3x3DoubleData {
    fn clone(&self) -> Self { *self }
}
/// @brief The btTransform class supports rigid transforms with only translation and rotation and no scaling/shear.
/// It can be used in combination with btVector3, btQuaternion and btMatrix3x3 linear algebra classes.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btTransform {
    /// Storage for the rotation
    pub m_basis: btMatrix3x3,
    /// Storage for the translation
    pub m_origin: btVector3,
}
#[test]
fn bindgen_test_layout_btTransform() {
    assert_eq!(::std::mem::size_of::<btTransform>() , 128usize , concat ! (
               "Size of: " , stringify ! ( btTransform ) ));
    assert_eq! (::std::mem::align_of::<btTransform>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( btTransform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btTransform ) ) . m_basis as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btTransform ) , "::" ,
                stringify ! ( m_basis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btTransform ) ) . m_origin as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( btTransform ) , "::" ,
                stringify ! ( m_origin ) ));
}
extern "C" {
    /// @brief Return the inverse of this transform times the other transform
/// @param t The other transform
/// return this.inverse() * the other
    #[link_name = "_ZNK11btTransform12inverseTimesERKS_"]
    pub fn btTransform_inverseTimes(this: *const btTransform,
                                    t: *const btTransform) -> btTransform;
}
extern "C" {
    #[link_name = "_ZNK11btTransform9serializeER21btTransformDoubleData"]
    pub fn btTransform_serialize(this: *const btTransform,
                                 dataOut: *mut btTransformDoubleData);
}
extern "C" {
    #[link_name = "_ZNK11btTransform14serializeFloatER20btTransformFloatData"]
    pub fn btTransform_serializeFloat(this: *const btTransform,
                                      dataOut: *mut btTransformFloatData);
}
extern "C" {
    #[link_name = "_ZN11btTransform11deSerializeERK21btTransformDoubleData"]
    pub fn btTransform_deSerialize(this: *mut btTransform,
                                   dataIn: *const btTransformDoubleData);
}
extern "C" {
    #[link_name =
          "_ZN11btTransform17deSerializeDoubleERK21btTransformDoubleData"]
    pub fn btTransform_deSerializeDouble(this: *mut btTransform,
                                         dataIn:
                                             *const btTransformDoubleData);
}
extern "C" {
    #[link_name =
          "_ZN11btTransform16deSerializeFloatERK20btTransformFloatData"]
    pub fn btTransform_deSerializeFloat(this: *mut btTransform,
                                        dataIn: *const btTransformFloatData);
}
impl Clone for btTransform {
    fn clone(&self) -> Self { *self }
}
impl btTransform {
    #[inline]
    pub unsafe fn inverseTimes(&self, t: *const btTransform) -> btTransform {
        btTransform_inverseTimes(self, t)
    }
    #[inline]
    pub unsafe fn serialize(&self, dataOut: *mut btTransformDoubleData) {
        btTransform_serialize(self, dataOut)
    }
    #[inline]
    pub unsafe fn serializeFloat(&self, dataOut: *mut btTransformFloatData) {
        btTransform_serializeFloat(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerialize(&mut self,
                              dataIn: *const btTransformDoubleData) {
        btTransform_deSerialize(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeDouble(&mut self,
                                    dataIn: *const btTransformDoubleData) {
        btTransform_deSerializeDouble(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeFloat(&mut self,
                                   dataIn: *const btTransformFloatData) {
        btTransform_deSerializeFloat(self, dataIn)
    }
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btTransformFloatData {
    pub m_basis: btMatrix3x3FloatData,
    pub m_origin: btVector3FloatData,
}
#[test]
fn bindgen_test_layout_btTransformFloatData() {
    assert_eq!(::std::mem::size_of::<btTransformFloatData>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( btTransformFloatData )
               ));
    assert_eq! (::std::mem::align_of::<btTransformFloatData>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( btTransformFloatData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btTransformFloatData ) ) . m_basis as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btTransformFloatData )
                , "::" , stringify ! ( m_basis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btTransformFloatData ) ) . m_origin as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( btTransformFloatData )
                , "::" , stringify ! ( m_origin ) ));
}
impl Clone for btTransformFloatData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btTransformDoubleData {
    pub m_basis: btMatrix3x3DoubleData,
    pub m_origin: btVector3DoubleData,
}
#[test]
fn bindgen_test_layout_btTransformDoubleData() {
    assert_eq!(::std::mem::size_of::<btTransformDoubleData>() , 128usize ,
               concat ! ( "Size of: " , stringify ! ( btTransformDoubleData )
               ));
    assert_eq! (::std::mem::align_of::<btTransformDoubleData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( btTransformDoubleData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btTransformDoubleData ) ) . m_basis as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btTransformDoubleData )
                , "::" , stringify ! ( m_basis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btTransformDoubleData ) ) . m_origin as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( btTransformDoubleData )
                , "::" , stringify ! ( m_origin ) ));
}
impl Clone for btTransformDoubleData {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// btDispatcher uses these types
/// IMPORTANT NOTE:The types are ordered polyhedral, implicit convex and concave
/// to facilitate type checking
/// CUSTOM_POLYHEDRAL_SHAPE_TYPE,CUSTOM_CONVEX_SHAPE_TYPE and CUSTOM_CONCAVE_SHAPE_TYPE can be used to extend Bullet without modifying source code
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BroadphaseNativeTypes {
    BOX_SHAPE_PROXYTYPE = 0,
    TRIANGLE_SHAPE_PROXYTYPE = 1,
    TETRAHEDRAL_SHAPE_PROXYTYPE = 2,
    CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE = 3,
    CONVEX_HULL_SHAPE_PROXYTYPE = 4,
    CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE = 5,
    CUSTOM_POLYHEDRAL_SHAPE_TYPE = 6,
    IMPLICIT_CONVEX_SHAPES_START_HERE = 7,
    SPHERE_SHAPE_PROXYTYPE = 8,
    MULTI_SPHERE_SHAPE_PROXYTYPE = 9,
    CAPSULE_SHAPE_PROXYTYPE = 10,
    CONE_SHAPE_PROXYTYPE = 11,
    CONVEX_SHAPE_PROXYTYPE = 12,
    CYLINDER_SHAPE_PROXYTYPE = 13,
    UNIFORM_SCALING_SHAPE_PROXYTYPE = 14,
    MINKOWSKI_SUM_SHAPE_PROXYTYPE = 15,
    MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE = 16,
    BOX_2D_SHAPE_PROXYTYPE = 17,
    CONVEX_2D_SHAPE_PROXYTYPE = 18,
    CUSTOM_CONVEX_SHAPE_TYPE = 19,
    CONCAVE_SHAPES_START_HERE = 20,
    TRIANGLE_MESH_SHAPE_PROXYTYPE = 21,
    SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE = 22,
    FAST_CONCAVE_MESH_PROXYTYPE = 23,
    TERRAIN_SHAPE_PROXYTYPE = 24,
    GIMPACT_SHAPE_PROXYTYPE = 25,
    MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE = 26,
    EMPTY_SHAPE_PROXYTYPE = 27,
    STATIC_PLANE_PROXYTYPE = 28,
    CUSTOM_CONCAVE_SHAPE_TYPE = 29,
    CONCAVE_SHAPES_END_HERE = 30,
    COMPOUND_SHAPE_PROXYTYPE = 31,
    SOFTBODY_SHAPE_PROXYTYPE = 32,
    HFFLUID_SHAPE_PROXYTYPE = 33,
    HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE = 34,
    INVALID_SHAPE_PROXYTYPE = 35,
    MAX_BROADPHASE_COLLISION_TYPES = 36,
}
/// The btBroadphaseProxy is the main class that can be used with the Bullet broadphases.
/// It stores collision shape type information, collision filter information and a client object, typically a btCollisionObject or btRigidBody.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btBroadphaseProxy {
    pub m_clientObject: *mut ::std::os::raw::c_void,
    pub m_collisionFilterGroup: ::std::os::raw::c_int,
    pub m_collisionFilterMask: ::std::os::raw::c_int,
    pub m_uniqueId: ::std::os::raw::c_int,
    pub m_aabbMin: btVector3,
    pub m_aabbMax: btVector3,
}
#[repr(i32)]
/// optional filtering to cull potential collisions
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum btBroadphaseProxy_CollisionFilterGroups {
    DefaultFilter = 1,
    StaticFilter = 2,
    KinematicFilter = 4,
    DebrisFilter = 8,
    SensorTrigger = 16,
    CharacterFilter = 32,
    AllFilter = -1,
}
#[test]
fn bindgen_test_layout_btBroadphaseProxy() {
    assert_eq!(::std::mem::size_of::<btBroadphaseProxy>() , 88usize , concat !
               ( "Size of: " , stringify ! ( btBroadphaseProxy ) ));
    assert_eq! (::std::mem::align_of::<btBroadphaseProxy>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( btBroadphaseProxy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btBroadphaseProxy ) ) . m_clientObject as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btBroadphaseProxy ) ,
                "::" , stringify ! ( m_clientObject ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btBroadphaseProxy ) ) .
                m_collisionFilterGroup as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btBroadphaseProxy ) ,
                "::" , stringify ! ( m_collisionFilterGroup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btBroadphaseProxy ) ) .
                m_collisionFilterMask as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btBroadphaseProxy ) ,
                "::" , stringify ! ( m_collisionFilterMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btBroadphaseProxy ) ) . m_uniqueId as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( btBroadphaseProxy ) ,
                "::" , stringify ! ( m_uniqueId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btBroadphaseProxy ) ) . m_aabbMin as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( btBroadphaseProxy ) ,
                "::" , stringify ! ( m_aabbMin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btBroadphaseProxy ) ) . m_aabbMax as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( btBroadphaseProxy ) ,
                "::" , stringify ! ( m_aabbMax ) ));
}
impl Clone for btBroadphaseProxy {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionAlgorithm {
    _unused: [u8; 0],
}
/// The btBroadphasePair class contains a pair of aabb-overlapping objects.
/// A btDispatcher can search a btCollisionAlgorithm that performs exact/narrowphase collision detection on the actual collision shapes.
#[repr(C)]
#[derive(Copy)]
pub struct btBroadphasePair {
    pub m_pProxy0: *mut btBroadphaseProxy,
    pub m_pProxy1: *mut btBroadphaseProxy,
    pub m_algorithm: *mut btCollisionAlgorithm,
    pub __bindgen_anon_1: btBroadphasePair__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union btBroadphasePair__bindgen_ty_1 {
    pub m_internalInfo1: *mut ::std::os::raw::c_void,
    pub m_internalTmpValue: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_btBroadphasePair__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<btBroadphasePair__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( btBroadphasePair__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<btBroadphasePair__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( btBroadphasePair__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btBroadphasePair__bindgen_ty_1 ) ) .
                m_internalInfo1 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                btBroadphasePair__bindgen_ty_1 ) , "::" , stringify ! (
                m_internalInfo1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btBroadphasePair__bindgen_ty_1 ) ) .
                m_internalTmpValue as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                btBroadphasePair__bindgen_ty_1 ) , "::" , stringify ! (
                m_internalTmpValue ) ));
}
impl Clone for btBroadphasePair__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_btBroadphasePair() {
    assert_eq!(::std::mem::size_of::<btBroadphasePair>() , 32usize , concat !
               ( "Size of: " , stringify ! ( btBroadphasePair ) ));
    assert_eq! (::std::mem::align_of::<btBroadphasePair>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( btBroadphasePair ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btBroadphasePair ) ) . m_pProxy0 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btBroadphasePair ) ,
                "::" , stringify ! ( m_pProxy0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btBroadphasePair ) ) . m_pProxy1 as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( btBroadphasePair ) ,
                "::" , stringify ! ( m_pProxy1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btBroadphasePair ) ) . m_algorithm as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( btBroadphasePair ) ,
                "::" , stringify ! ( m_algorithm ) ));
}
impl Clone for btBroadphasePair {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btBroadphasePairSortPredicate {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_btBroadphasePairSortPredicate() {
    assert_eq!(::std::mem::size_of::<btBroadphasePairSortPredicate>() , 1usize
               , concat ! (
               "Size of: " , stringify ! ( btBroadphasePairSortPredicate ) ));
    assert_eq! (::std::mem::align_of::<btBroadphasePairSortPredicate>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( btBroadphasePairSortPredicate
                ) ));
}
impl Clone for btBroadphasePairSortPredicate {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionShape {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionShapeData {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct btMotionState__bindgen_vtable(::std::os::raw::c_void);
/// The btMotionState interface class allows the dynamics world to synchronize and interpolate the updated world transforms with graphics
/// For optimizations, potentially only moving objects get synchronized (using setWorldPosition/setWorldOrientation)
#[repr(C)]
#[derive(Debug)]
pub struct btMotionState {
    pub vtable_: *const btMotionState__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btMotionState() {
    assert_eq!(::std::mem::size_of::<btMotionState>() , 8usize , concat ! (
               "Size of: " , stringify ! ( btMotionState ) ));
    assert_eq! (::std::mem::align_of::<btMotionState>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( btMotionState ) ));
}
extern "C" {
    #[link_name = "_ZNK13btMotionState17getWorldTransformER11btTransform"]
    pub fn btMotionState_getWorldTransform(this: *mut ::std::os::raw::c_void,
                                           worldTrans: *mut btTransform);
}
extern "C" {
    #[link_name = "_ZN13btMotionState17setWorldTransformERK11btTransform"]
    pub fn btMotionState_setWorldTransform(this: *mut ::std::os::raw::c_void,
                                           worldTrans: *const btTransform);
}
#[repr(C)]
pub struct btCollisionObject__bindgen_vtable(::std::os::raw::c_void);
/// btCollisionObject can be used to manage collision detection objects.
/// btCollisionObject maintains all information that is needed for a collision detection: Shape, Transform and AABB proxy.
/// They can be added to the btCollisionWorld.
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionObject {
    pub vtable_: *const btCollisionObject__bindgen_vtable,
    pub m_worldTransform: btTransform,
    /// m_interpolationWorldTransform is used for CCD and interpolation
    /// ///it can be either previous or future (predicted) transform
    pub m_interpolationWorldTransform: btTransform,
    pub m_interpolationLinearVelocity: btVector3,
    pub m_interpolationAngularVelocity: btVector3,
    pub m_anisotropicFriction: btVector3,
    pub m_hasAnisotropicFriction: ::std::os::raw::c_int,
    pub m_contactProcessingThreshold: btScalar,
    pub m_broadphaseHandle: *mut btBroadphaseProxy,
    pub m_collisionShape: *mut btCollisionShape,
    /// m_extensionPointer is used by some internal low-level Bullet extensions.
    pub m_extensionPointer: *mut ::std::os::raw::c_void,
    /// m_rootCollisionShape is temporarily used to store the original collision shape
    /// ///The m_collisionShape might be temporarily replaced by a child collision shape during collision detection purposes
    /// ///If it is NULL, the m_collisionShape is not temporarily replaced.
    pub m_rootCollisionShape: *mut btCollisionShape,
    pub m_collisionFlags: ::std::os::raw::c_int,
    pub m_islandTag1: ::std::os::raw::c_int,
    pub m_companionId: ::std::os::raw::c_int,
    pub m_worldArrayIndex: ::std::os::raw::c_int,
    pub m_activationState1: ::std::os::raw::c_int,
    pub m_deactivationTime: btScalar,
    pub m_friction: btScalar,
    pub m_restitution: btScalar,
    pub m_rollingFriction: btScalar,
    pub m_spinningFriction: btScalar,
    pub m_contactDamping: btScalar,
    pub m_contactStiffness: btScalar,
    /// m_internalType is reserved to distinguish Bullet's btCollisionObject, btRigidBody, btSoftBody, btGhostObject etc.
    /// ///do not assign your own m_internalType unless you write a new dynamics object class.
    pub m_internalType: ::std::os::raw::c_int,
    /// users can point to their objects, m_userPointer is not used by Bullet, see setUserPointer/getUserPointer
    pub m_userObjectPointer: *mut ::std::os::raw::c_void,
    pub m_userIndex2: ::std::os::raw::c_int,
    pub m_userIndex: ::std::os::raw::c_int,
    /// time of impact calculation
    pub m_hitFraction: btScalar,
    /// Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
    pub m_ccdSweptSphereRadius: btScalar,
    /// Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold
    pub m_ccdMotionThreshold: btScalar,
    /// If some object should have elaborate collision filtering by sub-classes
    pub m_checkCollideWith: ::std::os::raw::c_int,
    pub m_objectsWithoutCollisionCheck: btAlignedObjectArray<*const btCollisionObject>,
    /// internal update revision number. It will be increased when the object changes. This allows some subsystems to perform lazy evaluation.
    pub m_updateRevision: ::std::os::raw::c_int,
    pub m_customDebugColorRGB: btVector3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum btCollisionObject_CollisionFlags {
    CF_STATIC_OBJECT = 1,
    CF_KINEMATIC_OBJECT = 2,
    CF_NO_CONTACT_RESPONSE = 4,
    CF_CUSTOM_MATERIAL_CALLBACK = 8,
    CF_CHARACTER_OBJECT = 16,
    CF_DISABLE_VISUALIZE_OBJECT = 32,
    CF_DISABLE_SPU_COLLISION_PROCESSING = 64,
    CF_HAS_CONTACT_STIFFNESS_DAMPING = 128,
    CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR = 256,
    CF_HAS_FRICTION_ANCHOR = 512,
    CF_HAS_COLLISION_SOUND_TRIGGER = 1024,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum btCollisionObject_CollisionObjectTypes {
    CO_COLLISION_OBJECT = 1,
    CO_RIGID_BODY = 2,
    CO_GHOST_OBJECT = 4,
    CO_SOFT_BODY = 8,
    CO_HF_FLUID = 16,
    CO_USER_TYPE = 32,
    CO_FEATHERSTONE_LINK = 64,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum btCollisionObject_AnisotropicFrictionFlags {
    CF_ANISOTROPIC_FRICTION_DISABLED = 0,
    CF_ANISOTROPIC_FRICTION = 1,
    CF_ANISOTROPIC_ROLLING_FRICTION = 2,
}
#[test]
fn bindgen_test_layout_btCollisionObject() {
    assert_eq!(::std::mem::size_of::<btCollisionObject>() , 616usize , concat
               ! ( "Size of: " , stringify ! ( btCollisionObject ) ));
    assert_eq! (::std::mem::align_of::<btCollisionObject>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( btCollisionObject ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_worldTransform
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_worldTransform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_interpolationWorldTransform as * const _ as usize } ,
                136usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_interpolationWorldTransform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_interpolationLinearVelocity as * const _ as usize } ,
                264usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_interpolationLinearVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_interpolationAngularVelocity as * const _ as usize } ,
                296usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_interpolationAngularVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_anisotropicFriction as * const _ as usize } , 328usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_anisotropicFriction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_hasAnisotropicFriction as * const _ as usize } , 360usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_hasAnisotropicFriction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_contactProcessingThreshold as * const _ as usize } ,
                368usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_contactProcessingThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_broadphaseHandle as * const _ as usize } , 376usize , concat
                ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_broadphaseHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_collisionShape
                as * const _ as usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_collisionShape ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_extensionPointer as * const _ as usize } , 392usize , concat
                ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_extensionPointer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_rootCollisionShape as * const _ as usize } , 400usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_rootCollisionShape ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_collisionFlags
                as * const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_collisionFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_islandTag1 as *
                const _ as usize } , 412usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_islandTag1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_companionId as
                * const _ as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_companionId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_worldArrayIndex
                as * const _ as usize } , 420usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_worldArrayIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_activationState1 as * const _ as usize } , 424usize , concat
                ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_activationState1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_deactivationTime as * const _ as usize } , 432usize , concat
                ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_deactivationTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_friction as *
                const _ as usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_friction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_restitution as
                * const _ as usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_restitution ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_rollingFriction
                as * const _ as usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_rollingFriction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_spinningFriction as * const _ as usize } , 464usize , concat
                ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_spinningFriction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_contactDamping
                as * const _ as usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_contactDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_contactStiffness as * const _ as usize } , 480usize , concat
                ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_contactStiffness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_internalType as
                * const _ as usize } , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_internalType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_userObjectPointer as * const _ as usize } , 496usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_userObjectPointer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_userIndex2 as *
                const _ as usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_userIndex2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_userIndex as *
                const _ as usize } , 508usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_userIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_hitFraction as
                * const _ as usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_hitFraction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_ccdSweptSphereRadius as * const _ as usize } , 520usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_ccdSweptSphereRadius ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_ccdMotionThreshold as * const _ as usize } , 528usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_ccdMotionThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_checkCollideWith as * const _ as usize } , 536usize , concat
                ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_checkCollideWith ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_objectsWithoutCollisionCheck as * const _ as usize } ,
                544usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_objectsWithoutCollisionCheck ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) . m_updateRevision
                as * const _ as usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_updateRevision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObject ) ) .
                m_customDebugColorRGB as * const _ as usize } , 584usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btCollisionObject ) ,
                "::" , stringify ! ( m_customDebugColorRGB ) ));
}
extern "C" {
    #[link_name = "_ZNK17btCollisionObject18setActivationStateEi"]
    pub fn btCollisionObject_setActivationState(this:
                                                    *const btCollisionObject,
                                                newState:
                                                    ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "_ZNK17btCollisionObject20forceActivationStateEi"]
    pub fn btCollisionObject_forceActivationState(this:
                                                      *const btCollisionObject,
                                                  newState:
                                                      ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "_ZNK17btCollisionObject8activateEb"]
    pub fn btCollisionObject_activate(this: *const btCollisionObject,
                                      forceActivation: bool);
}
extern "C" {
    #[link_name = "_ZN17btCollisionObjectC1Ev"]
    pub fn btCollisionObject_btCollisionObject(this: *mut btCollisionObject);
}
impl btCollisionObject {
    #[inline]
    pub unsafe fn setActivationState(&self, newState: ::std::os::raw::c_int) {
        btCollisionObject_setActivationState(self, newState)
    }
    #[inline]
    pub unsafe fn forceActivationState(&self,
                                       newState: ::std::os::raw::c_int) {
        btCollisionObject_forceActivationState(self, newState)
    }
    #[inline]
    pub unsafe fn activate(&self, forceActivation: bool) {
        btCollisionObject_activate(self, forceActivation)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionObject_btCollisionObject(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "_ZN17btCollisionObjectD0Ev"]
    pub fn btCollisionObject_btCollisionObject_destructor(this:
                                                              *mut btCollisionObject);
}
extern "C" {
    #[link_name = "_ZNK17btCollisionObject28calculateSerializeBufferSizeEv"]
    pub fn btCollisionObject_calculateSerializeBufferSize(this:
                                                              *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "_ZNK17btCollisionObject9serializeEPvP12btSerializer"]
    pub fn btCollisionObject_serialize(this: *mut ::std::os::raw::c_void,
                                       dataBuffer:
                                           *mut ::std::os::raw::c_void,
                                       serializer: *mut btSerializer)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name =
          "_ZNK17btCollisionObject21serializeSingleObjectEP12btSerializer"]
    pub fn btCollisionObject_serializeSingleObject(this:
                                                       *mut ::std::os::raw::c_void,
                                                   serializer:
                                                       *mut btSerializer);
}
pub type btCollisionObjectArray =
    btAlignedObjectArray<*mut btCollisionObject>;
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btCollisionObjectDoubleData {
    pub m_broadphaseHandle: *mut ::std::os::raw::c_void,
    pub m_collisionShape: *mut ::std::os::raw::c_void,
    pub m_rootCollisionShape: *mut btCollisionShapeData,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_worldTransform: btTransformDoubleData,
    pub m_interpolationWorldTransform: btTransformDoubleData,
    pub m_interpolationLinearVelocity: btVector3DoubleData,
    pub m_interpolationAngularVelocity: btVector3DoubleData,
    pub m_anisotropicFriction: btVector3DoubleData,
    pub m_contactProcessingThreshold: f64,
    pub m_deactivationTime: f64,
    pub m_friction: f64,
    pub m_rollingFriction: f64,
    pub m_contactDamping: f64,
    pub m_contactStiffness: f64,
    pub m_restitution: f64,
    pub m_hitFraction: f64,
    pub m_ccdSweptSphereRadius: f64,
    pub m_ccdMotionThreshold: f64,
    pub m_hasAnisotropicFriction: ::std::os::raw::c_int,
    pub m_collisionFlags: ::std::os::raw::c_int,
    pub m_islandTag1: ::std::os::raw::c_int,
    pub m_companionId: ::std::os::raw::c_int,
    pub m_activationState1: ::std::os::raw::c_int,
    pub m_internalType: ::std::os::raw::c_int,
    pub m_checkCollideWith: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btCollisionObjectDoubleData() {
    assert_eq!(::std::mem::size_of::<btCollisionObjectDoubleData>() , 496usize
               , concat ! (
               "Size of: " , stringify ! ( btCollisionObjectDoubleData ) ));
    assert_eq! (::std::mem::align_of::<btCollisionObjectDoubleData>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( btCollisionObjectDoubleData )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_broadphaseHandle as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_broadphaseHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_collisionShape as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_collisionShape ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_rootCollisionShape as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_rootCollisionShape ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) . m_name
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! ( m_name )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_worldTransform as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_worldTransform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_interpolationWorldTransform as * const _ as usize } ,
                160usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_interpolationWorldTransform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_interpolationLinearVelocity as * const _ as usize } ,
                288usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_interpolationLinearVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_interpolationAngularVelocity as * const _ as usize } ,
                320usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_interpolationAngularVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_anisotropicFriction as * const _ as usize } , 352usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_anisotropicFriction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_contactProcessingThreshold as * const _ as usize } ,
                384usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_contactProcessingThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_deactivationTime as * const _ as usize } , 392usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_deactivationTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_friction as * const _ as usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_friction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_rollingFriction as * const _ as usize } , 408usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_rollingFriction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_contactDamping as * const _ as usize } , 416usize , concat !
                (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_contactDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_contactStiffness as * const _ as usize } , 424usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_contactStiffness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_restitution as * const _ as usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_restitution ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_hitFraction as * const _ as usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_hitFraction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_ccdSweptSphereRadius as * const _ as usize } , 448usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_ccdSweptSphereRadius ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_ccdMotionThreshold as * const _ as usize } , 456usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_ccdMotionThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_hasAnisotropicFriction as * const _ as usize } , 464usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_hasAnisotropicFriction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_collisionFlags as * const _ as usize } , 468usize , concat !
                (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_collisionFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_islandTag1 as * const _ as usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_islandTag1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_companionId as * const _ as usize } , 476usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_companionId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_activationState1 as * const _ as usize } , 480usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_activationState1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_internalType as * const _ as usize } , 484usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_internalType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_checkCollideWith as * const _ as usize } , 488usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! (
                m_checkCollideWith ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectDoubleData ) ) .
                m_padding as * const _ as usize } , 492usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectDoubleData ) , "::" , stringify ! ( m_padding
                ) ));
}
impl Clone for btCollisionObjectDoubleData {
    fn clone(&self) -> Self { *self }
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btCollisionObjectFloatData {
    pub m_broadphaseHandle: *mut ::std::os::raw::c_void,
    pub m_collisionShape: *mut ::std::os::raw::c_void,
    pub m_rootCollisionShape: *mut btCollisionShapeData,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_worldTransform: btTransformFloatData,
    pub m_interpolationWorldTransform: btTransformFloatData,
    pub m_interpolationLinearVelocity: btVector3FloatData,
    pub m_interpolationAngularVelocity: btVector3FloatData,
    pub m_anisotropicFriction: btVector3FloatData,
    pub m_contactProcessingThreshold: f32,
    pub m_deactivationTime: f32,
    pub m_friction: f32,
    pub m_rollingFriction: f32,
    pub m_contactDamping: f32,
    pub m_contactStiffness: f32,
    pub m_restitution: f32,
    pub m_hitFraction: f32,
    pub m_ccdSweptSphereRadius: f32,
    pub m_ccdMotionThreshold: f32,
    pub m_hasAnisotropicFriction: ::std::os::raw::c_int,
    pub m_collisionFlags: ::std::os::raw::c_int,
    pub m_islandTag1: ::std::os::raw::c_int,
    pub m_companionId: ::std::os::raw::c_int,
    pub m_activationState1: ::std::os::raw::c_int,
    pub m_internalType: ::std::os::raw::c_int,
    pub m_checkCollideWith: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btCollisionObjectFloatData() {
    assert_eq!(::std::mem::size_of::<btCollisionObjectFloatData>() , 280usize
               , concat ! (
               "Size of: " , stringify ! ( btCollisionObjectFloatData ) ));
    assert_eq! (::std::mem::align_of::<btCollisionObjectFloatData>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( btCollisionObjectFloatData )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_broadphaseHandle as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_broadphaseHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_collisionShape as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_collisionShape ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_rootCollisionShape as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_rootCollisionShape ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) . m_name
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! ( m_name )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_worldTransform as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_worldTransform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_interpolationWorldTransform as * const _ as usize } ,
                96usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_interpolationWorldTransform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_interpolationLinearVelocity as * const _ as usize } ,
                160usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_interpolationLinearVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_interpolationAngularVelocity as * const _ as usize } ,
                176usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_interpolationAngularVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_anisotropicFriction as * const _ as usize } , 192usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_anisotropicFriction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_contactProcessingThreshold as * const _ as usize } ,
                208usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_contactProcessingThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_deactivationTime as * const _ as usize } , 212usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_deactivationTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_friction as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! ( m_friction
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_rollingFriction as * const _ as usize } , 220usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_rollingFriction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_contactDamping as * const _ as usize } , 224usize , concat !
                (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_contactDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_contactStiffness as * const _ as usize } , 228usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_contactStiffness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_restitution as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_restitution ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_hitFraction as * const _ as usize } , 236usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_hitFraction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_ccdSweptSphereRadius as * const _ as usize } , 240usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_ccdSweptSphereRadius ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_ccdMotionThreshold as * const _ as usize } , 244usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_ccdMotionThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_hasAnisotropicFriction as * const _ as usize } , 248usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_hasAnisotropicFriction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_collisionFlags as * const _ as usize } , 252usize , concat !
                (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_collisionFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_islandTag1 as * const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_islandTag1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_companionId as * const _ as usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_companionId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_activationState1 as * const _ as usize } , 264usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_activationState1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_internalType as * const _ as usize } , 268usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_internalType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_checkCollideWith as * const _ as usize } , 272usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! (
                m_checkCollideWith ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btCollisionObjectFloatData ) ) .
                m_padding as * const _ as usize } , 276usize , concat ! (
                "Alignment of field: " , stringify ! (
                btCollisionObjectFloatData ) , "::" , stringify ! ( m_padding
                ) ));
}
impl Clone for btCollisionObjectFloatData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTypedConstraint {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "gDeactivationTime"]
    pub static mut gDeactivationTime: btScalar;
}
extern "C" {
    #[link_name = "gDisableDeactivation"]
    pub static mut gDisableDeactivation: bool;
}
pub const btRigidBodyFlags_BT_ENABLE_GYROPSCOPIC_FORCE: btRigidBodyFlags =
    btRigidBodyFlags::BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum btRigidBodyFlags {
    BT_DISABLE_WORLD_GRAVITY = 1,
    BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT = 2,
    BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD = 4,
    BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY = 8,
}
/// The btRigidBody is the main class for rigid body objects. It is derived from btCollisionObject, so it keeps a pointer to a btCollisionShape.
/// It is recommended for performance and memory use to share btCollisionShape objects whenever possible.
/// There are 3 types of rigid bodies:
/// - A) Dynamic rigid bodies, with positive mass. Motion is controlled by rigid body dynamics.
/// - B) Fixed objects with zero mass. They are not moving (basically collision objects)
/// - C) Kinematic objects, which are objects without mass, but the user can move them. There is on-way interaction, and Bullet calculates a velocity based on the timestep and previous and current world transform.
/// Bullet automatically deactivates dynamic rigid bodies, when the velocity is below a threshold for a given time.
/// Deactivated (sleeping) rigid bodies don't take any processing time, except a minor broadphase collision detection impact (to allow active objects to activate/wake up sleeping objects)
#[repr(C)]
#[derive(Debug)]
pub struct btRigidBody {
    pub _base: btCollisionObject,
    pub m_invInertiaTensorWorld: btMatrix3x3,
    pub m_linearVelocity: btVector3,
    pub m_angularVelocity: btVector3,
    pub m_inverseMass: btScalar,
    pub m_linearFactor: btVector3,
    pub m_gravity: btVector3,
    pub m_gravity_acceleration: btVector3,
    pub m_invInertiaLocal: btVector3,
    pub m_totalForce: btVector3,
    pub m_totalTorque: btVector3,
    pub m_linearDamping: btScalar,
    pub m_angularDamping: btScalar,
    pub m_additionalDamping: bool,
    pub m_additionalDampingFactor: btScalar,
    pub m_additionalLinearDampingThresholdSqr: btScalar,
    pub m_additionalAngularDampingThresholdSqr: btScalar,
    pub m_additionalAngularDampingFactor: btScalar,
    pub m_linearSleepingThreshold: btScalar,
    pub m_angularSleepingThreshold: btScalar,
    pub m_optionalMotionState: *mut btMotionState,
    pub m_constraintRefs: btAlignedObjectArray<*mut btTypedConstraint>,
    pub m_rigidbodyFlags: ::std::os::raw::c_int,
    pub m_debugBodyId: ::std::os::raw::c_int,
    pub m_deltaLinearVelocity: btVector3,
    pub m_deltaAngularVelocity: btVector3,
    pub m_angularFactor: btVector3,
    pub m_invMass: btVector3,
    pub m_pushVelocity: btVector3,
    pub m_turnVelocity: btVector3,
    pub m_contactSolverType: ::std::os::raw::c_int,
    pub m_frictionSolverType: ::std::os::raw::c_int,
}
/// The btRigidBodyConstructionInfo structure provides information to create a rigid body. Setting mass to zero creates a fixed (non-dynamic) rigid body.
/// ///For dynamic objects, you can use the collision shape to approximate the local inertia tensor, otherwise use the zero vector (default argument)
/// ///You can use the motion state to synchronize the world transform between physics and graphics objects.
/// ///And if the motion state is provided, the rigid body will initialize its initial world transform from the motion state,
/// ///m_startWorldTransform is only used when you don't provide a motion state.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btRigidBody_btRigidBodyConstructionInfo {
    pub m_mass: btScalar,
    /// When a motionState is provided, the rigid body will initialize its world transform from the motion state
    /// ///In this case, m_startWorldTransform is ignored.
    pub m_motionState: *mut btMotionState,
    pub m_startWorldTransform: btTransform,
    pub m_collisionShape: *mut btCollisionShape,
    pub m_localInertia: btVector3,
    pub m_linearDamping: btScalar,
    pub m_angularDamping: btScalar,
    /// best simulation results when friction is non-zero
    pub m_friction: btScalar,
    /// the m_rollingFriction prevents rounded shapes, such as spheres, cylinders and capsules from rolling forever.
    /// ///See Bullet/Demos/RollingFrictionDemo for usage
    pub m_rollingFriction: btScalar,
    pub m_spinningFriction: btScalar,
    /// best simulation results using zero restitution.
    pub m_restitution: btScalar,
    pub m_linearSleepingThreshold: btScalar,
    pub m_angularSleepingThreshold: btScalar,
    pub m_additionalDamping: bool,
    pub m_additionalDampingFactor: btScalar,
    pub m_additionalLinearDampingThresholdSqr: btScalar,
    pub m_additionalAngularDampingThresholdSqr: btScalar,
    pub m_additionalAngularDampingFactor: btScalar,
}
#[test]
fn bindgen_test_layout_btRigidBody_btRigidBodyConstructionInfo() {
    assert_eq!(::std::mem::size_of::<btRigidBody_btRigidBodyConstructionInfo>()
               , 288usize , concat ! (
               "Size of: " , stringify ! (
               btRigidBody_btRigidBodyConstructionInfo ) ));
    assert_eq! (::std::mem::align_of::<btRigidBody_btRigidBodyConstructionInfo>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_mass as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_mass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_motionState as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_motionState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_startWorldTransform as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_startWorldTransform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_collisionShape as * const _ as usize } , 144usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_collisionShape ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_localInertia as * const _ as usize } , 152usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_localInertia ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_linearDamping as * const _ as usize } , 184usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_linearDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_angularDamping as * const _ as usize } , 192usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_angularDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_friction as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_friction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_rollingFriction as * const _ as usize } , 208usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_rollingFriction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_spinningFriction as * const _ as usize } , 216usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_spinningFriction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_restitution as * const _ as usize } , 224usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_restitution ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_linearSleepingThreshold as * const _ as usize } ,
                232usize , concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_linearSleepingThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_angularSleepingThreshold as * const _ as usize } ,
                240usize , concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_angularSleepingThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_additionalDamping as * const _ as usize } , 248usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_additionalDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_additionalDampingFactor as * const _ as usize } ,
                256usize , concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_additionalDampingFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_additionalLinearDampingThresholdSqr as * const _ as
                usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_additionalLinearDampingThresholdSqr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_additionalAngularDampingThresholdSqr as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_additionalAngularDampingThresholdSqr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody_btRigidBodyConstructionInfo )
                ) . m_additionalAngularDampingFactor as * const _ as usize } ,
                280usize , concat ! (
                "Alignment of field: " , stringify ! (
                btRigidBody_btRigidBodyConstructionInfo ) , "::" , stringify !
                ( m_additionalAngularDampingFactor ) ));
}
impl Clone for btRigidBody_btRigidBodyConstructionInfo {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_btRigidBody() {
    assert_eq!(::std::mem::size_of::<btRigidBody>() , 1296usize , concat ! (
               "Size of: " , stringify ! ( btRigidBody ) ));
    assert_eq! (::std::mem::align_of::<btRigidBody>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( btRigidBody ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_invInertiaTensorWorld
                as * const _ as usize } , 616usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_invInertiaTensorWorld ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_linearVelocity as *
                const _ as usize } , 712usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_linearVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_angularVelocity as *
                const _ as usize } , 744usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_angularVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_inverseMass as *
                const _ as usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_inverseMass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_linearFactor as *
                const _ as usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_linearFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_gravity as * const _
                as usize } , 816usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_gravity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_gravity_acceleration
                as * const _ as usize } , 848usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_gravity_acceleration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_invInertiaLocal as *
                const _ as usize } , 880usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_invInertiaLocal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_totalForce as * const
                _ as usize } , 912usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_totalForce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_totalTorque as *
                const _ as usize } , 944usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_totalTorque ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_linearDamping as *
                const _ as usize } , 976usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_linearDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_angularDamping as *
                const _ as usize } , 984usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_angularDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_additionalDamping as
                * const _ as usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_additionalDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) .
                m_additionalDampingFactor as * const _ as usize } , 1000usize
                , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_additionalDampingFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) .
                m_additionalLinearDampingThresholdSqr as * const _ as usize }
                , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_additionalLinearDampingThresholdSqr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) .
                m_additionalAngularDampingThresholdSqr as * const _ as usize }
                , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_additionalAngularDampingThresholdSqr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) .
                m_additionalAngularDampingFactor as * const _ as usize } ,
                1024usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_additionalAngularDampingFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) .
                m_linearSleepingThreshold as * const _ as usize } , 1032usize
                , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_linearSleepingThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) .
                m_angularSleepingThreshold as * const _ as usize } , 1040usize
                , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_angularSleepingThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_optionalMotionState
                as * const _ as usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_optionalMotionState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_constraintRefs as *
                const _ as usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_constraintRefs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_rigidbodyFlags as *
                const _ as usize } , 1088usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_rigidbodyFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_debugBodyId as *
                const _ as usize } , 1092usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_debugBodyId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_deltaLinearVelocity
                as * const _ as usize } , 1096usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_deltaLinearVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_deltaAngularVelocity
                as * const _ as usize } , 1128usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_deltaAngularVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_angularFactor as *
                const _ as usize } , 1160usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_angularFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_invMass as * const _
                as usize } , 1192usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_invMass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_pushVelocity as *
                const _ as usize } , 1224usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_pushVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_turnVelocity as *
                const _ as usize } , 1256usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_turnVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_contactSolverType as
                * const _ as usize } , 1288usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_contactSolverType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBody ) ) . m_frictionSolverType as
                * const _ as usize } , 1292usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBody ) , "::" ,
                stringify ! ( m_frictionSolverType ) ));
}
extern "C" {
    /// setupRigidBody is only used internally by the constructor
    #[link_name =
          "_ZN11btRigidBody14setupRigidBodyERKNS_27btRigidBodyConstructionInfoE"]
    pub fn btRigidBody_setupRigidBody(this: *mut btRigidBody,
                                      constructionInfo:
                                          *const btRigidBody_btRigidBodyConstructionInfo);
}
extern "C" {
    #[link_name = "_ZN11btRigidBody18proceedToTransformERK11btTransform"]
    pub fn btRigidBody_proceedToTransform(this: *mut btRigidBody,
                                          newTrans: *const btTransform);
}
extern "C" {
    /// continuous collision detection needs prediction
    #[link_name =
          "_ZN11btRigidBody26predictIntegratedTransformEdR11btTransform"]
    pub fn btRigidBody_predictIntegratedTransform(this: *mut btRigidBody,
                                                  step: btScalar,
                                                  predictedTransform:
                                                      *mut btTransform);
}
extern "C" {
    #[link_name = "_ZN11btRigidBody18saveKinematicStateEd"]
    pub fn btRigidBody_saveKinematicState(this: *mut btRigidBody,
                                          step: btScalar);
}
extern "C" {
    #[link_name = "_ZN11btRigidBody12applyGravityEv"]
    pub fn btRigidBody_applyGravity(this: *mut btRigidBody);
}
extern "C" {
    #[link_name = "_ZN11btRigidBody10setGravityERK9btVector3"]
    pub fn btRigidBody_setGravity(this: *mut btRigidBody,
                                  acceleration: *const btVector3);
}
extern "C" {
    #[link_name = "_ZN11btRigidBody10setDampingEdd"]
    pub fn btRigidBody_setDamping(this: *mut btRigidBody,
                                  lin_damping: btScalar,
                                  ang_damping: btScalar);
}
extern "C" {
    #[link_name = "_ZN11btRigidBody12applyDampingEd"]
    pub fn btRigidBody_applyDamping(this: *mut btRigidBody,
                                    timeStep: btScalar);
}
extern "C" {
    #[link_name = "_ZN11btRigidBody12setMassPropsEdRK9btVector3"]
    pub fn btRigidBody_setMassProps(this: *mut btRigidBody, mass: btScalar,
                                    inertia: *const btVector3);
}
extern "C" {
    #[link_name = "_ZN11btRigidBody19integrateVelocitiesEd"]
    pub fn btRigidBody_integrateVelocities(this: *mut btRigidBody,
                                           step: btScalar);
}
extern "C" {
    #[link_name =
          "_ZN11btRigidBody24setCenterOfMassTransformERK11btTransform"]
    pub fn btRigidBody_setCenterOfMassTransform(this: *mut btRigidBody,
                                                xform: *const btTransform);
}
extern "C" {
    #[link_name = "_ZN11btRigidBody19updateInertiaTensorEv"]
    pub fn btRigidBody_updateInertiaTensor(this: *mut btRigidBody);
}
extern "C" {
    #[link_name = "_ZNK11btRigidBody14getOrientationEv"]
    pub fn btRigidBody_getOrientation(this: *const btRigidBody)
     -> btQuaternion;
}
extern "C" {
    #[link_name = "_ZNK11btRigidBody7getAabbER9btVector3S1_"]
    pub fn btRigidBody_getAabb(this: *const btRigidBody,
                               aabbMin: *mut btVector3,
                               aabbMax: *mut btVector3);
}
extern "C" {
    #[link_name = "_ZN11btRigidBody16addConstraintRefEP17btTypedConstraint"]
    pub fn btRigidBody_addConstraintRef(this: *mut btRigidBody,
                                        c: *mut btTypedConstraint);
}
extern "C" {
    #[link_name =
          "_ZN11btRigidBody19removeConstraintRefEP17btTypedConstraint"]
    pub fn btRigidBody_removeConstraintRef(this: *mut btRigidBody,
                                           c: *mut btTypedConstraint);
}
extern "C" {
    /// perform implicit force computation in world space
    #[link_name =
          "_ZNK11btRigidBody38computeGyroscopicImpulseImplicit_WorldEd"]
    pub fn btRigidBody_computeGyroscopicImpulseImplicit_World(this:
                                                                  *const btRigidBody,
                                                              dt: btScalar)
     -> btVector3;
}
extern "C" {
    /// perform implicit force computation in body space (inertial frame)
    #[link_name =
          "_ZNK11btRigidBody37computeGyroscopicImpulseImplicit_BodyEd"]
    pub fn btRigidBody_computeGyroscopicImpulseImplicit_Body(this:
                                                                 *const btRigidBody,
                                                             step: btScalar)
     -> btVector3;
}
extern "C" {
    /// explicit version is best avoided, it gains energy
    #[link_name = "_ZNK11btRigidBody30computeGyroscopicForceExplicitEd"]
    pub fn btRigidBody_computeGyroscopicForceExplicit(this:
                                                          *const btRigidBody,
                                                      maxGyroscopicForce:
                                                          btScalar)
     -> btVector3;
}
extern "C" {
    #[link_name = "_ZNK11btRigidBody15getLocalInertiaEv"]
    pub fn btRigidBody_getLocalInertia(this: *const btRigidBody) -> btVector3;
}
extern "C" {
    /// btRigidBody constructor using construction info
    #[link_name = "_ZN11btRigidBodyC1ERKNS_27btRigidBodyConstructionInfoE"]
    pub fn btRigidBody_btRigidBody(this: *mut btRigidBody,
                                   constructionInfo:
                                       *const btRigidBody_btRigidBodyConstructionInfo);
}
extern "C" {
    /// btRigidBody constructor for backwards compatibility.
/// ///To specify friction (etc) during rigid body construction, please use the other constructor (using btRigidBodyConstructionInfo)
    #[link_name =
          "_ZN11btRigidBodyC1EdP13btMotionStateP16btCollisionShapeRK9btVector3"]
    pub fn btRigidBody_btRigidBody1(this: *mut btRigidBody, mass: btScalar,
                                    motionState: *mut btMotionState,
                                    collisionShape: *mut btCollisionShape,
                                    localInertia: *const btVector3);
}
impl btRigidBody {
    #[inline]
    pub unsafe fn setupRigidBody(&mut self,
                                 constructionInfo:
                                     *const btRigidBody_btRigidBodyConstructionInfo) {
        btRigidBody_setupRigidBody(self, constructionInfo)
    }
    #[inline]
    pub unsafe fn proceedToTransform(&mut self,
                                     newTrans: *const btTransform) {
        btRigidBody_proceedToTransform(self, newTrans)
    }
    #[inline]
    pub unsafe fn predictIntegratedTransform(&mut self, step: btScalar,
                                             predictedTransform:
                                                 *mut btTransform) {
        btRigidBody_predictIntegratedTransform(self, step, predictedTransform)
    }
    #[inline]
    pub unsafe fn saveKinematicState(&mut self, step: btScalar) {
        btRigidBody_saveKinematicState(self, step)
    }
    #[inline]
    pub unsafe fn applyGravity(&mut self) { btRigidBody_applyGravity(self) }
    #[inline]
    pub unsafe fn setGravity(&mut self, acceleration: *const btVector3) {
        btRigidBody_setGravity(self, acceleration)
    }
    #[inline]
    pub unsafe fn setDamping(&mut self, lin_damping: btScalar,
                             ang_damping: btScalar) {
        btRigidBody_setDamping(self, lin_damping, ang_damping)
    }
    #[inline]
    pub unsafe fn applyDamping(&mut self, timeStep: btScalar) {
        btRigidBody_applyDamping(self, timeStep)
    }
    #[inline]
    pub unsafe fn setMassProps(&mut self, mass: btScalar,
                               inertia: *const btVector3) {
        btRigidBody_setMassProps(self, mass, inertia)
    }
    #[inline]
    pub unsafe fn integrateVelocities(&mut self, step: btScalar) {
        btRigidBody_integrateVelocities(self, step)
    }
    #[inline]
    pub unsafe fn setCenterOfMassTransform(&mut self,
                                           xform: *const btTransform) {
        btRigidBody_setCenterOfMassTransform(self, xform)
    }
    #[inline]
    pub unsafe fn updateInertiaTensor(&mut self) {
        btRigidBody_updateInertiaTensor(self)
    }
    #[inline]
    pub unsafe fn getOrientation(&self) -> btQuaternion {
        btRigidBody_getOrientation(self)
    }
    #[inline]
    pub unsafe fn getAabb(&self, aabbMin: *mut btVector3,
                          aabbMax: *mut btVector3) {
        btRigidBody_getAabb(self, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn addConstraintRef(&mut self, c: *mut btTypedConstraint) {
        btRigidBody_addConstraintRef(self, c)
    }
    #[inline]
    pub unsafe fn removeConstraintRef(&mut self, c: *mut btTypedConstraint) {
        btRigidBody_removeConstraintRef(self, c)
    }
    #[inline]
    pub unsafe fn computeGyroscopicImpulseImplicit_World(&self, dt: btScalar)
     -> btVector3 {
        btRigidBody_computeGyroscopicImpulseImplicit_World(self, dt)
    }
    #[inline]
    pub unsafe fn computeGyroscopicImpulseImplicit_Body(&self, step: btScalar)
     -> btVector3 {
        btRigidBody_computeGyroscopicImpulseImplicit_Body(self, step)
    }
    #[inline]
    pub unsafe fn computeGyroscopicForceExplicit(&self,
                                                 maxGyroscopicForce: btScalar)
     -> btVector3 {
        btRigidBody_computeGyroscopicForceExplicit(self, maxGyroscopicForce)
    }
    #[inline]
    pub unsafe fn getLocalInertia(&self) -> btVector3 {
        btRigidBody_getLocalInertia(self)
    }
    #[inline]
    pub unsafe fn new(constructionInfo:
                          *const btRigidBody_btRigidBodyConstructionInfo)
     -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btRigidBody_btRigidBody(&mut __bindgen_tmp, constructionInfo);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(mass: btScalar, motionState: *mut btMotionState,
                       collisionShape: *mut btCollisionShape,
                       localInertia: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btRigidBody_btRigidBody1(&mut __bindgen_tmp, mass, motionState,
                                 collisionShape, localInertia);
        __bindgen_tmp
    }
}
extern "C" {
    ///
    #[link_name = "_ZNK11btRigidBody28calculateSerializeBufferSizeEv"]
    pub fn btRigidBody_calculateSerializeBufferSize(this:
                                                        *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// fills the dataBuffer and returns the struct name (and 0 on failure)
    #[link_name = "_ZNK11btRigidBody9serializeEPvP12btSerializer"]
    pub fn btRigidBody_serialize(this: *mut ::std::os::raw::c_void,
                                 dataBuffer: *mut ::std::os::raw::c_void,
                                 serializer: *mut btSerializer)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "_ZNK11btRigidBody21serializeSingleObjectEP12btSerializer"]
    pub fn btRigidBody_serializeSingleObject(this:
                                                 *mut ::std::os::raw::c_void,
                                             serializer: *mut btSerializer);
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btRigidBodyFloatData {
    pub m_collisionObjectData: btCollisionObjectFloatData,
    pub m_invInertiaTensorWorld: btMatrix3x3FloatData,
    pub m_linearVelocity: btVector3FloatData,
    pub m_angularVelocity: btVector3FloatData,
    pub m_angularFactor: btVector3FloatData,
    pub m_linearFactor: btVector3FloatData,
    pub m_gravity: btVector3FloatData,
    pub m_gravity_acceleration: btVector3FloatData,
    pub m_invInertiaLocal: btVector3FloatData,
    pub m_totalForce: btVector3FloatData,
    pub m_totalTorque: btVector3FloatData,
    pub m_inverseMass: f32,
    pub m_linearDamping: f32,
    pub m_angularDamping: f32,
    pub m_additionalDampingFactor: f32,
    pub m_additionalLinearDampingThresholdSqr: f32,
    pub m_additionalAngularDampingThresholdSqr: f32,
    pub m_additionalAngularDampingFactor: f32,
    pub m_linearSleepingThreshold: f32,
    pub m_angularSleepingThreshold: f32,
    pub m_additionalDamping: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btRigidBodyFloatData() {
    assert_eq!(::std::mem::size_of::<btRigidBodyFloatData>() , 512usize ,
               concat ! ( "Size of: " , stringify ! ( btRigidBodyFloatData )
               ));
    assert_eq! (::std::mem::align_of::<btRigidBodyFloatData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( btRigidBodyFloatData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_collisionObjectData as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_collisionObjectData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_invInertiaTensorWorld as * const _ as usize } , 280usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_invInertiaTensorWorld ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_linearVelocity as * const _ as usize } , 328usize , concat !
                (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_linearVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_angularVelocity as * const _ as usize } , 344usize , concat
                ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_angularVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_angularFactor as * const _ as usize } , 360usize , concat !
                (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_angularFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) . m_linearFactor
                as * const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_linearFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) . m_gravity as *
                const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_gravity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_gravity_acceleration as * const _ as usize } , 408usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_gravity_acceleration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_invInertiaLocal as * const _ as usize } , 424usize , concat
                ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_invInertiaLocal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) . m_totalForce
                as * const _ as usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_totalForce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) . m_totalTorque
                as * const _ as usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_totalTorque ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) . m_inverseMass
                as * const _ as usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_inverseMass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_linearDamping as * const _ as usize } , 476usize , concat !
                (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_linearDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_angularDamping as * const _ as usize } , 480usize , concat !
                (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_angularDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_additionalDampingFactor as * const _ as usize } , 484usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_additionalDampingFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_additionalLinearDampingThresholdSqr as * const _ as usize }
                , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_additionalLinearDampingThresholdSqr )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_additionalAngularDampingThresholdSqr as * const _ as usize }
                , 492usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_additionalAngularDampingThresholdSqr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_additionalAngularDampingFactor as * const _ as usize } ,
                496usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_additionalAngularDampingFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_linearSleepingThreshold as * const _ as usize } , 500usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_linearSleepingThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_angularSleepingThreshold as * const _ as usize } , 504usize
                , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_angularSleepingThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyFloatData ) ) .
                m_additionalDamping as * const _ as usize } , 508usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyFloatData )
                , "::" , stringify ! ( m_additionalDamping ) ));
}
impl Clone for btRigidBodyFloatData {
    fn clone(&self) -> Self { *self }
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btRigidBodyDoubleData {
    pub m_collisionObjectData: btCollisionObjectDoubleData,
    pub m_invInertiaTensorWorld: btMatrix3x3DoubleData,
    pub m_linearVelocity: btVector3DoubleData,
    pub m_angularVelocity: btVector3DoubleData,
    pub m_angularFactor: btVector3DoubleData,
    pub m_linearFactor: btVector3DoubleData,
    pub m_gravity: btVector3DoubleData,
    pub m_gravity_acceleration: btVector3DoubleData,
    pub m_invInertiaLocal: btVector3DoubleData,
    pub m_totalForce: btVector3DoubleData,
    pub m_totalTorque: btVector3DoubleData,
    pub m_inverseMass: f64,
    pub m_linearDamping: f64,
    pub m_angularDamping: f64,
    pub m_additionalDampingFactor: f64,
    pub m_additionalLinearDampingThresholdSqr: f64,
    pub m_additionalAngularDampingThresholdSqr: f64,
    pub m_additionalAngularDampingFactor: f64,
    pub m_linearSleepingThreshold: f64,
    pub m_angularSleepingThreshold: f64,
    pub m_additionalDamping: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btRigidBodyDoubleData() {
    assert_eq!(::std::mem::size_of::<btRigidBodyDoubleData>() , 960usize ,
               concat ! ( "Size of: " , stringify ! ( btRigidBodyDoubleData )
               ));
    assert_eq! (::std::mem::align_of::<btRigidBodyDoubleData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( btRigidBodyDoubleData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_collisionObjectData as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_collisionObjectData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_invInertiaTensorWorld as * const _ as usize } , 496usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_invInertiaTensorWorld ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_linearVelocity as * const _ as usize } , 592usize , concat !
                (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_linearVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_angularVelocity as * const _ as usize } , 624usize , concat
                ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_angularVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_angularFactor as * const _ as usize } , 656usize , concat !
                (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_angularFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_linearFactor as * const _ as usize } , 688usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_linearFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) . m_gravity as
                * const _ as usize } , 720usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_gravity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_gravity_acceleration as * const _ as usize } , 752usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_gravity_acceleration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_invInertiaLocal as * const _ as usize } , 784usize , concat
                ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_invInertiaLocal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) . m_totalForce
                as * const _ as usize } , 816usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_totalForce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) . m_totalTorque
                as * const _ as usize } , 848usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_totalTorque ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) . m_inverseMass
                as * const _ as usize } , 880usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_inverseMass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_linearDamping as * const _ as usize } , 888usize , concat !
                (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_linearDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_angularDamping as * const _ as usize } , 896usize , concat !
                (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_angularDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_additionalDampingFactor as * const _ as usize } , 904usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_additionalDampingFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_additionalLinearDampingThresholdSqr as * const _ as usize }
                , 912usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_additionalLinearDampingThresholdSqr )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_additionalAngularDampingThresholdSqr as * const _ as usize }
                , 920usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_additionalAngularDampingThresholdSqr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_additionalAngularDampingFactor as * const _ as usize } ,
                928usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_additionalAngularDampingFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_linearSleepingThreshold as * const _ as usize } , 936usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_linearSleepingThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_angularSleepingThreshold as * const _ as usize } , 944usize
                , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_angularSleepingThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) .
                m_additionalDamping as * const _ as usize } , 952usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_additionalDamping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btRigidBodyDoubleData ) ) . m_padding as
                * const _ as usize } , 956usize , concat ! (
                "Alignment of field: " , stringify ! ( btRigidBodyDoubleData )
                , "::" , stringify ! ( m_padding ) ));
}
impl Clone for btRigidBodyDoubleData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_const_btCollisionObject_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<btAlignedObjectArray<*const btCollisionObject>>()
               , 32usize , concat ! (
               "Size of template specialization: " , stringify ! (
               btAlignedObjectArray<*const btCollisionObject> ) ));
    assert_eq!(::std::mem::align_of::<btAlignedObjectArray<*const btCollisionObject>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               btAlignedObjectArray<*const btCollisionObject> ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btSerializer {
    pub _address: u8,
}
impl Clone for btSerializer {
    fn clone(&self) -> Self { *self }
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_btTypedConstraint_close0_instantiation() {
    assert_eq!(::std::mem::size_of::<btAlignedObjectArray<*mut btTypedConstraint>>()
               , 32usize , concat ! (
               "Size of template specialization: " , stringify ! (
               btAlignedObjectArray<*mut btTypedConstraint> ) ));
    assert_eq!(::std::mem::align_of::<btAlignedObjectArray<*mut btTypedConstraint>>()
               , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               btAlignedObjectArray<*mut btTypedConstraint> ) ));
}
