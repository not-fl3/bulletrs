/* automatically generated by rust-bindgen */

pub const _GLIBCXX_MATH_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_CXX_CONFIG_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_RELEASE: ::std::os::raw::c_uint = 7;
pub const __GLIBCXX__: ::std::os::raw::c_uint = 20170630;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_DEPRECATED: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_DUAL_ABI: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_CXX11_ABI: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_INLINE_VERSION: ::std::os::raw::c_uint = 0;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_OS_DEFINES: ::std::os::raw::c_uint = 1;
pub const __NO_CTYPE: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _ISOC95_SOURCE: ::std::os::raw::c_uint = 1;
pub const _ISOC99_SOURCE: ::std::os::raw::c_uint = 1;
pub const _ISOC11_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const _XOPEN_SOURCE: ::std::os::raw::c_uint = 700;
pub const _XOPEN_SOURCE_EXTENDED: ::std::os::raw::c_uint = 1;
pub const _LARGEFILE64_SOURCE: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN_EXTENDED: ::std::os::raw::c_uint = 1;
pub const __USE_UNIX98: ::std::os::raw::c_uint = 1;
pub const _LARGEFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8XSI: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2KXSI: ::std::os::raw::c_uint = 1;
pub const __USE_LARGEFILE: ::std::os::raw::c_uint = 1;
pub const __USE_LARGEFILE64: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_GNU: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 25;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _GLIBCXX_CPU_DEFINES: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_FAST_MATH: ::std::os::raw::c_uint = 0;
pub const _GLIBCXX_HAVE_ACOSF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ACOSL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ALIGNED_ALLOC: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ASINF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ASINL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ATAN2F: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ATAN2L: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ATANF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ATANL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_AT_QUICK_EXIT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_CEILF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_CEILL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_COSF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_COSHF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_COSHL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_COSL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_DIRENT_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_DLFCN_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EBADMSG: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ECANCELED: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ECHILD: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EIDRM: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENODATA: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENOLINK: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENOSPC: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENOSR: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENOSTR: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENOTRECOVERABLE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ENOTSUP: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EOVERFLOW: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EOWNERDEAD: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EPERM: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EPROTO: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ETIME: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ETIMEDOUT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ETXTBSY: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EWOULDBLOCK: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EXECINFO_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EXPF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_EXPL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FABSF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FABSL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FENV_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FINITE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FINITEF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FINITEL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FLOORF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FLOORL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FMODF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FMODL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FREXPF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_FREXPL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_GETS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_HYPOT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_HYPOTF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_HYPOTL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ICONV: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_INT64_T: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_INT64_T_LONG: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ISINFF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ISINFL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ISNANF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ISNANL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LC_MESSAGES: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LDEXPF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LDEXPL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LIBINTL_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LIMIT_AS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LIMIT_DATA: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LIMIT_FSIZE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LIMIT_RSS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LIMIT_VMEM: ::std::os::raw::c_uint = 0;
pub const _GLIBCXX_HAVE_LINUX_FUTEX: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LOCALE_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LOG10F: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LOG10L: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LOGF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_LOGL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_MEMALIGN: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_MODF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_MODFF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_MODFL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_POLL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_POSIX_MEMALIGN: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_POWF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_POWL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_QUICK_EXIT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SETENV: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SINCOS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SINCOSF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SINCOSL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SINF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SINHF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SINHL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SINL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SQRTF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SQRTL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STDINT_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRERROR_L: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRERROR_R: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRING_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRTOF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRTOLD: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_STRXFRM_L: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_IOCTL_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_IPC_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_RESOURCE_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_SEM_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_STATVFS_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_SYSINFO_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_SYS_UIO_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_S_ISREG: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_TANF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_TANHF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_TANHL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_TANL: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_TLS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_UCHAR_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_UTIME_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_VWSCANF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_WCSTOF: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE_WRITEV: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL: ::std::os::raw::c_uint = 1;
pub const LT_OBJDIR: &'static [u8; 7usize] = b".libs/\0";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &'static [u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE_NAME: &'static [u8; 15usize] = b"package-unused\0";
pub const _GLIBCXX_PACKAGE_STRING: &'static [u8; 30usize] = b"package-unused version-unused\0";
pub const _GLIBCXX_PACKAGE_TARNAME: &'static [u8; 10usize] = b"libstdc++\0";
pub const _GLIBCXX_PACKAGE_URL: &'static [u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &'static [u8; 15usize] = b"version-unused\0";
pub const STDC_HEADERS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX11_USE_C99_COMPLEX: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX11_USE_C99_MATH: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX11_USE_C99_STDIO: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX98_USE_C99_MATH: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX98_USE_C99_STDIO: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_ATOMIC_BUILTINS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: ::std::os::raw::c_uint = 0;
pub const _GLIBCXX_HAS_GTHREADS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_HOSTED: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_RES_LIMITS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_STDIO_EOF: ::std::os::raw::c_int = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_STDIO_SEEK_END: ::std::os::raw::c_uint = 2;
pub const _GLIBCXX_SYMVER: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_SYMVER_GNU: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C11_UCHAR_CXX11: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99_FENV_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_CLOCK_MONOTONIC: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_CLOCK_REALTIME: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_DECIMAL_FLOAT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_FCHMOD: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_FCHMODAT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_FLOAT128: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_GET_NPROCS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_INT128: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_LFS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_LONG_LONG: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_NANOSLEEP: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_NLS: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_RANDOM_TR1: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_REALPATH: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_SCHED_YIELD: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_SC_NPROCESSORS_ONLN: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_SENDFILE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_ST_MTIM: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_TMPNAM: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_UTIMENSAT: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_USE_WCHAR_T: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_VERBOSE: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_X86_RDRAND: ::std::os::raw::c_uint = 1;
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: ::std::os::raw::c_uint = 1;
pub const _CPP_TYPE_TRAITS_H: ::std::os::raw::c_uint = 1;
pub const _EXT_TYPE_TRAITS: ::std::os::raw::c_uint = 1;
pub const _MATH_H: ::std::os::raw::c_uint = 1;
pub const __GLIBC_USE_LIB_EXT2: ::std::os::raw::c_uint = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::std::os::raw::c_uint = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: ::std::os::raw::c_uint = 1;
pub const __FP_LOGB0_IS_MIN: ::std::os::raw::c_uint = 1;
pub const __FP_LOGBNAN_IS_MIN: ::std::os::raw::c_uint = 1;
pub const FP_ILOGB0: ::std::os::raw::c_int = -2147483648;
pub const FP_ILOGBNAN: ::std::os::raw::c_int = -2147483648;
pub const __FP_LONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const FP_LLOGB0: ::std::os::raw::c_longlong = -9223372036854775808;
pub const FP_LLOGBNAN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const FP_INT_UPWARD: ::std::os::raw::c_uint = 0;
pub const FP_INT_DOWNWARD: ::std::os::raw::c_uint = 1;
pub const FP_INT_TOWARDZERO: ::std::os::raw::c_uint = 2;
pub const FP_INT_TONEARESTFROMZERO: ::std::os::raw::c_uint = 3;
pub const FP_INT_TONEAREST: ::std::os::raw::c_uint = 4;
pub const __MATH_DECLARING_DOUBLE: ::std::os::raw::c_uint = 1;
pub const __MATH_DECLARE_LDOUBLE: ::std::os::raw::c_uint = 1;
pub const FP_NAN: ::std::os::raw::c_uint = 0;
pub const FP_INFINITE: ::std::os::raw::c_uint = 1;
pub const FP_ZERO: ::std::os::raw::c_uint = 2;
pub const FP_SUBNORMAL: ::std::os::raw::c_uint = 3;
pub const FP_NORMAL: ::std::os::raw::c_uint = 4;
pub const MATH_ERRNO: ::std::os::raw::c_uint = 1;
pub const MATH_ERREXCEPT: ::std::os::raw::c_uint = 2;
pub const math_errhandling: ::std::os::raw::c_uint = 3;
pub const DOMAIN: ::std::os::raw::c_uint = 1;
pub const SING: ::std::os::raw::c_uint = 2;
pub const OVERFLOW: ::std::os::raw::c_uint = 3;
pub const UNDERFLOW: ::std::os::raw::c_uint = 4;
pub const TLOSS: ::std::os::raw::c_uint = 5;
pub const PLOSS: ::std::os::raw::c_uint = 6;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_El: f64 = 2.718281828459045;
pub const M_LOG2El: f64 = 1.4426950408889634;
pub const M_LOG10El: f64 = 0.4342944819032518;
pub const M_LN2l: f64 = 0.6931471805599453;
pub const M_LN10l: f64 = 2.302585092994046;
pub const M_PIl: f64 = 3.141592653589793;
pub const M_PI_2l: f64 = 1.5707963267948966;
pub const M_PI_4l: f64 = 0.7853981633974483;
pub const M_1_PIl: f64 = 0.3183098861837907;
pub const M_2_PIl: f64 = 0.6366197723675814;
pub const M_2_SQRTPIl: f64 = 1.1283791670955126;
pub const M_SQRT2l: f64 = 1.4142135623730951;
pub const M_SQRT1_2l: f64 = 0.7071067811865476;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const __lldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _BITS_UINTN_IDENTITY_H: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const __timeval_defined: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_CMATH: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_STDLIB_H: ::std::os::raw::c_uint = 1;
pub const _GLIBCXX_CSTDLIB: ::std::os::raw::c_uint = 1;
pub const BT_BULLET_VERSION: ::std::os::raw::c_uint = 287;
pub const _ASSERT_H: ::std::os::raw::c_uint = 1;
pub const BT_LARGE_FLOAT: f64 = 1000000000000000000000000000000.;
pub const BT_ONE: f64 = 1.;
pub const BT_ZERO: f64 = 0.;
pub const BT_TWO: f64 = 2.;
pub const BT_HALF: f64 = 0.5;
pub const btVector3DataName: &'static [u8; 20usize] = b"btVector3DoubleData\0";
pub const btQuaternionDataName: &'static [u8; 23usize] = b"btQuaternionDoubleData\0";
pub const _STDIO_H: ::std::os::raw::c_uint = 1;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const _G_config_h: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MMAP: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MREMAP: ::std::os::raw::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::std::os::raw::c_uint = 131073;
pub const _G_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const _IO_UNIFIED_JUMPTABLES: ::std::os::raw::c_uint = 1;
pub const EOF: ::std::os::raw::c_int = -1;
pub const _IOS_INPUT: ::std::os::raw::c_uint = 1;
pub const _IOS_OUTPUT: ::std::os::raw::c_uint = 2;
pub const _IOS_ATEND: ::std::os::raw::c_uint = 4;
pub const _IOS_APPEND: ::std::os::raw::c_uint = 8;
pub const _IOS_TRUNC: ::std::os::raw::c_uint = 16;
pub const _IOS_NOCREATE: ::std::os::raw::c_uint = 32;
pub const _IOS_NOREPLACE: ::std::os::raw::c_uint = 64;
pub const _IOS_BIN: ::std::os::raw::c_uint = 128;
pub const _IO_MAGIC: ::std::os::raw::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::std::os::raw::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::std::os::raw::c_uint = 4294901760;
pub const _IO_USER_BUF: ::std::os::raw::c_uint = 1;
pub const _IO_UNBUFFERED: ::std::os::raw::c_uint = 2;
pub const _IO_NO_READS: ::std::os::raw::c_uint = 4;
pub const _IO_NO_WRITES: ::std::os::raw::c_uint = 8;
pub const _IO_EOF_SEEN: ::std::os::raw::c_uint = 16;
pub const _IO_ERR_SEEN: ::std::os::raw::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::std::os::raw::c_uint = 64;
pub const _IO_LINKED: ::std::os::raw::c_uint = 128;
pub const _IO_IN_BACKUP: ::std::os::raw::c_uint = 256;
pub const _IO_LINE_BUF: ::std::os::raw::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::std::os::raw::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::std::os::raw::c_uint = 2048;
pub const _IO_IS_APPENDING: ::std::os::raw::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_BAD_SEEN: ::std::os::raw::c_uint = 16384;
pub const _IO_USER_LOCK: ::std::os::raw::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::std::os::raw::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::std::os::raw::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::std::os::raw::c_uint = 8;
pub const _IO_SKIPWS: ::std::os::raw::c_uint = 1;
pub const _IO_LEFT: ::std::os::raw::c_uint = 2;
pub const _IO_RIGHT: ::std::os::raw::c_uint = 4;
pub const _IO_INTERNAL: ::std::os::raw::c_uint = 8;
pub const _IO_DEC: ::std::os::raw::c_uint = 16;
pub const _IO_OCT: ::std::os::raw::c_uint = 32;
pub const _IO_HEX: ::std::os::raw::c_uint = 64;
pub const _IO_SHOWBASE: ::std::os::raw::c_uint = 128;
pub const _IO_SHOWPOINT: ::std::os::raw::c_uint = 256;
pub const _IO_UPPERCASE: ::std::os::raw::c_uint = 512;
pub const _IO_SHOWPOS: ::std::os::raw::c_uint = 1024;
pub const _IO_SCIENTIFIC: ::std::os::raw::c_uint = 2048;
pub const _IO_FIXED: ::std::os::raw::c_uint = 4096;
pub const _IO_UNITBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_STDIO: ::std::os::raw::c_uint = 16384;
pub const _IO_DONT_CLOSE: ::std::os::raw::c_uint = 32768;
pub const _IO_BOOLALPHA: ::std::os::raw::c_uint = 65536;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const SEEK_DATA: ::std::os::raw::c_uint = 3;
pub const SEEK_HOLE: ::std::os::raw::c_uint = 4;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const L_tmpnam: ::std::os::raw::c_uint = 20;
pub const TMP_MAX: ::std::os::raw::c_uint = 238328;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 4096;
pub const L_ctermid: ::std::os::raw::c_uint = 9;
pub const L_cuserid: ::std::os::raw::c_uint = 9;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 16;
pub const ACTIVE_TAG: ::std::os::raw::c_uint = 1;
pub const ISLAND_SLEEPING: ::std::os::raw::c_uint = 2;
pub const WANTS_DEACTIVATION: ::std::os::raw::c_uint = 3;
pub const DISABLE_DEACTIVATION: ::std::os::raw::c_uint = 4;
pub const DISABLE_SIMULATION: ::std::os::raw::c_uint = 5;
pub const BT_USE_PLACEMENT_NEW: ::std::os::raw::c_uint = 1;
pub const __EXCEPTION_H: ::std::os::raw::c_uint = 1;
pub const __cpp_lib_uncaught_exceptions: ::std::os::raw::c_uint = 201411;
pub const btCollisionObjectDataName: &'static [u8; 28usize] = b"btCollisionObjectDoubleData\0";
pub const MANIFOLD_CACHE_SIZE: ::std::os::raw::c_uint = 4;
pub const MAINTAIN_PERSISTENCY: ::std::os::raw::c_uint = 1;
pub const USE_DISPATCH_REGISTRY_ARRAY: ::std::os::raw::c_uint = 1;
pub const MAX_PREFERRED_PENETRATION_DIRECTIONS: ::std::os::raw::c_uint = 10;
pub const USE_BANCHLESS: ::std::os::raw::c_uint = 1;
pub const btQuantizedBvhDataName: &'static [u8; 25usize] = b"btQuantizedBvhDoubleData\0";
pub const MAX_SUBTREE_SIZE_IN_BYTES: ::std::os::raw::c_uint = 2048;
pub const MAX_NUM_PARTS_IN_BITS: ::std::os::raw::c_uint = 10;
pub const _MEMORY_H: ::std::os::raw::c_uint = 1;
pub const _STRING_H: ::std::os::raw::c_uint = 1;
pub const BT_HEADER_LENGTH: ::std::os::raw::c_uint = 12;
pub const TRI_INFO_V0V1_CONVEX: ::std::os::raw::c_uint = 1;
pub const TRI_INFO_V1V2_CONVEX: ::std::os::raw::c_uint = 2;
pub const TRI_INFO_V2V0_CONVEX: ::std::os::raw::c_uint = 4;
pub const TRI_INFO_V0V1_SWAP_NORMALB: ::std::os::raw::c_uint = 8;
pub const TRI_INFO_V1V2_SWAP_NORMALB: ::std::os::raw::c_uint = 16;
pub const TRI_INFO_V2V0_SWAP_NORMALB: ::std::os::raw::c_uint = 32;
pub const DBVT_IMPL_GENERIC: ::std::os::raw::c_uint = 0;
pub const DBVT_IMPL_SSE: ::std::os::raw::c_uint = 1;
pub const DBVT_USE_TEMPLATE: ::std::os::raw::c_uint = 0;
pub const DBVT_USE_INTRINSIC_SSE: ::std::os::raw::c_uint = 1;
pub const DBVT_USE_MEMMOVE: ::std::os::raw::c_uint = 1;
pub const DBVT_ENABLE_BENCHMARK: ::std::os::raw::c_uint = 0;
pub const DBVT_SELECT_IMPL: ::std::os::raw::c_uint = 0;
pub const DBVT_MERGE_IMPL: ::std::os::raw::c_uint = 0;
pub const DBVT_INT0_IMPL: ::std::os::raw::c_uint = 0;
pub const DBVT_BP_PROFILE: ::std::os::raw::c_uint = 0;
pub const DBVT_BP_PREVENTFALSEUPDATE: ::std::os::raw::c_uint = 0;
pub const DBVT_BP_ACCURATESLEEPING: ::std::os::raw::c_uint = 0;
pub const DBVT_BP_ENABLE_BENCHMARK: ::std::os::raw::c_uint = 0;
pub const USE_OVERLAP_TEST_ON_REMOVES: ::std::os::raw::c_uint = 1;
pub const CLEAN_INVALID_PAIRS: ::std::os::raw::c_uint = 1;
pub const USE_BT_CLOCK: ::std::os::raw::c_uint = 1;
pub const btRigidBodyDataName: &'static [u8; 22usize] = b"btRigidBodyDoubleData\0";
pub const btTypedConstraintDataName: &'static [u8; 28usize] = b"btTypedConstraintDoubleData\0";
pub const btPoint2PointConstraintDataName: &'static [u8; 35usize] =
    b"btPoint2PointConstraintDoubleData2\0";
pub const _BT_USE_CENTER_LIMIT_: ::std::os::raw::c_uint = 1;
pub const btHingeConstraintDataName: &'static [u8; 29usize] = b"btHingeConstraintDoubleData2\0";
pub const btConeTwistConstraintDataName: &'static [u8; 32usize] =
    b"btConeTwistConstraintDoubleData\0";
pub const btGeneric6DofConstraintDataName: &'static [u8; 35usize] =
    b"btGeneric6DofConstraintDoubleData2\0";
pub const BT_6DOF_FLAGS_AXIS_SHIFT: ::std::os::raw::c_uint = 3;
pub const btSliderConstraintDataName: &'static [u8; 29usize] = b"btSliderConstraintDoubleData\0";
pub const btGeneric6DofSpringConstraintDataName: &'static [u8; 41usize] =
    b"btGeneric6DofSpringConstraintDoubleData2\0";
pub const btGeneric6DofSpring2ConstraintDataName: &'static [u8; 42usize] =
    b"btGeneric6DofSpring2ConstraintDoubleData2\0";
pub const BT_6DOF_FLAGS_AXIS_SHIFT2: ::std::os::raw::c_uint = 4;
pub const btGearConstraintDataName: &'static [u8; 27usize] = b"btGearConstraintDoubleData\0";
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___true_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___true_type() {
    assert_eq!(
        ::std::mem::size_of::<std___true_type>(),
        1usize,
        concat!("Size of: ", stringify!(std___true_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___true_type>(),
        1usize,
        concat!("Alignment of ", stringify!(std___true_type))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___false_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___false_type() {
    assert_eq!(
        ::std::mem::size_of::<std___false_type>(),
        1usize,
        concat!("Size of: ", stringify!(std___false_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___false_type>(),
        1usize,
        concat!("Alignment of ", stringify!(std___false_type))
    );
}
pub type std___truth_type___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___traitor {
    pub _address: u8,
}
pub const std___traitor___value: std___traitor__bindgen_ty_1 = 0;
pub type std___traitor__bindgen_ty_1 = i32;
pub type std___traitor___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___are_same {
    pub _address: u8,
}
pub const std___are_same___value: std___are_same__bindgen_ty_1 = 0;
pub type std___are_same__bindgen_ty_1 = i32;
pub type std___are_same___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_void {
    pub _address: u8,
}
pub const std___is_void___value: std___is_void__bindgen_ty_1 = 0;
pub type std___is_void__bindgen_ty_1 = i32;
pub type std___is_void___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_void_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_void>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_void)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_void>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_void)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integer {
    pub _address: u8,
}
pub const std___is_integer___value: std___is_integer__bindgen_ty_1 = 0;
pub type std___is_integer__bindgen_ty_1 = i32;
pub type std___is_integer___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_integer_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integer_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_integer>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integer>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating {
    pub _address: u8,
}
pub const std___is_floating___value: std___is_floating__bindgen_ty_1 = 0;
pub type std___is_floating__bindgen_ty_1 = i32;
pub type std___is_floating___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_floating_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_floating_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_floating_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer {
    pub _address: u8,
}
pub const std___is_pointer___value: std___is_pointer__bindgen_ty_1 = 0;
pub type std___is_pointer__bindgen_ty_1 = i32;
pub type std___is_pointer___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_char {
    pub _address: u8,
}
pub const std___is_char___value: std___is_char__bindgen_ty_1 = 0;
pub type std___is_char__bindgen_ty_1 = i32;
pub type std___is_char___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_char_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_char>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_char)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_char>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_char)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_char_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_char>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_char)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_char>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_char)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_byte {
    pub _address: u8,
}
pub const std___is_byte___value: std___is_byte__bindgen_ty_1 = 0;
pub type std___is_byte__bindgen_ty_1 = i32;
pub type std___is_byte___type = std___false_type;
#[test]
fn __bindgen_test_layout_std___is_byte_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_byte>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_byte)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_byte>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_byte)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_byte_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_byte>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_byte)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_byte>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_byte)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_byte_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_byte>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_byte)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_byte>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_byte)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_move_iterator {
    pub _address: u8,
}
pub const std___is_move_iterator___value: std___is_move_iterator__bindgen_ty_1 = 0;
pub type std___is_move_iterator__bindgen_ty_1 = i32;
pub type std___is_move_iterator___type = std___false_type;
extern "C" {
    #[link_name = "\u{1}_ZSt3absl"]
    pub fn std_abs(__i: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3absx"]
    pub fn std_abs1(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3absd"]
    pub fn std_abs2(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3absf"]
    pub fn std_abs3(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3abse"]
    pub fn std_abs4(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3absn"]
    pub fn std_abs5(__x: [u64; 2]) -> [u64; 2];
}
extern "C" {
    #[link_name = "\u{1}_ZSt3absg"]
    pub fn std_abs6(__x: [u8; 16]) -> [u8; 16];
}
extern "C" {
    #[link_name = "\u{1}_ZSt4acosf"]
    pub fn std_acos(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4acose"]
    pub fn std_acos1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4asinf"]
    pub fn std_asin(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4asine"]
    pub fn std_asin1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4atanf"]
    pub fn std_atan(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4atane"]
    pub fn std_atan1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt5atan2ff"]
    pub fn std_atan2(__y: f32, __x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt5atan2ee"]
    pub fn std_atan21(__y: f64, __x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4ceilf"]
    pub fn std_ceil(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4ceile"]
    pub fn std_ceil1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3cosf"]
    pub fn std_cos(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3cose"]
    pub fn std_cos1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4coshf"]
    pub fn std_cosh(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4coshe"]
    pub fn std_cosh1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3expf"]
    pub fn std_exp(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3expe"]
    pub fn std_exp1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4fabsf"]
    pub fn std_fabs(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4fabse"]
    pub fn std_fabs1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt5floorf"]
    pub fn std_floor(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt5floore"]
    pub fn std_floor1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4fmodff"]
    pub fn std_fmod(__x: f32, __y: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4fmodee"]
    pub fn std_fmod1(__x: f64, __y: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt5frexpfPi"]
    pub fn std_frexp(__x: f32, __exp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt5frexpePi"]
    pub fn std_frexp1(__x: f64, __exp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt5ldexpfi"]
    pub fn std_ldexp(__x: f32, __exp: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt5ldexpei"]
    pub fn std_ldexp1(__x: f64, __exp: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3logf"]
    pub fn std_log(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3loge"]
    pub fn std_log1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt5log10f"]
    pub fn std_log10(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt5log10e"]
    pub fn std_log101(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4modffPf"]
    pub fn std_modf(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4modfePe"]
    pub fn std_modf1(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3powff"]
    pub fn std_pow(__x: f32, __y: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3powee"]
    pub fn std_pow1(__x: f64, __y: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3powdi"]
    pub fn std_pow2(__x: f64, __i: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3powfi"]
    pub fn std_pow3(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3powei"]
    pub fn std_pow4(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3sinf"]
    pub fn std_sin(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3sine"]
    pub fn std_sin1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4sinhf"]
    pub fn std_sinh(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4sinhe"]
    pub fn std_sinh1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4sqrtf"]
    pub fn std_sqrt(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4sqrte"]
    pub fn std_sqrt1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3tanf"]
    pub fn std_tan(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3tane"]
    pub fn std_tan1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4tanhf"]
    pub fn std_tanh(__x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZSt4tanhe"]
    pub fn std_tanh1(__x: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZSt3divll"]
    pub fn std_div(__i: ::std::os::raw::c_long, __j: ::std::os::raw::c_long) -> ldiv_t;
}
#[repr(C)]
pub struct std_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_exception {
    pub vtable_: *const std_exception__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_std_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_exception>(),
        8usize,
        concat!("Size of: ", stringify!(std_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9exceptionC1Ev"]
    pub fn std_exception_exception(this: *mut std_exception);
}
impl std_exception {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_exception_exception(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9exceptionD0Ev"]
    pub fn std_exception_exception_destructor(this: *mut std_exception);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9exception4whatEv"]
    pub fn std_exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_exception {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_exception>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13bad_exceptionC1Ev"]
    pub fn std_bad_exception_bad_exception(this: *mut std_bad_exception);
}
impl std_bad_exception {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_bad_exception_bad_exception(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13bad_exceptionD0Ev"]
    pub fn std_bad_exception_bad_exception_destructor(this: *mut std_bad_exception);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt13bad_exception4whatEv"]
    pub fn std_bad_exception_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub type std_terminate_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type std_unexpected_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}_ZSt13set_terminatePFvvE"]
    pub fn std_set_terminate(arg1: std_terminate_handler) -> std_terminate_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt9terminatev"]
    pub fn std_terminate();
}
extern "C" {
    #[link_name = "\u{1}_ZSt14set_unexpectedPFvvE"]
    pub fn std_set_unexpected(arg1: std_unexpected_handler) -> std_unexpected_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt10unexpectedv"]
    pub fn std_unexpected();
}
extern "C" {
    #[link_name = "\u{1}_ZSt18uncaught_exceptionv"]
    pub fn std_uncaught_exception() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19uncaught_exceptionsv"]
    pub fn std_uncaught_exceptions() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_alloc {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_std_bad_alloc() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_alloc>(),
        8usize,
        concat!("Size of: ", stringify!(std_bad_alloc))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_alloc>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bad_alloc))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9bad_allocC1Ev"]
    pub fn std_bad_alloc_bad_alloc(this: *mut std_bad_alloc);
}
impl std_bad_alloc {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        std_bad_alloc_bad_alloc(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9bad_allocD0Ev"]
    pub fn std_bad_alloc_bad_alloc_destructor(this: *mut std_bad_alloc);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9bad_alloc4whatEv"]
    pub fn std_bad_alloc_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_nothrow_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_nothrow_t() {
    assert_eq!(
        ::std::mem::size_of::<std_nothrow_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_nothrow_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nothrow_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_nothrow_t))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt7nothrow"]
    pub static mut std_nothrow: std_nothrow_t;
}
pub type std_new_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}_ZSt15set_new_handlerPFvvE"]
    pub fn std_set_new_handler(arg1: std_new_handler) -> std_new_handler;
}
pub type __gnu_cxx___conditional_type___type<_Iftrue> = _Iftrue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___add_unsigned {
    pub _address: u8,
}
pub type __gnu_cxx___add_unsigned___if_type = u8;
pub type __gnu_cxx___add_unsigned___type = __gnu_cxx___add_unsigned___if_type;
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___remove_unsigned {
    pub _address: u8,
}
pub type __gnu_cxx___remove_unsigned___if_type = u8;
pub type __gnu_cxx___remove_unsigned___type = __gnu_cxx___remove_unsigned___if_type;
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_long_long_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
pub type __gnu_cxx___promote___type = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_2 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_2___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_3 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_3___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_4 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_4___type<_Tp2> = _Tp2;
extern "C" {
    #[link_name = "\u{1}_ZN9__gnu_cxx3divExx"]
    pub fn __gnu_cxx_div(
        __n: ::std::os::raw::c_longlong,
        __d: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN9__gnu_cxx27__verbose_terminate_handlerEv"]
    pub fn __gnu_cxx___verbose_terminate_handler();
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __fsid_t)).__val as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type float_t = f32;
pub type double_t = f64;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn sincos(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
extern "C" {
    pub fn __sincos(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn exp10(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp10(__x: f64) -> f64;
}
extern "C" {
    pub fn pow10(__x: f64) -> f64;
}
extern "C" {
    pub fn __pow10(__x: f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nextdown(__x: f64) -> f64;
}
extern "C" {
    pub fn __nextdown(__x: f64) -> f64;
}
extern "C" {
    pub fn nextup(__x: f64) -> f64;
}
extern "C" {
    pub fn __nextup(__x: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llogb(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __llogb(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn roundeven(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundeven(__x: f64) -> f64;
}
extern "C" {
    pub fn fromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fmaxmag(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxmag(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminmag(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminmag(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalorder(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalordermag(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canonicalize(__cx: *mut f64, __x: *const f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpayload(__x: *const f64) -> f64;
}
extern "C" {
    pub fn __getpayload(__x: *const f64) -> f64;
}
extern "C" {
    pub fn setpayload(__x: *mut f64, __payload: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpayloadsig(__x: *mut f64, __payload: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn sincosf(__x: f32, __sinx: *mut f32, __cosx: *mut f32);
}
extern "C" {
    pub fn __sincosf(__x: f32, __sinx: *mut f32, __cosx: *mut f32);
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn exp10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp10f(__x: f32) -> f32;
}
extern "C" {
    pub fn pow10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __pow10f(__x: f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn nextdownf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nextdownf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextupf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nextupf(__x: f32) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llogbf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __llogbf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn roundevenf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundevenf(__x: f32) -> f32;
}
extern "C" {
    pub fn fromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fmaxmagf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxmagf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminmagf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminmagf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalorderf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalordermagf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canonicalizef(__cx: *mut f32, __x: *const f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpayloadf(__x: *const f32) -> f32;
}
extern "C" {
    pub fn __getpayloadf(__x: *const f32) -> f32;
}
extern "C" {
    pub fn setpayloadf(__x: *mut f32, __payload: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpayloadsigf(__x: *mut f32, __payload: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn sincosl(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
extern "C" {
    pub fn __sincosl(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
extern "C" {
    pub fn acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn expl(__x: f64) -> f64;
}
extern "C" {
    pub fn __expl(__x: f64) -> f64;
}
extern "C" {
    pub fn frexpl(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexpl(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexpl(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn logl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logl(__x: f64) -> f64;
}
extern "C" {
    pub fn log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn exp10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp10l(__x: f64) -> f64;
}
extern "C" {
    pub fn pow10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __pow10l(__x: f64) -> f64;
}
extern "C" {
    pub fn expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn __floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinfl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinfl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn __significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __isnanl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnanl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgammal_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nextdownl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nextdownl(__x: f64) -> f64;
}
extern "C" {
    pub fn nextupl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nextupl(__x: f64) -> f64;
}
extern "C" {
    pub fn remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbnl(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbl(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llogbl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __llogbl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scalblnl(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalblnl(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn __truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn remquol(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquol(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrintl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn roundevenl(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundevenl(__x: f64) -> f64;
}
extern "C" {
    pub fn fromfpl(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpl(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpl(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpl(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fromfpxl(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn __fromfpxl(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
extern "C" {
    pub fn ufromfpxl(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn __ufromfpxl(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
extern "C" {
    pub fn fmaxmagl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxmagl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminmagl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminmagl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __iseqsigl(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalorderl(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn totalordermagl(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canonicalizel(__cx: *mut f64, __x: *const f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpayloadl(__x: *const f64) -> f64;
}
extern "C" {
    pub fn __getpayloadl(__x: *const f64) -> f64;
}
extern "C" {
    pub fn setpayloadl(__x: *mut f64, __payload: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpayloadsigl(__x: *mut f64, __payload: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}signgam"]
    pub static mut signgam: ::std::os::raw::c_int;
}
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
extern "C" {
    pub fn __iscanonicall(__x: f64) -> ::std::os::raw::c_int;
}
pub const _LIB_VERSION_TYPE__IEEE_: _LIB_VERSION_TYPE = -1;
pub const _LIB_VERSION_TYPE__SVID_: _LIB_VERSION_TYPE = 0;
pub const _LIB_VERSION_TYPE__XOPEN_: _LIB_VERSION_TYPE = 1;
pub const _LIB_VERSION_TYPE__POSIX_: _LIB_VERSION_TYPE = 2;
pub const _LIB_VERSION_TYPE__ISOC_: _LIB_VERSION_TYPE = 3;
pub type _LIB_VERSION_TYPE = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "\u{1}_LIB_VERSION"]
    pub static mut _LIB_VERSION: _LIB_VERSION_TYPE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout___exception() {
    assert_eq!(
        ::std::mem::size_of::<__exception>(),
        40usize,
        concat!("Size of: ", stringify!(__exception))
    );
    assert_eq!(
        ::std::mem::align_of::<__exception>(),
        8usize,
        concat!("Alignment of ", stringify!(__exception))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __exception)).type_ as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __exception)).name as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(__exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __exception)).arg1 as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(__exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __exception)).arg2 as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(__exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __exception)).retval as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(__exception),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    pub fn matherr(__exc: *mut __exception) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const div_t)).quot as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const div_t)).rem as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const ldiv_t)).quot as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const ldiv_t)).rem as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const lldiv_t)).quot as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const lldiv_t)).rem as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strfromd(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfroml(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __locale_struct)).__locales as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __locale_struct)).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __locale_struct)).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __locale_struct)).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __locale_struct)).__names as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strtol_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: __locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: __locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoll_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: __locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: __locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtod_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: __locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtof_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: __locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtold_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: __locale_t,
    ) -> f64;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __sigset_t)).__val as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(0 as *const timeval)).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const timeval)).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(0 as *const timespec)).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const timespec)).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(0 as *const fd_set)).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_attr_t)).__size as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_attr_t)).__align as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __pthread_internal_list)).__prev as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __pthread_internal_list)).__next as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t___pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pthread_mutex_t___pthread_mutex_s)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__lock as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__count as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__owner as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__nusers as *const _ as usize
        },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__kind as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__spins as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__elision as *const _ as usize
        },
        22usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_mutex_t___pthread_mutex_s)).__list as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_mutex_t)).__data as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_mutex_t)).__size as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_mutex_t)).__align as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_mutexattr_t)).__size as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_mutexattr_t)).__align as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __bindgen_anon_1: pthread_cond_t__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: pthread_cond_t__bindgen_ty_1__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t__bindgen_ty_1__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_cond_t__bindgen_ty_1__bindgen_ty_1)).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_cond_t__bindgen_ty_1__bindgen_ty_1)).__wseq32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t__bindgen_ty_1__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_cond_t__bindgen_ty_1__bindgen_ty_2)).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_cond_t__bindgen_ty_1__bindgen_ty_2)).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_cond_t__bindgen_ty_1)).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_cond_t__bindgen_ty_1)).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_cond_t__bindgen_ty_1)).__g1_orig_size as *const _ as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_cond_t__bindgen_ty_1)).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_cond_t__bindgen_ty_1)).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__g_signals)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_cond_t)).__data as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_cond_t)).__size as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_cond_t)).__align as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_condattr_t)).__size as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_condattr_t)).__align as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__readers as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__writers as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__shared as *const _ as usize },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_rwlock_t__bindgen_ty_1)).__flags as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__flags)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_rwlock_t)).__data as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_rwlock_t)).__size as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_rwlock_t)).__align as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_rwlockattr_t)).__size as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_rwlockattr_t)).__align as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_barrier_t)).__size as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_barrier_t)).__align as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_barrierattr_t)).__size as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_barrierattr_t)).__align as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(0 as *const random_data)).fptr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const random_data)).rptr as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const random_data)).state as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const random_data)).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const random_data)).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const random_data)).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const random_data)).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drand48_data)).__x as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drand48_data)).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Alignment of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drand48_data)).__c as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drand48_data)).__init as *const _ as usize },
        14usize,
        concat!(
            "Alignment of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drand48_data)).__a as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn secure_getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp64(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkostemp(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp64(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canonicalize_file_name(
        __name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void, arg2: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_d_fn_t,
        __arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut u16,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut u16, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const u16, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *const ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(__key: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn posix_openpt(__oflag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlockpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpt() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Z12btGetVersionv"]
    pub fn btGetVersion() -> ::std::os::raw::c_int;
}
pub type btScalar = f64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btInfMaskConverter {
    pub __bindgen_anon_1: btInfMaskConverter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btInfMaskConverter__bindgen_ty_1 {
    pub mask: f32,
    pub intmask: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_btInfMaskConverter__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btInfMaskConverter__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(btInfMaskConverter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<btInfMaskConverter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(btInfMaskConverter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btInfMaskConverter__bindgen_ty_1)).mask as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btInfMaskConverter__bindgen_ty_1),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btInfMaskConverter__bindgen_ty_1)).intmask as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btInfMaskConverter__bindgen_ty_1),
            "::",
            stringify!(intmask)
        )
    );
}
#[test]
fn bindgen_test_layout_btInfMaskConverter() {
    assert_eq!(
        ::std::mem::size_of::<btInfMaskConverter>(),
        4usize,
        concat!("Size of: ", stringify!(btInfMaskConverter))
    );
    assert_eq!(
        ::std::mem::align_of::<btInfMaskConverter>(),
        4usize,
        concat!("Alignment of ", stringify!(btInfMaskConverter))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btInfMaskConverterC1Ei"]
    pub fn btInfMaskConverter_btInfMaskConverter(
        this: *mut btInfMaskConverter,
        mask: ::std::os::raw::c_int,
    );
}
impl btInfMaskConverter {
    #[inline]
    pub unsafe fn new(mask: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btInfMaskConverter_btInfMaskConverter(&mut __bindgen_tmp, mask);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZL14btInfinityMask"]
    pub static mut btInfinityMask: btInfMaskConverter;
}
extern "C" {
    #[link_name = "\u{1}_Z17btGetInfinityMaskv"]
    pub fn btGetInfinityMask() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Z6btSqrtd"]
    pub fn btSqrt(x: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z6btFabsd"]
    pub fn btFabs(x: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z5btCosd"]
    pub fn btCos(x: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z5btSind"]
    pub fn btSin(x: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z5btTand"]
    pub fn btTan(x: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z6btAcosd"]
    pub fn btAcos(x: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z6btAsind"]
    pub fn btAsin(x: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z6btAtand"]
    pub fn btAtan(x: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z7btAtan2dd"]
    pub fn btAtan2(x: btScalar, y: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z5btExpd"]
    pub fn btExp(x: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z5btLogd"]
    pub fn btLog(x: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z5btPowdd"]
    pub fn btPow(x: btScalar, y: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z6btFmoddd"]
    pub fn btFmod(x: btScalar, y: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z11btAtan2Fastdd"]
    pub fn btAtan2Fast(y: btScalar, x: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z11btFuzzyZerod"]
    pub fn btFuzzyZero(x: btScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z7btEqualdd"]
    pub fn btEqual(a: btScalar, eps: btScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z14btGreaterEqualdd"]
    pub fn btGreaterEqual(a: btScalar, eps: btScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z12btIsNegatived"]
    pub fn btIsNegative(x: btScalar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Z9btRadiansd"]
    pub fn btRadians(x: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z9btDegreesd"]
    pub fn btDegrees(x: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z6btFselddd"]
    pub fn btFsel(a: btScalar, b: btScalar, c: btScalar) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z23btMachineIsLittleEndianv"]
    pub fn btMachineIsLittleEndian() -> bool;
}
extern "C" {

    /// btSelect avoids branches, which makes performance much better for consoles like Playstation 3 and XBox 360
    /// Thanks Phil Knight. See also http://www.cellperformance.com/articles/2006/04/more_techniques_for_eliminatin_1.html

    #[link_name = "\u{1}_Z8btSelectjjj"]
    pub fn btSelect(
        condition: ::std::os::raw::c_uint,
        valueIfConditionNonZero: ::std::os::raw::c_uint,
        valueIfConditionZero: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_Z8btSelectjii"]
    pub fn btSelect1(
        condition: ::std::os::raw::c_uint,
        valueIfConditionNonZero: ::std::os::raw::c_int,
        valueIfConditionZero: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Z8btSelectjff"]
    pub fn btSelect2(
        condition: ::std::os::raw::c_uint,
        valueIfConditionNonZero: f32,
        valueIfConditionZero: f32,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_Z12btSwapEndianj"]
    pub fn btSwapEndian(val: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_Z12btSwapEndiant"]
    pub fn btSwapEndian1(val: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "\u{1}_Z12btSwapEndiani"]
    pub fn btSwapEndian2(val: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_Z12btSwapEndians"]
    pub fn btSwapEndian3(val: ::std::os::raw::c_short) -> ::std::os::raw::c_ushort;
}
extern "C" {

    /// btSwapFloat uses using char pointers to swap the endianness
    /// btSwapFloat/btSwapDouble will NOT return a float, because the machine might 'correct' invalid floating point values
    /// Not all values of sign/exponent/mantissa are valid floating point numbers according to IEEE 754.
    /// When a floating point unit is faced with an invalid value, it may actually change the value, or worse, throw an exception.
    /// In most systems, running user mode code, you wouldn't get an exception, but instead the hardware/os/runtime will 'fix' the number for you.
    /// so instead of returning a float/double, we return integer/long long integer

    #[link_name = "\u{1}_Z17btSwapEndianFloatf"]
    pub fn btSwapEndianFloat(d: f32) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_Z19btUnswapEndianFloatj"]
    pub fn btUnswapEndianFloat(a: ::std::os::raw::c_uint) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_Z18btSwapEndianDoubledPh"]
    pub fn btSwapEndianDouble(d: f64, dst: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}_Z20btUnswapEndianDoublePKh"]
    pub fn btUnswapEndianDouble(src: *const ::std::os::raw::c_uchar) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_Z10btLargeDotPKdS0_i"]
    pub fn btLargeDot(a: *const btScalar, b: *const btScalar, n: ::std::os::raw::c_int)
        -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z16btNormalizeAngled"]
    pub fn btNormalizeAngle(angleInRadians: btScalar) -> btScalar;
}
/// rudimentary class to provide type info
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTypedObject {
    pub m_objectType: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btTypedObject() {
    assert_eq!(
        ::std::mem::size_of::<btTypedObject>(),
        4usize,
        concat!("Size of: ", stringify!(btTypedObject))
    );
    assert_eq!(
        ::std::mem::align_of::<btTypedObject>(),
        4usize,
        concat!("Alignment of ", stringify!(btTypedObject))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedObject)).m_objectType as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedObject),
            "::",
            stringify!(m_objectType)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btTypedObject13getObjectTypeEv"]
    pub fn btTypedObject_getObjectType(this: *const btTypedObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN13btTypedObjectC1Ei"]
    pub fn btTypedObject_btTypedObject(this: *mut btTypedObject, objectType: ::std::os::raw::c_int);
}
impl btTypedObject {
    #[inline]
    pub unsafe fn getObjectType(&self) -> ::std::os::raw::c_int {
        btTypedObject_getObjectType(self)
    }
    #[inline]
    pub unsafe fn new(objectType: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTypedObject_btTypedObject(&mut __bindgen_tmp, objectType);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_Z22btAlignedAllocInternalmi"]
    pub fn btAlignedAllocInternal(
        size: usize,
        alignment: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_Z21btAlignedFreeInternalPv"]
    pub fn btAlignedFreeInternal(ptr: *mut ::std::os::raw::c_void);
}
pub type size_type = ::std::os::raw::c_int;
pub type btAlignedAllocFunc = ::std::option::Option<
    unsafe extern "C" fn(size: usize, alignment: ::std::os::raw::c_int)
        -> *mut ::std::os::raw::c_void,
>;
pub type btAlignedFreeFunc = ::std::option::Option<
    unsafe extern "C" fn(memblock: *mut ::std::os::raw::c_void),
>;
pub type btAllocFunc = ::std::option::Option<
    unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void,
>;
pub type btFreeFunc = ::std::option::Option<
    unsafe extern "C" fn(memblock: *mut ::std::os::raw::c_void),
>;
extern "C" {

    /// The developer can let all Bullet memory allocations go through a custom memory allocator, using btAlignedAllocSetCustom

    #[link_name = "\u{1}_Z23btAlignedAllocSetCustomPFPvmEPFvS_E"]
    pub fn btAlignedAllocSetCustom(allocFunc: btAllocFunc, freeFunc: btFreeFunc);
}
extern "C" {

    /// If the developer has already an custom aligned allocator, then btAlignedAllocSetCustomAligned can be used. The default aligned allocator pre-allocates extra memory using the non-aligned allocator, and instruments it.

    #[link_name = "\u{1}_Z30btAlignedAllocSetCustomAlignedPFPvmiEPFvS_E"]
    pub fn btAlignedAllocSetCustomAligned(
        allocFunc: btAlignedAllocFunc,
        freeFunc: btAlignedFreeFunc,
    );
}
pub type btAlignedAllocator_self_type = u8;
pub type btAlignedAllocator_const_pointer<T> = *mut T;
pub type btAlignedAllocator_const_reference<T> = *mut T;
pub type btAlignedAllocator_pointer<T> = *mut T;
pub type btAlignedAllocator_reference<T> = *mut T;
pub type btAlignedAllocator_value_type<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btAlignedAllocator_rebind {
    pub _address: u8,
}
pub type btAlignedAllocator_rebind_other = u8;
/// @brief btVector3 can be used to represent 3D points and vectors.
/// It has an un-used w component to suit 16-byte alignment when btVector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
/// Ideally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btVector3 {
    pub m_floats: [btScalar; 4usize],
}
#[test]
fn bindgen_test_layout_btVector3() {
    assert_eq!(
        ::std::mem::size_of::<btVector3>(),
        32usize,
        concat!("Size of: ", stringify!(btVector3))
    );
    assert_eq!(
        ::std::mem::align_of::<btVector3>(),
        8usize,
        concat!("Alignment of ", stringify!(btVector3))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btVector3)).m_floats as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btVector3),
            "::",
            stringify!(m_floats)
        )
    );
}
extern "C" {

    /// @brief Return the dot product
    /// @param v The other vector in the dot product

    #[link_name = "\u{1}_ZNK9btVector33dotERKS_"]
    pub fn btVector3_dot(this: *const btVector3, v: *const btVector3) -> btScalar;
}
extern "C" {

    /// @brief Return the length of the vector squared

    #[link_name = "\u{1}_ZNK9btVector37length2Ev"]
    pub fn btVector3_length2(this: *const btVector3) -> btScalar;
}
extern "C" {

    /// @brief Return the length of the vector

    #[link_name = "\u{1}_ZNK9btVector36lengthEv"]
    pub fn btVector3_length(this: *const btVector3) -> btScalar;
}
extern "C" {

    /// @brief Return the norm (length) of the vector

    #[link_name = "\u{1}_ZNK9btVector34normEv"]
    pub fn btVector3_norm(this: *const btVector3) -> btScalar;
}
extern "C" {

    /// @brief Return the norm (length) of the vector

    #[link_name = "\u{1}_ZNK9btVector38safeNormEv"]
    pub fn btVector3_safeNorm(this: *const btVector3) -> btScalar;
}
extern "C" {

    /// @brief Return the distance squared between the ends of this and another vector
    /// This is symantically treating the vector like a point

    #[link_name = "\u{1}_ZNK9btVector39distance2ERKS_"]
    pub fn btVector3_distance2(this: *const btVector3, v: *const btVector3) -> btScalar;
}
extern "C" {

    /// @brief Return the distance between the ends of this and another vector
    /// This is symantically treating the vector like a point

    #[link_name = "\u{1}_ZNK9btVector38distanceERKS_"]
    pub fn btVector3_distance(this: *const btVector3, v: *const btVector3) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN9btVector313safeNormalizeEv"]
    pub fn btVector3_safeNormalize(this: *mut btVector3) -> *mut btVector3;
}
extern "C" {

    /// @brief Normalize this vector
    /// x^2 + y^2 + z^2 = 1

    #[link_name = "\u{1}_ZN9btVector39normalizeEv"]
    pub fn btVector3_normalize(this: *mut btVector3) -> *mut btVector3;
}
extern "C" {

    /// @brief Return a normalized version of this vector

    #[link_name = "\u{1}_ZNK9btVector310normalizedEv"]
    pub fn btVector3_normalized(this: *const btVector3) -> btVector3;
}
extern "C" {

    /// @brief Return a rotated version of this vector
    /// @param wAxis The axis to rotate about
    /// @param angle The angle to rotate by

    #[link_name = "\u{1}_ZNK9btVector36rotateERKS_d"]
    pub fn btVector3_rotate(
        this: *const btVector3,
        wAxis: *const btVector3,
        angle: btScalar,
    ) -> btVector3;
}
extern "C" {

    /// @brief Return the angle between this and another vector
    /// @param v The other vector

    #[link_name = "\u{1}_ZNK9btVector35angleERKS_"]
    pub fn btVector3_angle(this: *const btVector3, v: *const btVector3) -> btScalar;
}
extern "C" {

    /// @brief Return a vector will the absolute values of each element

    #[link_name = "\u{1}_ZNK9btVector38absoluteEv"]
    pub fn btVector3_absolute(this: *const btVector3) -> btVector3;
}
extern "C" {

    /// @brief Return the cross product between this and another vector
    /// @param v The other vector

    #[link_name = "\u{1}_ZNK9btVector35crossERKS_"]
    pub fn btVector3_cross(this: *const btVector3, v: *const btVector3) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector36tripleERKS_S1_"]
    pub fn btVector3_triple(
        this: *const btVector3,
        v1: *const btVector3,
        v2: *const btVector3,
    ) -> btScalar;
}
extern "C" {

    /// @brief Return the axis with the smallest value
    /// Note return values are 0,1,2 for x, y, or z

    #[link_name = "\u{1}_ZNK9btVector37minAxisEv"]
    pub fn btVector3_minAxis(this: *const btVector3) -> ::std::os::raw::c_int;
}
extern "C" {

    /// @brief Return the axis with the largest value
    /// Note return values are 0,1,2 for x, y, or z

    #[link_name = "\u{1}_ZNK9btVector37maxAxisEv"]
    pub fn btVector3_maxAxis(this: *const btVector3) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector312furthestAxisEv"]
    pub fn btVector3_furthestAxis(this: *const btVector3) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector311closestAxisEv"]
    pub fn btVector3_closestAxis(this: *const btVector3) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN9btVector315setInterpolate3ERKS_S1_d"]
    pub fn btVector3_setInterpolate3(
        this: *mut btVector3,
        v0: *const btVector3,
        v1: *const btVector3,
        rt: btScalar,
    );
}
extern "C" {

    /// @brief Return the linear interpolation between this and another vector
    /// @param v The other vector
    /// @param t The ration of this to v (t = 0 => return this, t=1 => return other)

    #[link_name = "\u{1}_ZNK9btVector34lerpERKS_RKd"]
    pub fn btVector3_lerp(
        this: *const btVector3,
        v: *const btVector3,
        t: *const btScalar,
    ) -> btVector3;
}
extern "C" {

    /// @brief Return the x value

    #[link_name = "\u{1}_ZNK9btVector34getXEv"]
    pub fn btVector3_getX(this: *const btVector3) -> *const btScalar;
}
extern "C" {

    /// @brief Return the y value

    #[link_name = "\u{1}_ZNK9btVector34getYEv"]
    pub fn btVector3_getY(this: *const btVector3) -> *const btScalar;
}
extern "C" {

    /// @brief Return the z value

    #[link_name = "\u{1}_ZNK9btVector34getZEv"]
    pub fn btVector3_getZ(this: *const btVector3) -> *const btScalar;
}
extern "C" {

    /// @brief Set the x value

    #[link_name = "\u{1}_ZN9btVector34setXEd"]
    pub fn btVector3_setX(this: *mut btVector3, _x: btScalar);
}
extern "C" {

    /// @brief Set the y value

    #[link_name = "\u{1}_ZN9btVector34setYEd"]
    pub fn btVector3_setY(this: *mut btVector3, _y: btScalar);
}
extern "C" {

    /// @brief Set the z value

    #[link_name = "\u{1}_ZN9btVector34setZEd"]
    pub fn btVector3_setZ(this: *mut btVector3, _z: btScalar);
}
extern "C" {

    /// @brief Set the w value

    #[link_name = "\u{1}_ZN9btVector34setWEd"]
    pub fn btVector3_setW(this: *mut btVector3, _w: btScalar);
}
extern "C" {

    /// @brief Return the x value

    #[link_name = "\u{1}_ZNK9btVector31xEv"]
    pub fn btVector3_x(this: *const btVector3) -> *const btScalar;
}
extern "C" {

    /// @brief Return the y value

    #[link_name = "\u{1}_ZNK9btVector31yEv"]
    pub fn btVector3_y(this: *const btVector3) -> *const btScalar;
}
extern "C" {

    /// @brief Return the z value

    #[link_name = "\u{1}_ZNK9btVector31zEv"]
    pub fn btVector3_z(this: *const btVector3) -> *const btScalar;
}
extern "C" {

    /// @brief Return the w value

    #[link_name = "\u{1}_ZNK9btVector31wEv"]
    pub fn btVector3_w(this: *const btVector3) -> *const btScalar;
}
extern "C" {

    /// @brief Set each element to the max of the current values and the values of another btVector3
    /// @param other The other btVector3 to compare with

    #[link_name = "\u{1}_ZN9btVector36setMaxERKS_"]
    pub fn btVector3_setMax(this: *mut btVector3, other: *const btVector3);
}
extern "C" {

    /// @brief Set each element to the min of the current values and the values of another btVector3
    /// @param other The other btVector3 to compare with

    #[link_name = "\u{1}_ZN9btVector36setMinERKS_"]
    pub fn btVector3_setMin(this: *mut btVector3, other: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZN9btVector38setValueERKdS1_S1_"]
    pub fn btVector3_setValue(
        this: *mut btVector3,
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector322getSkewSymmetricMatrixEPS_S0_S0_"]
    pub fn btVector3_getSkewSymmetricMatrix(
        this: *const btVector3,
        v0: *mut btVector3,
        v1: *mut btVector3,
        v2: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9btVector37setZeroEv"]
    pub fn btVector3_setZero(this: *mut btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector36isZeroEv"]
    pub fn btVector3_isZero(this: *const btVector3) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector39fuzzyZeroEv"]
    pub fn btVector3_fuzzyZero(this: *const btVector3) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector39serializeER19btVector3DoubleData"]
    pub fn btVector3_serialize(this: *const btVector3, dataOut: *mut btVector3DoubleData);
}
extern "C" {
    #[link_name = "\u{1}_ZN9btVector311deSerializeERK19btVector3DoubleData"]
    pub fn btVector3_deSerialize(this: *mut btVector3, dataIn: *const btVector3DoubleData);
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector314serializeFloatER18btVector3FloatData"]
    pub fn btVector3_serializeFloat(this: *const btVector3, dataOut: *mut btVector3FloatData);
}
extern "C" {
    #[link_name = "\u{1}_ZN9btVector316deSerializeFloatERK18btVector3FloatData"]
    pub fn btVector3_deSerializeFloat(this: *mut btVector3, dataIn: *const btVector3FloatData);
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector315serializeDoubleER19btVector3DoubleData"]
    pub fn btVector3_serializeDouble(this: *const btVector3, dataOut: *mut btVector3DoubleData);
}
extern "C" {
    #[link_name = "\u{1}_ZN9btVector317deSerializeDoubleERK19btVector3DoubleData"]
    pub fn btVector3_deSerializeDouble(this: *mut btVector3, dataIn: *const btVector3DoubleData);
}
extern "C" {

    /// @brief returns index of maximum dot product between this and vectors in array[]
    /// @param array The other vectors
    /// @param array_count The number of other vectors
    /// @param dotOut The maximum dot product

    #[link_name = "\u{1}_ZNK9btVector36maxDotEPKS_lRd"]
    pub fn btVector3_maxDot(
        this: *const btVector3,
        array: *const btVector3,
        array_count: ::std::os::raw::c_long,
        dotOut: *mut btScalar,
    ) -> ::std::os::raw::c_long;
}
extern "C" {

    /// @brief returns index of minimum dot product between this and vectors in array[]
    /// @param array The other vectors
    /// @param array_count The number of other vectors
    /// @param dotOut The minimum dot product

    #[link_name = "\u{1}_ZNK9btVector36minDotEPKS_lRd"]
    pub fn btVector3_minDot(
        this: *const btVector3,
        array: *const btVector3,
        array_count: ::std::os::raw::c_long,
        dotOut: *mut btScalar,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector34dot3ERKS_S1_S1_"]
    pub fn btVector3_dot3(
        this: *const btVector3,
        v0: *const btVector3,
        v1: *const btVector3,
        v2: *const btVector3,
    ) -> btVector3;
}
extern "C" {

    /// @brief No initialization constructor

    #[link_name = "\u{1}_ZN9btVector3C1Ev"]
    pub fn btVector3_btVector3(this: *mut btVector3);
}
extern "C" {

    /// @brief Constructor from scalars
    /// @param x X value
    /// @param y Y value
    /// @param z Z value

    #[link_name = "\u{1}_ZN9btVector3C1ERKdS1_S1_"]
    pub fn btVector3_btVector31(
        this: *mut btVector3,
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
    );
}
impl btVector3 {
    #[inline]
    pub unsafe fn dot(&self, v: *const btVector3) -> btScalar {
        btVector3_dot(self, v)
    }
    #[inline]
    pub unsafe fn length2(&self) -> btScalar {
        btVector3_length2(self)
    }
    #[inline]
    pub unsafe fn length(&self) -> btScalar {
        btVector3_length(self)
    }
    #[inline]
    pub unsafe fn norm(&self) -> btScalar {
        btVector3_norm(self)
    }
    #[inline]
    pub unsafe fn safeNorm(&self) -> btScalar {
        btVector3_safeNorm(self)
    }
    #[inline]
    pub unsafe fn distance2(&self, v: *const btVector3) -> btScalar {
        btVector3_distance2(self, v)
    }
    #[inline]
    pub unsafe fn distance(&self, v: *const btVector3) -> btScalar {
        btVector3_distance(self, v)
    }
    #[inline]
    pub unsafe fn safeNormalize(&mut self) -> *mut btVector3 {
        btVector3_safeNormalize(self)
    }
    #[inline]
    pub unsafe fn normalize(&mut self) -> *mut btVector3 {
        btVector3_normalize(self)
    }
    #[inline]
    pub unsafe fn normalized(&self) -> btVector3 {
        btVector3_normalized(self)
    }
    #[inline]
    pub unsafe fn rotate(&self, wAxis: *const btVector3, angle: btScalar) -> btVector3 {
        btVector3_rotate(self, wAxis, angle)
    }
    #[inline]
    pub unsafe fn angle(&self, v: *const btVector3) -> btScalar {
        btVector3_angle(self, v)
    }
    #[inline]
    pub unsafe fn absolute(&self) -> btVector3 {
        btVector3_absolute(self)
    }
    #[inline]
    pub unsafe fn cross(&self, v: *const btVector3) -> btVector3 {
        btVector3_cross(self, v)
    }
    #[inline]
    pub unsafe fn triple(&self, v1: *const btVector3, v2: *const btVector3) -> btScalar {
        btVector3_triple(self, v1, v2)
    }
    #[inline]
    pub unsafe fn minAxis(&self) -> ::std::os::raw::c_int {
        btVector3_minAxis(self)
    }
    #[inline]
    pub unsafe fn maxAxis(&self) -> ::std::os::raw::c_int {
        btVector3_maxAxis(self)
    }
    #[inline]
    pub unsafe fn furthestAxis(&self) -> ::std::os::raw::c_int {
        btVector3_furthestAxis(self)
    }
    #[inline]
    pub unsafe fn closestAxis(&self) -> ::std::os::raw::c_int {
        btVector3_closestAxis(self)
    }
    #[inline]
    pub unsafe fn setInterpolate3(
        &mut self,
        v0: *const btVector3,
        v1: *const btVector3,
        rt: btScalar,
    ) {
        btVector3_setInterpolate3(self, v0, v1, rt)
    }
    #[inline]
    pub unsafe fn lerp(&self, v: *const btVector3, t: *const btScalar) -> btVector3 {
        btVector3_lerp(self, v, t)
    }
    #[inline]
    pub unsafe fn getX(&self) -> *const btScalar {
        btVector3_getX(self)
    }
    #[inline]
    pub unsafe fn getY(&self) -> *const btScalar {
        btVector3_getY(self)
    }
    #[inline]
    pub unsafe fn getZ(&self) -> *const btScalar {
        btVector3_getZ(self)
    }
    #[inline]
    pub unsafe fn setX(&mut self, _x: btScalar) {
        btVector3_setX(self, _x)
    }
    #[inline]
    pub unsafe fn setY(&mut self, _y: btScalar) {
        btVector3_setY(self, _y)
    }
    #[inline]
    pub unsafe fn setZ(&mut self, _z: btScalar) {
        btVector3_setZ(self, _z)
    }
    #[inline]
    pub unsafe fn setW(&mut self, _w: btScalar) {
        btVector3_setW(self, _w)
    }
    #[inline]
    pub unsafe fn x(&self) -> *const btScalar {
        btVector3_x(self)
    }
    #[inline]
    pub unsafe fn y(&self) -> *const btScalar {
        btVector3_y(self)
    }
    #[inline]
    pub unsafe fn z(&self) -> *const btScalar {
        btVector3_z(self)
    }
    #[inline]
    pub unsafe fn w(&self) -> *const btScalar {
        btVector3_w(self)
    }
    #[inline]
    pub unsafe fn setMax(&mut self, other: *const btVector3) {
        btVector3_setMax(self, other)
    }
    #[inline]
    pub unsafe fn setMin(&mut self, other: *const btVector3) {
        btVector3_setMin(self, other)
    }
    #[inline]
    pub unsafe fn setValue(
        &mut self,
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
    ) {
        btVector3_setValue(self, _x, _y, _z)
    }
    #[inline]
    pub unsafe fn getSkewSymmetricMatrix(
        &self,
        v0: *mut btVector3,
        v1: *mut btVector3,
        v2: *mut btVector3,
    ) {
        btVector3_getSkewSymmetricMatrix(self, v0, v1, v2)
    }
    #[inline]
    pub unsafe fn setZero(&mut self) {
        btVector3_setZero(self)
    }
    #[inline]
    pub unsafe fn isZero(&self) -> bool {
        btVector3_isZero(self)
    }
    #[inline]
    pub unsafe fn fuzzyZero(&self) -> bool {
        btVector3_fuzzyZero(self)
    }
    #[inline]
    pub unsafe fn serialize(&self, dataOut: *mut btVector3DoubleData) {
        btVector3_serialize(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerialize(&mut self, dataIn: *const btVector3DoubleData) {
        btVector3_deSerialize(self, dataIn)
    }
    #[inline]
    pub unsafe fn serializeFloat(&self, dataOut: *mut btVector3FloatData) {
        btVector3_serializeFloat(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerializeFloat(&mut self, dataIn: *const btVector3FloatData) {
        btVector3_deSerializeFloat(self, dataIn)
    }
    #[inline]
    pub unsafe fn serializeDouble(&self, dataOut: *mut btVector3DoubleData) {
        btVector3_serializeDouble(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerializeDouble(&mut self, dataIn: *const btVector3DoubleData) {
        btVector3_deSerializeDouble(self, dataIn)
    }
    #[inline]
    pub unsafe fn maxDot(
        &self,
        array: *const btVector3,
        array_count: ::std::os::raw::c_long,
        dotOut: *mut btScalar,
    ) -> ::std::os::raw::c_long {
        btVector3_maxDot(self, array, array_count, dotOut)
    }
    #[inline]
    pub unsafe fn minDot(
        &self,
        array: *const btVector3,
        array_count: ::std::os::raw::c_long,
        dotOut: *mut btScalar,
    ) -> ::std::os::raw::c_long {
        btVector3_minDot(self, array, array_count, dotOut)
    }
    #[inline]
    pub unsafe fn dot3(
        &self,
        v0: *const btVector3,
        v1: *const btVector3,
        v2: *const btVector3,
    ) -> btVector3 {
        btVector3_dot3(self, v0, v1, v2)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btVector3_btVector3(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(_x: *const btScalar, _y: *const btScalar, _z: *const btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btVector3_btVector31(&mut __bindgen_tmp, _x, _y, _z);
        __bindgen_tmp
    }
}
extern "C" {

    /// @brief Return the dot product between two vectors

    #[link_name = "\u{1}_Z5btDotRK9btVector3S1_"]
    pub fn btDot(v1: *const btVector3, v2: *const btVector3) -> btScalar;
}
extern "C" {

    /// @brief Return the distance squared between two vectors

    #[link_name = "\u{1}_Z11btDistance2RK9btVector3S1_"]
    pub fn btDistance2(v1: *const btVector3, v2: *const btVector3) -> btScalar;
}
extern "C" {

    /// @brief Return the distance between two vectors

    #[link_name = "\u{1}_Z10btDistanceRK9btVector3S1_"]
    pub fn btDistance(v1: *const btVector3, v2: *const btVector3) -> btScalar;
}
extern "C" {

    /// @brief Return the angle between two vectors

    #[link_name = "\u{1}_Z7btAngleRK9btVector3S1_"]
    pub fn btAngle(v1: *const btVector3, v2: *const btVector3) -> btScalar;
}
extern "C" {

    /// @brief Return the cross product of two vectors

    #[link_name = "\u{1}_Z7btCrossRK9btVector3S1_"]
    pub fn btCross(v1: *const btVector3, v2: *const btVector3) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_Z8btTripleRK9btVector3S1_S1_"]
    pub fn btTriple(v1: *const btVector3, v2: *const btVector3, v3: *const btVector3) -> btScalar;
}
extern "C" {

    /// @brief Return the linear interpolation between two vectors
    /// @param v1 One vector
    /// @param v2 The other vector
    /// @param t The ration of this to v (t = 0 => return v1, t=1 => return v2)

    #[link_name = "\u{1}_Z4lerpRK9btVector3S1_RKd"]
    pub fn lerp(v1: *const btVector3, v2: *const btVector3, t: *const btScalar) -> btVector3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btVector4 {
    pub _base: btVector3,
}
#[test]
fn bindgen_test_layout_btVector4() {
    assert_eq!(
        ::std::mem::size_of::<btVector4>(),
        32usize,
        concat!("Size of: ", stringify!(btVector4))
    );
    assert_eq!(
        ::std::mem::align_of::<btVector4>(),
        8usize,
        concat!("Alignment of ", stringify!(btVector4))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector49absolute4Ev"]
    pub fn btVector4_absolute4(this: *const btVector4) -> btVector4;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector44getWEv"]
    pub fn btVector4_getW(this: *const btVector4) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector48maxAxis4Ev"]
    pub fn btVector4_maxAxis4(this: *const btVector4) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector48minAxis4Ev"]
    pub fn btVector4_minAxis4(this: *const btVector4) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btVector412closestAxis4Ev"]
    pub fn btVector4_closestAxis4(this: *const btVector4) -> ::std::os::raw::c_int;
}
extern "C" {

    /// @brief Set the values
    /// @param x Value of x
    /// @param y Value of y
    /// @param z Value of z
    /// @param w Value of w

    #[link_name = "\u{1}_ZN9btVector48setValueERKdS1_S1_S1_"]
    pub fn btVector4_setValue(
        this: *mut btVector4,
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
        _w: *const btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9btVector4C1Ev"]
    pub fn btVector4_btVector4(this: *mut btVector4);
}
extern "C" {
    #[link_name = "\u{1}_ZN9btVector4C1ERKdS1_S1_S1_"]
    pub fn btVector4_btVector41(
        this: *mut btVector4,
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
        _w: *const btScalar,
    );
}
impl btVector4 {
    #[inline]
    pub unsafe fn absolute4(&self) -> btVector4 {
        btVector4_absolute4(self)
    }
    #[inline]
    pub unsafe fn getW(&self) -> btScalar {
        btVector4_getW(self)
    }
    #[inline]
    pub unsafe fn maxAxis4(&self) -> ::std::os::raw::c_int {
        btVector4_maxAxis4(self)
    }
    #[inline]
    pub unsafe fn minAxis4(&self) -> ::std::os::raw::c_int {
        btVector4_minAxis4(self)
    }
    #[inline]
    pub unsafe fn closestAxis4(&self) -> ::std::os::raw::c_int {
        btVector4_closestAxis4(self)
    }
    #[inline]
    pub unsafe fn setValue(
        &mut self,
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
        _w: *const btScalar,
    ) {
        btVector4_setValue(self, _x, _y, _z, _w)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btVector4_btVector4(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
        _w: *const btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btVector4_btVector41(&mut __bindgen_tmp, _x, _y, _z, _w);
        __bindgen_tmp
    }
}
extern "C" {

    /// btSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization

    #[link_name = "\u{1}_Z18btSwapScalarEndianRKdRd"]
    pub fn btSwapScalarEndian(sourceVal: *const btScalar, destVal: *mut btScalar);
}
extern "C" {

    /// btSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization

    #[link_name = "\u{1}_Z19btSwapVector3EndianRK9btVector3RS_"]
    pub fn btSwapVector3Endian(sourceVec: *const btVector3, destVec: *mut btVector3);
}
extern "C" {

    /// btUnSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization

    #[link_name = "\u{1}_Z21btUnSwapVector3EndianR9btVector3"]
    pub fn btUnSwapVector3Endian(vector: *mut btVector3);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btVector3FloatData {
    pub m_floats: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_btVector3FloatData() {
    assert_eq!(
        ::std::mem::size_of::<btVector3FloatData>(),
        16usize,
        concat!("Size of: ", stringify!(btVector3FloatData))
    );
    assert_eq!(
        ::std::mem::align_of::<btVector3FloatData>(),
        4usize,
        concat!("Alignment of ", stringify!(btVector3FloatData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btVector3FloatData)).m_floats as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btVector3FloatData),
            "::",
            stringify!(m_floats)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btVector3DoubleData {
    pub m_floats: [f64; 4usize],
}
#[test]
fn bindgen_test_layout_btVector3DoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btVector3DoubleData>(),
        32usize,
        concat!("Size of: ", stringify!(btVector3DoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btVector3DoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btVector3DoubleData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btVector3DoubleData)).m_floats as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btVector3DoubleData),
            "::",
            stringify!(m_floats)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuadWord {
    pub m_floats: [btScalar; 4usize],
}
#[test]
fn bindgen_test_layout_btQuadWord() {
    assert_eq!(
        ::std::mem::size_of::<btQuadWord>(),
        32usize,
        concat!("Size of: ", stringify!(btQuadWord))
    );
    assert_eq!(
        ::std::mem::align_of::<btQuadWord>(),
        8usize,
        concat!("Alignment of ", stringify!(btQuadWord))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuadWord)).m_floats as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuadWord),
            "::",
            stringify!(m_floats)
        )
    );
}
extern "C" {

    /// @brief Return the x value

    #[link_name = "\u{1}_ZNK10btQuadWord4getXEv"]
    pub fn btQuadWord_getX(this: *const btQuadWord) -> *const btScalar;
}
extern "C" {

    /// @brief Return the y value

    #[link_name = "\u{1}_ZNK10btQuadWord4getYEv"]
    pub fn btQuadWord_getY(this: *const btQuadWord) -> *const btScalar;
}
extern "C" {

    /// @brief Return the z value

    #[link_name = "\u{1}_ZNK10btQuadWord4getZEv"]
    pub fn btQuadWord_getZ(this: *const btQuadWord) -> *const btScalar;
}
extern "C" {

    /// @brief Set the x value

    #[link_name = "\u{1}_ZN10btQuadWord4setXEd"]
    pub fn btQuadWord_setX(this: *mut btQuadWord, _x: btScalar);
}
extern "C" {

    /// @brief Set the y value

    #[link_name = "\u{1}_ZN10btQuadWord4setYEd"]
    pub fn btQuadWord_setY(this: *mut btQuadWord, _y: btScalar);
}
extern "C" {

    /// @brief Set the z value

    #[link_name = "\u{1}_ZN10btQuadWord4setZEd"]
    pub fn btQuadWord_setZ(this: *mut btQuadWord, _z: btScalar);
}
extern "C" {

    /// @brief Set the w value

    #[link_name = "\u{1}_ZN10btQuadWord4setWEd"]
    pub fn btQuadWord_setW(this: *mut btQuadWord, _w: btScalar);
}
extern "C" {

    /// @brief Return the x value

    #[link_name = "\u{1}_ZNK10btQuadWord1xEv"]
    pub fn btQuadWord_x(this: *const btQuadWord) -> *const btScalar;
}
extern "C" {

    /// @brief Return the y value

    #[link_name = "\u{1}_ZNK10btQuadWord1yEv"]
    pub fn btQuadWord_y(this: *const btQuadWord) -> *const btScalar;
}
extern "C" {

    /// @brief Return the z value

    #[link_name = "\u{1}_ZNK10btQuadWord1zEv"]
    pub fn btQuadWord_z(this: *const btQuadWord) -> *const btScalar;
}
extern "C" {

    /// @brief Return the w value

    #[link_name = "\u{1}_ZNK10btQuadWord1wEv"]
    pub fn btQuadWord_w(this: *const btQuadWord) -> *const btScalar;
}
extern "C" {

    /// @brief Set x,y,z and zero w
    /// @param x Value of x
    /// @param y Value of y
    /// @param z Value of z

    #[link_name = "\u{1}_ZN10btQuadWord8setValueERKdS1_S1_"]
    pub fn btQuadWord_setValue(
        this: *mut btQuadWord,
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
    );
}
extern "C" {

    /// @brief Set the values
    /// @param x Value of x
    /// @param y Value of y
    /// @param z Value of z
    /// @param w Value of w

    #[link_name = "\u{1}_ZN10btQuadWord8setValueERKdS1_S1_S1_"]
    pub fn btQuadWord_setValue1(
        this: *mut btQuadWord,
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
        _w: *const btScalar,
    );
}
extern "C" {

    /// @brief Set each element to the max of the current values and the values of another btQuadWord
    /// @param other The other btQuadWord to compare with

    #[link_name = "\u{1}_ZN10btQuadWord6setMaxERKS_"]
    pub fn btQuadWord_setMax(this: *mut btQuadWord, other: *const btQuadWord);
}
extern "C" {

    /// @brief Set each element to the min of the current values and the values of another btQuadWord
    /// @param other The other btQuadWord to compare with

    #[link_name = "\u{1}_ZN10btQuadWord6setMinERKS_"]
    pub fn btQuadWord_setMin(this: *mut btQuadWord, other: *const btQuadWord);
}
extern "C" {

    /// @brief No initialization constructor

    #[link_name = "\u{1}_ZN10btQuadWordC1Ev"]
    pub fn btQuadWord_btQuadWord(this: *mut btQuadWord);
}
extern "C" {

    /// @brief Three argument constructor (zeros w)
    /// @param x Value of x
    /// @param y Value of y
    /// @param z Value of z

    #[link_name = "\u{1}_ZN10btQuadWordC1ERKdS1_S1_"]
    pub fn btQuadWord_btQuadWord1(
        this: *mut btQuadWord,
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
    );
}
extern "C" {

    /// @brief Initializing constructor
    /// @param x Value of x
    /// @param y Value of y
    /// @param z Value of z
    /// @param w Value of w

    #[link_name = "\u{1}_ZN10btQuadWordC1ERKdS1_S1_S1_"]
    pub fn btQuadWord_btQuadWord2(
        this: *mut btQuadWord,
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
        _w: *const btScalar,
    );
}
impl btQuadWord {
    #[inline]
    pub unsafe fn getX(&self) -> *const btScalar {
        btQuadWord_getX(self)
    }
    #[inline]
    pub unsafe fn getY(&self) -> *const btScalar {
        btQuadWord_getY(self)
    }
    #[inline]
    pub unsafe fn getZ(&self) -> *const btScalar {
        btQuadWord_getZ(self)
    }
    #[inline]
    pub unsafe fn setX(&mut self, _x: btScalar) {
        btQuadWord_setX(self, _x)
    }
    #[inline]
    pub unsafe fn setY(&mut self, _y: btScalar) {
        btQuadWord_setY(self, _y)
    }
    #[inline]
    pub unsafe fn setZ(&mut self, _z: btScalar) {
        btQuadWord_setZ(self, _z)
    }
    #[inline]
    pub unsafe fn setW(&mut self, _w: btScalar) {
        btQuadWord_setW(self, _w)
    }
    #[inline]
    pub unsafe fn x(&self) -> *const btScalar {
        btQuadWord_x(self)
    }
    #[inline]
    pub unsafe fn y(&self) -> *const btScalar {
        btQuadWord_y(self)
    }
    #[inline]
    pub unsafe fn z(&self) -> *const btScalar {
        btQuadWord_z(self)
    }
    #[inline]
    pub unsafe fn w(&self) -> *const btScalar {
        btQuadWord_w(self)
    }
    #[inline]
    pub unsafe fn setValue(
        &mut self,
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
    ) {
        btQuadWord_setValue(self, _x, _y, _z)
    }
    #[inline]
    pub unsafe fn setValue1(
        &mut self,
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
        _w: *const btScalar,
    ) {
        btQuadWord_setValue1(self, _x, _y, _z, _w)
    }
    #[inline]
    pub unsafe fn setMax(&mut self, other: *const btQuadWord) {
        btQuadWord_setMax(self, other)
    }
    #[inline]
    pub unsafe fn setMin(&mut self, other: *const btQuadWord) {
        btQuadWord_setMin(self, other)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btQuadWord_btQuadWord(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(_x: *const btScalar, _y: *const btScalar, _z: *const btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btQuadWord_btQuadWord1(&mut __bindgen_tmp, _x, _y, _z);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
        _w: *const btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btQuadWord_btQuadWord2(&mut __bindgen_tmp, _x, _y, _z, _w);
        __bindgen_tmp
    }
}
/// @brief The btQuaternion implements quaternion to perform linear algebra rotations in combination with btMatrix3x3, btVector3 and btTransform.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuaternion {
    pub _base: btQuadWord,
}
#[test]
fn bindgen_test_layout_btQuaternion() {
    assert_eq!(
        ::std::mem::size_of::<btQuaternion>(),
        32usize,
        concat!("Size of: ", stringify!(btQuaternion))
    );
    assert_eq!(
        ::std::mem::align_of::<btQuaternion>(),
        8usize,
        concat!("Alignment of ", stringify!(btQuaternion))
    );
}
extern "C" {

    /// @brief Set the rotation using axis angle notation
    /// @param axis The axis around which to rotate
    /// @param angle The magnitude of the rotation in Radians

    #[link_name = "\u{1}_ZN12btQuaternion11setRotationERK9btVector3RKd"]
    pub fn btQuaternion_setRotation(
        this: *mut btQuaternion,
        axis: *const btVector3,
        _angle: *const btScalar,
    );
}
extern "C" {

    /// @brief Set the quaternion using Euler angles
    /// @param yaw Angle around Y
    /// @param pitch Angle around X
    /// @param roll Angle around Z

    #[link_name = "\u{1}_ZN12btQuaternion8setEulerERKdS1_S1_"]
    pub fn btQuaternion_setEuler(
        this: *mut btQuaternion,
        yaw: *const btScalar,
        pitch: *const btScalar,
        roll: *const btScalar,
    );
}
extern "C" {

    /// @brief Set the quaternion using euler angles
    /// @param yaw Angle around Z
    /// @param pitch Angle around Y
    /// @param roll Angle around X

    #[link_name = "\u{1}_ZN12btQuaternion11setEulerZYXERKdS1_S1_"]
    pub fn btQuaternion_setEulerZYX(
        this: *mut btQuaternion,
        yawZ: *const btScalar,
        pitchY: *const btScalar,
        rollX: *const btScalar,
    );
}
extern "C" {

    /// @brief Get the euler angles from this quaternion
    /// @param yaw Angle around Z
    /// @param pitch Angle around Y
    /// @param roll Angle around X

    #[link_name = "\u{1}_ZNK12btQuaternion11getEulerZYXERdS0_S0_"]
    pub fn btQuaternion_getEulerZYX(
        this: *const btQuaternion,
        yawZ: *mut btScalar,
        pitchY: *mut btScalar,
        rollX: *mut btScalar,
    );
}
extern "C" {

    /// @brief Return the dot product between this quaternion and another
    /// @param q The other quaternion

    #[link_name = "\u{1}_ZNK12btQuaternion3dotERKS_"]
    pub fn btQuaternion_dot(this: *const btQuaternion, q: *const btQuaternion) -> btScalar;
}
extern "C" {

    /// @brief Return the length squared of the quaternion

    #[link_name = "\u{1}_ZNK12btQuaternion7length2Ev"]
    pub fn btQuaternion_length2(this: *const btQuaternion) -> btScalar;
}
extern "C" {

    /// @brief Return the length of the quaternion

    #[link_name = "\u{1}_ZNK12btQuaternion6lengthEv"]
    pub fn btQuaternion_length(this: *const btQuaternion) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btQuaternion13safeNormalizeEv"]
    pub fn btQuaternion_safeNormalize(this: *mut btQuaternion) -> *mut btQuaternion;
}
extern "C" {

    /// @brief Normalize the quaternion
    /// Such that x^2 + y^2 + z^2 +w^2 = 1

    #[link_name = "\u{1}_ZN12btQuaternion9normalizeEv"]
    pub fn btQuaternion_normalize(this: *mut btQuaternion) -> *mut btQuaternion;
}
extern "C" {

    /// @brief Return a normalized version of this quaternion

    #[link_name = "\u{1}_ZNK12btQuaternion10normalizedEv"]
    pub fn btQuaternion_normalized(this: *const btQuaternion) -> btQuaternion;
}
extern "C" {

    /// @brief Return the ***half*** angle between this quaternion and the other
    /// @param q The other quaternion

    #[link_name = "\u{1}_ZNK12btQuaternion5angleERKS_"]
    pub fn btQuaternion_angle(this: *const btQuaternion, q: *const btQuaternion) -> btScalar;
}
extern "C" {

    /// @brief Return the angle between this quaternion and the other along the shortest path
    /// @param q The other quaternion

    #[link_name = "\u{1}_ZNK12btQuaternion17angleShortestPathERKS_"]
    pub fn btQuaternion_angleShortestPath(
        this: *const btQuaternion,
        q: *const btQuaternion,
    ) -> btScalar;
}
extern "C" {

    /// @brief Return the angle [0, 2Pi] of rotation represented by this quaternion

    #[link_name = "\u{1}_ZNK12btQuaternion8getAngleEv"]
    pub fn btQuaternion_getAngle(this: *const btQuaternion) -> btScalar;
}
extern "C" {

    /// @brief Return the angle [0, Pi] of rotation represented by this quaternion along the shortest path

    #[link_name = "\u{1}_ZNK12btQuaternion20getAngleShortestPathEv"]
    pub fn btQuaternion_getAngleShortestPath(this: *const btQuaternion) -> btScalar;
}
extern "C" {

    /// @brief Return the axis of the rotation represented by this quaternion

    #[link_name = "\u{1}_ZNK12btQuaternion7getAxisEv"]
    pub fn btQuaternion_getAxis(this: *const btQuaternion) -> btVector3;
}
extern "C" {

    /// @brief Return the inverse of this quaternion

    #[link_name = "\u{1}_ZNK12btQuaternion7inverseEv"]
    pub fn btQuaternion_inverse(this: *const btQuaternion) -> btQuaternion;
}
extern "C" {

    /// @todo document this and it's use

    #[link_name = "\u{1}_ZNK12btQuaternion8farthestERKS_"]
    pub fn btQuaternion_farthest(
        this: *const btQuaternion,
        qd: *const btQuaternion,
    ) -> btQuaternion;
}
extern "C" {

    /// @todo document this and it's use

    #[link_name = "\u{1}_ZNK12btQuaternion7nearestERKS_"]
    pub fn btQuaternion_nearest(this: *const btQuaternion, qd: *const btQuaternion)
        -> btQuaternion;
}
extern "C" {

    /// @brief Return the quaternion which is the result of Spherical Linear Interpolation between this and the other quaternion
    /// @param q The other quaternion to interpolate with
    /// @param t The ratio between this and q to interpolate.  If t = 0 the result is this, if t=1 the result is q.
    /// Slerp interpolates assuming constant velocity.

    #[link_name = "\u{1}_ZNK12btQuaternion5slerpERKS_RKd"]
    pub fn btQuaternion_slerp(
        this: *const btQuaternion,
        q: *const btQuaternion,
        t: *const btScalar,
    ) -> btQuaternion;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btQuaternion11getIdentityEv"]
    pub fn btQuaternion_getIdentity() -> *const btQuaternion;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btQuaternion4getWEv"]
    pub fn btQuaternion_getW(this: *const btQuaternion) -> *const btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btQuaternion9serializeER22btQuaternionDoubleData"]
    pub fn btQuaternion_serialize(this: *const btQuaternion, dataOut: *mut btQuaternionDoubleData);
}
extern "C" {
    #[link_name = "\u{1}_ZN12btQuaternion11deSerializeERK22btQuaternionDoubleData"]
    pub fn btQuaternion_deSerialize(this: *mut btQuaternion, dataIn: *const btQuaternionDoubleData);
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btQuaternion14serializeFloatER21btQuaternionFloatData"]
    pub fn btQuaternion_serializeFloat(
        this: *const btQuaternion,
        dataOut: *mut btQuaternionFloatData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btQuaternion16deSerializeFloatERK21btQuaternionFloatData"]
    pub fn btQuaternion_deSerializeFloat(
        this: *mut btQuaternion,
        dataIn: *const btQuaternionFloatData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btQuaternion15serializeDoubleER22btQuaternionDoubleData"]
    pub fn btQuaternion_serializeDouble(
        this: *const btQuaternion,
        dataOut: *mut btQuaternionDoubleData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btQuaternion17deSerializeDoubleERK22btQuaternionDoubleData"]
    pub fn btQuaternion_deSerializeDouble(
        this: *mut btQuaternion,
        dataIn: *const btQuaternionDoubleData,
    );
}
extern "C" {

    /// @brief No initialization constructor

    #[link_name = "\u{1}_ZN12btQuaternionC1Ev"]
    pub fn btQuaternion_btQuaternion(this: *mut btQuaternion);
}
extern "C" {

    /// @brief Constructor from scalars

    #[link_name = "\u{1}_ZN12btQuaternionC1ERKdS1_S1_S1_"]
    pub fn btQuaternion_btQuaternion1(
        this: *mut btQuaternion,
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
        _w: *const btScalar,
    );
}
extern "C" {

    /// @brief Axis angle Constructor
    /// @param axis The axis which the rotation is around
    /// @param angle The magnitude of the rotation around the angle (Radians)

    #[link_name = "\u{1}_ZN12btQuaternionC1ERK9btVector3RKd"]
    pub fn btQuaternion_btQuaternion2(
        this: *mut btQuaternion,
        _axis: *const btVector3,
        _angle: *const btScalar,
    );
}
extern "C" {

    /// @brief Constructor from Euler angles
    /// @param yaw Angle around Y unless BT_EULER_DEFAULT_ZYX defined then Z
    /// @param pitch Angle around X unless BT_EULER_DEFAULT_ZYX defined then Y
    /// @param roll Angle around Z unless BT_EULER_DEFAULT_ZYX defined then X

    #[link_name = "\u{1}_ZN12btQuaternionC1ERKdS1_S1_"]
    pub fn btQuaternion_btQuaternion3(
        this: *mut btQuaternion,
        yaw: *const btScalar,
        pitch: *const btScalar,
        roll: *const btScalar,
    );
}
impl btQuaternion {
    #[inline]
    pub unsafe fn setRotation(&mut self, axis: *const btVector3, _angle: *const btScalar) {
        btQuaternion_setRotation(self, axis, _angle)
    }
    #[inline]
    pub unsafe fn setEuler(
        &mut self,
        yaw: *const btScalar,
        pitch: *const btScalar,
        roll: *const btScalar,
    ) {
        btQuaternion_setEuler(self, yaw, pitch, roll)
    }
    #[inline]
    pub unsafe fn setEulerZYX(
        &mut self,
        yawZ: *const btScalar,
        pitchY: *const btScalar,
        rollX: *const btScalar,
    ) {
        btQuaternion_setEulerZYX(self, yawZ, pitchY, rollX)
    }
    #[inline]
    pub unsafe fn getEulerZYX(
        &self,
        yawZ: *mut btScalar,
        pitchY: *mut btScalar,
        rollX: *mut btScalar,
    ) {
        btQuaternion_getEulerZYX(self, yawZ, pitchY, rollX)
    }
    #[inline]
    pub unsafe fn dot(&self, q: *const btQuaternion) -> btScalar {
        btQuaternion_dot(self, q)
    }
    #[inline]
    pub unsafe fn length2(&self) -> btScalar {
        btQuaternion_length2(self)
    }
    #[inline]
    pub unsafe fn length(&self) -> btScalar {
        btQuaternion_length(self)
    }
    #[inline]
    pub unsafe fn safeNormalize(&mut self) -> *mut btQuaternion {
        btQuaternion_safeNormalize(self)
    }
    #[inline]
    pub unsafe fn normalize(&mut self) -> *mut btQuaternion {
        btQuaternion_normalize(self)
    }
    #[inline]
    pub unsafe fn normalized(&self) -> btQuaternion {
        btQuaternion_normalized(self)
    }
    #[inline]
    pub unsafe fn angle(&self, q: *const btQuaternion) -> btScalar {
        btQuaternion_angle(self, q)
    }
    #[inline]
    pub unsafe fn angleShortestPath(&self, q: *const btQuaternion) -> btScalar {
        btQuaternion_angleShortestPath(self, q)
    }
    #[inline]
    pub unsafe fn getAngle(&self) -> btScalar {
        btQuaternion_getAngle(self)
    }
    #[inline]
    pub unsafe fn getAngleShortestPath(&self) -> btScalar {
        btQuaternion_getAngleShortestPath(self)
    }
    #[inline]
    pub unsafe fn getAxis(&self) -> btVector3 {
        btQuaternion_getAxis(self)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> btQuaternion {
        btQuaternion_inverse(self)
    }
    #[inline]
    pub unsafe fn farthest(&self, qd: *const btQuaternion) -> btQuaternion {
        btQuaternion_farthest(self, qd)
    }
    #[inline]
    pub unsafe fn nearest(&self, qd: *const btQuaternion) -> btQuaternion {
        btQuaternion_nearest(self, qd)
    }
    #[inline]
    pub unsafe fn slerp(&self, q: *const btQuaternion, t: *const btScalar) -> btQuaternion {
        btQuaternion_slerp(self, q, t)
    }
    #[inline]
    pub unsafe fn getIdentity() -> *const btQuaternion {
        btQuaternion_getIdentity()
    }
    #[inline]
    pub unsafe fn getW(&self) -> *const btScalar {
        btQuaternion_getW(self)
    }
    #[inline]
    pub unsafe fn serialize(&self, dataOut: *mut btQuaternionDoubleData) {
        btQuaternion_serialize(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerialize(&mut self, dataIn: *const btQuaternionDoubleData) {
        btQuaternion_deSerialize(self, dataIn)
    }
    #[inline]
    pub unsafe fn serializeFloat(&self, dataOut: *mut btQuaternionFloatData) {
        btQuaternion_serializeFloat(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerializeFloat(&mut self, dataIn: *const btQuaternionFloatData) {
        btQuaternion_deSerializeFloat(self, dataIn)
    }
    #[inline]
    pub unsafe fn serializeDouble(&self, dataOut: *mut btQuaternionDoubleData) {
        btQuaternion_serializeDouble(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerializeDouble(&mut self, dataIn: *const btQuaternionDoubleData) {
        btQuaternion_deSerializeDouble(self, dataIn)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btQuaternion_btQuaternion(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        _x: *const btScalar,
        _y: *const btScalar,
        _z: *const btScalar,
        _w: *const btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btQuaternion_btQuaternion1(&mut __bindgen_tmp, _x, _y, _z, _w);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(_axis: *const btVector3, _angle: *const btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btQuaternion_btQuaternion2(&mut __bindgen_tmp, _axis, _angle);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(
        yaw: *const btScalar,
        pitch: *const btScalar,
        roll: *const btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btQuaternion_btQuaternion3(&mut __bindgen_tmp, yaw, pitch, roll);
        __bindgen_tmp
    }
}
extern "C" {

    /// @brief Calculate the dot product between two quaternions

    #[link_name = "\u{1}_Z3dotRK12btQuaternionS1_"]
    pub fn dot(q1: *const btQuaternion, q2: *const btQuaternion) -> btScalar;
}
extern "C" {

    /// @brief Return the length of a quaternion

    #[link_name = "\u{1}_Z6lengthRK12btQuaternion"]
    pub fn length(q: *const btQuaternion) -> btScalar;
}
extern "C" {

    /// @brief Return the angle between two quaternions

    #[link_name = "\u{1}_Z7btAngleRK12btQuaternionS1_"]
    pub fn btAngle1(q1: *const btQuaternion, q2: *const btQuaternion) -> btScalar;
}
extern "C" {

    /// @brief Return the inverse of a quaternion

    #[link_name = "\u{1}_Z7inverseRK12btQuaternion"]
    pub fn inverse(q: *const btQuaternion) -> btQuaternion;
}
extern "C" {

    /// @brief Return the result of spherical linear interpolation betwen two quaternions
    /// @param q1 The first quaternion
    /// @param q2 The second quaternion
    /// @param t The ration between q1 and q2.  t = 0 return q1, t=1 returns q2
    /// Slerp assumes constant velocity between positions.

    #[link_name = "\u{1}_Z5slerpRK12btQuaternionS1_RKd"]
    pub fn slerp(
        q1: *const btQuaternion,
        q2: *const btQuaternion,
        t: *const btScalar,
    ) -> btQuaternion;
}
extern "C" {
    #[link_name = "\u{1}_Z10quatRotateRK12btQuaternionRK9btVector3"]
    pub fn quatRotate(rotation: *const btQuaternion, v: *const btVector3) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_Z15shortestArcQuatRK9btVector3S1_"]
    pub fn shortestArcQuat(v0: *const btVector3, v1: *const btVector3) -> btQuaternion;
}
extern "C" {
    #[link_name = "\u{1}_Z25shortestArcQuatNormalize2R9btVector3S0_"]
    pub fn shortestArcQuatNormalize2(v0: *mut btVector3, v1: *mut btVector3) -> btQuaternion;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuaternionFloatData {
    pub m_floats: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_btQuaternionFloatData() {
    assert_eq!(
        ::std::mem::size_of::<btQuaternionFloatData>(),
        16usize,
        concat!("Size of: ", stringify!(btQuaternionFloatData))
    );
    assert_eq!(
        ::std::mem::align_of::<btQuaternionFloatData>(),
        4usize,
        concat!("Alignment of ", stringify!(btQuaternionFloatData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuaternionFloatData)).m_floats as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuaternionFloatData),
            "::",
            stringify!(m_floats)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuaternionDoubleData {
    pub m_floats: [f64; 4usize],
}
#[test]
fn bindgen_test_layout_btQuaternionDoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btQuaternionDoubleData>(),
        32usize,
        concat!("Size of: ", stringify!(btQuaternionDoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btQuaternionDoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btQuaternionDoubleData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuaternionDoubleData)).m_floats as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuaternionDoubleData),
            "::",
            stringify!(m_floats)
        )
    );
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __mbstate_t__bindgen_ty_1)).__wch as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __mbstate_t__bindgen_ty_1)).__wchb as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __mbstate_t)).__count as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __mbstate_t)).__value as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const _G_fpos_t)).__pos as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _G_fpos_t)).__state as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const _G_fpos64_t)).__pos as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _G_fpos64_t)).__state as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_marker))._next as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_marker))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_marker))._pos as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._flags as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._markers as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._chain as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._lock as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._offset as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE)).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE)).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE)).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE)).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE)).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._mode as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_FILE))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
pub type cookie_read_function_t = __io_read_fn;
pub type cookie_write_function_t = __io_write_fn;
pub type cookie_seek_function_t = __io_seek_fn;
pub type cookie_close_function_t = __io_close_fn;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: __io_read_fn,
    pub write: __io_write_fn,
    pub seek: __io_seek_fn,
    pub close: __io_close_fn,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_cookie_io_functions_t)).read as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_cookie_io_functions_t)).write as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_cookie_io_functions_t)).seek as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const _IO_cookie_io_functions_t)).close as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_file {
    _unused: [u8; 0],
}
extern "C" {
    pub fn _IO_cookie_init(
        __cfile: *mut _IO_cookie_file,
        __read_write: ::std::os::raw::c_int,
        __cookie: *mut ::std::os::raw::c_void,
        __fns: _IO_cookie_io_functions_t,
    );
}
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type fpos_t = _G_fpos_t;
pub type fpos64_t = _G_fpos64_t;
extern "C" {
    #[link_name = "\u{1}stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: _IO_cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gets(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgets_unlocked(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fputs_unlocked(
        __s: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko64(
        __stream: *mut FILE,
        __off: __off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
}
extern "C" {
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos64(__stream: *mut FILE, __pos: *const fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_sys_nerr"]
    pub static mut _sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sys_errlist"]
    pub static mut _sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cuserid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
extern "C" {
    pub fn obstack_printf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obstack_vprintf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        __args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
/// @brief The btMatrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with btQuaternion, btTransform and btVector3.
/// Make sure to only include a pure orthogonal matrix without scaling.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMatrix3x3 {
    /// Data storage for the matrix, each vector is a row of the matrix
    pub m_el: [btVector3; 3usize],
}
#[test]
fn bindgen_test_layout_btMatrix3x3() {
    assert_eq!(
        ::std::mem::size_of::<btMatrix3x3>(),
        96usize,
        concat!("Size of: ", stringify!(btMatrix3x3))
    );
    assert_eq!(
        ::std::mem::align_of::<btMatrix3x3>(),
        8usize,
        concat!("Alignment of ", stringify!(btMatrix3x3))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btMatrix3x3)).m_el as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMatrix3x3),
            "::",
            stringify!(m_el)
        )
    );
}
extern "C" {

    /// @brief Get a column of the matrix as a vector
    /// @param i Column number 0 indexed

    #[link_name = "\u{1}_ZNK11btMatrix3x39getColumnEi"]
    pub fn btMatrix3x3_getColumn(this: *const btMatrix3x3, i: ::std::os::raw::c_int) -> btVector3;
}
extern "C" {

    /// @brief Get a row of the matrix as a vector
    /// @param i Row number 0 indexed

    #[link_name = "\u{1}_ZNK11btMatrix3x36getRowEi"]
    pub fn btMatrix3x3_getRow(
        this: *const btMatrix3x3,
        i: ::std::os::raw::c_int,
    ) -> *const btVector3;
}
extern "C" {

    /// @brief Set from the rotational part of a 4x4 OpenGL matrix
    /// @param m A pointer to the beginning of the array of scalars

    #[link_name = "\u{1}_ZN11btMatrix3x322setFromOpenGLSubMatrixEPKd"]
    pub fn btMatrix3x3_setFromOpenGLSubMatrix(this: *mut btMatrix3x3, m: *const btScalar);
}
extern "C" {

    /// @brief Set the values of the matrix explicitly (row major)
    /// @param xx Top left
    /// @param xy Top Middle
    /// @param xz Top Right
    /// @param yx Middle Left
    /// @param yy Middle Middle
    /// @param yz Middle Right
    /// @param zx Bottom Left
    /// @param zy Bottom Middle
    /// @param zz Bottom Right

    #[link_name = "\u{1}_ZN11btMatrix3x38setValueERKdS1_S1_S1_S1_S1_S1_S1_S1_"]
    pub fn btMatrix3x3_setValue(
        this: *mut btMatrix3x3,
        xx: *const btScalar,
        xy: *const btScalar,
        xz: *const btScalar,
        yx: *const btScalar,
        yy: *const btScalar,
        yz: *const btScalar,
        zx: *const btScalar,
        zy: *const btScalar,
        zz: *const btScalar,
    );
}
extern "C" {

    /// @brief Set the matrix from a quaternion
    /// @param q The Quaternion to match

    #[link_name = "\u{1}_ZN11btMatrix3x311setRotationERK12btQuaternion"]
    pub fn btMatrix3x3_setRotation(this: *mut btMatrix3x3, q: *const btQuaternion);
}
extern "C" {

    /// @brief Set the matrix from euler angles using YPR around YXZ respectively
    /// @param yaw Yaw about Y axis
    /// @param pitch Pitch about X axis
    /// @param roll Roll about Z axis

    #[link_name = "\u{1}_ZN11btMatrix3x311setEulerYPRERKdS1_S1_"]
    pub fn btMatrix3x3_setEulerYPR(
        this: *mut btMatrix3x3,
        yaw: *const btScalar,
        pitch: *const btScalar,
        roll: *const btScalar,
    );
}
extern "C" {

    /// @brief Set the matrix from euler angles YPR around ZYX axes
    /// @param eulerX Roll about X axis
    /// @param eulerY Pitch around Y axis
    /// @param eulerZ Yaw aboud Z axis
    ///
    /// These angles are used to produce a rotation matrix. The euler
    /// angles are applied in ZYX order. I.e a vector is first rotated
    /// about X then Y and then Z

    #[link_name = "\u{1}_ZN11btMatrix3x311setEulerZYXEddd"]
    pub fn btMatrix3x3_setEulerZYX(
        this: *mut btMatrix3x3,
        eulerX: btScalar,
        eulerY: btScalar,
        eulerZ: btScalar,
    );
}
extern "C" {

    /// @brief Set the matrix to the identity

    #[link_name = "\u{1}_ZN11btMatrix3x311setIdentityEv"]
    pub fn btMatrix3x3_setIdentity(this: *mut btMatrix3x3);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btMatrix3x311getIdentityEv"]
    pub fn btMatrix3x3_getIdentity() -> *const btMatrix3x3;
}
extern "C" {

    /// @brief Fill the rotational part of an OpenGL matrix and clear the shear/perspective
    /// @param m The array to be filled

    #[link_name = "\u{1}_ZNK11btMatrix3x318getOpenGLSubMatrixEPd"]
    pub fn btMatrix3x3_getOpenGLSubMatrix(this: *const btMatrix3x3, m: *mut btScalar);
}
extern "C" {

    /// @brief Get the matrix represented as a quaternion
    /// @param q The quaternion which will be set

    #[link_name = "\u{1}_ZNK11btMatrix3x311getRotationER12btQuaternion"]
    pub fn btMatrix3x3_getRotation(this: *const btMatrix3x3, q: *mut btQuaternion);
}
extern "C" {

    /// @brief Get the matrix represented as euler angles around YXZ, roundtrip with setEulerYPR
    /// @param yaw Yaw around Y axis
    /// @param pitch Pitch around X axis
    /// @param roll around Z axis

    #[link_name = "\u{1}_ZNK11btMatrix3x311getEulerYPRERdS0_S0_"]
    pub fn btMatrix3x3_getEulerYPR(
        this: *const btMatrix3x3,
        yaw: *mut btScalar,
        pitch: *mut btScalar,
        roll: *mut btScalar,
    );
}
extern "C" {

    /// @brief Get the matrix represented as euler angles around ZYX
    /// @param yaw Yaw around X axis
    /// @param pitch Pitch around Y axis
    /// @param roll around X axis
    /// @param solution_number Which solution of two possible solutions ( 1 or 2) are possible values

    #[link_name = "\u{1}_ZNK11btMatrix3x311getEulerZYXERdS0_S0_j"]
    pub fn btMatrix3x3_getEulerZYX(
        this: *const btMatrix3x3,
        yaw: *mut btScalar,
        pitch: *mut btScalar,
        roll: *mut btScalar,
        solution_number: ::std::os::raw::c_uint,
    );
}
extern "C" {

    /// @brief Create a scaled copy of the matrix
    /// @param s Scaling vector The elements of the vector will scale each column

    #[link_name = "\u{1}_ZNK11btMatrix3x36scaledERK9btVector3"]
    pub fn btMatrix3x3_scaled(this: *const btMatrix3x3, s: *const btVector3) -> btMatrix3x3;
}
extern "C" {

    /// @brief Return the determinant of the matrix

    #[link_name = "\u{1}_ZNK11btMatrix3x311determinantEv"]
    pub fn btMatrix3x3_determinant(this: *const btMatrix3x3) -> btScalar;
}
extern "C" {

    /// @brief Return the adjoint of the matrix

    #[link_name = "\u{1}_ZNK11btMatrix3x37adjointEv"]
    pub fn btMatrix3x3_adjoint(this: *const btMatrix3x3) -> btMatrix3x3;
}
extern "C" {

    /// @brief Return the matrix with all values non negative

    #[link_name = "\u{1}_ZNK11btMatrix3x38absoluteEv"]
    pub fn btMatrix3x3_absolute(this: *const btMatrix3x3) -> btMatrix3x3;
}
extern "C" {

    /// @brief Return the transpose of the matrix

    #[link_name = "\u{1}_ZNK11btMatrix3x39transposeEv"]
    pub fn btMatrix3x3_transpose(this: *const btMatrix3x3) -> btMatrix3x3;
}
extern "C" {

    /// @brief Return the inverse of the matrix

    #[link_name = "\u{1}_ZNK11btMatrix3x37inverseEv"]
    pub fn btMatrix3x3_inverse(this: *const btMatrix3x3) -> btMatrix3x3;
}
extern "C" {

    /// Solve A * x = b, where b is a column vector. This is more efficient
    /// /// than computing the inverse in one-shot cases.
    /// ///Solve33 is from Box2d, thanks to Erin Catto,

    #[link_name = "\u{1}_ZNK11btMatrix3x37solve33ERK9btVector3"]
    pub fn btMatrix3x3_solve33(this: *const btMatrix3x3, b: *const btVector3) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btMatrix3x314transposeTimesERKS_"]
    pub fn btMatrix3x3_transposeTimes(
        this: *const btMatrix3x3,
        m: *const btMatrix3x3,
    ) -> btMatrix3x3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btMatrix3x314timesTransposeERKS_"]
    pub fn btMatrix3x3_timesTranspose(
        this: *const btMatrix3x3,
        m: *const btMatrix3x3,
    ) -> btMatrix3x3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btMatrix3x35tdotxERK9btVector3"]
    pub fn btMatrix3x3_tdotx(this: *const btMatrix3x3, v: *const btVector3) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btMatrix3x35tdotyERK9btVector3"]
    pub fn btMatrix3x3_tdoty(this: *const btMatrix3x3, v: *const btVector3) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btMatrix3x35tdotzERK9btVector3"]
    pub fn btMatrix3x3_tdotz(this: *const btMatrix3x3, v: *const btVector3) -> btScalar;
}
extern "C" {

    /// extractRotation is from "A robust method to extract the rotational part of deformations"
    /// ///See http://dl.acm.org/citation.cfm?doid=2994258.2994269

    #[link_name = "\u{1}_ZN11btMatrix3x315extractRotationER12btQuaterniondi"]
    pub fn btMatrix3x3_extractRotation(
        this: *mut btMatrix3x3,
        q: *mut btQuaternion,
        tolerance: btScalar,
        maxIter: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// @brief diagonalizes this matrix
    /// @param rot stores the rotation from the coordinate system in which the matrix is diagonal to the original
    /// coordinate system, i.e., old_this = rot * new_this * rot^T.
    /// @param threshold See iteration
    /// @param maxIter The iteration stops when we hit the given tolerance or when maxIter have been executed.

    #[link_name = "\u{1}_ZN11btMatrix3x311diagonalizeERS_di"]
    pub fn btMatrix3x3_diagonalize(
        this: *mut btMatrix3x3,
        rot: *mut btMatrix3x3,
        tolerance: btScalar,
        maxIter: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// @brief Calculate the matrix cofactor
    /// @param r1 The first row to use for calculating the cofactor
    /// @param c1 The first column to use for calculating the cofactor
    /// @param r1 The second row to use for calculating the cofactor
    /// @param c1 The second column to use for calculating the cofactor
    /// See http://en.wikipedia.org/wiki/Cofactor_(linear_algebra) for more details

    #[link_name = "\u{1}_ZNK11btMatrix3x35cofacEiiii"]
    pub fn btMatrix3x3_cofac(
        this: *const btMatrix3x3,
        r1: ::std::os::raw::c_int,
        c1: ::std::os::raw::c_int,
        r2: ::std::os::raw::c_int,
        c2: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btMatrix3x39serializeER21btMatrix3x3DoubleData"]
    pub fn btMatrix3x3_serialize(this: *const btMatrix3x3, dataOut: *mut btMatrix3x3DoubleData);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btMatrix3x314serializeFloatER20btMatrix3x3FloatData"]
    pub fn btMatrix3x3_serializeFloat(this: *const btMatrix3x3, dataOut: *mut btMatrix3x3FloatData);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btMatrix3x311deSerializeERK21btMatrix3x3DoubleData"]
    pub fn btMatrix3x3_deSerialize(this: *mut btMatrix3x3, dataIn: *const btMatrix3x3DoubleData);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btMatrix3x316deSerializeFloatERK20btMatrix3x3FloatData"]
    pub fn btMatrix3x3_deSerializeFloat(
        this: *mut btMatrix3x3,
        dataIn: *const btMatrix3x3FloatData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11btMatrix3x317deSerializeDoubleERK21btMatrix3x3DoubleData"]
    pub fn btMatrix3x3_deSerializeDouble(
        this: *mut btMatrix3x3,
        dataIn: *const btMatrix3x3DoubleData,
    );
}
extern "C" {

    /// @brief No initializaion constructor

    #[link_name = "\u{1}_ZN11btMatrix3x3C1Ev"]
    pub fn btMatrix3x3_btMatrix3x3(this: *mut btMatrix3x3);
}
extern "C" {

    /// @brief Constructor from Quaternion

    #[link_name = "\u{1}_ZN11btMatrix3x3C1ERK12btQuaternion"]
    pub fn btMatrix3x3_btMatrix3x31(this: *mut btMatrix3x3, q: *const btQuaternion);
}
extern "C" {

    /// @brief Constructor with row major formatting

    #[link_name = "\u{1}_ZN11btMatrix3x3C1ERKdS1_S1_S1_S1_S1_S1_S1_S1_"]
    pub fn btMatrix3x3_btMatrix3x32(
        this: *mut btMatrix3x3,
        xx: *const btScalar,
        xy: *const btScalar,
        xz: *const btScalar,
        yx: *const btScalar,
        yy: *const btScalar,
        yz: *const btScalar,
        zx: *const btScalar,
        zy: *const btScalar,
        zz: *const btScalar,
    );
}
extern "C" {

    /// @brief Copy constructor

    #[link_name = "\u{1}_ZN11btMatrix3x3C1ERKS_"]
    pub fn btMatrix3x3_btMatrix3x33(this: *mut btMatrix3x3, other: *const btMatrix3x3);
}
impl btMatrix3x3 {
    #[inline]
    pub unsafe fn getColumn(&self, i: ::std::os::raw::c_int) -> btVector3 {
        btMatrix3x3_getColumn(self, i)
    }
    #[inline]
    pub unsafe fn getRow(&self, i: ::std::os::raw::c_int) -> *const btVector3 {
        btMatrix3x3_getRow(self, i)
    }
    #[inline]
    pub unsafe fn setFromOpenGLSubMatrix(&mut self, m: *const btScalar) {
        btMatrix3x3_setFromOpenGLSubMatrix(self, m)
    }
    #[inline]
    pub unsafe fn setValue(
        &mut self,
        xx: *const btScalar,
        xy: *const btScalar,
        xz: *const btScalar,
        yx: *const btScalar,
        yy: *const btScalar,
        yz: *const btScalar,
        zx: *const btScalar,
        zy: *const btScalar,
        zz: *const btScalar,
    ) {
        btMatrix3x3_setValue(self, xx, xy, xz, yx, yy, yz, zx, zy, zz)
    }
    #[inline]
    pub unsafe fn setRotation(&mut self, q: *const btQuaternion) {
        btMatrix3x3_setRotation(self, q)
    }
    #[inline]
    pub unsafe fn setEulerYPR(
        &mut self,
        yaw: *const btScalar,
        pitch: *const btScalar,
        roll: *const btScalar,
    ) {
        btMatrix3x3_setEulerYPR(self, yaw, pitch, roll)
    }
    #[inline]
    pub unsafe fn setEulerZYX(&mut self, eulerX: btScalar, eulerY: btScalar, eulerZ: btScalar) {
        btMatrix3x3_setEulerZYX(self, eulerX, eulerY, eulerZ)
    }
    #[inline]
    pub unsafe fn setIdentity(&mut self) {
        btMatrix3x3_setIdentity(self)
    }
    #[inline]
    pub unsafe fn getIdentity() -> *const btMatrix3x3 {
        btMatrix3x3_getIdentity()
    }
    #[inline]
    pub unsafe fn getOpenGLSubMatrix(&self, m: *mut btScalar) {
        btMatrix3x3_getOpenGLSubMatrix(self, m)
    }
    #[inline]
    pub unsafe fn getRotation(&self, q: *mut btQuaternion) {
        btMatrix3x3_getRotation(self, q)
    }
    #[inline]
    pub unsafe fn getEulerYPR(
        &self,
        yaw: *mut btScalar,
        pitch: *mut btScalar,
        roll: *mut btScalar,
    ) {
        btMatrix3x3_getEulerYPR(self, yaw, pitch, roll)
    }
    #[inline]
    pub unsafe fn getEulerZYX(
        &self,
        yaw: *mut btScalar,
        pitch: *mut btScalar,
        roll: *mut btScalar,
        solution_number: ::std::os::raw::c_uint,
    ) {
        btMatrix3x3_getEulerZYX(self, yaw, pitch, roll, solution_number)
    }
    #[inline]
    pub unsafe fn scaled(&self, s: *const btVector3) -> btMatrix3x3 {
        btMatrix3x3_scaled(self, s)
    }
    #[inline]
    pub unsafe fn determinant(&self) -> btScalar {
        btMatrix3x3_determinant(self)
    }
    #[inline]
    pub unsafe fn adjoint(&self) -> btMatrix3x3 {
        btMatrix3x3_adjoint(self)
    }
    #[inline]
    pub unsafe fn absolute(&self) -> btMatrix3x3 {
        btMatrix3x3_absolute(self)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> btMatrix3x3 {
        btMatrix3x3_transpose(self)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> btMatrix3x3 {
        btMatrix3x3_inverse(self)
    }
    #[inline]
    pub unsafe fn solve33(&self, b: *const btVector3) -> btVector3 {
        btMatrix3x3_solve33(self, b)
    }
    #[inline]
    pub unsafe fn transposeTimes(&self, m: *const btMatrix3x3) -> btMatrix3x3 {
        btMatrix3x3_transposeTimes(self, m)
    }
    #[inline]
    pub unsafe fn timesTranspose(&self, m: *const btMatrix3x3) -> btMatrix3x3 {
        btMatrix3x3_timesTranspose(self, m)
    }
    #[inline]
    pub unsafe fn tdotx(&self, v: *const btVector3) -> btScalar {
        btMatrix3x3_tdotx(self, v)
    }
    #[inline]
    pub unsafe fn tdoty(&self, v: *const btVector3) -> btScalar {
        btMatrix3x3_tdoty(self, v)
    }
    #[inline]
    pub unsafe fn tdotz(&self, v: *const btVector3) -> btScalar {
        btMatrix3x3_tdotz(self, v)
    }
    #[inline]
    pub unsafe fn extractRotation(
        &mut self,
        q: *mut btQuaternion,
        tolerance: btScalar,
        maxIter: ::std::os::raw::c_int,
    ) {
        btMatrix3x3_extractRotation(self, q, tolerance, maxIter)
    }
    #[inline]
    pub unsafe fn diagonalize(
        &mut self,
        rot: *mut btMatrix3x3,
        tolerance: btScalar,
        maxIter: ::std::os::raw::c_int,
    ) {
        btMatrix3x3_diagonalize(self, rot, tolerance, maxIter)
    }
    #[inline]
    pub unsafe fn cofac(
        &self,
        r1: ::std::os::raw::c_int,
        c1: ::std::os::raw::c_int,
        r2: ::std::os::raw::c_int,
        c2: ::std::os::raw::c_int,
    ) -> btScalar {
        btMatrix3x3_cofac(self, r1, c1, r2, c2)
    }
    #[inline]
    pub unsafe fn serialize(&self, dataOut: *mut btMatrix3x3DoubleData) {
        btMatrix3x3_serialize(self, dataOut)
    }
    #[inline]
    pub unsafe fn serializeFloat(&self, dataOut: *mut btMatrix3x3FloatData) {
        btMatrix3x3_serializeFloat(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerialize(&mut self, dataIn: *const btMatrix3x3DoubleData) {
        btMatrix3x3_deSerialize(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeFloat(&mut self, dataIn: *const btMatrix3x3FloatData) {
        btMatrix3x3_deSerializeFloat(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeDouble(&mut self, dataIn: *const btMatrix3x3DoubleData) {
        btMatrix3x3_deSerializeDouble(self, dataIn)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMatrix3x3_btMatrix3x3(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(q: *const btQuaternion) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMatrix3x3_btMatrix3x31(&mut __bindgen_tmp, q);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(
        xx: *const btScalar,
        xy: *const btScalar,
        xz: *const btScalar,
        yx: *const btScalar,
        yy: *const btScalar,
        yz: *const btScalar,
        zx: *const btScalar,
        zy: *const btScalar,
        zz: *const btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMatrix3x3_btMatrix3x32(&mut __bindgen_tmp, xx, xy, xz, yx, yy, yz, zx, zy, zz);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(other: *const btMatrix3x3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMatrix3x3_btMatrix3x33(&mut __bindgen_tmp, other);
        __bindgen_tmp
    }
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMatrix3x3FloatData {
    pub m_el: [btVector3FloatData; 3usize],
}
#[test]
fn bindgen_test_layout_btMatrix3x3FloatData() {
    assert_eq!(
        ::std::mem::size_of::<btMatrix3x3FloatData>(),
        48usize,
        concat!("Size of: ", stringify!(btMatrix3x3FloatData))
    );
    assert_eq!(
        ::std::mem::align_of::<btMatrix3x3FloatData>(),
        4usize,
        concat!("Alignment of ", stringify!(btMatrix3x3FloatData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btMatrix3x3FloatData)).m_el as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMatrix3x3FloatData),
            "::",
            stringify!(m_el)
        )
    );
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMatrix3x3DoubleData {
    pub m_el: [btVector3DoubleData; 3usize],
}
#[test]
fn bindgen_test_layout_btMatrix3x3DoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btMatrix3x3DoubleData>(),
        96usize,
        concat!("Size of: ", stringify!(btMatrix3x3DoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btMatrix3x3DoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btMatrix3x3DoubleData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btMatrix3x3DoubleData)).m_el as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMatrix3x3DoubleData),
            "::",
            stringify!(m_el)
        )
    );
}
/// @brief The btTransform class supports rigid transforms with only translation and rotation and no scaling/shear.
/// It can be used in combination with btVector3, btQuaternion and btMatrix3x3 linear algebra classes.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTransform {
    /// Storage for the rotation
    pub m_basis: btMatrix3x3,
    /// Storage for the translation
    pub m_origin: btVector3,
}
#[test]
fn bindgen_test_layout_btTransform() {
    assert_eq!(
        ::std::mem::size_of::<btTransform>(),
        128usize,
        concat!("Size of: ", stringify!(btTransform))
    );
    assert_eq!(
        ::std::mem::align_of::<btTransform>(),
        8usize,
        concat!("Alignment of ", stringify!(btTransform))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTransform)).m_basis as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTransform),
            "::",
            stringify!(m_basis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTransform)).m_origin as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTransform),
            "::",
            stringify!(m_origin)
        )
    );
}
extern "C" {

    /// @brief Set the current transform as the value of the product of two transforms
    /// @param t1 Transform 1
    /// @param t2 Transform 2
    /// This = Transform1 * Transform2

    #[link_name = "\u{1}_ZN11btTransform4multERKS_S1_"]
    pub fn btTransform_mult(this: *mut btTransform, t1: *const btTransform, t2: *const btTransform);
}
extern "C" {

    /// @brief Return the basis matrix for the rotation

    #[link_name = "\u{1}_ZN11btTransform8getBasisEv"]
    pub fn btTransform_getBasis(this: *mut btTransform) -> *mut btMatrix3x3;
}
extern "C" {

    /// @brief Return the basis matrix for the rotation

    #[link_name = "\u{1}_ZNK11btTransform8getBasisEv"]
    pub fn btTransform_getBasis1(this: *const btTransform) -> *const btMatrix3x3;
}
extern "C" {

    /// @brief Return the origin vector translation

    #[link_name = "\u{1}_ZN11btTransform9getOriginEv"]
    pub fn btTransform_getOrigin(this: *mut btTransform) -> *mut btVector3;
}
extern "C" {

    /// @brief Return the origin vector translation

    #[link_name = "\u{1}_ZNK11btTransform9getOriginEv"]
    pub fn btTransform_getOrigin1(this: *const btTransform) -> *const btVector3;
}
extern "C" {

    /// @brief Return a quaternion representing the rotation

    #[link_name = "\u{1}_ZNK11btTransform11getRotationEv"]
    pub fn btTransform_getRotation(this: *const btTransform) -> btQuaternion;
}
extern "C" {

    /// @brief Set from an array
    /// @param m A pointer to a 16 element array (12 rotation(row major padded on the right by 1), and 3 translation

    #[link_name = "\u{1}_ZN11btTransform19setFromOpenGLMatrixEPKd"]
    pub fn btTransform_setFromOpenGLMatrix(this: *mut btTransform, m: *const btScalar);
}
extern "C" {

    /// @brief Fill an array representation
    /// @param m A pointer to a 16 element array (12 rotation(row major padded on the right by 1), and 3 translation

    #[link_name = "\u{1}_ZNK11btTransform15getOpenGLMatrixEPd"]
    pub fn btTransform_getOpenGLMatrix(this: *const btTransform, m: *mut btScalar);
}
extern "C" {

    /// @brief Set the translational element
    /// @param origin The vector to set the translation to

    #[link_name = "\u{1}_ZN11btTransform9setOriginERK9btVector3"]
    pub fn btTransform_setOrigin(this: *mut btTransform, origin: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btTransform8invXformERK9btVector3"]
    pub fn btTransform_invXform(this: *const btTransform, inVec: *const btVector3) -> btVector3;
}
extern "C" {

    /// @brief Set the rotational element by btMatrix3x3

    #[link_name = "\u{1}_ZN11btTransform8setBasisERK11btMatrix3x3"]
    pub fn btTransform_setBasis(this: *mut btTransform, basis: *const btMatrix3x3);
}
extern "C" {

    /// @brief Set the rotational element by btQuaternion

    #[link_name = "\u{1}_ZN11btTransform11setRotationERK12btQuaternion"]
    pub fn btTransform_setRotation(this: *mut btTransform, q: *const btQuaternion);
}
extern "C" {

    /// @brief Set this transformation to the identity

    #[link_name = "\u{1}_ZN11btTransform11setIdentityEv"]
    pub fn btTransform_setIdentity(this: *mut btTransform);
}
extern "C" {

    /// @brief Return the inverse of this transform

    #[link_name = "\u{1}_ZNK11btTransform7inverseEv"]
    pub fn btTransform_inverse(this: *const btTransform) -> btTransform;
}
extern "C" {

    /// @brief Return the inverse of this transform times the other transform
    /// @param t The other transform
    /// return this.inverse() * the other

    #[link_name = "\u{1}_ZNK11btTransform12inverseTimesERKS_"]
    pub fn btTransform_inverseTimes(this: *const btTransform, t: *const btTransform)
        -> btTransform;
}
extern "C" {

    /// @brief Return an identity transform

    #[link_name = "\u{1}_ZN11btTransform11getIdentityEv"]
    pub fn btTransform_getIdentity() -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btTransform9serializeER21btTransformDoubleData"]
    pub fn btTransform_serialize(this: *const btTransform, dataOut: *mut btTransformDoubleData);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btTransform14serializeFloatER20btTransformFloatData"]
    pub fn btTransform_serializeFloat(this: *const btTransform, dataOut: *mut btTransformFloatData);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btTransform11deSerializeERK21btTransformDoubleData"]
    pub fn btTransform_deSerialize(this: *mut btTransform, dataIn: *const btTransformDoubleData);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btTransform17deSerializeDoubleERK21btTransformDoubleData"]
    pub fn btTransform_deSerializeDouble(
        this: *mut btTransform,
        dataIn: *const btTransformDoubleData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11btTransform16deSerializeFloatERK20btTransformFloatData"]
    pub fn btTransform_deSerializeFloat(
        this: *mut btTransform,
        dataIn: *const btTransformFloatData,
    );
}
extern "C" {

    /// @brief No initialization constructor

    #[link_name = "\u{1}_ZN11btTransformC1Ev"]
    pub fn btTransform_btTransform(this: *mut btTransform);
}
extern "C" {

    /// @brief Constructor from btQuaternion (optional btVector3 )
    /// @param q Rotation from quaternion
    /// @param c Translation from Vector (default 0,0,0)

    #[link_name = "\u{1}_ZN11btTransformC1ERK12btQuaternionRK9btVector3"]
    pub fn btTransform_btTransform1(
        this: *mut btTransform,
        q: *const btQuaternion,
        c: *const btVector3,
    );
}
extern "C" {

    /// @brief Constructor from btMatrix3x3 (optional btVector3)
    /// @param b Rotation from Matrix
    /// @param c Translation from Vector default (0,0,0)

    #[link_name = "\u{1}_ZN11btTransformC1ERK11btMatrix3x3RK9btVector3"]
    pub fn btTransform_btTransform2(
        this: *mut btTransform,
        b: *const btMatrix3x3,
        c: *const btVector3,
    );
}
extern "C" {

    /// @brief Copy constructor

    #[link_name = "\u{1}_ZN11btTransformC1ERKS_"]
    pub fn btTransform_btTransform3(this: *mut btTransform, other: *const btTransform);
}
impl btTransform {
    #[inline]
    pub unsafe fn mult(&mut self, t1: *const btTransform, t2: *const btTransform) {
        btTransform_mult(self, t1, t2)
    }
    #[inline]
    pub unsafe fn getBasis(&mut self) -> *mut btMatrix3x3 {
        btTransform_getBasis(self)
    }
    #[inline]
    pub unsafe fn getBasis1(&self) -> *const btMatrix3x3 {
        btTransform_getBasis1(self)
    }
    #[inline]
    pub unsafe fn getOrigin(&mut self) -> *mut btVector3 {
        btTransform_getOrigin(self)
    }
    #[inline]
    pub unsafe fn getOrigin1(&self) -> *const btVector3 {
        btTransform_getOrigin1(self)
    }
    #[inline]
    pub unsafe fn getRotation(&self) -> btQuaternion {
        btTransform_getRotation(self)
    }
    #[inline]
    pub unsafe fn setFromOpenGLMatrix(&mut self, m: *const btScalar) {
        btTransform_setFromOpenGLMatrix(self, m)
    }
    #[inline]
    pub unsafe fn getOpenGLMatrix(&self, m: *mut btScalar) {
        btTransform_getOpenGLMatrix(self, m)
    }
    #[inline]
    pub unsafe fn setOrigin(&mut self, origin: *const btVector3) {
        btTransform_setOrigin(self, origin)
    }
    #[inline]
    pub unsafe fn invXform(&self, inVec: *const btVector3) -> btVector3 {
        btTransform_invXform(self, inVec)
    }
    #[inline]
    pub unsafe fn setBasis(&mut self, basis: *const btMatrix3x3) {
        btTransform_setBasis(self, basis)
    }
    #[inline]
    pub unsafe fn setRotation(&mut self, q: *const btQuaternion) {
        btTransform_setRotation(self, q)
    }
    #[inline]
    pub unsafe fn setIdentity(&mut self) {
        btTransform_setIdentity(self)
    }
    #[inline]
    pub unsafe fn inverse(&self) -> btTransform {
        btTransform_inverse(self)
    }
    #[inline]
    pub unsafe fn inverseTimes(&self, t: *const btTransform) -> btTransform {
        btTransform_inverseTimes(self, t)
    }
    #[inline]
    pub unsafe fn getIdentity() -> *const btTransform {
        btTransform_getIdentity()
    }
    #[inline]
    pub unsafe fn serialize(&self, dataOut: *mut btTransformDoubleData) {
        btTransform_serialize(self, dataOut)
    }
    #[inline]
    pub unsafe fn serializeFloat(&self, dataOut: *mut btTransformFloatData) {
        btTransform_serializeFloat(self, dataOut)
    }
    #[inline]
    pub unsafe fn deSerialize(&mut self, dataIn: *const btTransformDoubleData) {
        btTransform_deSerialize(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeDouble(&mut self, dataIn: *const btTransformDoubleData) {
        btTransform_deSerializeDouble(self, dataIn)
    }
    #[inline]
    pub unsafe fn deSerializeFloat(&mut self, dataIn: *const btTransformFloatData) {
        btTransform_deSerializeFloat(self, dataIn)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTransform_btTransform(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(q: *const btQuaternion, c: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTransform_btTransform1(&mut __bindgen_tmp, q, c);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(b: *const btMatrix3x3, c: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTransform_btTransform2(&mut __bindgen_tmp, b, c);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(other: *const btTransform) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTransform_btTransform3(&mut __bindgen_tmp, other);
        __bindgen_tmp
    }
}
/// for serialization
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTransformFloatData {
    pub m_basis: btMatrix3x3FloatData,
    pub m_origin: btVector3FloatData,
}
#[test]
fn bindgen_test_layout_btTransformFloatData() {
    assert_eq!(
        ::std::mem::size_of::<btTransformFloatData>(),
        64usize,
        concat!("Size of: ", stringify!(btTransformFloatData))
    );
    assert_eq!(
        ::std::mem::align_of::<btTransformFloatData>(),
        4usize,
        concat!("Alignment of ", stringify!(btTransformFloatData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTransformFloatData)).m_basis as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTransformFloatData),
            "::",
            stringify!(m_basis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTransformFloatData)).m_origin as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTransformFloatData),
            "::",
            stringify!(m_origin)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTransformDoubleData {
    pub m_basis: btMatrix3x3DoubleData,
    pub m_origin: btVector3DoubleData,
}
#[test]
fn bindgen_test_layout_btTransformDoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btTransformDoubleData>(),
        128usize,
        concat!("Size of: ", stringify!(btTransformDoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btTransformDoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btTransformDoubleData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTransformDoubleData)).m_basis as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTransformDoubleData),
            "::",
            stringify!(m_basis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTransformDoubleData)).m_origin as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTransformDoubleData),
            "::",
            stringify!(m_origin)
        )
    );
}
#[repr(C)]
pub struct btMotionState__bindgen_vtable(::std::os::raw::c_void);
/// The btMotionState interface class allows the dynamics world to synchronize and interpolate the updated world transforms with graphics
/// For optimizations, potentially only moving objects get synchronized (using setWorldPosition/setWorldOrientation)
#[repr(C)]
#[derive(Debug)]
pub struct btMotionState {
    pub vtable_: *const btMotionState__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btMotionState() {
    assert_eq!(
        ::std::mem::size_of::<btMotionState>(),
        8usize,
        concat!("Size of: ", stringify!(btMotionState))
    );
    assert_eq!(
        ::std::mem::align_of::<btMotionState>(),
        8usize,
        concat!("Alignment of ", stringify!(btMotionState))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13btMotionStateD1Ev"]
    pub fn btMotionState_btMotionState_destructor(this: *mut btMotionState);
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btMotionState17getWorldTransformER11btTransform"]
    pub fn btMotionState_getWorldTransform(
        this: *mut ::std::os::raw::c_void,
        worldTrans: *mut btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13btMotionState17setWorldTransformERK11btTransform"]
    pub fn btMotionState_setWorldTransform(
        this: *mut ::std::os::raw::c_void,
        worldTrans: *const btTransform,
    );
}
/// The btAlignedObjectArray template class uses a subset of the stl::vector interface for its methods
/// It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data
#[repr(C)]
#[derive(Debug)]
pub struct btAlignedObjectArray<T> {
    pub m_allocator: u8,
    pub m_size: ::std::os::raw::c_int,
    pub m_capacity: ::std::os::raw::c_int,
    pub m_data: *mut T,
    pub m_ownsMemory: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btAlignedObjectArray_less {
    pub _address: u8,
}
pub type btCollisionObjectArray = btAlignedObjectArray<*mut btCollisionObject>;
#[repr(C)]
pub struct btCollisionObject__bindgen_vtable(::std::os::raw::c_void);
/// btCollisionObject can be used to manage collision detection objects.
/// btCollisionObject maintains all information that is needed for a collision detection: Shape, Transform and AABB proxy.
/// They can be added to the btCollisionWorld.
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionObject {
    pub vtable_: *const btCollisionObject__bindgen_vtable,
    pub m_worldTransform: btTransform,
    /// m_interpolationWorldTransform is used for CCD and interpolation
    /// ///it can be either previous or future (predicted) transform
    pub m_interpolationWorldTransform: btTransform,
    pub m_interpolationLinearVelocity: btVector3,
    pub m_interpolationAngularVelocity: btVector3,
    pub m_anisotropicFriction: btVector3,
    pub m_hasAnisotropicFriction: ::std::os::raw::c_int,
    pub m_contactProcessingThreshold: btScalar,
    pub m_broadphaseHandle: *mut btBroadphaseProxy,
    pub m_collisionShape: *mut btCollisionShape,
    /// m_extensionPointer is used by some internal low-level Bullet extensions.
    pub m_extensionPointer: *mut ::std::os::raw::c_void,
    /// m_rootCollisionShape is temporarily used to store the original collision shape
    /// ///The m_collisionShape might be temporarily replaced by a child collision shape during collision detection purposes
    /// ///If it is NULL, the m_collisionShape is not temporarily replaced.
    pub m_rootCollisionShape: *mut btCollisionShape,
    pub m_collisionFlags: ::std::os::raw::c_int,
    pub m_islandTag1: ::std::os::raw::c_int,
    pub m_companionId: ::std::os::raw::c_int,
    pub m_worldArrayIndex: ::std::os::raw::c_int,
    pub m_activationState1: ::std::os::raw::c_int,
    pub m_deactivationTime: btScalar,
    pub m_friction: btScalar,
    pub m_restitution: btScalar,
    pub m_rollingFriction: btScalar,
    pub m_spinningFriction: btScalar,
    pub m_contactDamping: btScalar,
    pub m_contactStiffness: btScalar,
    /// m_internalType is reserved to distinguish Bullet's btCollisionObject, btRigidBody, btSoftBody, btGhostObject etc.
    /// ///do not assign your own m_internalType unless you write a new dynamics object class.
    pub m_internalType: ::std::os::raw::c_int,
    /// users can point to their objects, m_userPointer is not used by Bullet, see setUserPointer/getUserPointer
    pub m_userObjectPointer: *mut ::std::os::raw::c_void,
    pub m_userIndex2: ::std::os::raw::c_int,
    pub m_userIndex: ::std::os::raw::c_int,
    /// time of impact calculation
    pub m_hitFraction: btScalar,
    /// Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
    pub m_ccdSweptSphereRadius: btScalar,
    /// Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold
    pub m_ccdMotionThreshold: btScalar,
    /// If some object should have elaborate collision filtering by sub-classes
    pub m_checkCollideWith: ::std::os::raw::c_int,
    pub m_objectsWithoutCollisionCheck: btAlignedObjectArray<*const btCollisionObject>,
    /// internal update revision number. It will be increased when the object changes. This allows some subsystems to perform lazy evaluation.
    pub m_updateRevision: ::std::os::raw::c_int,
    pub m_customDebugColorRGB: btVector3,
}
pub const btCollisionObject_CollisionFlags_CF_STATIC_OBJECT: btCollisionObject_CollisionFlags = 1;
pub const btCollisionObject_CollisionFlags_CF_KINEMATIC_OBJECT: btCollisionObject_CollisionFlags =
    2;
pub const btCollisionObject_CollisionFlags_CF_NO_CONTACT_RESPONSE : btCollisionObject_CollisionFlags = 4 ;
pub const btCollisionObject_CollisionFlags_CF_CUSTOM_MATERIAL_CALLBACK : btCollisionObject_CollisionFlags = 8 ;
pub const btCollisionObject_CollisionFlags_CF_CHARACTER_OBJECT: btCollisionObject_CollisionFlags =
    16;
pub const btCollisionObject_CollisionFlags_CF_DISABLE_VISUALIZE_OBJECT : btCollisionObject_CollisionFlags = 32 ;
pub const btCollisionObject_CollisionFlags_CF_DISABLE_SPU_COLLISION_PROCESSING : btCollisionObject_CollisionFlags = 64 ;
pub const btCollisionObject_CollisionFlags_CF_HAS_CONTACT_STIFFNESS_DAMPING : btCollisionObject_CollisionFlags = 128 ;
pub const btCollisionObject_CollisionFlags_CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR : btCollisionObject_CollisionFlags = 256 ;
pub const btCollisionObject_CollisionFlags_CF_HAS_FRICTION_ANCHOR : btCollisionObject_CollisionFlags = 512 ;
pub const btCollisionObject_CollisionFlags_CF_HAS_COLLISION_SOUND_TRIGGER : btCollisionObject_CollisionFlags = 1024 ;
pub type btCollisionObject_CollisionFlags = ::std::os::raw::c_uint;
pub const btCollisionObject_CollisionObjectTypes_CO_COLLISION_OBJECT : btCollisionObject_CollisionObjectTypes = 1 ;
pub const btCollisionObject_CollisionObjectTypes_CO_RIGID_BODY : btCollisionObject_CollisionObjectTypes = 2 ;
pub const btCollisionObject_CollisionObjectTypes_CO_GHOST_OBJECT : btCollisionObject_CollisionObjectTypes = 4 ;
pub const btCollisionObject_CollisionObjectTypes_CO_SOFT_BODY : btCollisionObject_CollisionObjectTypes = 8 ;
pub const btCollisionObject_CollisionObjectTypes_CO_HF_FLUID : btCollisionObject_CollisionObjectTypes = 16 ;
pub const btCollisionObject_CollisionObjectTypes_CO_USER_TYPE : btCollisionObject_CollisionObjectTypes = 32 ;
pub const btCollisionObject_CollisionObjectTypes_CO_FEATHERSTONE_LINK : btCollisionObject_CollisionObjectTypes = 64 ;
pub type btCollisionObject_CollisionObjectTypes = ::std::os::raw::c_uint;
pub const btCollisionObject_AnisotropicFrictionFlags_CF_ANISOTROPIC_FRICTION_DISABLED : btCollisionObject_AnisotropicFrictionFlags = 0 ;
pub const btCollisionObject_AnisotropicFrictionFlags_CF_ANISOTROPIC_FRICTION : btCollisionObject_AnisotropicFrictionFlags = 1 ;
pub const btCollisionObject_AnisotropicFrictionFlags_CF_ANISOTROPIC_ROLLING_FRICTION : btCollisionObject_AnisotropicFrictionFlags = 2 ;
pub type btCollisionObject_AnisotropicFrictionFlags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_btCollisionObject() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionObject>(),
        616usize,
        concat!("Size of: ", stringify!(btCollisionObject))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionObject>(),
        8usize,
        concat!("Alignment of ", stringify!(btCollisionObject))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_worldTransform as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_worldTransform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObject)).m_interpolationWorldTransform as *const _ as usize
        },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_interpolationWorldTransform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObject)).m_interpolationLinearVelocity as *const _ as usize
        },
        264usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_interpolationLinearVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObject)).m_interpolationAngularVelocity as *const _ as usize
        },
        296usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_interpolationAngularVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_anisotropicFriction as *const _ as usize },
        328usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_anisotropicFriction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObject)).m_hasAnisotropicFriction as *const _ as usize
        },
        360usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_hasAnisotropicFriction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObject)).m_contactProcessingThreshold as *const _ as usize
        },
        368usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_contactProcessingThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_broadphaseHandle as *const _ as usize },
        376usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_broadphaseHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_collisionShape as *const _ as usize },
        384usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_collisionShape)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_extensionPointer as *const _ as usize },
        392usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_extensionPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_rootCollisionShape as *const _ as usize },
        400usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_rootCollisionShape)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_collisionFlags as *const _ as usize },
        408usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_collisionFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_islandTag1 as *const _ as usize },
        412usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_islandTag1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_companionId as *const _ as usize },
        416usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_companionId)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_worldArrayIndex as *const _ as usize },
        420usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_worldArrayIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_activationState1 as *const _ as usize },
        424usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_activationState1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_deactivationTime as *const _ as usize },
        432usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_deactivationTime)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_friction as *const _ as usize },
        440usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_friction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_restitution as *const _ as usize },
        448usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_restitution)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_rollingFriction as *const _ as usize },
        456usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_rollingFriction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_spinningFriction as *const _ as usize },
        464usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_spinningFriction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_contactDamping as *const _ as usize },
        472usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_contactDamping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_contactStiffness as *const _ as usize },
        480usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_contactStiffness)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_internalType as *const _ as usize },
        488usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_internalType)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_userObjectPointer as *const _ as usize },
        496usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_userObjectPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_userIndex2 as *const _ as usize },
        504usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_userIndex2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_userIndex as *const _ as usize },
        508usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_userIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_hitFraction as *const _ as usize },
        512usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_hitFraction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_ccdSweptSphereRadius as *const _ as usize },
        520usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_ccdSweptSphereRadius)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_ccdMotionThreshold as *const _ as usize },
        528usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_ccdMotionThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_checkCollideWith as *const _ as usize },
        536usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_checkCollideWith)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObject)).m_objectsWithoutCollisionCheck as *const _ as usize
        },
        544usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_objectsWithoutCollisionCheck)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_updateRevision as *const _ as usize },
        576usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_updateRevision)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObject)).m_customDebugColorRGB as *const _ as usize },
        584usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObject),
            "::",
            stringify!(m_customDebugColorRGB)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject23mergesSimulationIslandsEv"]
    pub fn btCollisionObject_mergesSimulationIslands(this: *const btCollisionObject) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject22getAnisotropicFrictionEv"]
    pub fn btCollisionObject_getAnisotropicFriction(
        this: *const btCollisionObject,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject22setAnisotropicFrictionERK9btVector3i"]
    pub fn btCollisionObject_setAnisotropicFriction(
        this: *mut btCollisionObject,
        anisotropicFriction: *const btVector3,
        frictionMode: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject22hasAnisotropicFrictionEi"]
    pub fn btCollisionObject_hasAnisotropicFriction(
        this: *const btCollisionObject,
        frictionMode: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {

    /// the constraint solver can discard solving contacts, if the distance is above this threshold. 0 by default.
    /// ///Note that using contacts with positive distance can improve stability. It increases, however, the chance of colliding with degerate contacts, such as 'interior' triangle edges

    #[link_name = "\u{1}_ZN17btCollisionObject29setContactProcessingThresholdEd"]
    pub fn btCollisionObject_setContactProcessingThreshold(
        this: *mut btCollisionObject,
        contactProcessingThreshold: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject29getContactProcessingThresholdEv"]
    pub fn btCollisionObject_getContactProcessingThreshold(
        this: *const btCollisionObject,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject14isStaticObjectEv"]
    pub fn btCollisionObject_isStaticObject(this: *const btCollisionObject) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject17isKinematicObjectEv"]
    pub fn btCollisionObject_isKinematicObject(this: *const btCollisionObject) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject25isStaticOrKinematicObjectEv"]
    pub fn btCollisionObject_isStaticOrKinematicObject(this: *const btCollisionObject) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject18hasContactResponseEv"]
    pub fn btCollisionObject_hasContactResponse(this: *const btCollisionObject) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject17getCollisionShapeEv"]
    pub fn btCollisionObject_getCollisionShape(
        this: *const btCollisionObject,
    ) -> *const btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject17getCollisionShapeEv"]
    pub fn btCollisionObject_getCollisionShape1(
        this: *mut btCollisionObject,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject23setIgnoreCollisionCheckEPKS_b"]
    pub fn btCollisionObject_setIgnoreCollisionCheck(
        this: *mut btCollisionObject,
        co: *const btCollisionObject,
        ignoreCollisionCheck: bool,
    );
}
extern "C" {

    /// Avoid using this internal API call, the extension pointer is used by some Bullet extensions.
    /// ///If you need to store your own user pointer, use 'setUserPointer/getUserPointer' instead.

    #[link_name = "\u{1}_ZNK17btCollisionObject27internalGetExtensionPointerEv"]
    pub fn btCollisionObject_internalGetExtensionPointer(
        this: *const btCollisionObject,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {

    /// Avoid using this internal API call, the extension pointer is used by some Bullet extensions
    /// ///If you need to store your own user pointer, use 'setUserPointer/getUserPointer' instead.

    #[link_name = "\u{1}_ZN17btCollisionObject27internalSetExtensionPointerEPv"]
    pub fn btCollisionObject_internalSetExtensionPointer(
        this: *mut btCollisionObject,
        pointer: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject18getActivationStateEv"]
    pub fn btCollisionObject_getActivationState(
        this: *const btCollisionObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject18setActivationStateEi"]
    pub fn btCollisionObject_setActivationState(
        this: *const btCollisionObject,
        newState: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject19setDeactivationTimeEd"]
    pub fn btCollisionObject_setDeactivationTime(this: *mut btCollisionObject, time: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject19getDeactivationTimeEv"]
    pub fn btCollisionObject_getDeactivationTime(this: *const btCollisionObject) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject20forceActivationStateEi"]
    pub fn btCollisionObject_forceActivationState(
        this: *const btCollisionObject,
        newState: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject8activateEb"]
    pub fn btCollisionObject_activate(this: *const btCollisionObject, forceActivation: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject8isActiveEv"]
    pub fn btCollisionObject_isActive(this: *const btCollisionObject) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject14setRestitutionEd"]
    pub fn btCollisionObject_setRestitution(this: *mut btCollisionObject, rest: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject14getRestitutionEv"]
    pub fn btCollisionObject_getRestitution(this: *const btCollisionObject) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject11setFrictionEd"]
    pub fn btCollisionObject_setFriction(this: *mut btCollisionObject, frict: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject11getFrictionEv"]
    pub fn btCollisionObject_getFriction(this: *const btCollisionObject) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject18setRollingFrictionEd"]
    pub fn btCollisionObject_setRollingFriction(this: *mut btCollisionObject, frict: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject18getRollingFrictionEv"]
    pub fn btCollisionObject_getRollingFriction(this: *const btCollisionObject) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject19setSpinningFrictionEd"]
    pub fn btCollisionObject_setSpinningFriction(this: *mut btCollisionObject, frict: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject19getSpinningFrictionEv"]
    pub fn btCollisionObject_getSpinningFriction(this: *const btCollisionObject) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject29setContactStiffnessAndDampingEdd"]
    pub fn btCollisionObject_setContactStiffnessAndDamping(
        this: *mut btCollisionObject,
        stiffness: btScalar,
        damping: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject19getContactStiffnessEv"]
    pub fn btCollisionObject_getContactStiffness(this: *const btCollisionObject) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject17getContactDampingEv"]
    pub fn btCollisionObject_getContactDamping(this: *const btCollisionObject) -> btScalar;
}
extern "C" {

    /// reserved for Bullet internal usage

    #[link_name = "\u{1}_ZNK17btCollisionObject15getInternalTypeEv"]
    pub fn btCollisionObject_getInternalType(
        this: *const btCollisionObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject17getWorldTransformEv"]
    pub fn btCollisionObject_getWorldTransform(this: *mut btCollisionObject) -> *mut btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject17getWorldTransformEv"]
    pub fn btCollisionObject_getWorldTransform1(
        this: *const btCollisionObject,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject17setWorldTransformERK11btTransform"]
    pub fn btCollisionObject_setWorldTransform(
        this: *mut btCollisionObject,
        worldTrans: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject19getBroadphaseHandleEv"]
    pub fn btCollisionObject_getBroadphaseHandle(
        this: *mut btCollisionObject,
    ) -> *mut btBroadphaseProxy;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject19getBroadphaseHandleEv"]
    pub fn btCollisionObject_getBroadphaseHandle1(
        this: *const btCollisionObject,
    ) -> *const btBroadphaseProxy;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject19setBroadphaseHandleEP17btBroadphaseProxy"]
    pub fn btCollisionObject_setBroadphaseHandle(
        this: *mut btCollisionObject,
        handle: *mut btBroadphaseProxy,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject30getInterpolationWorldTransformEv"]
    pub fn btCollisionObject_getInterpolationWorldTransform(
        this: *const btCollisionObject,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject30getInterpolationWorldTransformEv"]
    pub fn btCollisionObject_getInterpolationWorldTransform1(
        this: *mut btCollisionObject,
    ) -> *mut btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject30setInterpolationWorldTransformERK11btTransform"]
    pub fn btCollisionObject_setInterpolationWorldTransform(
        this: *mut btCollisionObject,
        trans: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject30setInterpolationLinearVelocityERK9btVector3"]
    pub fn btCollisionObject_setInterpolationLinearVelocity(
        this: *mut btCollisionObject,
        linvel: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject31setInterpolationAngularVelocityERK9btVector3"]
    pub fn btCollisionObject_setInterpolationAngularVelocity(
        this: *mut btCollisionObject,
        angvel: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject30getInterpolationLinearVelocityEv"]
    pub fn btCollisionObject_getInterpolationLinearVelocity(
        this: *const btCollisionObject,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject31getInterpolationAngularVelocityEv"]
    pub fn btCollisionObject_getInterpolationAngularVelocity(
        this: *const btCollisionObject,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject12getIslandTagEv"]
    pub fn btCollisionObject_getIslandTag(this: *const btCollisionObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject12setIslandTagEi"]
    pub fn btCollisionObject_setIslandTag(this: *mut btCollisionObject, tag: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject14getCompanionIdEv"]
    pub fn btCollisionObject_getCompanionId(
        this: *const btCollisionObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject14setCompanionIdEi"]
    pub fn btCollisionObject_setCompanionId(
        this: *mut btCollisionObject,
        id: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject18getWorldArrayIndexEv"]
    pub fn btCollisionObject_getWorldArrayIndex(
        this: *const btCollisionObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject18setWorldArrayIndexEi"]
    pub fn btCollisionObject_setWorldArrayIndex(
        this: *mut btCollisionObject,
        ix: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject14getHitFractionEv"]
    pub fn btCollisionObject_getHitFraction(this: *const btCollisionObject) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject14setHitFractionEd"]
    pub fn btCollisionObject_setHitFraction(this: *mut btCollisionObject, hitFraction: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject17getCollisionFlagsEv"]
    pub fn btCollisionObject_getCollisionFlags(
        this: *const btCollisionObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject17setCollisionFlagsEi"]
    pub fn btCollisionObject_setCollisionFlags(
        this: *mut btCollisionObject,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::

    #[link_name = "\u{1}_ZNK17btCollisionObject23getCcdSweptSphereRadiusEv"]
    pub fn btCollisionObject_getCcdSweptSphereRadius(this: *const btCollisionObject) -> btScalar;
}
extern "C" {

    /// Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::

    #[link_name = "\u{1}_ZN17btCollisionObject23setCcdSweptSphereRadiusEd"]
    pub fn btCollisionObject_setCcdSweptSphereRadius(
        this: *mut btCollisionObject,
        radius: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject21getCcdMotionThresholdEv"]
    pub fn btCollisionObject_getCcdMotionThreshold(this: *const btCollisionObject) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject27getCcdSquareMotionThresholdEv"]
    pub fn btCollisionObject_getCcdSquareMotionThreshold(
        this: *const btCollisionObject,
    ) -> btScalar;
}
extern "C" {

    /// Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold

    #[link_name = "\u{1}_ZN17btCollisionObject21setCcdMotionThresholdEd"]
    pub fn btCollisionObject_setCcdMotionThreshold(
        this: *mut btCollisionObject,
        ccdMotionThreshold: btScalar,
    );
}
extern "C" {

    /// users can point to their objects, userPointer is not used by Bullet

    #[link_name = "\u{1}_ZNK17btCollisionObject14getUserPointerEv"]
    pub fn btCollisionObject_getUserPointer(
        this: *const btCollisionObject,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject12getUserIndexEv"]
    pub fn btCollisionObject_getUserIndex(this: *const btCollisionObject) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject13getUserIndex2Ev"]
    pub fn btCollisionObject_getUserIndex2(this: *const btCollisionObject)
        -> ::std::os::raw::c_int;
}
extern "C" {

    /// users can point to their objects, userPointer is not used by Bullet

    #[link_name = "\u{1}_ZN17btCollisionObject14setUserPointerEPv"]
    pub fn btCollisionObject_setUserPointer(
        this: *mut btCollisionObject,
        userPointer: *mut ::std::os::raw::c_void,
    );
}
extern "C" {

    /// users can point to their objects, userPointer is not used by Bullet

    #[link_name = "\u{1}_ZN17btCollisionObject12setUserIndexEi"]
    pub fn btCollisionObject_setUserIndex(
        this: *mut btCollisionObject,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject13setUserIndex2Ei"]
    pub fn btCollisionObject_setUserIndex2(
        this: *mut btCollisionObject,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject25getUpdateRevisionInternalEv"]
    pub fn btCollisionObject_getUpdateRevisionInternal(
        this: *const btCollisionObject,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject19setCustomDebugColorERK9btVector3"]
    pub fn btCollisionObject_setCustomDebugColor(
        this: *mut btCollisionObject,
        colorRGB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject22removeCustomDebugColorEv"]
    pub fn btCollisionObject_removeCustomDebugColor(this: *mut btCollisionObject);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject19getCustomDebugColorER9btVector3"]
    pub fn btCollisionObject_getCustomDebugColor(
        this: *const btCollisionObject,
        colorRGB: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject16checkCollideWithEPKS_"]
    pub fn btCollisionObject_checkCollideWith(
        this: *const btCollisionObject,
        co: *const btCollisionObject,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObjectC1Ev"]
    pub fn btCollisionObject_btCollisionObject(this: *mut btCollisionObject);
}
impl btCollisionObject {
    #[inline]
    pub unsafe fn mergesSimulationIslands(&self) -> bool {
        btCollisionObject_mergesSimulationIslands(self)
    }
    #[inline]
    pub unsafe fn getAnisotropicFriction(&self) -> *const btVector3 {
        btCollisionObject_getAnisotropicFriction(self)
    }
    #[inline]
    pub unsafe fn setAnisotropicFriction(
        &mut self,
        anisotropicFriction: *const btVector3,
        frictionMode: ::std::os::raw::c_int,
    ) {
        btCollisionObject_setAnisotropicFriction(self, anisotropicFriction, frictionMode)
    }
    #[inline]
    pub unsafe fn hasAnisotropicFriction(&self, frictionMode: ::std::os::raw::c_int) -> bool {
        btCollisionObject_hasAnisotropicFriction(self, frictionMode)
    }
    #[inline]
    pub unsafe fn setContactProcessingThreshold(&mut self, contactProcessingThreshold: btScalar) {
        btCollisionObject_setContactProcessingThreshold(self, contactProcessingThreshold)
    }
    #[inline]
    pub unsafe fn getContactProcessingThreshold(&self) -> btScalar {
        btCollisionObject_getContactProcessingThreshold(self)
    }
    #[inline]
    pub unsafe fn isStaticObject(&self) -> bool {
        btCollisionObject_isStaticObject(self)
    }
    #[inline]
    pub unsafe fn isKinematicObject(&self) -> bool {
        btCollisionObject_isKinematicObject(self)
    }
    #[inline]
    pub unsafe fn isStaticOrKinematicObject(&self) -> bool {
        btCollisionObject_isStaticOrKinematicObject(self)
    }
    #[inline]
    pub unsafe fn hasContactResponse(&self) -> bool {
        btCollisionObject_hasContactResponse(self)
    }
    #[inline]
    pub unsafe fn getCollisionShape(&self) -> *const btCollisionShape {
        btCollisionObject_getCollisionShape(self)
    }
    #[inline]
    pub unsafe fn getCollisionShape1(&mut self) -> *mut btCollisionShape {
        btCollisionObject_getCollisionShape1(self)
    }
    #[inline]
    pub unsafe fn setIgnoreCollisionCheck(
        &mut self,
        co: *const btCollisionObject,
        ignoreCollisionCheck: bool,
    ) {
        btCollisionObject_setIgnoreCollisionCheck(self, co, ignoreCollisionCheck)
    }
    #[inline]
    pub unsafe fn internalGetExtensionPointer(&self) -> *mut ::std::os::raw::c_void {
        btCollisionObject_internalGetExtensionPointer(self)
    }
    #[inline]
    pub unsafe fn internalSetExtensionPointer(&mut self, pointer: *mut ::std::os::raw::c_void) {
        btCollisionObject_internalSetExtensionPointer(self, pointer)
    }
    #[inline]
    pub unsafe fn getActivationState(&self) -> ::std::os::raw::c_int {
        btCollisionObject_getActivationState(self)
    }
    #[inline]
    pub unsafe fn setActivationState(&self, newState: ::std::os::raw::c_int) {
        btCollisionObject_setActivationState(self, newState)
    }
    #[inline]
    pub unsafe fn setDeactivationTime(&mut self, time: btScalar) {
        btCollisionObject_setDeactivationTime(self, time)
    }
    #[inline]
    pub unsafe fn getDeactivationTime(&self) -> btScalar {
        btCollisionObject_getDeactivationTime(self)
    }
    #[inline]
    pub unsafe fn forceActivationState(&self, newState: ::std::os::raw::c_int) {
        btCollisionObject_forceActivationState(self, newState)
    }
    #[inline]
    pub unsafe fn activate(&self, forceActivation: bool) {
        btCollisionObject_activate(self, forceActivation)
    }
    #[inline]
    pub unsafe fn isActive(&self) -> bool {
        btCollisionObject_isActive(self)
    }
    #[inline]
    pub unsafe fn setRestitution(&mut self, rest: btScalar) {
        btCollisionObject_setRestitution(self, rest)
    }
    #[inline]
    pub unsafe fn getRestitution(&self) -> btScalar {
        btCollisionObject_getRestitution(self)
    }
    #[inline]
    pub unsafe fn setFriction(&mut self, frict: btScalar) {
        btCollisionObject_setFriction(self, frict)
    }
    #[inline]
    pub unsafe fn getFriction(&self) -> btScalar {
        btCollisionObject_getFriction(self)
    }
    #[inline]
    pub unsafe fn setRollingFriction(&mut self, frict: btScalar) {
        btCollisionObject_setRollingFriction(self, frict)
    }
    #[inline]
    pub unsafe fn getRollingFriction(&self) -> btScalar {
        btCollisionObject_getRollingFriction(self)
    }
    #[inline]
    pub unsafe fn setSpinningFriction(&mut self, frict: btScalar) {
        btCollisionObject_setSpinningFriction(self, frict)
    }
    #[inline]
    pub unsafe fn getSpinningFriction(&self) -> btScalar {
        btCollisionObject_getSpinningFriction(self)
    }
    #[inline]
    pub unsafe fn setContactStiffnessAndDamping(&mut self, stiffness: btScalar, damping: btScalar) {
        btCollisionObject_setContactStiffnessAndDamping(self, stiffness, damping)
    }
    #[inline]
    pub unsafe fn getContactStiffness(&self) -> btScalar {
        btCollisionObject_getContactStiffness(self)
    }
    #[inline]
    pub unsafe fn getContactDamping(&self) -> btScalar {
        btCollisionObject_getContactDamping(self)
    }
    #[inline]
    pub unsafe fn getInternalType(&self) -> ::std::os::raw::c_int {
        btCollisionObject_getInternalType(self)
    }
    #[inline]
    pub unsafe fn getWorldTransform(&mut self) -> *mut btTransform {
        btCollisionObject_getWorldTransform(self)
    }
    #[inline]
    pub unsafe fn getWorldTransform1(&self) -> *const btTransform {
        btCollisionObject_getWorldTransform1(self)
    }
    #[inline]
    pub unsafe fn setWorldTransform(&mut self, worldTrans: *const btTransform) {
        btCollisionObject_setWorldTransform(self, worldTrans)
    }
    #[inline]
    pub unsafe fn getBroadphaseHandle(&mut self) -> *mut btBroadphaseProxy {
        btCollisionObject_getBroadphaseHandle(self)
    }
    #[inline]
    pub unsafe fn getBroadphaseHandle1(&self) -> *const btBroadphaseProxy {
        btCollisionObject_getBroadphaseHandle1(self)
    }
    #[inline]
    pub unsafe fn setBroadphaseHandle(&mut self, handle: *mut btBroadphaseProxy) {
        btCollisionObject_setBroadphaseHandle(self, handle)
    }
    #[inline]
    pub unsafe fn getInterpolationWorldTransform(&self) -> *const btTransform {
        btCollisionObject_getInterpolationWorldTransform(self)
    }
    #[inline]
    pub unsafe fn getInterpolationWorldTransform1(&mut self) -> *mut btTransform {
        btCollisionObject_getInterpolationWorldTransform1(self)
    }
    #[inline]
    pub unsafe fn setInterpolationWorldTransform(&mut self, trans: *const btTransform) {
        btCollisionObject_setInterpolationWorldTransform(self, trans)
    }
    #[inline]
    pub unsafe fn setInterpolationLinearVelocity(&mut self, linvel: *const btVector3) {
        btCollisionObject_setInterpolationLinearVelocity(self, linvel)
    }
    #[inline]
    pub unsafe fn setInterpolationAngularVelocity(&mut self, angvel: *const btVector3) {
        btCollisionObject_setInterpolationAngularVelocity(self, angvel)
    }
    #[inline]
    pub unsafe fn getInterpolationLinearVelocity(&self) -> *const btVector3 {
        btCollisionObject_getInterpolationLinearVelocity(self)
    }
    #[inline]
    pub unsafe fn getInterpolationAngularVelocity(&self) -> *const btVector3 {
        btCollisionObject_getInterpolationAngularVelocity(self)
    }
    #[inline]
    pub unsafe fn getIslandTag(&self) -> ::std::os::raw::c_int {
        btCollisionObject_getIslandTag(self)
    }
    #[inline]
    pub unsafe fn setIslandTag(&mut self, tag: ::std::os::raw::c_int) {
        btCollisionObject_setIslandTag(self, tag)
    }
    #[inline]
    pub unsafe fn getCompanionId(&self) -> ::std::os::raw::c_int {
        btCollisionObject_getCompanionId(self)
    }
    #[inline]
    pub unsafe fn setCompanionId(&mut self, id: ::std::os::raw::c_int) {
        btCollisionObject_setCompanionId(self, id)
    }
    #[inline]
    pub unsafe fn getWorldArrayIndex(&self) -> ::std::os::raw::c_int {
        btCollisionObject_getWorldArrayIndex(self)
    }
    #[inline]
    pub unsafe fn setWorldArrayIndex(&mut self, ix: ::std::os::raw::c_int) {
        btCollisionObject_setWorldArrayIndex(self, ix)
    }
    #[inline]
    pub unsafe fn getHitFraction(&self) -> btScalar {
        btCollisionObject_getHitFraction(self)
    }
    #[inline]
    pub unsafe fn setHitFraction(&mut self, hitFraction: btScalar) {
        btCollisionObject_setHitFraction(self, hitFraction)
    }
    #[inline]
    pub unsafe fn getCollisionFlags(&self) -> ::std::os::raw::c_int {
        btCollisionObject_getCollisionFlags(self)
    }
    #[inline]
    pub unsafe fn setCollisionFlags(&mut self, flags: ::std::os::raw::c_int) {
        btCollisionObject_setCollisionFlags(self, flags)
    }
    #[inline]
    pub unsafe fn getCcdSweptSphereRadius(&self) -> btScalar {
        btCollisionObject_getCcdSweptSphereRadius(self)
    }
    #[inline]
    pub unsafe fn setCcdSweptSphereRadius(&mut self, radius: btScalar) {
        btCollisionObject_setCcdSweptSphereRadius(self, radius)
    }
    #[inline]
    pub unsafe fn getCcdMotionThreshold(&self) -> btScalar {
        btCollisionObject_getCcdMotionThreshold(self)
    }
    #[inline]
    pub unsafe fn getCcdSquareMotionThreshold(&self) -> btScalar {
        btCollisionObject_getCcdSquareMotionThreshold(self)
    }
    #[inline]
    pub unsafe fn setCcdMotionThreshold(&mut self, ccdMotionThreshold: btScalar) {
        btCollisionObject_setCcdMotionThreshold(self, ccdMotionThreshold)
    }
    #[inline]
    pub unsafe fn getUserPointer(&self) -> *mut ::std::os::raw::c_void {
        btCollisionObject_getUserPointer(self)
    }
    #[inline]
    pub unsafe fn getUserIndex(&self) -> ::std::os::raw::c_int {
        btCollisionObject_getUserIndex(self)
    }
    #[inline]
    pub unsafe fn getUserIndex2(&self) -> ::std::os::raw::c_int {
        btCollisionObject_getUserIndex2(self)
    }
    #[inline]
    pub unsafe fn setUserPointer(&mut self, userPointer: *mut ::std::os::raw::c_void) {
        btCollisionObject_setUserPointer(self, userPointer)
    }
    #[inline]
    pub unsafe fn setUserIndex(&mut self, index: ::std::os::raw::c_int) {
        btCollisionObject_setUserIndex(self, index)
    }
    #[inline]
    pub unsafe fn setUserIndex2(&mut self, index: ::std::os::raw::c_int) {
        btCollisionObject_setUserIndex2(self, index)
    }
    #[inline]
    pub unsafe fn getUpdateRevisionInternal(&self) -> ::std::os::raw::c_int {
        btCollisionObject_getUpdateRevisionInternal(self)
    }
    #[inline]
    pub unsafe fn setCustomDebugColor(&mut self, colorRGB: *const btVector3) {
        btCollisionObject_setCustomDebugColor(self, colorRGB)
    }
    #[inline]
    pub unsafe fn removeCustomDebugColor(&mut self) {
        btCollisionObject_removeCustomDebugColor(self)
    }
    #[inline]
    pub unsafe fn getCustomDebugColor(&self, colorRGB: *mut btVector3) -> bool {
        btCollisionObject_getCustomDebugColor(self, colorRGB)
    }
    #[inline]
    pub unsafe fn checkCollideWith(&self, co: *const btCollisionObject) -> bool {
        btCollisionObject_checkCollideWith(self, co)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionObject_btCollisionObject(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObjectD0Ev"]
    pub fn btCollisionObject_btCollisionObject_destructor(this: *mut btCollisionObject);
}
extern "C" {
    #[link_name = "\u{1}_ZN17btCollisionObject17setCollisionShapeEP16btCollisionShape"]
    pub fn btCollisionObject_setCollisionShape(
        this: *mut ::std::os::raw::c_void,
        collisionShape: *mut btCollisionShape,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject24checkCollideWithOverrideEPKS_"]
    pub fn btCollisionObject_checkCollideWithOverride(
        this: *mut ::std::os::raw::c_void,
        co: *const btCollisionObject,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject28calculateSerializeBufferSizeEv"]
    pub fn btCollisionObject_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK17btCollisionObject9serializeEPvP12btSerializer"]
    pub fn btCollisionObject_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btCollisionObject21serializeSingleObjectEP12btSerializer"]
    pub fn btCollisionObject_serializeSingleObject(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionObjectDoubleData {
    pub m_broadphaseHandle: *mut ::std::os::raw::c_void,
    pub m_collisionShape: *mut ::std::os::raw::c_void,
    pub m_rootCollisionShape: *mut btCollisionShapeData,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_worldTransform: btTransformDoubleData,
    pub m_interpolationWorldTransform: btTransformDoubleData,
    pub m_interpolationLinearVelocity: btVector3DoubleData,
    pub m_interpolationAngularVelocity: btVector3DoubleData,
    pub m_anisotropicFriction: btVector3DoubleData,
    pub m_contactProcessingThreshold: f64,
    pub m_deactivationTime: f64,
    pub m_friction: f64,
    pub m_rollingFriction: f64,
    pub m_contactDamping: f64,
    pub m_contactStiffness: f64,
    pub m_restitution: f64,
    pub m_hitFraction: f64,
    pub m_ccdSweptSphereRadius: f64,
    pub m_ccdMotionThreshold: f64,
    pub m_hasAnisotropicFriction: ::std::os::raw::c_int,
    pub m_collisionFlags: ::std::os::raw::c_int,
    pub m_islandTag1: ::std::os::raw::c_int,
    pub m_companionId: ::std::os::raw::c_int,
    pub m_activationState1: ::std::os::raw::c_int,
    pub m_internalType: ::std::os::raw::c_int,
    pub m_checkCollideWith: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btCollisionObjectDoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionObjectDoubleData>(),
        496usize,
        concat!("Size of: ", stringify!(btCollisionObjectDoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionObjectDoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btCollisionObjectDoubleData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_broadphaseHandle as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_broadphaseHandle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_collisionShape as *const _ as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_collisionShape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_rootCollisionShape as *const _ as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_rootCollisionShape)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectDoubleData)).m_name as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_worldTransform as *const _ as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_worldTransform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_interpolationWorldTransform as *const _
                as usize
        },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_interpolationWorldTransform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_interpolationLinearVelocity as *const _
                as usize
        },
        288usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_interpolationLinearVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_interpolationAngularVelocity as *const _
                as usize
        },
        320usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_interpolationAngularVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_anisotropicFriction as *const _ as usize
        },
        352usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_anisotropicFriction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_contactProcessingThreshold as *const _
                as usize
        },
        384usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_contactProcessingThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_deactivationTime as *const _ as usize
        },
        392usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_deactivationTime)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectDoubleData)).m_friction as *const _ as usize },
        400usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_friction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_rollingFriction as *const _ as usize
        },
        408usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_rollingFriction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_contactDamping as *const _ as usize
        },
        416usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_contactDamping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_contactStiffness as *const _ as usize
        },
        424usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_contactStiffness)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectDoubleData)).m_restitution as *const _ as usize },
        432usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_restitution)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectDoubleData)).m_hitFraction as *const _ as usize },
        440usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_hitFraction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_ccdSweptSphereRadius as *const _
                as usize
        },
        448usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_ccdSweptSphereRadius)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_ccdMotionThreshold as *const _ as usize
        },
        456usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_ccdMotionThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_hasAnisotropicFriction as *const _
                as usize
        },
        464usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_hasAnisotropicFriction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_collisionFlags as *const _ as usize
        },
        468usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_collisionFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectDoubleData)).m_islandTag1 as *const _ as usize },
        472usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_islandTag1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectDoubleData)).m_companionId as *const _ as usize },
        476usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_companionId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_activationState1 as *const _ as usize
        },
        480usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_activationState1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_internalType as *const _ as usize
        },
        484usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_internalType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectDoubleData)).m_checkCollideWith as *const _ as usize
        },
        488usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_checkCollideWith)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectDoubleData)).m_padding as *const _ as usize },
        492usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectDoubleData),
            "::",
            stringify!(m_padding)
        )
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionObjectFloatData {
    pub m_broadphaseHandle: *mut ::std::os::raw::c_void,
    pub m_collisionShape: *mut ::std::os::raw::c_void,
    pub m_rootCollisionShape: *mut btCollisionShapeData,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_worldTransform: btTransformFloatData,
    pub m_interpolationWorldTransform: btTransformFloatData,
    pub m_interpolationLinearVelocity: btVector3FloatData,
    pub m_interpolationAngularVelocity: btVector3FloatData,
    pub m_anisotropicFriction: btVector3FloatData,
    pub m_contactProcessingThreshold: f32,
    pub m_deactivationTime: f32,
    pub m_friction: f32,
    pub m_rollingFriction: f32,
    pub m_contactDamping: f32,
    pub m_contactStiffness: f32,
    pub m_restitution: f32,
    pub m_hitFraction: f32,
    pub m_ccdSweptSphereRadius: f32,
    pub m_ccdMotionThreshold: f32,
    pub m_hasAnisotropicFriction: ::std::os::raw::c_int,
    pub m_collisionFlags: ::std::os::raw::c_int,
    pub m_islandTag1: ::std::os::raw::c_int,
    pub m_companionId: ::std::os::raw::c_int,
    pub m_activationState1: ::std::os::raw::c_int,
    pub m_internalType: ::std::os::raw::c_int,
    pub m_checkCollideWith: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btCollisionObjectFloatData() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionObjectFloatData>(),
        280usize,
        concat!("Size of: ", stringify!(btCollisionObjectFloatData))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionObjectFloatData>(),
        8usize,
        concat!("Alignment of ", stringify!(btCollisionObjectFloatData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_broadphaseHandle as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_broadphaseHandle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_collisionShape as *const _ as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_collisionShape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_rootCollisionShape as *const _ as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_rootCollisionShape)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectFloatData)).m_name as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_worldTransform as *const _ as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_worldTransform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_interpolationWorldTransform as *const _
                as usize
        },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_interpolationWorldTransform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_interpolationLinearVelocity as *const _
                as usize
        },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_interpolationLinearVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_interpolationAngularVelocity as *const _
                as usize
        },
        176usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_interpolationAngularVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_anisotropicFriction as *const _ as usize
        },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_anisotropicFriction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_contactProcessingThreshold as *const _
                as usize
        },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_contactProcessingThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_deactivationTime as *const _ as usize
        },
        212usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_deactivationTime)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectFloatData)).m_friction as *const _ as usize },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_friction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_rollingFriction as *const _ as usize
        },
        220usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_rollingFriction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_contactDamping as *const _ as usize
        },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_contactDamping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_contactStiffness as *const _ as usize
        },
        228usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_contactStiffness)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectFloatData)).m_restitution as *const _ as usize },
        232usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_restitution)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectFloatData)).m_hitFraction as *const _ as usize },
        236usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_hitFraction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_ccdSweptSphereRadius as *const _ as usize
        },
        240usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_ccdSweptSphereRadius)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_ccdMotionThreshold as *const _ as usize
        },
        244usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_ccdMotionThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_hasAnisotropicFriction as *const _
                as usize
        },
        248usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_hasAnisotropicFriction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_collisionFlags as *const _ as usize
        },
        252usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_collisionFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectFloatData)).m_islandTag1 as *const _ as usize },
        256usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_islandTag1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectFloatData)).m_companionId as *const _ as usize },
        260usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_companionId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_activationState1 as *const _ as usize
        },
        264usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_activationState1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectFloatData)).m_internalType as *const _ as usize },
        268usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_internalType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectFloatData)).m_checkCollideWith as *const _ as usize
        },
        272usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_checkCollideWith)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectFloatData)).m_padding as *const _ as usize },
        276usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectFloatData),
            "::",
            stringify!(m_padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPoolAllocator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDispatcherInfo {
    pub m_timeStep: btScalar,
    pub m_stepCount: ::std::os::raw::c_int,
    pub m_dispatchFunc: ::std::os::raw::c_int,
    pub m_timeOfImpact: btScalar,
    pub m_useContinuous: bool,
    pub m_debugDraw: *mut btIDebugDraw,
    pub m_enableSatConvex: bool,
    pub m_enableSPU: bool,
    pub m_useEpa: bool,
    pub m_allowedCcdPenetration: btScalar,
    pub m_useConvexConservativeDistanceUtil: bool,
    pub m_convexConservativeDistanceThreshold: btScalar,
}
pub const btDispatcherInfo_DispatchFunc_DISPATCH_DISCRETE: btDispatcherInfo_DispatchFunc = 1;
pub const btDispatcherInfo_DispatchFunc_DISPATCH_CONTINUOUS: btDispatcherInfo_DispatchFunc = 2;
pub type btDispatcherInfo_DispatchFunc = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_btDispatcherInfo() {
    assert_eq!(
        ::std::mem::size_of::<btDispatcherInfo>(),
        72usize,
        concat!("Size of: ", stringify!(btDispatcherInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<btDispatcherInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(btDispatcherInfo))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDispatcherInfo)).m_timeStep as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDispatcherInfo),
            "::",
            stringify!(m_timeStep)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDispatcherInfo)).m_stepCount as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDispatcherInfo),
            "::",
            stringify!(m_stepCount)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDispatcherInfo)).m_dispatchFunc as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDispatcherInfo),
            "::",
            stringify!(m_dispatchFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDispatcherInfo)).m_timeOfImpact as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDispatcherInfo),
            "::",
            stringify!(m_timeOfImpact)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDispatcherInfo)).m_useContinuous as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDispatcherInfo),
            "::",
            stringify!(m_useContinuous)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDispatcherInfo)).m_debugDraw as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDispatcherInfo),
            "::",
            stringify!(m_debugDraw)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDispatcherInfo)).m_enableSatConvex as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDispatcherInfo),
            "::",
            stringify!(m_enableSatConvex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDispatcherInfo)).m_enableSPU as *const _ as usize },
        41usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDispatcherInfo),
            "::",
            stringify!(m_enableSPU)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDispatcherInfo)).m_useEpa as *const _ as usize },
        42usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDispatcherInfo),
            "::",
            stringify!(m_useEpa)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDispatcherInfo)).m_allowedCcdPenetration as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDispatcherInfo),
            "::",
            stringify!(m_allowedCcdPenetration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDispatcherInfo)).m_useConvexConservativeDistanceUtil as *const _
                as usize
        },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDispatcherInfo),
            "::",
            stringify!(m_useConvexConservativeDistanceUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDispatcherInfo)).m_convexConservativeDistanceThreshold as *const _
                as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDispatcherInfo),
            "::",
            stringify!(m_convexConservativeDistanceThreshold)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDispatcherInfoC1Ev"]
    pub fn btDispatcherInfo_btDispatcherInfo(this: *mut btDispatcherInfo);
}
impl btDispatcherInfo {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDispatcherInfo_btDispatcherInfo(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
pub const ebtDispatcherQueryType_BT_CONTACT_POINT_ALGORITHMS: ebtDispatcherQueryType = 1;
pub const ebtDispatcherQueryType_BT_CLOSEST_POINT_ALGORITHMS: ebtDispatcherQueryType = 2;
pub type ebtDispatcherQueryType = ::std::os::raw::c_uint;
#[repr(C)]
pub struct btDispatcher__bindgen_vtable(::std::os::raw::c_void);
/// The btDispatcher interface class can be used in combination with broadphase to dispatch calculations for overlapping pairs.
/// For example for pairwise collision detection, calculating contact points stored in btPersistentManifold or user callbacks (game logic).
#[repr(C)]
#[derive(Debug)]
pub struct btDispatcher {
    pub vtable_: *const btDispatcher__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btDispatcher() {
    assert_eq!(
        ::std::mem::size_of::<btDispatcher>(),
        8usize,
        concat!("Size of: ", stringify!(btDispatcher))
    );
    assert_eq!(
        ::std::mem::align_of::<btDispatcher>(),
        8usize,
        concat!("Alignment of ", stringify!(btDispatcher))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDispatcherD0Ev"]
    pub fn btDispatcher_btDispatcher_destructor(this: *mut btDispatcher);
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDispatcher13findAlgorithmEPK24btCollisionObjectWrapperS2_P20btPersistentManifold22ebtDispatcherQueryType"]
    pub fn btDispatcher_findAlgorithm(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        sharedManifold: *mut btPersistentManifold,
        queryType: ebtDispatcherQueryType,
    ) -> *mut btCollisionAlgorithm;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDispatcher14getNewManifoldEPK17btCollisionObjectS2_"]
    pub fn btDispatcher_getNewManifold(
        this: *mut ::std::os::raw::c_void,
        b0: *const btCollisionObject,
        b1: *const btCollisionObject,
    ) -> *mut btPersistentManifold;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDispatcher15releaseManifoldEP20btPersistentManifold"]
    pub fn btDispatcher_releaseManifold(
        this: *mut ::std::os::raw::c_void,
        manifold: *mut btPersistentManifold,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDispatcher13clearManifoldEP20btPersistentManifold"]
    pub fn btDispatcher_clearManifold(
        this: *mut ::std::os::raw::c_void,
        manifold: *mut btPersistentManifold,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDispatcher14needsCollisionEPK17btCollisionObjectS2_"]
    pub fn btDispatcher_needsCollision(
        this: *mut ::std::os::raw::c_void,
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDispatcher13needsResponseEPK17btCollisionObjectS2_"]
    pub fn btDispatcher_needsResponse(
        this: *mut ::std::os::raw::c_void,
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDispatcher25dispatchAllCollisionPairsEP22btOverlappingPairCacheRK16btDispatcherInfoPS_"]
    pub fn btDispatcher_dispatchAllCollisionPairs(
        this: *mut ::std::os::raw::c_void,
        pairCache: *mut btOverlappingPairCache,
        dispatchInfo: *const btDispatcherInfo,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btDispatcher15getNumManifoldsEv"]
    pub fn btDispatcher_getNumManifolds(this: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDispatcher26getManifoldByIndexInternalEi"]
    pub fn btDispatcher_getManifoldByIndexInternal(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
    ) -> *mut btPersistentManifold;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDispatcher26getInternalManifoldPointerEv"]
    pub fn btDispatcher_getInternalManifoldPointer(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut *mut btPersistentManifold;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDispatcher23getInternalManifoldPoolEv"]
    pub fn btDispatcher_getInternalManifoldPool(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btPoolAllocator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btDispatcher23getInternalManifoldPoolEv"]
    pub fn btDispatcher_getInternalManifoldPool1(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btPoolAllocator;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDispatcher26allocateCollisionAlgorithmEi"]
    pub fn btDispatcher_allocateCollisionAlgorithm(
        this: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDispatcher22freeCollisionAlgorithmEPv"]
    pub fn btDispatcher_freeCollisionAlgorithm(
        this: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z13btAabbSupportRK9btVector3S1_"]
    pub fn btAabbSupport(halfExtents: *const btVector3, supportDir: *const btVector3) -> btVector3;
}
/// Utils related to temporal transforms
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTransformUtil {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_btTransformUtil() {
    assert_eq!(
        ::std::mem::size_of::<btTransformUtil>(),
        1usize,
        concat!("Size of: ", stringify!(btTransformUtil))
    );
    assert_eq!(
        ::std::mem::align_of::<btTransformUtil>(),
        1usize,
        concat!("Alignment of ", stringify!(btTransformUtil))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btTransformUtil18integrateTransformERK11btTransformRK9btVector3S5_dRS0_"]
    pub fn btTransformUtil_integrateTransform(
        curTrans: *const btTransform,
        linvel: *const btVector3,
        angvel: *const btVector3,
        timeStep: btScalar,
        predictedTransform: *mut btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btTransformUtil27calculateVelocityQuaternionERK9btVector3S2_RK12btQuaternionS5_dRS0_S6_"]
    pub fn btTransformUtil_calculateVelocityQuaternion(
        pos0: *const btVector3,
        pos1: *const btVector3,
        orn0: *const btQuaternion,
        orn1: *const btQuaternion,
        timeStep: btScalar,
        linVel: *mut btVector3,
        angVel: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btTransformUtil32calculateDiffAxisAngleQuaternionERK12btQuaternionS2_R9btVector3Rd"]
    pub fn btTransformUtil_calculateDiffAxisAngleQuaternion(
        orn0: *const btQuaternion,
        orn1a: *const btQuaternion,
        axis: *mut btVector3,
        angle: *mut btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btTransformUtil17calculateVelocityERK11btTransformS2_dR9btVector3S4_"]
    pub fn btTransformUtil_calculateVelocity(
        transform0: *const btTransform,
        transform1: *const btTransform,
        timeStep: btScalar,
        linVel: *mut btVector3,
        angVel: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btTransformUtil22calculateDiffAxisAngleERK11btTransformS2_R9btVector3Rd"]
    pub fn btTransformUtil_calculateDiffAxisAngle(
        transform0: *const btTransform,
        transform1: *const btTransform,
        axis: *mut btVector3,
        angle: *mut btScalar,
    );
}
impl btTransformUtil {
    #[inline]
    pub unsafe fn integrateTransform(
        curTrans: *const btTransform,
        linvel: *const btVector3,
        angvel: *const btVector3,
        timeStep: btScalar,
        predictedTransform: *mut btTransform,
    ) {
        btTransformUtil_integrateTransform(curTrans, linvel, angvel, timeStep, predictedTransform)
    }
    #[inline]
    pub unsafe fn calculateVelocityQuaternion(
        pos0: *const btVector3,
        pos1: *const btVector3,
        orn0: *const btQuaternion,
        orn1: *const btQuaternion,
        timeStep: btScalar,
        linVel: *mut btVector3,
        angVel: *mut btVector3,
    ) {
        btTransformUtil_calculateVelocityQuaternion(
            pos0,
            pos1,
            orn0,
            orn1,
            timeStep,
            linVel,
            angVel,
        )
    }
    #[inline]
    pub unsafe fn calculateDiffAxisAngleQuaternion(
        orn0: *const btQuaternion,
        orn1a: *const btQuaternion,
        axis: *mut btVector3,
        angle: *mut btScalar,
    ) {
        btTransformUtil_calculateDiffAxisAngleQuaternion(orn0, orn1a, axis, angle)
    }
    #[inline]
    pub unsafe fn calculateVelocity(
        transform0: *const btTransform,
        transform1: *const btTransform,
        timeStep: btScalar,
        linVel: *mut btVector3,
        angVel: *mut btVector3,
    ) {
        btTransformUtil_calculateVelocity(transform0, transform1, timeStep, linVel, angVel)
    }
    #[inline]
    pub unsafe fn calculateDiffAxisAngle(
        transform0: *const btTransform,
        transform1: *const btTransform,
        axis: *mut btVector3,
        angle: *mut btScalar,
    ) {
        btTransformUtil_calculateDiffAxisAngle(transform0, transform1, axis, angle)
    }
}
/// The btConvexSeparatingDistanceUtil can help speed up convex collision detection
/// by conservatively updating a cached separating distance/vector instead of re-calculating the closest distance
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConvexSeparatingDistanceUtil {
    pub m_ornA: btQuaternion,
    pub m_ornB: btQuaternion,
    pub m_posA: btVector3,
    pub m_posB: btVector3,
    pub m_separatingNormal: btVector3,
    pub m_boundingRadiusA: btScalar,
    pub m_boundingRadiusB: btScalar,
    pub m_separatingDistance: btScalar,
}
#[test]
fn bindgen_test_layout_btConvexSeparatingDistanceUtil() {
    assert_eq!(
        ::std::mem::size_of::<btConvexSeparatingDistanceUtil>(),
        184usize,
        concat!("Size of: ", stringify!(btConvexSeparatingDistanceUtil))
    );
    assert_eq!(
        ::std::mem::align_of::<btConvexSeparatingDistanceUtil>(),
        8usize,
        concat!("Alignment of ", stringify!(btConvexSeparatingDistanceUtil))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConvexSeparatingDistanceUtil)).m_ornA as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexSeparatingDistanceUtil),
            "::",
            stringify!(m_ornA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConvexSeparatingDistanceUtil)).m_ornB as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexSeparatingDistanceUtil),
            "::",
            stringify!(m_ornB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConvexSeparatingDistanceUtil)).m_posA as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexSeparatingDistanceUtil),
            "::",
            stringify!(m_posA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConvexSeparatingDistanceUtil)).m_posB as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexSeparatingDistanceUtil),
            "::",
            stringify!(m_posB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConvexSeparatingDistanceUtil)).m_separatingNormal as *const _ as usize
        },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexSeparatingDistanceUtil),
            "::",
            stringify!(m_separatingNormal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConvexSeparatingDistanceUtil)).m_boundingRadiusA as *const _ as usize
        },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexSeparatingDistanceUtil),
            "::",
            stringify!(m_boundingRadiusA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConvexSeparatingDistanceUtil)).m_boundingRadiusB as *const _ as usize
        },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexSeparatingDistanceUtil),
            "::",
            stringify!(m_boundingRadiusB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConvexSeparatingDistanceUtil)).m_separatingDistance as *const _
                as usize
        },
        176usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexSeparatingDistanceUtil),
            "::",
            stringify!(m_separatingDistance)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btConvexSeparatingDistanceUtil33getConservativeSeparatingDistanceEv"]
    pub fn btConvexSeparatingDistanceUtil_getConservativeSeparatingDistance(
        this: *mut btConvexSeparatingDistanceUtil,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btConvexSeparatingDistanceUtil24updateSeparatingDistanceERK11btTransformS2_"]
    pub fn btConvexSeparatingDistanceUtil_updateSeparatingDistance(
        this: *mut btConvexSeparatingDistanceUtil,
        transA: *const btTransform,
        transB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btConvexSeparatingDistanceUtil22initSeparatingDistanceERK9btVector3dRK11btTransformS5_"]
    pub fn btConvexSeparatingDistanceUtil_initSeparatingDistance(
        this: *mut btConvexSeparatingDistanceUtil,
        separatingVector: *const btVector3,
        separatingDistance: btScalar,
        transA: *const btTransform,
        transB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btConvexSeparatingDistanceUtilC1Edd"]
    pub fn btConvexSeparatingDistanceUtil_btConvexSeparatingDistanceUtil(
        this: *mut btConvexSeparatingDistanceUtil,
        boundingRadiusA: btScalar,
        boundingRadiusB: btScalar,
    );
}
impl btConvexSeparatingDistanceUtil {
    #[inline]
    pub unsafe fn getConservativeSeparatingDistance(&mut self) -> btScalar {
        btConvexSeparatingDistanceUtil_getConservativeSeparatingDistance(self)
    }
    #[inline]
    pub unsafe fn updateSeparatingDistance(
        &mut self,
        transA: *const btTransform,
        transB: *const btTransform,
    ) {
        btConvexSeparatingDistanceUtil_updateSeparatingDistance(self, transA, transB)
    }
    #[inline]
    pub unsafe fn initSeparatingDistance(
        &mut self,
        separatingVector: *const btVector3,
        separatingDistance: btScalar,
        transA: *const btTransform,
        transB: *const btTransform,
    ) {
        btConvexSeparatingDistanceUtil_initSeparatingDistance(
            self,
            separatingVector,
            separatingDistance,
            transA,
            transB,
        )
    }
    #[inline]
    pub unsafe fn new(boundingRadiusA: btScalar, boundingRadiusB: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexSeparatingDistanceUtil_btConvexSeparatingDistanceUtil(
            &mut __bindgen_tmp,
            boundingRadiusA,
            boundingRadiusB,
        );
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConstraintRow {
    pub m_normal: [btScalar; 3usize],
    pub m_rhs: btScalar,
    pub m_jacDiagInv: btScalar,
    pub m_lowerLimit: btScalar,
    pub m_upperLimit: btScalar,
    pub m_accumImpulse: btScalar,
}
#[test]
fn bindgen_test_layout_btConstraintRow() {
    assert_eq!(
        ::std::mem::size_of::<btConstraintRow>(),
        64usize,
        concat!("Size of: ", stringify!(btConstraintRow))
    );
    assert_eq!(
        ::std::mem::align_of::<btConstraintRow>(),
        8usize,
        concat!("Alignment of ", stringify!(btConstraintRow))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConstraintRow)).m_normal as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConstraintRow),
            "::",
            stringify!(m_normal)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConstraintRow)).m_rhs as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConstraintRow),
            "::",
            stringify!(m_rhs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConstraintRow)).m_jacDiagInv as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConstraintRow),
            "::",
            stringify!(m_jacDiagInv)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConstraintRow)).m_lowerLimit as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConstraintRow),
            "::",
            stringify!(m_lowerLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConstraintRow)).m_upperLimit as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConstraintRow),
            "::",
            stringify!(m_upperLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConstraintRow)).m_accumImpulse as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConstraintRow),
            "::",
            stringify!(m_accumImpulse)
        )
    );
}
pub type PfxConstraintRow = btConstraintRow;
pub const btContactPointFlags_BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED: btContactPointFlags = 1;
pub const btContactPointFlags_BT_CONTACT_FLAG_HAS_CONTACT_CFM: btContactPointFlags = 2;
pub const btContactPointFlags_BT_CONTACT_FLAG_HAS_CONTACT_ERP: btContactPointFlags = 4;
pub const btContactPointFlags_BT_CONTACT_FLAG_CONTACT_STIFFNESS_DAMPING: btContactPointFlags = 8;
pub const btContactPointFlags_BT_CONTACT_FLAG_FRICTION_ANCHOR: btContactPointFlags = 16;
pub type btContactPointFlags = ::std::os::raw::c_uint;
/// ManifoldContactPoint collects and maintains persistent contactpoints.
/// used to improve stability and performance of rigidbody dynamics response.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btManifoldPoint {
    pub m_localPointA: btVector3,
    pub m_localPointB: btVector3,
    pub m_positionWorldOnB: btVector3,
    /// m_positionWorldOnA is redundant information, see getPositionWorldOnA(), but for clarity
    pub m_positionWorldOnA: btVector3,
    pub m_normalWorldOnB: btVector3,
    pub m_distance1: btScalar,
    pub m_combinedFriction: btScalar,
    pub m_combinedRollingFriction: btScalar,
    pub m_combinedSpinningFriction: btScalar,
    pub m_combinedRestitution: btScalar,
    pub m_partId0: ::std::os::raw::c_int,
    pub m_partId1: ::std::os::raw::c_int,
    pub m_index0: ::std::os::raw::c_int,
    pub m_index1: ::std::os::raw::c_int,
    pub m_userPersistentData: *mut ::std::os::raw::c_void,
    pub m_contactPointFlags: ::std::os::raw::c_int,
    pub m_appliedImpulse: btScalar,
    pub m_appliedImpulseLateral1: btScalar,
    pub m_appliedImpulseLateral2: btScalar,
    pub m_contactMotion1: btScalar,
    pub m_contactMotion2: btScalar,
    pub __bindgen_anon_1: btManifoldPoint__bindgen_ty_1,
    pub __bindgen_anon_2: btManifoldPoint__bindgen_ty_2,
    pub m_frictionCFM: btScalar,
    pub m_lifeTime: ::std::os::raw::c_int,
    pub m_lateralFrictionDir1: btVector3,
    pub m_lateralFrictionDir2: btVector3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btManifoldPoint__bindgen_ty_1 {
    pub m_contactCFM: btScalar,
    pub m_combinedContactStiffness1: btScalar,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_btManifoldPoint__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btManifoldPoint__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(btManifoldPoint__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<btManifoldPoint__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(btManifoldPoint__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btManifoldPoint__bindgen_ty_1)).m_contactCFM as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint__bindgen_ty_1),
            "::",
            stringify!(m_contactCFM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btManifoldPoint__bindgen_ty_1)).m_combinedContactStiffness1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint__bindgen_ty_1),
            "::",
            stringify!(m_combinedContactStiffness1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btManifoldPoint__bindgen_ty_2 {
    pub m_contactERP: btScalar,
    pub m_combinedContactDamping1: btScalar,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_btManifoldPoint__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<btManifoldPoint__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(btManifoldPoint__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<btManifoldPoint__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(btManifoldPoint__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btManifoldPoint__bindgen_ty_2)).m_contactERP as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint__bindgen_ty_2),
            "::",
            stringify!(m_contactERP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btManifoldPoint__bindgen_ty_2)).m_combinedContactDamping1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint__bindgen_ty_2),
            "::",
            stringify!(m_combinedContactDamping1)
        )
    );
}
#[test]
fn bindgen_test_layout_btManifoldPoint() {
    assert_eq!(
        ::std::mem::size_of::<btManifoldPoint>(),
        368usize,
        concat!("Size of: ", stringify!(btManifoldPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<btManifoldPoint>(),
        8usize,
        concat!("Alignment of ", stringify!(btManifoldPoint))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_localPointA as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_localPointA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_localPointB as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_localPointB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_positionWorldOnB as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_positionWorldOnB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_positionWorldOnA as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_positionWorldOnA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_normalWorldOnB as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_normalWorldOnB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_distance1 as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_distance1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_combinedFriction as *const _ as usize },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_combinedFriction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_combinedRollingFriction as *const _ as usize },
        176usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_combinedRollingFriction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btManifoldPoint)).m_combinedSpinningFriction as *const _ as usize
        },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_combinedSpinningFriction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_combinedRestitution as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_combinedRestitution)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_partId0 as *const _ as usize },
        200usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_partId0)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_partId1 as *const _ as usize },
        204usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_partId1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_index0 as *const _ as usize },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_index0)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_index1 as *const _ as usize },
        212usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_index1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_userPersistentData as *const _ as usize },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_userPersistentData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_contactPointFlags as *const _ as usize },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_contactPointFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_appliedImpulse as *const _ as usize },
        232usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_appliedImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_appliedImpulseLateral1 as *const _ as usize },
        240usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_appliedImpulseLateral1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_appliedImpulseLateral2 as *const _ as usize },
        248usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_appliedImpulseLateral2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_contactMotion1 as *const _ as usize },
        256usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_contactMotion1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_contactMotion2 as *const _ as usize },
        264usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_contactMotion2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_frictionCFM as *const _ as usize },
        288usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_frictionCFM)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_lifeTime as *const _ as usize },
        296usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_lifeTime)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_lateralFrictionDir1 as *const _ as usize },
        304usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_lateralFrictionDir1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldPoint)).m_lateralFrictionDir2 as *const _ as usize },
        336usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldPoint),
            "::",
            stringify!(m_lateralFrictionDir2)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btManifoldPoint11getDistanceEv"]
    pub fn btManifoldPoint_getDistance(this: *const btManifoldPoint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btManifoldPoint11getLifeTimeEv"]
    pub fn btManifoldPoint_getLifeTime(this: *const btManifoldPoint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btManifoldPoint19getPositionWorldOnAEv"]
    pub fn btManifoldPoint_getPositionWorldOnA(this: *const btManifoldPoint) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btManifoldPoint19getPositionWorldOnBEv"]
    pub fn btManifoldPoint_getPositionWorldOnB(this: *const btManifoldPoint) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btManifoldPoint11setDistanceEd"]
    pub fn btManifoldPoint_setDistance(this: *mut btManifoldPoint, dist: btScalar);
}
extern "C" {

    /// this returns the most recent applied impulse, to satisfy contact constraints by the constraint solver

    #[link_name = "\u{1}_ZNK15btManifoldPoint17getAppliedImpulseEv"]
    pub fn btManifoldPoint_getAppliedImpulse(this: *const btManifoldPoint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btManifoldPointC1Ev"]
    pub fn btManifoldPoint_btManifoldPoint(this: *mut btManifoldPoint);
}
extern "C" {
    #[link_name = "\u{1}_ZN15btManifoldPointC1ERK9btVector3S2_S2_d"]
    pub fn btManifoldPoint_btManifoldPoint1(
        this: *mut btManifoldPoint,
        pointA: *const btVector3,
        pointB: *const btVector3,
        normal: *const btVector3,
        distance: btScalar,
    );
}
impl btManifoldPoint {
    #[inline]
    pub unsafe fn getDistance(&self) -> btScalar {
        btManifoldPoint_getDistance(self)
    }
    #[inline]
    pub unsafe fn getLifeTime(&self) -> ::std::os::raw::c_int {
        btManifoldPoint_getLifeTime(self)
    }
    #[inline]
    pub unsafe fn getPositionWorldOnA(&self) -> *const btVector3 {
        btManifoldPoint_getPositionWorldOnA(self)
    }
    #[inline]
    pub unsafe fn getPositionWorldOnB(&self) -> *const btVector3 {
        btManifoldPoint_getPositionWorldOnB(self)
    }
    #[inline]
    pub unsafe fn setDistance(&mut self, dist: btScalar) {
        btManifoldPoint_setDistance(self, dist)
    }
    #[inline]
    pub unsafe fn getAppliedImpulse(&self) -> btScalar {
        btManifoldPoint_getAppliedImpulse(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btManifoldPoint_btManifoldPoint(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        pointA: *const btVector3,
        pointB: *const btVector3,
        normal: *const btVector3,
        distance: btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btManifoldPoint_btManifoldPoint1(&mut __bindgen_tmp, pointA, pointB, normal, distance);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionResult {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}gContactBreakingThreshold"]
    pub static mut gContactBreakingThreshold: btScalar;
}
pub type ContactDestroyedCallback = ::std::option::Option<
    unsafe extern "C" fn(userPersistentData: *mut ::std::os::raw::c_void) -> bool,
>;
pub type ContactProcessedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cp: *mut btManifoldPoint,
        body0: *mut ::std::os::raw::c_void,
        body1: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type ContactStartedCallback = ::std::option::Option<
    unsafe extern "C" fn(manifold: *const *const btPersistentManifold),
>;
pub type ContactEndedCallback = ::std::option::Option<
    unsafe extern "C" fn(manifold: *const *const btPersistentManifold),
>;
extern "C" {
    #[link_name = "\u{1}gContactDestroyedCallback"]
    pub static mut gContactDestroyedCallback: ContactDestroyedCallback;
}
extern "C" {
    #[link_name = "\u{1}gContactProcessedCallback"]
    pub static mut gContactProcessedCallback: ContactProcessedCallback;
}
extern "C" {
    #[link_name = "\u{1}gContactStartedCallback"]
    pub static mut gContactStartedCallback: ContactStartedCallback;
}
extern "C" {
    #[link_name = "\u{1}gContactEndedCallback"]
    pub static mut gContactEndedCallback: ContactEndedCallback;
}
pub const btContactManifoldTypes_MIN_CONTACT_MANIFOLD_TYPE: btContactManifoldTypes = 1024;
pub const btContactManifoldTypes_BT_PERSISTENT_MANIFOLD_TYPE: btContactManifoldTypes = 1025;
pub type btContactManifoldTypes = ::std::os::raw::c_uint;
/// btPersistentManifold is a contact point cache, it stays persistent as long as objects are overlapping in the broadphase.
/// Those contact points are created by the collision narrow phase.
/// The cache can be empty, or hold 1,2,3 or 4 points. Some collision algorithms (GJK) might only add one point at a time.
/// updates/refreshes old contact points, and throw them away if necessary (distance becomes too large)
/// reduces the cache to 4 points, when more then 4 points are added, using following rules:
/// the contact point with deepest penetration is always kept, and it tries to maximuze the area covered by the points
/// note that some pairs of objects might have more then one contact manifold.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btPersistentManifold {
    pub _base: btTypedObject,
    pub m_pointCache: [btManifoldPoint; 4usize],
    /// this two body pointers can point to the physics rigidbody class.
    pub m_body0: *const btCollisionObject,
    pub m_body1: *const btCollisionObject,
    pub m_cachedPoints: ::std::os::raw::c_int,
    pub m_contactBreakingThreshold: btScalar,
    pub m_contactProcessingThreshold: btScalar,
    pub m_companionIdA: ::std::os::raw::c_int,
    pub m_companionIdB: ::std::os::raw::c_int,
    pub m_index1a: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btPersistentManifold() {
    assert_eq!(
        ::std::mem::size_of::<btPersistentManifold>(),
        1536usize,
        concat!("Size of: ", stringify!(btPersistentManifold))
    );
    assert_eq!(
        ::std::mem::align_of::<btPersistentManifold>(),
        8usize,
        concat!("Alignment of ", stringify!(btPersistentManifold))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPersistentManifold)).m_pointCache as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPersistentManifold),
            "::",
            stringify!(m_pointCache)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPersistentManifold)).m_body0 as *const _ as usize },
        1480usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPersistentManifold),
            "::",
            stringify!(m_body0)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPersistentManifold)).m_body1 as *const _ as usize },
        1488usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPersistentManifold),
            "::",
            stringify!(m_body1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPersistentManifold)).m_cachedPoints as *const _ as usize },
        1496usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPersistentManifold),
            "::",
            stringify!(m_cachedPoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPersistentManifold)).m_contactBreakingThreshold as *const _ as usize
        },
        1504usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPersistentManifold),
            "::",
            stringify!(m_contactBreakingThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPersistentManifold)).m_contactProcessingThreshold as *const _ as usize
        },
        1512usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPersistentManifold),
            "::",
            stringify!(m_contactProcessingThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPersistentManifold)).m_companionIdA as *const _ as usize },
        1520usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPersistentManifold),
            "::",
            stringify!(m_companionIdA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPersistentManifold)).m_companionIdB as *const _ as usize },
        1524usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPersistentManifold),
            "::",
            stringify!(m_companionIdB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPersistentManifold)).m_index1a as *const _ as usize },
        1528usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPersistentManifold),
            "::",
            stringify!(m_index1a)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK20btPersistentManifold8getBody0Ev"]
    pub fn btPersistentManifold_getBody0(
        this: *const btPersistentManifold,
    ) -> *const btCollisionObject;
}
extern "C" {
    #[link_name = "\u{1}_ZNK20btPersistentManifold8getBody1Ev"]
    pub fn btPersistentManifold_getBody1(
        this: *const btPersistentManifold,
    ) -> *const btCollisionObject;
}
extern "C" {
    #[link_name = "\u{1}_ZN20btPersistentManifold9setBodiesEPK17btCollisionObjectS2_"]
    pub fn btPersistentManifold_setBodies(
        this: *mut btPersistentManifold,
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN20btPersistentManifold14clearUserCacheER15btManifoldPoint"]
    pub fn btPersistentManifold_clearUserCache(
        this: *mut btPersistentManifold,
        pt: *mut btManifoldPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK20btPersistentManifold14getNumContactsEv"]
    pub fn btPersistentManifold_getNumContacts(
        this: *const btPersistentManifold,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// the setNumContacts API is usually not used, except when you gather/fill all contacts manually

    #[link_name = "\u{1}_ZN20btPersistentManifold14setNumContactsEi"]
    pub fn btPersistentManifold_setNumContacts(
        this: *mut btPersistentManifold,
        cachedPoints: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK20btPersistentManifold15getContactPointEi"]
    pub fn btPersistentManifold_getContactPoint(
        this: *const btPersistentManifold,
        index: ::std::os::raw::c_int,
    ) -> *const btManifoldPoint;
}
extern "C" {
    #[link_name = "\u{1}_ZN20btPersistentManifold15getContactPointEi"]
    pub fn btPersistentManifold_getContactPoint1(
        this: *mut btPersistentManifold,
        index: ::std::os::raw::c_int,
    ) -> *mut btManifoldPoint;
}
extern "C" {

    /// @todo: get this margin from the current physics / collision environment

    #[link_name = "\u{1}_ZNK20btPersistentManifold27getContactBreakingThresholdEv"]
    pub fn btPersistentManifold_getContactBreakingThreshold(
        this: *const btPersistentManifold,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK20btPersistentManifold29getContactProcessingThresholdEv"]
    pub fn btPersistentManifold_getContactProcessingThreshold(
        this: *const btPersistentManifold,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN20btPersistentManifold27setContactBreakingThresholdEd"]
    pub fn btPersistentManifold_setContactBreakingThreshold(
        this: *mut btPersistentManifold,
        contactBreakingThreshold: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN20btPersistentManifold29setContactProcessingThresholdEd"]
    pub fn btPersistentManifold_setContactProcessingThreshold(
        this: *mut btPersistentManifold,
        contactProcessingThreshold: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK20btPersistentManifold13getCacheEntryERK15btManifoldPoint"]
    pub fn btPersistentManifold_getCacheEntry(
        this: *const btPersistentManifold,
        newPoint: *const btManifoldPoint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN20btPersistentManifold16addManifoldPointERK15btManifoldPointb"]
    pub fn btPersistentManifold_addManifoldPoint(
        this: *mut btPersistentManifold,
        newPoint: *const btManifoldPoint,
        isPredictive: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN20btPersistentManifold18removeContactPointEi"]
    pub fn btPersistentManifold_removeContactPoint(
        this: *mut btPersistentManifold,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN20btPersistentManifold19replaceContactPointERK15btManifoldPointi"]
    pub fn btPersistentManifold_replaceContactPoint(
        this: *mut btPersistentManifold,
        newPoint: *const btManifoldPoint,
        insertIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK20btPersistentManifold20validContactDistanceERK15btManifoldPoint"]
    pub fn btPersistentManifold_validContactDistance(
        this: *const btPersistentManifold,
        pt: *const btManifoldPoint,
    ) -> bool;
}
extern "C" {

    /// calculated new worldspace coordinates and depth, and reject points that exceed the collision margin

    #[link_name = "\u{1}_ZN20btPersistentManifold20refreshContactPointsERK11btTransformS2_"]
    pub fn btPersistentManifold_refreshContactPoints(
        this: *mut btPersistentManifold,
        trA: *const btTransform,
        trB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN20btPersistentManifold13clearManifoldEv"]
    pub fn btPersistentManifold_clearManifold(this: *mut btPersistentManifold);
}
extern "C" {
    #[link_name = "\u{1}_ZN20btPersistentManifoldC1Ev"]
    pub fn btPersistentManifold_btPersistentManifold(this: *mut btPersistentManifold);
}
extern "C" {
    #[link_name = "\u{1}_ZN20btPersistentManifoldC1EPK17btCollisionObjectS2_idd"]
    pub fn btPersistentManifold_btPersistentManifold1(
        this: *mut btPersistentManifold,
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
        arg1: ::std::os::raw::c_int,
        contactBreakingThreshold: btScalar,
        contactProcessingThreshold: btScalar,
    );
}
impl btPersistentManifold {
    #[inline]
    pub unsafe fn getBody0(&self) -> *const btCollisionObject {
        btPersistentManifold_getBody0(self)
    }
    #[inline]
    pub unsafe fn getBody1(&self) -> *const btCollisionObject {
        btPersistentManifold_getBody1(self)
    }
    #[inline]
    pub unsafe fn setBodies(
        &mut self,
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) {
        btPersistentManifold_setBodies(self, body0, body1)
    }
    #[inline]
    pub unsafe fn clearUserCache(&mut self, pt: *mut btManifoldPoint) {
        btPersistentManifold_clearUserCache(self, pt)
    }
    #[inline]
    pub unsafe fn getNumContacts(&self) -> ::std::os::raw::c_int {
        btPersistentManifold_getNumContacts(self)
    }
    #[inline]
    pub unsafe fn setNumContacts(&mut self, cachedPoints: ::std::os::raw::c_int) {
        btPersistentManifold_setNumContacts(self, cachedPoints)
    }
    #[inline]
    pub unsafe fn getContactPoint(&self, index: ::std::os::raw::c_int) -> *const btManifoldPoint {
        btPersistentManifold_getContactPoint(self, index)
    }
    #[inline]
    pub unsafe fn getContactPoint1(
        &mut self,
        index: ::std::os::raw::c_int,
    ) -> *mut btManifoldPoint {
        btPersistentManifold_getContactPoint1(self, index)
    }
    #[inline]
    pub unsafe fn getContactBreakingThreshold(&self) -> btScalar {
        btPersistentManifold_getContactBreakingThreshold(self)
    }
    #[inline]
    pub unsafe fn getContactProcessingThreshold(&self) -> btScalar {
        btPersistentManifold_getContactProcessingThreshold(self)
    }
    #[inline]
    pub unsafe fn setContactBreakingThreshold(&mut self, contactBreakingThreshold: btScalar) {
        btPersistentManifold_setContactBreakingThreshold(self, contactBreakingThreshold)
    }
    #[inline]
    pub unsafe fn setContactProcessingThreshold(&mut self, contactProcessingThreshold: btScalar) {
        btPersistentManifold_setContactProcessingThreshold(self, contactProcessingThreshold)
    }
    #[inline]
    pub unsafe fn getCacheEntry(&self, newPoint: *const btManifoldPoint) -> ::std::os::raw::c_int {
        btPersistentManifold_getCacheEntry(self, newPoint)
    }
    #[inline]
    pub unsafe fn addManifoldPoint(
        &mut self,
        newPoint: *const btManifoldPoint,
        isPredictive: bool,
    ) -> ::std::os::raw::c_int {
        btPersistentManifold_addManifoldPoint(self, newPoint, isPredictive)
    }
    #[inline]
    pub unsafe fn removeContactPoint(&mut self, index: ::std::os::raw::c_int) {
        btPersistentManifold_removeContactPoint(self, index)
    }
    #[inline]
    pub unsafe fn replaceContactPoint(
        &mut self,
        newPoint: *const btManifoldPoint,
        insertIndex: ::std::os::raw::c_int,
    ) {
        btPersistentManifold_replaceContactPoint(self, newPoint, insertIndex)
    }
    #[inline]
    pub unsafe fn validContactDistance(&self, pt: *const btManifoldPoint) -> bool {
        btPersistentManifold_validContactDistance(self, pt)
    }
    #[inline]
    pub unsafe fn refreshContactPoints(
        &mut self,
        trA: *const btTransform,
        trB: *const btTransform,
    ) {
        btPersistentManifold_refreshContactPoints(self, trA, trB)
    }
    #[inline]
    pub unsafe fn clearManifold(&mut self) {
        btPersistentManifold_clearManifold(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btPersistentManifold_btPersistentManifold(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
        arg1: ::std::os::raw::c_int,
        contactBreakingThreshold: btScalar,
        contactProcessingThreshold: btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btPersistentManifold_btPersistentManifold1(
            &mut __bindgen_tmp,
            body0,
            body1,
            arg1,
            contactBreakingThreshold,
            contactProcessingThreshold,
        );
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct btDiscreteCollisionDetectorInterface__bindgen_vtable(::std::os::raw::c_void);
/// This interface is made to be used by an iterative approach to do TimeOfImpact calculations
/// This interface allows to query for closest points and penetration depth between two (convex) objects
/// the closest point is on the second object (B), and the normal points from the surface on B towards A.
/// distance is between closest points on B and closest point on A. So you can calculate closest point on A
/// by taking closestPointInA = closestPointInB + m_distance * m_normalOnSurfaceB
#[repr(C)]
#[derive(Debug)]
pub struct btDiscreteCollisionDetectorInterface {
    pub vtable_: *const btDiscreteCollisionDetectorInterface__bindgen_vtable,
}
#[repr(C)]
pub struct btDiscreteCollisionDetectorInterface_Result__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btDiscreteCollisionDetectorInterface_Result {
    pub vtable_: *const btDiscreteCollisionDetectorInterface_Result__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btDiscreteCollisionDetectorInterface_Result() {
    assert_eq!(
        ::std::mem::size_of::<btDiscreteCollisionDetectorInterface_Result>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(btDiscreteCollisionDetectorInterface_Result)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btDiscreteCollisionDetectorInterface_Result>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btDiscreteCollisionDetectorInterface_Result)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDiscreteCollisionDetectorInterface_ClosestPointInput {
    pub m_transformA: btTransform,
    pub m_transformB: btTransform,
    pub m_maximumDistanceSquared: btScalar,
}
#[test]
fn bindgen_test_layout_btDiscreteCollisionDetectorInterface_ClosestPointInput() {
    assert_eq!(
        ::std::mem::size_of::<btDiscreteCollisionDetectorInterface_ClosestPointInput>(),
        264usize,
        concat!(
            "Size of: ",
            stringify!(btDiscreteCollisionDetectorInterface_ClosestPointInput)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btDiscreteCollisionDetectorInterface_ClosestPointInput>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btDiscreteCollisionDetectorInterface_ClosestPointInput)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDiscreteCollisionDetectorInterface_ClosestPointInput)).m_transformA
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteCollisionDetectorInterface_ClosestPointInput),
            "::",
            stringify!(m_transformA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDiscreteCollisionDetectorInterface_ClosestPointInput)).m_transformB
                as *const _ as usize
        },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteCollisionDetectorInterface_ClosestPointInput),
            "::",
            stringify!(m_transformB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDiscreteCollisionDetectorInterface_ClosestPointInput))
                .m_maximumDistanceSquared as *const _ as usize
        },
        256usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteCollisionDetectorInterface_ClosestPointInput),
            "::",
            stringify!(m_maximumDistanceSquared)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN36btDiscreteCollisionDetectorInterface17ClosestPointInputC1Ev"]
    pub fn btDiscreteCollisionDetectorInterface_ClosestPointInput_ClosestPointInput(
        this: *mut btDiscreteCollisionDetectorInterface_ClosestPointInput,
    );
}
impl btDiscreteCollisionDetectorInterface_ClosestPointInput {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDiscreteCollisionDetectorInterface_ClosestPointInput_ClosestPointInput(
            &mut __bindgen_tmp,
        );
        __bindgen_tmp
    }
}
#[test]
fn bindgen_test_layout_btDiscreteCollisionDetectorInterface() {
    assert_eq!(
        ::std::mem::size_of::<btDiscreteCollisionDetectorInterface>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(btDiscreteCollisionDetectorInterface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btDiscreteCollisionDetectorInterface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btDiscreteCollisionDetectorInterface)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN36btDiscreteCollisionDetectorInterface6ResultD0Ev"]
    pub fn btDiscreteCollisionDetectorInterface_Result_Result_destructor(
        this: *mut btDiscreteCollisionDetectorInterface_Result,
    );
}
extern "C" {

    /// setShapeIdentifiersA/B provides experimental support for per-triangle material / custom material combiner

    #[link_name = "\u{1}_ZN36btDiscreteCollisionDetectorInterface6Result20setShapeIdentifiersAEii"]
    pub fn btDiscreteCollisionDetectorInterface_Result_setShapeIdentifiersA(
        this: *mut ::std::os::raw::c_void,
        partId0: ::std::os::raw::c_int,
        index0: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN36btDiscreteCollisionDetectorInterface6Result20setShapeIdentifiersBEii"]
    pub fn btDiscreteCollisionDetectorInterface_Result_setShapeIdentifiersB(
        this: *mut ::std::os::raw::c_void,
        partId1: ::std::os::raw::c_int,
        index1: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN36btDiscreteCollisionDetectorInterface6Result15addContactPointERK9btVector3S3_d"]
    pub fn btDiscreteCollisionDetectorInterface_Result_addContactPoint(
        this: *mut ::std::os::raw::c_void,
        normalOnBInWorld: *const btVector3,
        pointInWorld: *const btVector3,
        depth: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN36btDiscreteCollisionDetectorInterfaceD0Ev"]
    pub fn btDiscreteCollisionDetectorInterface_btDiscreteCollisionDetectorInterface_destructor(
        this: *mut btDiscreteCollisionDetectorInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN36btDiscreteCollisionDetectorInterface16getClosestPointsERKNS_17ClosestPointInputERNS_6ResultEP12btIDebugDrawb"]
    pub fn btDiscreteCollisionDetectorInterface_getClosestPoints(
        this: *mut ::std::os::raw::c_void,
        input: *const btDiscreteCollisionDetectorInterface_ClosestPointInput,
        output: *mut btDiscreteCollisionDetectorInterface_Result,
        debugDraw: *mut btIDebugDraw,
        swapResults: bool,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btStorageResult {
    pub _base: btDiscreteCollisionDetectorInterface_Result,
    pub m_normalOnSurfaceB: btVector3,
    pub m_closestPointInB: btVector3,
    pub m_distance: btScalar,
}
#[test]
fn bindgen_test_layout_btStorageResult() {
    assert_eq!(
        ::std::mem::size_of::<btStorageResult>(),
        80usize,
        concat!("Size of: ", stringify!(btStorageResult))
    );
    assert_eq!(
        ::std::mem::align_of::<btStorageResult>(),
        8usize,
        concat!("Alignment of ", stringify!(btStorageResult))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStorageResult)).m_normalOnSurfaceB as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStorageResult),
            "::",
            stringify!(m_normalOnSurfaceB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStorageResult)).m_closestPointInB as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStorageResult),
            "::",
            stringify!(m_closestPointInB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStorageResult)).m_distance as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStorageResult),
            "::",
            stringify!(m_distance)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btStorageResultC2Ev"]
    pub fn btStorageResult_btStorageResult(this: *mut btStorageResult);
}
impl btStorageResult {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btStorageResult_btStorageResult(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN15btStorageResultD0Ev"]
    pub fn btStorageResult_btStorageResult_destructor(this: *mut btStorageResult);
}
extern "C" {
    #[link_name = "\u{1}_ZN15btStorageResult15addContactPointERK9btVector3S2_d"]
    pub fn btStorageResult_addContactPoint(
        this: *mut ::std::os::raw::c_void,
        normalOnBInWorld: *const btVector3,
        pointInWorld: *const btVector3,
        depth: btScalar,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionObjectWrapper {
    pub m_parent: *const btCollisionObjectWrapper,
    pub m_shape: *const btCollisionShape,
    pub m_collisionObject: *const btCollisionObject,
    pub m_worldTransform: *const btTransform,
    pub m_partId: ::std::os::raw::c_int,
    pub m_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btCollisionObjectWrapper() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionObjectWrapper>(),
        40usize,
        concat!("Size of: ", stringify!(btCollisionObjectWrapper))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionObjectWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(btCollisionObjectWrapper))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectWrapper)).m_parent as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectWrapper),
            "::",
            stringify!(m_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectWrapper)).m_shape as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectWrapper),
            "::",
            stringify!(m_shape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionObjectWrapper)).m_collisionObject as *const _ as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectWrapper),
            "::",
            stringify!(m_collisionObject)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectWrapper)).m_worldTransform as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectWrapper),
            "::",
            stringify!(m_worldTransform)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectWrapper)).m_partId as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectWrapper),
            "::",
            stringify!(m_partId)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionObjectWrapper)).m_index as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionObjectWrapper),
            "::",
            stringify!(m_index)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK24btCollisionObjectWrapper17getWorldTransformEv"]
    pub fn btCollisionObjectWrapper_getWorldTransform(
        this: *const btCollisionObjectWrapper,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK24btCollisionObjectWrapper18getCollisionObjectEv"]
    pub fn btCollisionObjectWrapper_getCollisionObject(
        this: *const btCollisionObjectWrapper,
    ) -> *const btCollisionObject;
}
extern "C" {
    #[link_name = "\u{1}_ZNK24btCollisionObjectWrapper17getCollisionShapeEv"]
    pub fn btCollisionObjectWrapper_getCollisionShape(
        this: *const btCollisionObjectWrapper,
    ) -> *const btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}_ZN24btCollisionObjectWrapperC1EPKS_PK16btCollisionShapePK17btCollisionObjectRK11btTransformii"]
    pub fn btCollisionObjectWrapper_btCollisionObjectWrapper(
        this: *mut btCollisionObjectWrapper,
        parent: *const btCollisionObjectWrapper,
        shape: *const btCollisionShape,
        collisionObject: *const btCollisionObject,
        worldTransform: *const btTransform,
        partId: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
    );
}
impl btCollisionObjectWrapper {
    #[inline]
    pub unsafe fn getWorldTransform(&self) -> *const btTransform {
        btCollisionObjectWrapper_getWorldTransform(self)
    }
    #[inline]
    pub unsafe fn getCollisionObject(&self) -> *const btCollisionObject {
        btCollisionObjectWrapper_getCollisionObject(self)
    }
    #[inline]
    pub unsafe fn getCollisionShape(&self) -> *const btCollisionShape {
        btCollisionObjectWrapper_getCollisionShape(self)
    }
    #[inline]
    pub unsafe fn new(
        parent: *const btCollisionObjectWrapper,
        shape: *const btCollisionShape,
        collisionObject: *const btCollisionObject,
        worldTransform: *const btTransform,
        partId: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionObjectWrapper_btCollisionObjectWrapper(
            &mut __bindgen_tmp,
            parent,
            shape,
            collisionObject,
            worldTransform,
            partId,
            index,
        );
        __bindgen_tmp
    }
}
pub type ContactAddedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cp: *mut btManifoldPoint,
        colObj0Wrap: *const btCollisionObjectWrapper,
        partId0: ::std::os::raw::c_int,
        index0: ::std::os::raw::c_int,
        colObj1Wrap: *const btCollisionObjectWrapper,
        partId1: ::std::os::raw::c_int,
        index1: ::std::os::raw::c_int,
    ) -> bool,
>;
extern "C" {
    #[link_name = "\u{1}gContactAddedCallback"]
    pub static mut gContactAddedCallback: ContactAddedCallback;
}
/// btManifoldResult is a helper class to manage  contact results.
#[repr(C)]
#[derive(Debug)]
pub struct btManifoldResult {
    pub _base: btDiscreteCollisionDetectorInterface_Result,
    pub m_manifoldPtr: *mut btPersistentManifold,
    pub m_body0Wrap: *const btCollisionObjectWrapper,
    pub m_body1Wrap: *const btCollisionObjectWrapper,
    pub m_partId0: ::std::os::raw::c_int,
    pub m_partId1: ::std::os::raw::c_int,
    pub m_index0: ::std::os::raw::c_int,
    pub m_index1: ::std::os::raw::c_int,
    pub m_closestPointDistanceThreshold: btScalar,
}
#[test]
fn bindgen_test_layout_btManifoldResult() {
    assert_eq!(
        ::std::mem::size_of::<btManifoldResult>(),
        56usize,
        concat!("Size of: ", stringify!(btManifoldResult))
    );
    assert_eq!(
        ::std::mem::align_of::<btManifoldResult>(),
        8usize,
        concat!("Alignment of ", stringify!(btManifoldResult))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldResult)).m_manifoldPtr as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldResult),
            "::",
            stringify!(m_manifoldPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldResult)).m_body0Wrap as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldResult),
            "::",
            stringify!(m_body0Wrap)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldResult)).m_body1Wrap as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldResult),
            "::",
            stringify!(m_body1Wrap)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldResult)).m_partId0 as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldResult),
            "::",
            stringify!(m_partId0)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldResult)).m_partId1 as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldResult),
            "::",
            stringify!(m_partId1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldResult)).m_index0 as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldResult),
            "::",
            stringify!(m_index0)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btManifoldResult)).m_index1 as *const _ as usize },
        44usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldResult),
            "::",
            stringify!(m_index1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btManifoldResult)).m_closestPointDistanceThreshold as *const _ as usize
        },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btManifoldResult),
            "::",
            stringify!(m_closestPointDistanceThreshold)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResult21setPersistentManifoldEP20btPersistentManifold"]
    pub fn btManifoldResult_setPersistentManifold(
        this: *mut btManifoldResult,
        manifoldPtr: *mut btPersistentManifold,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btManifoldResult21getPersistentManifoldEv"]
    pub fn btManifoldResult_getPersistentManifold(
        this: *const btManifoldResult,
    ) -> *const btPersistentManifold;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResult21getPersistentManifoldEv"]
    pub fn btManifoldResult_getPersistentManifold1(
        this: *mut btManifoldResult,
    ) -> *mut btPersistentManifold;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResult20refreshContactPointsEv"]
    pub fn btManifoldResult_refreshContactPoints(this: *mut btManifoldResult);
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btManifoldResult12getBody0WrapEv"]
    pub fn btManifoldResult_getBody0Wrap(
        this: *const btManifoldResult,
    ) -> *const btCollisionObjectWrapper;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btManifoldResult12getBody1WrapEv"]
    pub fn btManifoldResult_getBody1Wrap(
        this: *const btManifoldResult,
    ) -> *const btCollisionObjectWrapper;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResult12setBody0WrapEPK24btCollisionObjectWrapper"]
    pub fn btManifoldResult_setBody0Wrap(
        this: *mut btManifoldResult,
        obj0Wrap: *const btCollisionObjectWrapper,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResult12setBody1WrapEPK24btCollisionObjectWrapper"]
    pub fn btManifoldResult_setBody1Wrap(
        this: *mut btManifoldResult,
        obj1Wrap: *const btCollisionObjectWrapper,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btManifoldResult16getBody0InternalEv"]
    pub fn btManifoldResult_getBody0Internal(
        this: *const btManifoldResult,
    ) -> *const btCollisionObject;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btManifoldResult16getBody1InternalEv"]
    pub fn btManifoldResult_getBody1Internal(
        this: *const btManifoldResult,
    ) -> *const btCollisionObject;
}
extern "C" {

    /// in the future we can let the user override the methods to combine restitution and friction

    #[link_name = "\u{1}_ZN16btManifoldResult28calculateCombinedRestitutionEPK17btCollisionObjectS2_"]
    pub fn btManifoldResult_calculateCombinedRestitution(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResult25calculateCombinedFrictionEPK17btCollisionObjectS2_"]
    pub fn btManifoldResult_calculateCombinedFriction(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResult32calculateCombinedRollingFrictionEPK17btCollisionObjectS2_"]
    pub fn btManifoldResult_calculateCombinedRollingFriction(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResult33calculateCombinedSpinningFrictionEPK17btCollisionObjectS2_"]
    pub fn btManifoldResult_calculateCombinedSpinningFriction(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResult31calculateCombinedContactDampingEPK17btCollisionObjectS2_"]
    pub fn btManifoldResult_calculateCombinedContactDamping(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResult33calculateCombinedContactStiffnessEPK17btCollisionObjectS2_"]
    pub fn btManifoldResult_calculateCombinedContactStiffness(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResultC1Ev"]
    pub fn btManifoldResult_btManifoldResult(this: *mut btManifoldResult);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResultC1EPK24btCollisionObjectWrapperS2_"]
    pub fn btManifoldResult_btManifoldResult1(
        this: *mut btManifoldResult,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    );
}
impl btManifoldResult {
    #[inline]
    pub unsafe fn setPersistentManifold(&mut self, manifoldPtr: *mut btPersistentManifold) {
        btManifoldResult_setPersistentManifold(self, manifoldPtr)
    }
    #[inline]
    pub unsafe fn getPersistentManifold(&self) -> *const btPersistentManifold {
        btManifoldResult_getPersistentManifold(self)
    }
    #[inline]
    pub unsafe fn getPersistentManifold1(&mut self) -> *mut btPersistentManifold {
        btManifoldResult_getPersistentManifold1(self)
    }
    #[inline]
    pub unsafe fn refreshContactPoints(&mut self) {
        btManifoldResult_refreshContactPoints(self)
    }
    #[inline]
    pub unsafe fn getBody0Wrap(&self) -> *const btCollisionObjectWrapper {
        btManifoldResult_getBody0Wrap(self)
    }
    #[inline]
    pub unsafe fn getBody1Wrap(&self) -> *const btCollisionObjectWrapper {
        btManifoldResult_getBody1Wrap(self)
    }
    #[inline]
    pub unsafe fn setBody0Wrap(&mut self, obj0Wrap: *const btCollisionObjectWrapper) {
        btManifoldResult_setBody0Wrap(self, obj0Wrap)
    }
    #[inline]
    pub unsafe fn setBody1Wrap(&mut self, obj1Wrap: *const btCollisionObjectWrapper) {
        btManifoldResult_setBody1Wrap(self, obj1Wrap)
    }
    #[inline]
    pub unsafe fn getBody0Internal(&self) -> *const btCollisionObject {
        btManifoldResult_getBody0Internal(self)
    }
    #[inline]
    pub unsafe fn getBody1Internal(&self) -> *const btCollisionObject {
        btManifoldResult_getBody1Internal(self)
    }
    #[inline]
    pub unsafe fn calculateCombinedRestitution(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar {
        btManifoldResult_calculateCombinedRestitution(body0, body1)
    }
    #[inline]
    pub unsafe fn calculateCombinedFriction(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar {
        btManifoldResult_calculateCombinedFriction(body0, body1)
    }
    #[inline]
    pub unsafe fn calculateCombinedRollingFriction(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar {
        btManifoldResult_calculateCombinedRollingFriction(body0, body1)
    }
    #[inline]
    pub unsafe fn calculateCombinedSpinningFriction(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar {
        btManifoldResult_calculateCombinedSpinningFriction(body0, body1)
    }
    #[inline]
    pub unsafe fn calculateCombinedContactDamping(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar {
        btManifoldResult_calculateCombinedContactDamping(body0, body1)
    }
    #[inline]
    pub unsafe fn calculateCombinedContactStiffness(
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> btScalar {
        btManifoldResult_calculateCombinedContactStiffness(body0, body1)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btManifoldResult_btManifoldResult(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btManifoldResult_btManifoldResult1(&mut __bindgen_tmp, body0Wrap, body1Wrap);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResultD0Ev"]
    pub fn btManifoldResult_btManifoldResult_destructor(this: *mut btManifoldResult);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResult20setShapeIdentifiersAEii"]
    pub fn btManifoldResult_setShapeIdentifiersA(
        this: *mut ::std::os::raw::c_void,
        partId0: ::std::os::raw::c_int,
        index0: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResult20setShapeIdentifiersBEii"]
    pub fn btManifoldResult_setShapeIdentifiersB(
        this: *mut ::std::os::raw::c_void,
        partId1: ::std::os::raw::c_int,
        index1: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btManifoldResult15addContactPointERK9btVector3S2_d"]
    pub fn btManifoldResult_addContactPoint(
        this: *mut ::std::os::raw::c_void,
        normalOnBInWorld: *const btVector3,
        pointInWorld: *const btVector3,
        depth: btScalar,
    );
}
pub const BroadphaseNativeTypes_BOX_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 0;
pub const BroadphaseNativeTypes_TRIANGLE_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 1;
pub const BroadphaseNativeTypes_TETRAHEDRAL_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 2;
pub const BroadphaseNativeTypes_CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 3;
pub const BroadphaseNativeTypes_CONVEX_HULL_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 4;
pub const BroadphaseNativeTypes_CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 5;
pub const BroadphaseNativeTypes_CUSTOM_POLYHEDRAL_SHAPE_TYPE: BroadphaseNativeTypes = 6;
pub const BroadphaseNativeTypes_IMPLICIT_CONVEX_SHAPES_START_HERE: BroadphaseNativeTypes = 7;
pub const BroadphaseNativeTypes_SPHERE_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 8;
pub const BroadphaseNativeTypes_MULTI_SPHERE_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 9;
pub const BroadphaseNativeTypes_CAPSULE_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 10;
pub const BroadphaseNativeTypes_CONE_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 11;
pub const BroadphaseNativeTypes_CONVEX_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 12;
pub const BroadphaseNativeTypes_CYLINDER_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 13;
pub const BroadphaseNativeTypes_UNIFORM_SCALING_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 14;
pub const BroadphaseNativeTypes_MINKOWSKI_SUM_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 15;
pub const BroadphaseNativeTypes_MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 16;
pub const BroadphaseNativeTypes_BOX_2D_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 17;
pub const BroadphaseNativeTypes_CONVEX_2D_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 18;
pub const BroadphaseNativeTypes_CUSTOM_CONVEX_SHAPE_TYPE: BroadphaseNativeTypes = 19;
pub const BroadphaseNativeTypes_CONCAVE_SHAPES_START_HERE: BroadphaseNativeTypes = 20;
pub const BroadphaseNativeTypes_TRIANGLE_MESH_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 21;
pub const BroadphaseNativeTypes_SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 22;
pub const BroadphaseNativeTypes_FAST_CONCAVE_MESH_PROXYTYPE: BroadphaseNativeTypes = 23;
pub const BroadphaseNativeTypes_TERRAIN_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 24;
pub const BroadphaseNativeTypes_GIMPACT_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 25;
pub const BroadphaseNativeTypes_MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE: BroadphaseNativeTypes = 26;
pub const BroadphaseNativeTypes_EMPTY_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 27;
pub const BroadphaseNativeTypes_STATIC_PLANE_PROXYTYPE: BroadphaseNativeTypes = 28;
pub const BroadphaseNativeTypes_CUSTOM_CONCAVE_SHAPE_TYPE: BroadphaseNativeTypes = 29;
pub const BroadphaseNativeTypes_CONCAVE_SHAPES_END_HERE: BroadphaseNativeTypes = 30;
pub const BroadphaseNativeTypes_COMPOUND_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 31;
pub const BroadphaseNativeTypes_SOFTBODY_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 32;
pub const BroadphaseNativeTypes_HFFLUID_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 33;
pub const BroadphaseNativeTypes_HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 34;
pub const BroadphaseNativeTypes_INVALID_SHAPE_PROXYTYPE: BroadphaseNativeTypes = 35;
pub const BroadphaseNativeTypes_MAX_BROADPHASE_COLLISION_TYPES: BroadphaseNativeTypes = 36;
pub type BroadphaseNativeTypes = ::std::os::raw::c_uint;
/// The btBroadphaseProxy is the main class that can be used with the Bullet broadphases.
/// It stores collision shape type information, collision filter information and a client object, typically a btCollisionObject or btRigidBody.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btBroadphaseProxy {
    pub m_clientObject: *mut ::std::os::raw::c_void,
    pub m_collisionFilterGroup: ::std::os::raw::c_int,
    pub m_collisionFilterMask: ::std::os::raw::c_int,
    pub m_uniqueId: ::std::os::raw::c_int,
    pub m_aabbMin: btVector3,
    pub m_aabbMax: btVector3,
}
pub const btBroadphaseProxy_CollisionFilterGroups_DefaultFilter : btBroadphaseProxy_CollisionFilterGroups = 1 ;
pub const btBroadphaseProxy_CollisionFilterGroups_StaticFilter : btBroadphaseProxy_CollisionFilterGroups = 2 ;
pub const btBroadphaseProxy_CollisionFilterGroups_KinematicFilter : btBroadphaseProxy_CollisionFilterGroups = 4 ;
pub const btBroadphaseProxy_CollisionFilterGroups_DebrisFilter : btBroadphaseProxy_CollisionFilterGroups = 8 ;
pub const btBroadphaseProxy_CollisionFilterGroups_SensorTrigger : btBroadphaseProxy_CollisionFilterGroups = 16 ;
pub const btBroadphaseProxy_CollisionFilterGroups_CharacterFilter : btBroadphaseProxy_CollisionFilterGroups = 32 ;
pub const btBroadphaseProxy_CollisionFilterGroups_AllFilter : btBroadphaseProxy_CollisionFilterGroups = -1 ;
pub type btBroadphaseProxy_CollisionFilterGroups = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_btBroadphaseProxy() {
    assert_eq!(
        ::std::mem::size_of::<btBroadphaseProxy>(),
        88usize,
        concat!("Size of: ", stringify!(btBroadphaseProxy))
    );
    assert_eq!(
        ::std::mem::align_of::<btBroadphaseProxy>(),
        8usize,
        concat!("Alignment of ", stringify!(btBroadphaseProxy))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBroadphaseProxy)).m_clientObject as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBroadphaseProxy),
            "::",
            stringify!(m_clientObject)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBroadphaseProxy)).m_collisionFilterGroup as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBroadphaseProxy),
            "::",
            stringify!(m_collisionFilterGroup)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBroadphaseProxy)).m_collisionFilterMask as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBroadphaseProxy),
            "::",
            stringify!(m_collisionFilterMask)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBroadphaseProxy)).m_uniqueId as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBroadphaseProxy),
            "::",
            stringify!(m_uniqueId)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBroadphaseProxy)).m_aabbMin as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBroadphaseProxy),
            "::",
            stringify!(m_aabbMin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBroadphaseProxy)).m_aabbMax as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBroadphaseProxy),
            "::",
            stringify!(m_aabbMax)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btBroadphaseProxy6getUidEv"]
    pub fn btBroadphaseProxy_getUid(this: *const btBroadphaseProxy) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btBroadphaseProxy12isPolyhedralEi"]
    pub fn btBroadphaseProxy_isPolyhedral(proxyType: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btBroadphaseProxy8isConvexEi"]
    pub fn btBroadphaseProxy_isConvex(proxyType: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btBroadphaseProxy11isNonMovingEi"]
    pub fn btBroadphaseProxy_isNonMoving(proxyType: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btBroadphaseProxy9isConcaveEi"]
    pub fn btBroadphaseProxy_isConcave(proxyType: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btBroadphaseProxy10isCompoundEi"]
    pub fn btBroadphaseProxy_isCompound(proxyType: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btBroadphaseProxy10isSoftBodyEi"]
    pub fn btBroadphaseProxy_isSoftBody(proxyType: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btBroadphaseProxy10isInfiniteEi"]
    pub fn btBroadphaseProxy_isInfinite(proxyType: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btBroadphaseProxy10isConvex2dEi"]
    pub fn btBroadphaseProxy_isConvex2d(proxyType: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btBroadphaseProxyC1Ev"]
    pub fn btBroadphaseProxy_btBroadphaseProxy(this: *mut btBroadphaseProxy);
}
extern "C" {
    #[link_name = "\u{1}_ZN17btBroadphaseProxyC1ERK9btVector3S2_Pvii"]
    pub fn btBroadphaseProxy_btBroadphaseProxy1(
        this: *mut btBroadphaseProxy,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
impl btBroadphaseProxy {
    #[inline]
    pub unsafe fn getUid(&self) -> ::std::os::raw::c_int {
        btBroadphaseProxy_getUid(self)
    }
    #[inline]
    pub unsafe fn isPolyhedral(proxyType: ::std::os::raw::c_int) -> bool {
        btBroadphaseProxy_isPolyhedral(proxyType)
    }
    #[inline]
    pub unsafe fn isConvex(proxyType: ::std::os::raw::c_int) -> bool {
        btBroadphaseProxy_isConvex(proxyType)
    }
    #[inline]
    pub unsafe fn isNonMoving(proxyType: ::std::os::raw::c_int) -> bool {
        btBroadphaseProxy_isNonMoving(proxyType)
    }
    #[inline]
    pub unsafe fn isConcave(proxyType: ::std::os::raw::c_int) -> bool {
        btBroadphaseProxy_isConcave(proxyType)
    }
    #[inline]
    pub unsafe fn isCompound(proxyType: ::std::os::raw::c_int) -> bool {
        btBroadphaseProxy_isCompound(proxyType)
    }
    #[inline]
    pub unsafe fn isSoftBody(proxyType: ::std::os::raw::c_int) -> bool {
        btBroadphaseProxy_isSoftBody(proxyType)
    }
    #[inline]
    pub unsafe fn isInfinite(proxyType: ::std::os::raw::c_int) -> bool {
        btBroadphaseProxy_isInfinite(proxyType)
    }
    #[inline]
    pub unsafe fn isConvex2d(proxyType: ::std::os::raw::c_int) -> bool {
        btBroadphaseProxy_isConvex2d(proxyType)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBroadphaseProxy_btBroadphaseProxy(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBroadphaseProxy_btBroadphaseProxy1(
            &mut __bindgen_tmp,
            aabbMin,
            aabbMax,
            userPtr,
            collisionFilterGroup,
            collisionFilterMask,
        );
        __bindgen_tmp
    }
}
/// The btBroadphasePair class contains a pair of aabb-overlapping objects.
/// A btDispatcher can search a btCollisionAlgorithm that performs exact/narrowphase collision detection on the actual collision shapes.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btBroadphasePair {
    pub m_pProxy0: *mut btBroadphaseProxy,
    pub m_pProxy1: *mut btBroadphaseProxy,
    pub m_algorithm: *mut btCollisionAlgorithm,
    pub __bindgen_anon_1: btBroadphasePair__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btBroadphasePair__bindgen_ty_1 {
    pub m_internalInfo1: *mut ::std::os::raw::c_void,
    pub m_internalTmpValue: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_btBroadphasePair__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btBroadphasePair__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(btBroadphasePair__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<btBroadphasePair__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(btBroadphasePair__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btBroadphasePair__bindgen_ty_1)).m_internalInfo1 as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBroadphasePair__bindgen_ty_1),
            "::",
            stringify!(m_internalInfo1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btBroadphasePair__bindgen_ty_1)).m_internalTmpValue as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBroadphasePair__bindgen_ty_1),
            "::",
            stringify!(m_internalTmpValue)
        )
    );
}
#[test]
fn bindgen_test_layout_btBroadphasePair() {
    assert_eq!(
        ::std::mem::size_of::<btBroadphasePair>(),
        32usize,
        concat!("Size of: ", stringify!(btBroadphasePair))
    );
    assert_eq!(
        ::std::mem::align_of::<btBroadphasePair>(),
        8usize,
        concat!("Alignment of ", stringify!(btBroadphasePair))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBroadphasePair)).m_pProxy0 as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBroadphasePair),
            "::",
            stringify!(m_pProxy0)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBroadphasePair)).m_pProxy1 as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBroadphasePair),
            "::",
            stringify!(m_pProxy1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBroadphasePair)).m_algorithm as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBroadphasePair),
            "::",
            stringify!(m_algorithm)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btBroadphasePairC1Ev"]
    pub fn btBroadphasePair_btBroadphasePair(this: *mut btBroadphasePair);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btBroadphasePairC1ERKS_"]
    pub fn btBroadphasePair_btBroadphasePair1(
        this: *mut btBroadphasePair,
        other: *const btBroadphasePair,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btBroadphasePairC1ER17btBroadphaseProxyS1_"]
    pub fn btBroadphasePair_btBroadphasePair2(
        this: *mut btBroadphasePair,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    );
}
impl btBroadphasePair {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBroadphasePair_btBroadphasePair(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(other: *const btBroadphasePair) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBroadphasePair_btBroadphasePair1(&mut __bindgen_tmp, other);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(proxy0: *mut btBroadphaseProxy, proxy1: *mut btBroadphaseProxy) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBroadphasePair_btBroadphasePair2(&mut __bindgen_tmp, proxy0, proxy1);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btBroadphasePairSortPredicate {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_btBroadphasePairSortPredicate() {
    assert_eq!(
        ::std::mem::size_of::<btBroadphasePairSortPredicate>(),
        1usize,
        concat!("Size of: ", stringify!(btBroadphasePairSortPredicate))
    );
    assert_eq!(
        ::std::mem::align_of::<btBroadphasePairSortPredicate>(),
        1usize,
        concat!("Alignment of ", stringify!(btBroadphasePairSortPredicate))
    );
}
#[repr(C)]
pub struct btCollisionAlgorithmCreateFunc__bindgen_vtable(::std::os::raw::c_void);
/// Used by the btCollisionDispatcher to register and create instances for btCollisionAlgorithm
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionAlgorithmCreateFunc {
    pub vtable_: *const btCollisionAlgorithmCreateFunc__bindgen_vtable,
    pub m_swapped: bool,
}
#[test]
fn bindgen_test_layout_btCollisionAlgorithmCreateFunc() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionAlgorithmCreateFunc>(),
        16usize,
        concat!("Size of: ", stringify!(btCollisionAlgorithmCreateFunc))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionAlgorithmCreateFunc>(),
        8usize,
        concat!("Alignment of ", stringify!(btCollisionAlgorithmCreateFunc))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionAlgorithmCreateFunc)).m_swapped as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionAlgorithmCreateFunc),
            "::",
            stringify!(m_swapped)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btCollisionAlgorithmCreateFuncC1Ev"]
    pub fn btCollisionAlgorithmCreateFunc_btCollisionAlgorithmCreateFunc(
        this: *mut btCollisionAlgorithmCreateFunc,
    );
}
impl btCollisionAlgorithmCreateFunc {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionAlgorithmCreateFunc_btCollisionAlgorithmCreateFunc(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN30btCollisionAlgorithmCreateFuncD0Ev"]
    pub fn btCollisionAlgorithmCreateFunc_btCollisionAlgorithmCreateFunc_destructor(
        this: *mut btCollisionAlgorithmCreateFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btCollisionAlgorithmCreateFunc24CreateCollisionAlgorithmER36btCollisionAlgorithmConstructionInfoPK24btCollisionObjectWrapperS4_"]
    pub fn btCollisionAlgorithmCreateFunc_CreateCollisionAlgorithm(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    ) -> *mut btCollisionAlgorithm;
}
/// user can override this nearcallback for collision filtering and more finegrained control over collision detection
pub type btNearCallback = ::std::option::Option<
    unsafe extern "C" fn(
        collisionPair: *mut btBroadphasePair,
        dispatcher: *mut btCollisionDispatcher,
        dispatchInfo: *const btDispatcherInfo,
    ),
>;
/// btCollisionDispatcher supports algorithms that handle ConvexConvex and ConvexConcave collision pairs.
/// Time of Impact, Closest Points and Penetration Depth.
#[repr(C)]
pub struct btCollisionDispatcher {
    pub _base: btDispatcher,
    pub m_dispatcherFlags: ::std::os::raw::c_int,
    pub m_manifoldsPtr: btAlignedObjectArray<*mut btPersistentManifold>,
    pub m_defaultManifoldResult: btManifoldResult,
    pub m_nearCallback: btNearCallback,
    pub m_collisionAlgorithmPoolAllocator: *mut btPoolAllocator,
    pub m_persistentManifoldPoolAllocator: *mut btPoolAllocator,
    pub m_doubleDispatchContactPoints: [[*mut btCollisionAlgorithmCreateFunc; 36usize]; 36usize],
    pub m_doubleDispatchClosestPoints: [[*mut btCollisionAlgorithmCreateFunc; 36usize]; 36usize],
    pub m_collisionConfiguration: *mut btCollisionConfiguration,
}
pub const btCollisionDispatcher_DispatcherFlags_CD_STATIC_STATIC_REPORTED : btCollisionDispatcher_DispatcherFlags = 1 ;
pub const btCollisionDispatcher_DispatcherFlags_CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD : btCollisionDispatcher_DispatcherFlags = 2 ;
pub const btCollisionDispatcher_DispatcherFlags_CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION : btCollisionDispatcher_DispatcherFlags = 4 ;
pub type btCollisionDispatcher_DispatcherFlags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_btCollisionDispatcher() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionDispatcher>(),
        20872usize,
        concat!("Size of: ", stringify!(btCollisionDispatcher))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionDispatcher>(),
        8usize,
        concat!("Alignment of ", stringify!(btCollisionDispatcher))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionDispatcher)).m_dispatcherFlags as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionDispatcher),
            "::",
            stringify!(m_dispatcherFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionDispatcher)).m_manifoldsPtr as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionDispatcher),
            "::",
            stringify!(m_manifoldsPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionDispatcher)).m_defaultManifoldResult as *const _ as usize
        },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionDispatcher),
            "::",
            stringify!(m_defaultManifoldResult)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionDispatcher)).m_nearCallback as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionDispatcher),
            "::",
            stringify!(m_nearCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionDispatcher)).m_collisionAlgorithmPoolAllocator as *const _
                as usize
        },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionDispatcher),
            "::",
            stringify!(m_collisionAlgorithmPoolAllocator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionDispatcher)).m_persistentManifoldPoolAllocator as *const _
                as usize
        },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionDispatcher),
            "::",
            stringify!(m_persistentManifoldPoolAllocator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionDispatcher)).m_doubleDispatchContactPoints as *const _
                as usize
        },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionDispatcher),
            "::",
            stringify!(m_doubleDispatchContactPoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionDispatcher)).m_doubleDispatchClosestPoints as *const _
                as usize
        },
        10496usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionDispatcher),
            "::",
            stringify!(m_doubleDispatchClosestPoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionDispatcher)).m_collisionConfiguration as *const _ as usize
        },
        20864usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionDispatcher),
            "::",
            stringify!(m_collisionConfiguration)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btCollisionDispatcher18getDispatcherFlagsEv"]
    pub fn btCollisionDispatcher_getDispatcherFlags(
        this: *const btCollisionDispatcher,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher18setDispatcherFlagsEi"]
    pub fn btCollisionDispatcher_setDispatcherFlags(
        this: *mut btCollisionDispatcher,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// registerCollisionCreateFunc allows registration of custom/alternative collision create functions

    #[link_name = "\u{1}_ZN21btCollisionDispatcher27registerCollisionCreateFuncEiiP30btCollisionAlgorithmCreateFunc"]
    pub fn btCollisionDispatcher_registerCollisionCreateFunc(
        this: *mut btCollisionDispatcher,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
        createFunc: *mut btCollisionAlgorithmCreateFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher31registerClosestPointsCreateFuncEiiP30btCollisionAlgorithmCreateFunc"]
    pub fn btCollisionDispatcher_registerClosestPointsCreateFunc(
        this: *mut btCollisionDispatcher,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
        createFunc: *mut btCollisionAlgorithmCreateFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btCollisionDispatcher26getManifoldByIndexInternalEi"]
    pub fn btCollisionDispatcher_getManifoldByIndexInternal1(
        this: *const btCollisionDispatcher,
        index: ::std::os::raw::c_int,
    ) -> *const btPersistentManifold;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher15setNearCallbackEPFvR16btBroadphasePairRS_RK16btDispatcherInfoE"]
    pub fn btCollisionDispatcher_setNearCallback(
        this: *mut btCollisionDispatcher,
        nearCallback: btNearCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btCollisionDispatcher15getNearCallbackEv"]
    pub fn btCollisionDispatcher_getNearCallback(
        this: *const btCollisionDispatcher,
    ) -> btNearCallback;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher19defaultNearCallbackER16btBroadphasePairRS_RK16btDispatcherInfo"]
    pub fn btCollisionDispatcher_defaultNearCallback(
        collisionPair: *mut btBroadphasePair,
        dispatcher: *mut btCollisionDispatcher,
        dispatchInfo: *const btDispatcherInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher25getCollisionConfigurationEv"]
    pub fn btCollisionDispatcher_getCollisionConfiguration(
        this: *mut btCollisionDispatcher,
    ) -> *mut btCollisionConfiguration;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btCollisionDispatcher25getCollisionConfigurationEv"]
    pub fn btCollisionDispatcher_getCollisionConfiguration1(
        this: *const btCollisionDispatcher,
    ) -> *const btCollisionConfiguration;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher25setCollisionConfigurationEP24btCollisionConfiguration"]
    pub fn btCollisionDispatcher_setCollisionConfiguration(
        this: *mut btCollisionDispatcher,
        config: *mut btCollisionConfiguration,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcherC1EP24btCollisionConfiguration"]
    pub fn btCollisionDispatcher_btCollisionDispatcher(
        this: *mut btCollisionDispatcher,
        collisionConfiguration: *mut btCollisionConfiguration,
    );
}
impl btCollisionDispatcher {
    #[inline]
    pub unsafe fn getDispatcherFlags(&self) -> ::std::os::raw::c_int {
        btCollisionDispatcher_getDispatcherFlags(self)
    }
    #[inline]
    pub unsafe fn setDispatcherFlags(&mut self, flags: ::std::os::raw::c_int) {
        btCollisionDispatcher_setDispatcherFlags(self, flags)
    }
    #[inline]
    pub unsafe fn registerCollisionCreateFunc(
        &mut self,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
        createFunc: *mut btCollisionAlgorithmCreateFunc,
    ) {
        btCollisionDispatcher_registerCollisionCreateFunc(self, proxyType0, proxyType1, createFunc)
    }
    #[inline]
    pub unsafe fn registerClosestPointsCreateFunc(
        &mut self,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
        createFunc: *mut btCollisionAlgorithmCreateFunc,
    ) {
        btCollisionDispatcher_registerClosestPointsCreateFunc(
            self,
            proxyType0,
            proxyType1,
            createFunc,
        )
    }
    #[inline]
    pub unsafe fn getManifoldByIndexInternal(
        &self,
        index: ::std::os::raw::c_int,
    ) -> *const btPersistentManifold {
        btCollisionDispatcher_getManifoldByIndexInternal1(self, index)
    }
    #[inline]
    pub unsafe fn setNearCallback(&mut self, nearCallback: btNearCallback) {
        btCollisionDispatcher_setNearCallback(self, nearCallback)
    }
    #[inline]
    pub unsafe fn getNearCallback(&self) -> btNearCallback {
        btCollisionDispatcher_getNearCallback(self)
    }
    #[inline]
    pub unsafe fn defaultNearCallback(
        collisionPair: *mut btBroadphasePair,
        dispatcher: *mut btCollisionDispatcher,
        dispatchInfo: *const btDispatcherInfo,
    ) {
        btCollisionDispatcher_defaultNearCallback(collisionPair, dispatcher, dispatchInfo)
    }
    #[inline]
    pub unsafe fn getCollisionConfiguration(&mut self) -> *mut btCollisionConfiguration {
        btCollisionDispatcher_getCollisionConfiguration(self)
    }
    #[inline]
    pub unsafe fn getCollisionConfiguration1(&self) -> *const btCollisionConfiguration {
        btCollisionDispatcher_getCollisionConfiguration1(self)
    }
    #[inline]
    pub unsafe fn setCollisionConfiguration(&mut self, config: *mut btCollisionConfiguration) {
        btCollisionDispatcher_setCollisionConfiguration(self, config)
    }
    #[inline]
    pub unsafe fn new(collisionConfiguration: *mut btCollisionConfiguration) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionDispatcher_btCollisionDispatcher(&mut __bindgen_tmp, collisionConfiguration);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btCollisionDispatcher15getNumManifoldsEv"]
    pub fn btCollisionDispatcher_getNumManifolds(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher26getInternalManifoldPointerEv"]
    pub fn btCollisionDispatcher_getInternalManifoldPointer(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut *mut btPersistentManifold;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher26getManifoldByIndexInternalEi"]
    pub fn btCollisionDispatcher_getManifoldByIndexInternal(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
    ) -> *mut btPersistentManifold;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcherD1Ev"]
    pub fn btCollisionDispatcher_btCollisionDispatcher_destructor(this: *mut btCollisionDispatcher);
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher14getNewManifoldEPK17btCollisionObjectS2_"]
    pub fn btCollisionDispatcher_getNewManifold(
        this: *mut ::std::os::raw::c_void,
        b0: *const btCollisionObject,
        b1: *const btCollisionObject,
    ) -> *mut btPersistentManifold;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher15releaseManifoldEP20btPersistentManifold"]
    pub fn btCollisionDispatcher_releaseManifold(
        this: *mut ::std::os::raw::c_void,
        manifold: *mut btPersistentManifold,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher13clearManifoldEP20btPersistentManifold"]
    pub fn btCollisionDispatcher_clearManifold(
        this: *mut ::std::os::raw::c_void,
        manifold: *mut btPersistentManifold,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher13findAlgorithmEPK24btCollisionObjectWrapperS2_P20btPersistentManifold22ebtDispatcherQueryType"]
    pub fn btCollisionDispatcher_findAlgorithm(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        sharedManifold: *mut btPersistentManifold,
        queryType: ebtDispatcherQueryType,
    ) -> *mut btCollisionAlgorithm;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher14needsCollisionEPK17btCollisionObjectS2_"]
    pub fn btCollisionDispatcher_needsCollision(
        this: *mut ::std::os::raw::c_void,
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher13needsResponseEPK17btCollisionObjectS2_"]
    pub fn btCollisionDispatcher_needsResponse(
        this: *mut ::std::os::raw::c_void,
        body0: *const btCollisionObject,
        body1: *const btCollisionObject,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher25dispatchAllCollisionPairsEP22btOverlappingPairCacheRK16btDispatcherInfoP12btDispatcher"]
    pub fn btCollisionDispatcher_dispatchAllCollisionPairs(
        this: *mut ::std::os::raw::c_void,
        pairCache: *mut btOverlappingPairCache,
        dispatchInfo: *const btDispatcherInfo,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher26allocateCollisionAlgorithmEi"]
    pub fn btCollisionDispatcher_allocateCollisionAlgorithm(
        this: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher22freeCollisionAlgorithmEPv"]
    pub fn btCollisionDispatcher_freeCollisionAlgorithm(
        this: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btCollisionDispatcher23getInternalManifoldPoolEv"]
    pub fn btCollisionDispatcher_getInternalManifoldPool(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btPoolAllocator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btCollisionDispatcher23getInternalManifoldPoolEv"]
    pub fn btCollisionDispatcher_getInternalManifoldPool1(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btPoolAllocator;
}
#[repr(C)]
pub struct btBroadphaseAabbCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btBroadphaseAabbCallback {
    pub vtable_: *const btBroadphaseAabbCallback__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btBroadphaseAabbCallback() {
    assert_eq!(
        ::std::mem::size_of::<btBroadphaseAabbCallback>(),
        8usize,
        concat!("Size of: ", stringify!(btBroadphaseAabbCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<btBroadphaseAabbCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(btBroadphaseAabbCallback))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN24btBroadphaseAabbCallbackD0Ev"]
    pub fn btBroadphaseAabbCallback_btBroadphaseAabbCallback_destructor(
        this: *mut btBroadphaseAabbCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN24btBroadphaseAabbCallback7processEPK17btBroadphaseProxy"]
    pub fn btBroadphaseAabbCallback_process(
        this: *mut ::std::os::raw::c_void,
        proxy: *const btBroadphaseProxy,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct btBroadphaseRayCallback {
    pub _base: btBroadphaseAabbCallback,
    /// added some cached data to accelerate ray-AABB tests
    pub m_rayDirectionInverse: btVector3,
    pub m_signs: [::std::os::raw::c_uint; 3usize],
    pub m_lambda_max: btScalar,
}
#[test]
fn bindgen_test_layout_btBroadphaseRayCallback() {
    assert_eq!(
        ::std::mem::size_of::<btBroadphaseRayCallback>(),
        64usize,
        concat!("Size of: ", stringify!(btBroadphaseRayCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<btBroadphaseRayCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(btBroadphaseRayCallback))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btBroadphaseRayCallback)).m_rayDirectionInverse as *const _ as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBroadphaseRayCallback),
            "::",
            stringify!(m_rayDirectionInverse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBroadphaseRayCallback)).m_signs as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBroadphaseRayCallback),
            "::",
            stringify!(m_signs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBroadphaseRayCallback)).m_lambda_max as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBroadphaseRayCallback),
            "::",
            stringify!(m_lambda_max)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btBroadphaseRayCallbackC2Ev"]
    pub fn btBroadphaseRayCallback_btBroadphaseRayCallback(this: *mut btBroadphaseRayCallback);
}
impl btBroadphaseRayCallback {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBroadphaseRayCallback_btBroadphaseRayCallback(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN23btBroadphaseRayCallbackD0Ev"]
    pub fn btBroadphaseRayCallback_btBroadphaseRayCallback_destructor(
        this: *mut btBroadphaseRayCallback,
    );
}
#[repr(C)]
pub struct btBroadphaseInterface__bindgen_vtable(::std::os::raw::c_void);
/// The btBroadphaseInterface class provides an interface to detect aabb-overlapping object pairs.
/// Some implementations for this broadphase interface include btAxisSweep3, bt32BitAxisSweep3 and btDbvtBroadphase.
/// The actual overlapping pair management, storage, adding and removing of pairs is dealt by the btOverlappingPairCache class.
#[repr(C)]
#[derive(Debug)]
pub struct btBroadphaseInterface {
    pub vtable_: *const btBroadphaseInterface__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btBroadphaseInterface() {
    assert_eq!(
        ::std::mem::size_of::<btBroadphaseInterface>(),
        8usize,
        concat!("Size of: ", stringify!(btBroadphaseInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<btBroadphaseInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(btBroadphaseInterface))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btBroadphaseInterfaceD0Ev"]
    pub fn btBroadphaseInterface_btBroadphaseInterface_destructor(this: *mut btBroadphaseInterface);
}
extern "C" {
    #[link_name = "\u{1}_ZN21btBroadphaseInterface11createProxyERK9btVector3S2_iPviiP12btDispatcher"]
    pub fn btBroadphaseInterface_createProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        shapeType: ::std::os::raw::c_int,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
        dispatcher: *mut btDispatcher,
    ) -> *mut btBroadphaseProxy;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btBroadphaseInterface12destroyProxyEP17btBroadphaseProxyP12btDispatcher"]
    pub fn btBroadphaseInterface_destroyProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btBroadphaseInterface7setAabbEP17btBroadphaseProxyRK9btVector3S4_P12btDispatcher"]
    pub fn btBroadphaseInterface_setAabb(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btBroadphaseInterface7getAabbEP17btBroadphaseProxyR9btVector3S3_"]
    pub fn btBroadphaseInterface_getAabb(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btBroadphaseInterface7rayTestERK9btVector3S2_R23btBroadphaseRayCallbackS2_S2_"]
    pub fn btBroadphaseInterface_rayTest(
        this: *mut ::std::os::raw::c_void,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        rayCallback: *mut btBroadphaseRayCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btBroadphaseInterface8aabbTestERK9btVector3S2_R24btBroadphaseAabbCallback"]
    pub fn btBroadphaseInterface_aabbTest(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        callback: *mut btBroadphaseAabbCallback,
    );
}
extern "C" {

    /// calculateOverlappingPairs is optional: incremental algorithms (sweep and prune) might do it during the set aabb

    #[link_name = "\u{1}_ZN21btBroadphaseInterface25calculateOverlappingPairsEP12btDispatcher"]
    pub fn btBroadphaseInterface_calculateOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btBroadphaseInterface23getOverlappingPairCacheEv"]
    pub fn btBroadphaseInterface_getOverlappingPairCache(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btOverlappingPairCache;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btBroadphaseInterface23getOverlappingPairCacheEv"]
    pub fn btBroadphaseInterface_getOverlappingPairCache1(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btOverlappingPairCache;
}
extern "C" {

    /// getAabb returns the axis aligned bounding box in the 'global' coordinate frame
    /// ///will add some transform later

    #[link_name = "\u{1}_ZNK21btBroadphaseInterface17getBroadphaseAabbER9btVector3S1_"]
    pub fn btBroadphaseInterface_getBroadphaseAabb(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {

    /// reset broadphase internal structures, to ensure determinism/reproducability

    #[link_name = "\u{1}_ZN21btBroadphaseInterface9resetPoolEP12btDispatcher"]
    pub fn btBroadphaseInterface_resetPool(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btBroadphaseInterface10printStatsEv"]
    pub fn btBroadphaseInterface_printStats(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
pub struct btOverlappingPairCallback__bindgen_vtable(::std::os::raw::c_void);
/// The btOverlappingPairCallback class is an additional optional broadphase user callback for adding/removing overlapping pairs, similar interface to btOverlappingPairCache.
#[repr(C)]
#[derive(Debug)]
pub struct btOverlappingPairCallback {
    pub vtable_: *const btOverlappingPairCallback__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btOverlappingPairCallback() {
    assert_eq!(
        ::std::mem::size_of::<btOverlappingPairCallback>(),
        8usize,
        concat!("Size of: ", stringify!(btOverlappingPairCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<btOverlappingPairCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(btOverlappingPairCallback))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN25btOverlappingPairCallbackC2Ev"]
    pub fn btOverlappingPairCallback_btOverlappingPairCallback(
        this: *mut btOverlappingPairCallback,
    );
}
impl btOverlappingPairCallback {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btOverlappingPairCallback_btOverlappingPairCallback(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN25btOverlappingPairCallbackD0Ev"]
    pub fn btOverlappingPairCallback_btOverlappingPairCallback_destructor(
        this: *mut btOverlappingPairCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN25btOverlappingPairCallback18addOverlappingPairEP17btBroadphaseProxyS1_"]
    pub fn btOverlappingPairCallback_addOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> *mut btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZN25btOverlappingPairCallback21removeOverlappingPairEP17btBroadphaseProxyS1_P12btDispatcher"]
    pub fn btOverlappingPairCallback_removeOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN25btOverlappingPairCallback37removeOverlappingPairsContainingProxyEP17btBroadphaseProxyP12btDispatcher"]
    pub fn btOverlappingPairCallback_removeOverlappingPairsContainingProxy(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
pub type btBroadphasePairArray = btAlignedObjectArray<btBroadphasePair>;
#[repr(C)]
pub struct btOverlapCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btOverlapCallback {
    pub vtable_: *const btOverlapCallback__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btOverlapCallback() {
    assert_eq!(
        ::std::mem::size_of::<btOverlapCallback>(),
        8usize,
        concat!("Size of: ", stringify!(btOverlapCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<btOverlapCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(btOverlapCallback))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btOverlapCallbackD0Ev"]
    pub fn btOverlapCallback_btOverlapCallback_destructor(this: *mut btOverlapCallback);
}
extern "C" {
    #[link_name = "\u{1}_ZN17btOverlapCallback14processOverlapER16btBroadphasePair"]
    pub fn btOverlapCallback_processOverlap(
        this: *mut ::std::os::raw::c_void,
        pair: *mut btBroadphasePair,
    ) -> bool;
}
#[repr(C)]
pub struct btOverlapFilterCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btOverlapFilterCallback {
    pub vtable_: *const btOverlapFilterCallback__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btOverlapFilterCallback() {
    assert_eq!(
        ::std::mem::size_of::<btOverlapFilterCallback>(),
        8usize,
        concat!("Size of: ", stringify!(btOverlapFilterCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<btOverlapFilterCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(btOverlapFilterCallback))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btOverlapFilterCallbackD0Ev"]
    pub fn btOverlapFilterCallback_btOverlapFilterCallback_destructor(
        this: *mut btOverlapFilterCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btOverlapFilterCallback23needBroadphaseCollisionEP17btBroadphaseProxyS1_"]
    pub fn btOverlapFilterCallback_needBroadphaseCollision(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}gRemovePairs"]
    pub static mut gRemovePairs: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}gAddedPairs"]
    pub static mut gAddedPairs: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}gFindPairs"]
    pub static mut gFindPairs: ::std::os::raw::c_int;
}
pub const BT_NULL_PAIR: ::std::os::raw::c_int = -1;
/// The btOverlappingPairCache provides an interface for overlapping pair management (add, remove, storage), used by the btBroadphaseInterface broadphases.
/// The btHashedOverlappingPairCache and btSortedOverlappingPairCache classes are two implementations.
#[repr(C)]
#[derive(Debug)]
pub struct btOverlappingPairCache {
    pub _base: btOverlappingPairCallback,
}
#[test]
fn bindgen_test_layout_btOverlappingPairCache() {
    assert_eq!(
        ::std::mem::size_of::<btOverlappingPairCache>(),
        8usize,
        concat!("Size of: ", stringify!(btOverlappingPairCache))
    );
    assert_eq!(
        ::std::mem::align_of::<btOverlappingPairCache>(),
        8usize,
        concat!("Alignment of ", stringify!(btOverlappingPairCache))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22btOverlappingPairCacheD0Ev"]
    pub fn btOverlappingPairCache_btOverlappingPairCache_destructor(
        this: *mut btOverlappingPairCache,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22btOverlappingPairCache26getOverlappingPairArrayPtrEv"]
    pub fn btOverlappingPairCache_getOverlappingPairArrayPtr(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZNK22btOverlappingPairCache26getOverlappingPairArrayPtrEv"]
    pub fn btOverlappingPairCache_getOverlappingPairArrayPtr1(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZN22btOverlappingPairCache23getOverlappingPairArrayEv"]
    pub fn btOverlappingPairCache_getOverlappingPairArray(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btBroadphasePairArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN22btOverlappingPairCache20cleanOverlappingPairER16btBroadphasePairP12btDispatcher"]
    pub fn btOverlappingPairCache_cleanOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        pair: *mut btBroadphasePair,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK22btOverlappingPairCache22getNumOverlappingPairsEv"]
    pub fn btOverlappingPairCache_getNumOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN22btOverlappingPairCache19cleanProxyFromPairsEP17btBroadphaseProxyP12btDispatcher"]
    pub fn btOverlappingPairCache_cleanProxyFromPairs(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22btOverlappingPairCache24setOverlapFilterCallbackEP23btOverlapFilterCallback"]
    pub fn btOverlappingPairCache_setOverlapFilterCallback(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btOverlapFilterCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22btOverlappingPairCache26processAllOverlappingPairsEP17btOverlapCallbackP12btDispatcher"]
    pub fn btOverlappingPairCache_processAllOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btOverlapCallback,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22btOverlappingPairCache8findPairEP17btBroadphaseProxyS1_"]
    pub fn btOverlappingPairCache_findPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> *mut btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZN22btOverlappingPairCache18hasDeferredRemovalEv"]
    pub fn btOverlappingPairCache_hasDeferredRemoval(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN22btOverlappingPairCache28setInternalGhostPairCallbackEP25btOverlappingPairCallback"]
    pub fn btOverlappingPairCache_setInternalGhostPairCallback(
        this: *mut ::std::os::raw::c_void,
        ghostPairCallback: *mut btOverlappingPairCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22btOverlappingPairCache20sortOverlappingPairsEP12btDispatcher"]
    pub fn btOverlappingPairCache_sortOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
/// Hash-space based Pair Cache, thanks to Erin Catto, Box2D, http://www.box2d.org, and Pierre Terdiman, Codercorner, http://codercorner.com
#[repr(C)]
pub struct btHashedOverlappingPairCache {
    pub _base: btOverlappingPairCache,
    pub m_overlappingPairArray: btBroadphasePairArray,
    pub m_overlapFilterCallback: *mut btOverlapFilterCallback,
    pub m_hashTable: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_next: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_ghostPairCallback: *mut btOverlappingPairCallback,
}
#[test]
fn bindgen_test_layout_btHashedOverlappingPairCache() {
    assert_eq!(
        ::std::mem::size_of::<btHashedOverlappingPairCache>(),
        120usize,
        concat!("Size of: ", stringify!(btHashedOverlappingPairCache))
    );
    assert_eq!(
        ::std::mem::align_of::<btHashedOverlappingPairCache>(),
        8usize,
        concat!("Alignment of ", stringify!(btHashedOverlappingPairCache))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHashedOverlappingPairCache)).m_overlappingPairArray as *const _
                as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHashedOverlappingPairCache),
            "::",
            stringify!(m_overlappingPairArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHashedOverlappingPairCache)).m_overlapFilterCallback as *const _
                as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHashedOverlappingPairCache),
            "::",
            stringify!(m_overlapFilterCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHashedOverlappingPairCache)).m_hashTable as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHashedOverlappingPairCache),
            "::",
            stringify!(m_hashTable)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHashedOverlappingPairCache)).m_next as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHashedOverlappingPairCache),
            "::",
            stringify!(m_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHashedOverlappingPairCache)).m_ghostPairCallback as *const _ as usize
        },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHashedOverlappingPairCache),
            "::",
            stringify!(m_ghostPairCallback)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btHashedOverlappingPairCache24needsBroadphaseCollisionEP17btBroadphaseProxyS1_"]
    pub fn btHashedOverlappingPairCache_needsBroadphaseCollision(
        this: *const btHashedOverlappingPairCache,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btHashedOverlappingPairCache23getOverlappingPairArrayEv"]
    pub fn btHashedOverlappingPairCache_getOverlappingPairArray1(
        this: *const btHashedOverlappingPairCache,
    ) -> *const btBroadphasePairArray;
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btHashedOverlappingPairCache8GetCountEv"]
    pub fn btHashedOverlappingPairCache_GetCount(
        this: *const btHashedOverlappingPairCache,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache24getOverlapFilterCallbackEv"]
    pub fn btHashedOverlappingPairCache_getOverlapFilterCallback(
        this: *mut btHashedOverlappingPairCache,
    ) -> *mut btOverlapFilterCallback;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btHashedOverlappingPairCacheC1Ev"]
    pub fn btHashedOverlappingPairCache_btHashedOverlappingPairCache(
        this: *mut btHashedOverlappingPairCache,
    );
}
impl btHashedOverlappingPairCache {
    #[inline]
    pub unsafe fn needsBroadphaseCollision(
        &self,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> bool {
        btHashedOverlappingPairCache_needsBroadphaseCollision(self, proxy0, proxy1)
    }
    #[inline]
    pub unsafe fn getOverlappingPairArray(&self) -> *const btBroadphasePairArray {
        btHashedOverlappingPairCache_getOverlappingPairArray1(self)
    }
    #[inline]
    pub unsafe fn GetCount(&self) -> ::std::os::raw::c_int {
        btHashedOverlappingPairCache_GetCount(self)
    }
    #[inline]
    pub unsafe fn getOverlapFilterCallback(&mut self) -> *mut btOverlapFilterCallback {
        btHashedOverlappingPairCache_getOverlapFilterCallback(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHashedOverlappingPairCache_btHashedOverlappingPairCache(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN28btHashedOverlappingPairCacheD0Ev"]
    pub fn btHashedOverlappingPairCache_btHashedOverlappingPairCache_destructor(
        this: *mut btHashedOverlappingPairCache,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache37removeOverlappingPairsContainingProxyEP17btBroadphaseProxyP12btDispatcher"]
    pub fn btHashedOverlappingPairCache_removeOverlappingPairsContainingProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache21removeOverlappingPairEP17btBroadphaseProxyS1_P12btDispatcher"]
    pub fn btHashedOverlappingPairCache_removeOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache18addOverlappingPairEP17btBroadphaseProxyS1_"]
    pub fn btHashedOverlappingPairCache_addOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> *mut btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache19cleanProxyFromPairsEP17btBroadphaseProxyP12btDispatcher"]
    pub fn btHashedOverlappingPairCache_cleanProxyFromPairs(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache26processAllOverlappingPairsEP17btOverlapCallbackP12btDispatcher"]
    pub fn btHashedOverlappingPairCache_processAllOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btOverlapCallback,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache26getOverlappingPairArrayPtrEv"]
    pub fn btHashedOverlappingPairCache_getOverlappingPairArrayPtr(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btHashedOverlappingPairCache26getOverlappingPairArrayPtrEv"]
    pub fn btHashedOverlappingPairCache_getOverlappingPairArrayPtr1(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache23getOverlappingPairArrayEv"]
    pub fn btHashedOverlappingPairCache_getOverlappingPairArray(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btBroadphasePairArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache20cleanOverlappingPairER16btBroadphasePairP12btDispatcher"]
    pub fn btHashedOverlappingPairCache_cleanOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        pair: *mut btBroadphasePair,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache8findPairEP17btBroadphaseProxyS1_"]
    pub fn btHashedOverlappingPairCache_findPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> *mut btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btHashedOverlappingPairCache24setOverlapFilterCallbackEP23btOverlapFilterCallback"]
    pub fn btHashedOverlappingPairCache_setOverlapFilterCallback(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btOverlapFilterCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btHashedOverlappingPairCache22getNumOverlappingPairsEv"]
    pub fn btHashedOverlappingPairCache_getNumOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
/// btSortedOverlappingPairCache maintains the objects with overlapping AABB
/// Typically managed by the Broadphase, Axis3Sweep or btSimpleBroadphase
#[repr(C)]
pub struct btSortedOverlappingPairCache {
    pub _base: btOverlappingPairCache,
    pub m_overlappingPairArray: btBroadphasePairArray,
    pub m_blockedForChanges: bool,
    /// by default, do the removal during the pair traversal
    pub m_hasDeferredRemoval: bool,
    pub m_overlapFilterCallback: *mut btOverlapFilterCallback,
    pub m_ghostPairCallback: *mut btOverlappingPairCallback,
}
#[test]
fn bindgen_test_layout_btSortedOverlappingPairCache() {
    assert_eq!(
        ::std::mem::size_of::<btSortedOverlappingPairCache>(),
        64usize,
        concat!("Size of: ", stringify!(btSortedOverlappingPairCache))
    );
    assert_eq!(
        ::std::mem::align_of::<btSortedOverlappingPairCache>(),
        8usize,
        concat!("Alignment of ", stringify!(btSortedOverlappingPairCache))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSortedOverlappingPairCache)).m_overlappingPairArray as *const _
                as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSortedOverlappingPairCache),
            "::",
            stringify!(m_overlappingPairArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSortedOverlappingPairCache)).m_blockedForChanges as *const _ as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSortedOverlappingPairCache),
            "::",
            stringify!(m_blockedForChanges)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSortedOverlappingPairCache)).m_hasDeferredRemoval as *const _ as usize
        },
        41usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSortedOverlappingPairCache),
            "::",
            stringify!(m_hasDeferredRemoval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSortedOverlappingPairCache)).m_overlapFilterCallback as *const _
                as usize
        },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSortedOverlappingPairCache),
            "::",
            stringify!(m_overlapFilterCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSortedOverlappingPairCache)).m_ghostPairCallback as *const _ as usize
        },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSortedOverlappingPairCache),
            "::",
            stringify!(m_ghostPairCallback)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btSortedOverlappingPairCache24needsBroadphaseCollisionEP17btBroadphaseProxyS1_"]
    pub fn btSortedOverlappingPairCache_needsBroadphaseCollision(
        this: *const btSortedOverlappingPairCache,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btSortedOverlappingPairCache23getOverlappingPairArrayEv"]
    pub fn btSortedOverlappingPairCache_getOverlappingPairArray1(
        this: *const btSortedOverlappingPairCache,
    ) -> *const btBroadphasePairArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache24getOverlapFilterCallbackEv"]
    pub fn btSortedOverlappingPairCache_getOverlapFilterCallback(
        this: *mut btSortedOverlappingPairCache,
    ) -> *mut btOverlapFilterCallback;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCacheC1Ev"]
    pub fn btSortedOverlappingPairCache_btSortedOverlappingPairCache(
        this: *mut btSortedOverlappingPairCache,
    );
}
impl btSortedOverlappingPairCache {
    #[inline]
    pub unsafe fn needsBroadphaseCollision(
        &self,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> bool {
        btSortedOverlappingPairCache_needsBroadphaseCollision(self, proxy0, proxy1)
    }
    #[inline]
    pub unsafe fn getOverlappingPairArray(&self) -> *const btBroadphasePairArray {
        btSortedOverlappingPairCache_getOverlappingPairArray1(self)
    }
    #[inline]
    pub unsafe fn getOverlapFilterCallback(&mut self) -> *mut btOverlapFilterCallback {
        btSortedOverlappingPairCache_getOverlapFilterCallback(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSortedOverlappingPairCache_btSortedOverlappingPairCache(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCacheD0Ev"]
    pub fn btSortedOverlappingPairCache_btSortedOverlappingPairCache_destructor(
        this: *mut btSortedOverlappingPairCache,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache26processAllOverlappingPairsEP17btOverlapCallbackP12btDispatcher"]
    pub fn btSortedOverlappingPairCache_processAllOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btOverlapCallback,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache21removeOverlappingPairEP17btBroadphaseProxyS1_P12btDispatcher"]
    pub fn btSortedOverlappingPairCache_removeOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache20cleanOverlappingPairER16btBroadphasePairP12btDispatcher"]
    pub fn btSortedOverlappingPairCache_cleanOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        pair: *mut btBroadphasePair,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache18addOverlappingPairEP17btBroadphaseProxyS1_"]
    pub fn btSortedOverlappingPairCache_addOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> *mut btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache8findPairEP17btBroadphaseProxyS1_"]
    pub fn btSortedOverlappingPairCache_findPair(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> *mut btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache19cleanProxyFromPairsEP17btBroadphaseProxyP12btDispatcher"]
    pub fn btSortedOverlappingPairCache_cleanProxyFromPairs(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache37removeOverlappingPairsContainingProxyEP17btBroadphaseProxyP12btDispatcher"]
    pub fn btSortedOverlappingPairCache_removeOverlappingPairsContainingProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache23getOverlappingPairArrayEv"]
    pub fn btSortedOverlappingPairCache_getOverlappingPairArray(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btBroadphasePairArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache26getOverlappingPairArrayPtrEv"]
    pub fn btSortedOverlappingPairCache_getOverlappingPairArrayPtr(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btSortedOverlappingPairCache26getOverlappingPairArrayPtrEv"]
    pub fn btSortedOverlappingPairCache_getOverlappingPairArrayPtr1(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btSortedOverlappingPairCache22getNumOverlappingPairsEv"]
    pub fn btSortedOverlappingPairCache_getNumOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache24setOverlapFilterCallbackEP23btOverlapFilterCallback"]
    pub fn btSortedOverlappingPairCache_setOverlapFilterCallback(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btOverlapFilterCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache18hasDeferredRemovalEv"]
    pub fn btSortedOverlappingPairCache_hasDeferredRemoval(
        this: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache28setInternalGhostPairCallbackEP25btOverlappingPairCallback"]
    pub fn btSortedOverlappingPairCache_setInternalGhostPairCallback(
        this: *mut ::std::os::raw::c_void,
        ghostPairCallback: *mut btOverlappingPairCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28btSortedOverlappingPairCache20sortOverlappingPairsEP12btDispatcher"]
    pub fn btSortedOverlappingPairCache_sortOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
/// btNullPairCache skips add/removal of overlapping pairs. Userful for benchmarking and unit testing.
#[repr(C)]
pub struct btNullPairCache {
    pub _base: btOverlappingPairCache,
    pub m_overlappingPairArray: btBroadphasePairArray,
}
#[test]
fn bindgen_test_layout_btNullPairCache() {
    assert_eq!(
        ::std::mem::size_of::<btNullPairCache>(),
        40usize,
        concat!("Size of: ", stringify!(btNullPairCache))
    );
    assert_eq!(
        ::std::mem::align_of::<btNullPairCache>(),
        8usize,
        concat!("Alignment of ", stringify!(btNullPairCache))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btNullPairCache)).m_overlappingPairArray as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btNullPairCache),
            "::",
            stringify!(m_overlappingPairArray)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btNullPairCache26getOverlappingPairArrayPtrEv"]
    pub fn btNullPairCache_getOverlappingPairArrayPtr(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btNullPairCache26getOverlappingPairArrayPtrEv"]
    pub fn btNullPairCache_getOverlappingPairArrayPtr1(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btNullPairCache23getOverlappingPairArrayEv"]
    pub fn btNullPairCache_getOverlappingPairArray(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btBroadphasePairArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btNullPairCache20cleanOverlappingPairER16btBroadphasePairP12btDispatcher"]
    pub fn btNullPairCache_cleanOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btBroadphasePair,
        arg2: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btNullPairCache22getNumOverlappingPairsEv"]
    pub fn btNullPairCache_getNumOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btNullPairCache19cleanProxyFromPairsEP17btBroadphaseProxyP12btDispatcher"]
    pub fn btNullPairCache_cleanProxyFromPairs(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btBroadphaseProxy,
        arg2: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btNullPairCache24setOverlapFilterCallbackEP23btOverlapFilterCallback"]
    pub fn btNullPairCache_setOverlapFilterCallback(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btOverlapFilterCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btNullPairCache26processAllOverlappingPairsEP17btOverlapCallbackP12btDispatcher"]
    pub fn btNullPairCache_processAllOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btOverlapCallback,
        arg2: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btNullPairCache8findPairEP17btBroadphaseProxyS1_"]
    pub fn btNullPairCache_findPair(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btBroadphaseProxy,
        arg2: *mut btBroadphaseProxy,
    ) -> *mut btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btNullPairCache18hasDeferredRemovalEv"]
    pub fn btNullPairCache_hasDeferredRemoval(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btNullPairCache28setInternalGhostPairCallbackEP25btOverlappingPairCallback"]
    pub fn btNullPairCache_setInternalGhostPairCallback(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btOverlappingPairCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btNullPairCache18addOverlappingPairEP17btBroadphaseProxyS1_"]
    pub fn btNullPairCache_addOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btBroadphaseProxy,
        arg2: *mut btBroadphaseProxy,
    ) -> *mut btBroadphasePair;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btNullPairCache21removeOverlappingPairEP17btBroadphaseProxyS1_P12btDispatcher"]
    pub fn btNullPairCache_removeOverlappingPair(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btBroadphaseProxy,
        arg2: *mut btBroadphaseProxy,
        arg3: *mut btDispatcher,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btNullPairCache37removeOverlappingPairsContainingProxyEP17btBroadphaseProxyP12btDispatcher"]
    pub fn btNullPairCache_removeOverlappingPairsContainingProxy(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btBroadphaseProxy,
        arg2: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btNullPairCache20sortOverlappingPairsEP12btDispatcher"]
    pub fn btNullPairCache_sortOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
#[repr(C)]
pub struct btCollisionWorld__bindgen_vtable(::std::os::raw::c_void);
/// CollisionWorld is interface and container for the collision detection
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionWorld {
    pub vtable_: *const btCollisionWorld__bindgen_vtable,
    pub m_collisionObjects: btAlignedObjectArray<*mut btCollisionObject>,
    pub m_dispatcher1: *mut btDispatcher,
    pub m_dispatchInfo: btDispatcherInfo,
    pub m_broadphasePairCache: *mut btBroadphaseInterface,
    pub m_debugDrawer: *mut btIDebugDraw,
    /// m_forceUpdateAllAabbs can be set to false as an optimization to only update active object AABBs
    /// ///it is true by default, because it is error-prone (setting the position of static objects wouldn't update their AABB)
    pub m_forceUpdateAllAabbs: bool,
}
/// LocalShapeInfo gives extra information for complex shapes
/// ///Currently, only btTriangleMeshShape is available, so it just contains triangleIndex and subpart
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionWorld_LocalShapeInfo {
    pub m_shapePart: ::std::os::raw::c_int,
    pub m_triangleIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btCollisionWorld_LocalShapeInfo() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionWorld_LocalShapeInfo>(),
        8usize,
        concat!("Size of: ", stringify!(btCollisionWorld_LocalShapeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionWorld_LocalShapeInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(btCollisionWorld_LocalShapeInfo))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_LocalShapeInfo)).m_shapePart as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_LocalShapeInfo),
            "::",
            stringify!(m_shapePart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_LocalShapeInfo)).m_triangleIndex as *const _ as usize
        },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_LocalShapeInfo),
            "::",
            stringify!(m_triangleIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionWorld_LocalRayResult {
    pub m_collisionObject: *const btCollisionObject,
    pub m_localShapeInfo: *mut btCollisionWorld_LocalShapeInfo,
    pub m_hitNormalLocal: btVector3,
    pub m_hitFraction: btScalar,
}
#[test]
fn bindgen_test_layout_btCollisionWorld_LocalRayResult() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionWorld_LocalRayResult>(),
        56usize,
        concat!("Size of: ", stringify!(btCollisionWorld_LocalRayResult))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionWorld_LocalRayResult>(),
        8usize,
        concat!("Alignment of ", stringify!(btCollisionWorld_LocalRayResult))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_LocalRayResult)).m_collisionObject as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_LocalRayResult),
            "::",
            stringify!(m_collisionObject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_LocalRayResult)).m_localShapeInfo as *const _ as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_LocalRayResult),
            "::",
            stringify!(m_localShapeInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_LocalRayResult)).m_hitNormalLocal as *const _ as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_LocalRayResult),
            "::",
            stringify!(m_hitNormalLocal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_LocalRayResult)).m_hitFraction as *const _ as usize
        },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_LocalRayResult),
            "::",
            stringify!(m_hitFraction)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld14LocalRayResultC1EPK17btCollisionObjectPNS_14LocalShapeInfoERK9btVector3d"]
    pub fn btCollisionWorld_LocalRayResult_LocalRayResult(
        this: *mut btCollisionWorld_LocalRayResult,
        collisionObject: *const btCollisionObject,
        localShapeInfo: *mut btCollisionWorld_LocalShapeInfo,
        hitNormalLocal: *const btVector3,
        hitFraction: btScalar,
    );
}
impl btCollisionWorld_LocalRayResult {
    #[inline]
    pub unsafe fn new(
        collisionObject: *const btCollisionObject,
        localShapeInfo: *mut btCollisionWorld_LocalShapeInfo,
        hitNormalLocal: *const btVector3,
        hitFraction: btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionWorld_LocalRayResult_LocalRayResult(
            &mut __bindgen_tmp,
            collisionObject,
            localShapeInfo,
            hitNormalLocal,
            hitFraction,
        );
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct btCollisionWorld_RayResultCallback__bindgen_vtable(::std::os::raw::c_void);
/// RayResultCallback is used to report new raycast results
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionWorld_RayResultCallback {
    pub vtable_: *const btCollisionWorld_RayResultCallback__bindgen_vtable,
    pub m_closestHitFraction: btScalar,
    pub m_collisionObject: *const btCollisionObject,
    pub m_collisionFilterGroup: ::std::os::raw::c_int,
    pub m_collisionFilterMask: ::std::os::raw::c_int,
    pub m_flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_btCollisionWorld_RayResultCallback() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionWorld_RayResultCallback>(),
        40usize,
        concat!("Size of: ", stringify!(btCollisionWorld_RayResultCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionWorld_RayResultCallback>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btCollisionWorld_RayResultCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_RayResultCallback)).m_closestHitFraction as *const _
                as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_RayResultCallback),
            "::",
            stringify!(m_closestHitFraction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_RayResultCallback)).m_collisionObject as *const _
                as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_RayResultCallback),
            "::",
            stringify!(m_collisionObject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_RayResultCallback)).m_collisionFilterGroup as *const _
                as usize
        },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_RayResultCallback),
            "::",
            stringify!(m_collisionFilterGroup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_RayResultCallback)).m_collisionFilterMask as *const _
                as usize
        },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_RayResultCallback),
            "::",
            stringify!(m_collisionFilterMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_RayResultCallback)).m_flags as *const _ as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_RayResultCallback),
            "::",
            stringify!(m_flags)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionWorld17RayResultCallback6hasHitEv"]
    pub fn btCollisionWorld_RayResultCallback_hasHit(
        this: *const btCollisionWorld_RayResultCallback,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld17RayResultCallbackC2Ev"]
    pub fn btCollisionWorld_RayResultCallback_RayResultCallback(
        this: *mut btCollisionWorld_RayResultCallback,
    );
}
impl btCollisionWorld_RayResultCallback {
    #[inline]
    pub unsafe fn hasHit(&self) -> bool {
        btCollisionWorld_RayResultCallback_hasHit(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionWorld_RayResultCallback_RayResultCallback(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionWorld_ClosestRayResultCallback {
    pub _base: btCollisionWorld_RayResultCallback,
    pub m_rayFromWorld: btVector3,
    pub m_rayToWorld: btVector3,
    pub m_hitNormalWorld: btVector3,
    pub m_hitPointWorld: btVector3,
}
#[test]
fn bindgen_test_layout_btCollisionWorld_ClosestRayResultCallback() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionWorld_ClosestRayResultCallback>(),
        168usize,
        concat!(
            "Size of: ",
            stringify!(btCollisionWorld_ClosestRayResultCallback)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionWorld_ClosestRayResultCallback>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btCollisionWorld_ClosestRayResultCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ClosestRayResultCallback)).m_rayFromWorld as *const _
                as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ClosestRayResultCallback),
            "::",
            stringify!(m_rayFromWorld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ClosestRayResultCallback)).m_rayToWorld as *const _
                as usize
        },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ClosestRayResultCallback),
            "::",
            stringify!(m_rayToWorld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ClosestRayResultCallback)).m_hitNormalWorld as *const _
                as usize
        },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ClosestRayResultCallback),
            "::",
            stringify!(m_hitNormalWorld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ClosestRayResultCallback)).m_hitPointWorld as *const _
                as usize
        },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ClosestRayResultCallback),
            "::",
            stringify!(m_hitPointWorld)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld24ClosestRayResultCallbackC1ERK9btVector3S3_"]
    pub fn btCollisionWorld_ClosestRayResultCallback_ClosestRayResultCallback(
        this: *mut btCollisionWorld_ClosestRayResultCallback,
        rayFromWorld: *const btVector3,
        rayToWorld: *const btVector3,
    );
}
impl btCollisionWorld_ClosestRayResultCallback {
    #[inline]
    pub unsafe fn new(rayFromWorld: *const btVector3, rayToWorld: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionWorld_ClosestRayResultCallback_ClosestRayResultCallback(
            &mut __bindgen_tmp,
            rayFromWorld,
            rayToWorld,
        );
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionWorld_AllHitsRayResultCallback {
    pub _base: btCollisionWorld_RayResultCallback,
    pub m_collisionObjects: btAlignedObjectArray<*const btCollisionObject>,
    pub m_rayFromWorld: btVector3,
    pub m_rayToWorld: btVector3,
    pub m_hitNormalWorld: btAlignedObjectArray<btVector3>,
    pub m_hitPointWorld: btAlignedObjectArray<btVector3>,
    pub m_hitFractions: btAlignedObjectArray<btScalar>,
}
#[test]
fn bindgen_test_layout_btCollisionWorld_AllHitsRayResultCallback() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionWorld_AllHitsRayResultCallback>(),
        232usize,
        concat!(
            "Size of: ",
            stringify!(btCollisionWorld_AllHitsRayResultCallback)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionWorld_AllHitsRayResultCallback>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btCollisionWorld_AllHitsRayResultCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_AllHitsRayResultCallback)).m_collisionObjects
                as *const _ as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_AllHitsRayResultCallback),
            "::",
            stringify!(m_collisionObjects)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_AllHitsRayResultCallback)).m_rayFromWorld as *const _
                as usize
        },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_AllHitsRayResultCallback),
            "::",
            stringify!(m_rayFromWorld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_AllHitsRayResultCallback)).m_rayToWorld as *const _
                as usize
        },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_AllHitsRayResultCallback),
            "::",
            stringify!(m_rayToWorld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_AllHitsRayResultCallback)).m_hitNormalWorld as *const _
                as usize
        },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_AllHitsRayResultCallback),
            "::",
            stringify!(m_hitNormalWorld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_AllHitsRayResultCallback)).m_hitPointWorld as *const _
                as usize
        },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_AllHitsRayResultCallback),
            "::",
            stringify!(m_hitPointWorld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_AllHitsRayResultCallback)).m_hitFractions as *const _
                as usize
        },
        200usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_AllHitsRayResultCallback),
            "::",
            stringify!(m_hitFractions)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld24AllHitsRayResultCallbackC1ERK9btVector3S3_"]
    pub fn btCollisionWorld_AllHitsRayResultCallback_AllHitsRayResultCallback(
        this: *mut btCollisionWorld_AllHitsRayResultCallback,
        rayFromWorld: *const btVector3,
        rayToWorld: *const btVector3,
    );
}
impl btCollisionWorld_AllHitsRayResultCallback {
    #[inline]
    pub unsafe fn new(rayFromWorld: *const btVector3, rayToWorld: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionWorld_AllHitsRayResultCallback_AllHitsRayResultCallback(
            &mut __bindgen_tmp,
            rayFromWorld,
            rayToWorld,
        );
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionWorld_LocalConvexResult {
    pub m_hitCollisionObject: *const btCollisionObject,
    pub m_localShapeInfo: *mut btCollisionWorld_LocalShapeInfo,
    pub m_hitNormalLocal: btVector3,
    pub m_hitPointLocal: btVector3,
    pub m_hitFraction: btScalar,
}
#[test]
fn bindgen_test_layout_btCollisionWorld_LocalConvexResult() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionWorld_LocalConvexResult>(),
        88usize,
        concat!("Size of: ", stringify!(btCollisionWorld_LocalConvexResult))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionWorld_LocalConvexResult>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btCollisionWorld_LocalConvexResult)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_LocalConvexResult)).m_hitCollisionObject as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_LocalConvexResult),
            "::",
            stringify!(m_hitCollisionObject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_LocalConvexResult)).m_localShapeInfo as *const _
                as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_LocalConvexResult),
            "::",
            stringify!(m_localShapeInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_LocalConvexResult)).m_hitNormalLocal as *const _
                as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_LocalConvexResult),
            "::",
            stringify!(m_hitNormalLocal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_LocalConvexResult)).m_hitPointLocal as *const _
                as usize
        },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_LocalConvexResult),
            "::",
            stringify!(m_hitPointLocal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_LocalConvexResult)).m_hitFraction as *const _ as usize
        },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_LocalConvexResult),
            "::",
            stringify!(m_hitFraction)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld17LocalConvexResultC1EPK17btCollisionObjectPNS_14LocalShapeInfoERK9btVector3S8_d"]
    pub fn btCollisionWorld_LocalConvexResult_LocalConvexResult(
        this: *mut btCollisionWorld_LocalConvexResult,
        hitCollisionObject: *const btCollisionObject,
        localShapeInfo: *mut btCollisionWorld_LocalShapeInfo,
        hitNormalLocal: *const btVector3,
        hitPointLocal: *const btVector3,
        hitFraction: btScalar,
    );
}
impl btCollisionWorld_LocalConvexResult {
    #[inline]
    pub unsafe fn new(
        hitCollisionObject: *const btCollisionObject,
        localShapeInfo: *mut btCollisionWorld_LocalShapeInfo,
        hitNormalLocal: *const btVector3,
        hitPointLocal: *const btVector3,
        hitFraction: btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionWorld_LocalConvexResult_LocalConvexResult(
            &mut __bindgen_tmp,
            hitCollisionObject,
            localShapeInfo,
            hitNormalLocal,
            hitPointLocal,
            hitFraction,
        );
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct btCollisionWorld_ConvexResultCallback__bindgen_vtable(::std::os::raw::c_void);
/// RayResultCallback is used to report new raycast results
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionWorld_ConvexResultCallback {
    pub vtable_: *const btCollisionWorld_ConvexResultCallback__bindgen_vtable,
    pub m_closestHitFraction: btScalar,
    pub m_collisionFilterGroup: ::std::os::raw::c_int,
    pub m_collisionFilterMask: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btCollisionWorld_ConvexResultCallback() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionWorld_ConvexResultCallback>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(btCollisionWorld_ConvexResultCallback)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionWorld_ConvexResultCallback>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btCollisionWorld_ConvexResultCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ConvexResultCallback)).m_closestHitFraction as *const _
                as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ConvexResultCallback),
            "::",
            stringify!(m_closestHitFraction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ConvexResultCallback)).m_collisionFilterGroup
                as *const _ as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ConvexResultCallback),
            "::",
            stringify!(m_collisionFilterGroup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ConvexResultCallback)).m_collisionFilterMask
                as *const _ as usize
        },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ConvexResultCallback),
            "::",
            stringify!(m_collisionFilterMask)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionWorld20ConvexResultCallback6hasHitEv"]
    pub fn btCollisionWorld_ConvexResultCallback_hasHit(
        this: *const btCollisionWorld_ConvexResultCallback,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld20ConvexResultCallbackC2Ev"]
    pub fn btCollisionWorld_ConvexResultCallback_ConvexResultCallback(
        this: *mut btCollisionWorld_ConvexResultCallback,
    );
}
impl btCollisionWorld_ConvexResultCallback {
    #[inline]
    pub unsafe fn hasHit(&self) -> bool {
        btCollisionWorld_ConvexResultCallback_hasHit(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionWorld_ConvexResultCallback_ConvexResultCallback(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionWorld_ClosestConvexResultCallback {
    pub _base: btCollisionWorld_ConvexResultCallback,
    pub m_convexFromWorld: btVector3,
    pub m_convexToWorld: btVector3,
    pub m_hitNormalWorld: btVector3,
    pub m_hitPointWorld: btVector3,
    pub m_hitCollisionObject: *const btCollisionObject,
}
#[test]
fn bindgen_test_layout_btCollisionWorld_ClosestConvexResultCallback() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionWorld_ClosestConvexResultCallback>(),
        160usize,
        concat!(
            "Size of: ",
            stringify!(btCollisionWorld_ClosestConvexResultCallback)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionWorld_ClosestConvexResultCallback>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btCollisionWorld_ClosestConvexResultCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ClosestConvexResultCallback)).m_convexFromWorld
                as *const _ as usize
        },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ClosestConvexResultCallback),
            "::",
            stringify!(m_convexFromWorld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ClosestConvexResultCallback)).m_convexToWorld
                as *const _ as usize
        },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ClosestConvexResultCallback),
            "::",
            stringify!(m_convexToWorld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ClosestConvexResultCallback)).m_hitNormalWorld
                as *const _ as usize
        },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ClosestConvexResultCallback),
            "::",
            stringify!(m_hitNormalWorld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ClosestConvexResultCallback)).m_hitPointWorld
                as *const _ as usize
        },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ClosestConvexResultCallback),
            "::",
            stringify!(m_hitPointWorld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ClosestConvexResultCallback)).m_hitCollisionObject
                as *const _ as usize
        },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ClosestConvexResultCallback),
            "::",
            stringify!(m_hitCollisionObject)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld27ClosestConvexResultCallbackC1ERK9btVector3S3_"]
    pub fn btCollisionWorld_ClosestConvexResultCallback_ClosestConvexResultCallback(
        this: *mut btCollisionWorld_ClosestConvexResultCallback,
        convexFromWorld: *const btVector3,
        convexToWorld: *const btVector3,
    );
}
impl btCollisionWorld_ClosestConvexResultCallback {
    #[inline]
    pub unsafe fn new(convexFromWorld: *const btVector3, convexToWorld: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionWorld_ClosestConvexResultCallback_ClosestConvexResultCallback(
            &mut __bindgen_tmp,
            convexFromWorld,
            convexToWorld,
        );
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct btCollisionWorld_ContactResultCallback__bindgen_vtable(::std::os::raw::c_void);
/// ContactResultCallback is used to report contact points
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionWorld_ContactResultCallback {
    pub vtable_: *const btCollisionWorld_ContactResultCallback__bindgen_vtable,
    pub m_collisionFilterGroup: ::std::os::raw::c_int,
    pub m_collisionFilterMask: ::std::os::raw::c_int,
    pub m_closestDistanceThreshold: btScalar,
}
#[test]
fn bindgen_test_layout_btCollisionWorld_ContactResultCallback() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionWorld_ContactResultCallback>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(btCollisionWorld_ContactResultCallback)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionWorld_ContactResultCallback>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btCollisionWorld_ContactResultCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ContactResultCallback)).m_collisionFilterGroup
                as *const _ as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ContactResultCallback),
            "::",
            stringify!(m_collisionFilterGroup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ContactResultCallback)).m_collisionFilterMask
                as *const _ as usize
        },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ContactResultCallback),
            "::",
            stringify!(m_collisionFilterMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionWorld_ContactResultCallback)).m_closestDistanceThreshold
                as *const _ as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld_ContactResultCallback),
            "::",
            stringify!(m_closestDistanceThreshold)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld21ContactResultCallbackC2Ev"]
    pub fn btCollisionWorld_ContactResultCallback_ContactResultCallback(
        this: *mut btCollisionWorld_ContactResultCallback,
    );
}
impl btCollisionWorld_ContactResultCallback {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionWorld_ContactResultCallback_ContactResultCallback(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[test]
fn bindgen_test_layout_btCollisionWorld() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionWorld>(),
        144usize,
        concat!("Size of: ", stringify!(btCollisionWorld))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionWorld>(),
        8usize,
        concat!("Alignment of ", stringify!(btCollisionWorld))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionWorld)).m_collisionObjects as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld),
            "::",
            stringify!(m_collisionObjects)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionWorld)).m_dispatcher1 as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld),
            "::",
            stringify!(m_dispatcher1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionWorld)).m_dispatchInfo as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld),
            "::",
            stringify!(m_dispatchInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionWorld)).m_broadphasePairCache as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld),
            "::",
            stringify!(m_broadphasePairCache)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionWorld)).m_debugDrawer as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld),
            "::",
            stringify!(m_debugDrawer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionWorld)).m_forceUpdateAllAabbs as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionWorld),
            "::",
            stringify!(m_forceUpdateAllAabbs)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld25serializeCollisionObjectsEP12btSerializer"]
    pub fn btCollisionWorld_serializeCollisionObjects(
        this: *mut btCollisionWorld,
        serializer: *mut btSerializer,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld13setBroadphaseEP21btBroadphaseInterface"]
    pub fn btCollisionWorld_setBroadphase(
        this: *mut btCollisionWorld,
        pairCache: *mut btBroadphaseInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionWorld13getBroadphaseEv"]
    pub fn btCollisionWorld_getBroadphase(
        this: *const btCollisionWorld,
    ) -> *const btBroadphaseInterface;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld13getBroadphaseEv"]
    pub fn btCollisionWorld_getBroadphase1(
        this: *mut btCollisionWorld,
    ) -> *mut btBroadphaseInterface;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld12getPairCacheEv"]
    pub fn btCollisionWorld_getPairCache(
        this: *mut btCollisionWorld,
    ) -> *mut btOverlappingPairCache;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld13getDispatcherEv"]
    pub fn btCollisionWorld_getDispatcher(this: *mut btCollisionWorld) -> *mut btDispatcher;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionWorld13getDispatcherEv"]
    pub fn btCollisionWorld_getDispatcher1(this: *const btCollisionWorld) -> *const btDispatcher;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld16updateSingleAabbEP17btCollisionObject"]
    pub fn btCollisionWorld_updateSingleAabb(
        this: *mut btCollisionWorld,
        colObj: *mut btCollisionObject,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionWorld22getNumCollisionObjectsEv"]
    pub fn btCollisionWorld_getNumCollisionObjects(
        this: *const btCollisionWorld,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// convexTest performs a swept convex cast on all objects in the btCollisionWorld, and calls the resultCallback
    /// /// This allows for several queries: first hit, all hits, any hit, dependent on the value return by the callback.

    #[link_name = "\u{1}_ZNK16btCollisionWorld15convexSweepTestEPK13btConvexShapeRK11btTransformS5_RNS_20ConvexResultCallbackEd"]
    pub fn btCollisionWorld_convexSweepTest(
        this: *const btCollisionWorld,
        castShape: *const btConvexShape,
        from: *const btTransform,
        to: *const btTransform,
        resultCallback: *mut btCollisionWorld_ConvexResultCallback,
        allowedCcdPenetration: btScalar,
    );
}
extern "C" {

    /// contactTest performs a discrete collision test between colObj against all objects in the btCollisionWorld, and calls the resultCallback.
    /// ///it reports one or more contact points for every overlapping object (including the one with deepest penetration)

    #[link_name = "\u{1}_ZN16btCollisionWorld11contactTestEP17btCollisionObjectRNS_21ContactResultCallbackE"]
    pub fn btCollisionWorld_contactTest(
        this: *mut btCollisionWorld,
        colObj: *mut btCollisionObject,
        resultCallback: *mut btCollisionWorld_ContactResultCallback,
    );
}
extern "C" {

    /// contactTest performs a discrete collision test between two collision objects and calls the resultCallback if overlap if detected.
    /// ///it reports one or more contact points (including the one with deepest penetration)

    #[link_name = "\u{1}_ZN16btCollisionWorld15contactPairTestEP17btCollisionObjectS1_RNS_21ContactResultCallbackE"]
    pub fn btCollisionWorld_contactPairTest(
        this: *mut btCollisionWorld,
        colObjA: *mut btCollisionObject,
        colObjB: *mut btCollisionObject,
        resultCallback: *mut btCollisionWorld_ContactResultCallback,
    );
}
extern "C" {

    /// rayTestSingle performs a raycast call and calls the resultCallback. It is used internally by rayTest.
    /// /// In a future implementation, we consider moving the ray test as a virtual method in btCollisionShape.
    /// /// This allows more customization.

    #[link_name = "\u{1}_ZN16btCollisionWorld13rayTestSingleERK11btTransformS2_P17btCollisionObjectPK16btCollisionShapeS2_RNS_17RayResultCallbackE"]
    pub fn btCollisionWorld_rayTestSingle(
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObject: *mut btCollisionObject,
        collisionShape: *const btCollisionShape,
        colObjWorldTransform: *const btTransform,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld21rayTestSingleInternalERK11btTransformS2_PK24btCollisionObjectWrapperRNS_17RayResultCallbackE"]
    pub fn btCollisionWorld_rayTestSingleInternal(
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObjectWrap: *const btCollisionObjectWrapper,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    );
}
extern "C" {

    /// objectQuerySingle performs a collision detection query and calls the resultCallback. It is used internally by rayTest.

    #[link_name = "\u{1}_ZN16btCollisionWorld17objectQuerySingleEPK13btConvexShapeRK11btTransformS5_P17btCollisionObjectPK16btCollisionShapeS5_RNS_20ConvexResultCallbackEd"]
    pub fn btCollisionWorld_objectQuerySingle(
        castShape: *const btConvexShape,
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObject: *mut btCollisionObject,
        collisionShape: *const btCollisionShape,
        colObjWorldTransform: *const btTransform,
        resultCallback: *mut btCollisionWorld_ConvexResultCallback,
        allowedPenetration: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld25objectQuerySingleInternalEPK13btConvexShapeRK11btTransformS5_PK24btCollisionObjectWrapperRNS_20ConvexResultCallbackEd"]
    pub fn btCollisionWorld_objectQuerySingleInternal(
        castShape: *const btConvexShape,
        convexFromTrans: *const btTransform,
        convexToTrans: *const btTransform,
        colObjWrap: *const btCollisionObjectWrapper,
        resultCallback: *mut btCollisionWorld_ConvexResultCallback,
        allowedPenetration: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld23getCollisionObjectArrayEv"]
    pub fn btCollisionWorld_getCollisionObjectArray(
        this: *mut btCollisionWorld,
    ) -> *mut btCollisionObjectArray;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionWorld23getCollisionObjectArrayEv"]
    pub fn btCollisionWorld_getCollisionObjectArray1(
        this: *const btCollisionWorld,
    ) -> *const btCollisionObjectArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld15getDispatchInfoEv"]
    pub fn btCollisionWorld_getDispatchInfo(this: *mut btCollisionWorld) -> *mut btDispatcherInfo;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionWorld15getDispatchInfoEv"]
    pub fn btCollisionWorld_getDispatchInfo1(
        this: *const btCollisionWorld,
    ) -> *const btDispatcherInfo;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionWorld22getForceUpdateAllAabbsEv"]
    pub fn btCollisionWorld_getForceUpdateAllAabbs(this: *const btCollisionWorld) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld22setForceUpdateAllAabbsEb"]
    pub fn btCollisionWorld_setForceUpdateAllAabbs(
        this: *mut btCollisionWorld,
        forceUpdateAllAabbs: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorldC1EP12btDispatcherP21btBroadphaseInterfaceP24btCollisionConfiguration"]
    pub fn btCollisionWorld_btCollisionWorld(
        this: *mut btCollisionWorld,
        dispatcher: *mut btDispatcher,
        broadphasePairCache: *mut btBroadphaseInterface,
        collisionConfiguration: *mut btCollisionConfiguration,
    );
}
impl btCollisionWorld {
    #[inline]
    pub unsafe fn serializeCollisionObjects(&mut self, serializer: *mut btSerializer) {
        btCollisionWorld_serializeCollisionObjects(self, serializer)
    }
    #[inline]
    pub unsafe fn setBroadphase(&mut self, pairCache: *mut btBroadphaseInterface) {
        btCollisionWorld_setBroadphase(self, pairCache)
    }
    #[inline]
    pub unsafe fn getBroadphase(&self) -> *const btBroadphaseInterface {
        btCollisionWorld_getBroadphase(self)
    }
    #[inline]
    pub unsafe fn getBroadphase1(&mut self) -> *mut btBroadphaseInterface {
        btCollisionWorld_getBroadphase1(self)
    }
    #[inline]
    pub unsafe fn getPairCache(&mut self) -> *mut btOverlappingPairCache {
        btCollisionWorld_getPairCache(self)
    }
    #[inline]
    pub unsafe fn getDispatcher(&mut self) -> *mut btDispatcher {
        btCollisionWorld_getDispatcher(self)
    }
    #[inline]
    pub unsafe fn getDispatcher1(&self) -> *const btDispatcher {
        btCollisionWorld_getDispatcher1(self)
    }
    #[inline]
    pub unsafe fn updateSingleAabb(&mut self, colObj: *mut btCollisionObject) {
        btCollisionWorld_updateSingleAabb(self, colObj)
    }
    #[inline]
    pub unsafe fn getNumCollisionObjects(&self) -> ::std::os::raw::c_int {
        btCollisionWorld_getNumCollisionObjects(self)
    }
    #[inline]
    pub unsafe fn convexSweepTest(
        &self,
        castShape: *const btConvexShape,
        from: *const btTransform,
        to: *const btTransform,
        resultCallback: *mut btCollisionWorld_ConvexResultCallback,
        allowedCcdPenetration: btScalar,
    ) {
        btCollisionWorld_convexSweepTest(
            self,
            castShape,
            from,
            to,
            resultCallback,
            allowedCcdPenetration,
        )
    }
    #[inline]
    pub unsafe fn contactTest(
        &mut self,
        colObj: *mut btCollisionObject,
        resultCallback: *mut btCollisionWorld_ContactResultCallback,
    ) {
        btCollisionWorld_contactTest(self, colObj, resultCallback)
    }
    #[inline]
    pub unsafe fn contactPairTest(
        &mut self,
        colObjA: *mut btCollisionObject,
        colObjB: *mut btCollisionObject,
        resultCallback: *mut btCollisionWorld_ContactResultCallback,
    ) {
        btCollisionWorld_contactPairTest(self, colObjA, colObjB, resultCallback)
    }
    #[inline]
    pub unsafe fn rayTestSingle(
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObject: *mut btCollisionObject,
        collisionShape: *const btCollisionShape,
        colObjWorldTransform: *const btTransform,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    ) {
        btCollisionWorld_rayTestSingle(
            rayFromTrans,
            rayToTrans,
            collisionObject,
            collisionShape,
            colObjWorldTransform,
            resultCallback,
        )
    }
    #[inline]
    pub unsafe fn rayTestSingleInternal(
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObjectWrap: *const btCollisionObjectWrapper,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    ) {
        btCollisionWorld_rayTestSingleInternal(
            rayFromTrans,
            rayToTrans,
            collisionObjectWrap,
            resultCallback,
        )
    }
    #[inline]
    pub unsafe fn objectQuerySingle(
        castShape: *const btConvexShape,
        rayFromTrans: *const btTransform,
        rayToTrans: *const btTransform,
        collisionObject: *mut btCollisionObject,
        collisionShape: *const btCollisionShape,
        colObjWorldTransform: *const btTransform,
        resultCallback: *mut btCollisionWorld_ConvexResultCallback,
        allowedPenetration: btScalar,
    ) {
        btCollisionWorld_objectQuerySingle(
            castShape,
            rayFromTrans,
            rayToTrans,
            collisionObject,
            collisionShape,
            colObjWorldTransform,
            resultCallback,
            allowedPenetration,
        )
    }
    #[inline]
    pub unsafe fn objectQuerySingleInternal(
        castShape: *const btConvexShape,
        convexFromTrans: *const btTransform,
        convexToTrans: *const btTransform,
        colObjWrap: *const btCollisionObjectWrapper,
        resultCallback: *mut btCollisionWorld_ConvexResultCallback,
        allowedPenetration: btScalar,
    ) {
        btCollisionWorld_objectQuerySingleInternal(
            castShape,
            convexFromTrans,
            convexToTrans,
            colObjWrap,
            resultCallback,
            allowedPenetration,
        )
    }
    #[inline]
    pub unsafe fn getCollisionObjectArray(&mut self) -> *mut btCollisionObjectArray {
        btCollisionWorld_getCollisionObjectArray(self)
    }
    #[inline]
    pub unsafe fn getCollisionObjectArray1(&self) -> *const btCollisionObjectArray {
        btCollisionWorld_getCollisionObjectArray1(self)
    }
    #[inline]
    pub unsafe fn getDispatchInfo(&mut self) -> *mut btDispatcherInfo {
        btCollisionWorld_getDispatchInfo(self)
    }
    #[inline]
    pub unsafe fn getDispatchInfo1(&self) -> *const btDispatcherInfo {
        btCollisionWorld_getDispatchInfo1(self)
    }
    #[inline]
    pub unsafe fn getForceUpdateAllAabbs(&self) -> bool {
        btCollisionWorld_getForceUpdateAllAabbs(self)
    }
    #[inline]
    pub unsafe fn setForceUpdateAllAabbs(&mut self, forceUpdateAllAabbs: bool) {
        btCollisionWorld_setForceUpdateAllAabbs(self, forceUpdateAllAabbs)
    }
    #[inline]
    pub unsafe fn new(
        dispatcher: *mut btDispatcher,
        broadphasePairCache: *mut btBroadphaseInterface,
        collisionConfiguration: *mut btCollisionConfiguration,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionWorld_btCollisionWorld(
            &mut __bindgen_tmp,
            dispatcher,
            broadphasePairCache,
            collisionConfiguration,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorldD0Ev"]
    pub fn btCollisionWorld_btCollisionWorld_destructor(this: *mut btCollisionWorld);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld11updateAabbsEv"]
    pub fn btCollisionWorld_updateAabbs(this: *mut ::std::os::raw::c_void);
}
extern "C" {

    /// the computeOverlappingPairs is usually already called by performDiscreteCollisionDetection (or stepSimulation)
    /// ///it can be useful to use if you perform ray tests without collision detection/simulation

    #[link_name = "\u{1}_ZN16btCollisionWorld23computeOverlappingPairsEv"]
    pub fn btCollisionWorld_computeOverlappingPairs(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld14setDebugDrawerEP12btIDebugDraw"]
    pub fn btCollisionWorld_setDebugDrawer(
        this: *mut ::std::os::raw::c_void,
        debugDrawer: *mut btIDebugDraw,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld14getDebugDrawerEv"]
    pub fn btCollisionWorld_getDebugDrawer(this: *mut ::std::os::raw::c_void) -> *mut btIDebugDraw;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld14debugDrawWorldEv"]
    pub fn btCollisionWorld_debugDrawWorld(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld15debugDrawObjectERK11btTransformPK16btCollisionShapeRK9btVector3"]
    pub fn btCollisionWorld_debugDrawObject(
        this: *mut ::std::os::raw::c_void,
        worldTransform: *const btTransform,
        shape: *const btCollisionShape,
        color: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld17RayResultCallbackD0Ev"]
    pub fn btCollisionWorld_RayResultCallback_RayResultCallback_destructor(
        this: *mut btCollisionWorld_RayResultCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionWorld17RayResultCallback14needsCollisionEP17btBroadphaseProxy"]
    pub fn btCollisionWorld_RayResultCallback_needsCollision(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld17RayResultCallback15addSingleResultERNS_14LocalRayResultEb"]
    pub fn btCollisionWorld_RayResultCallback_addSingleResult(
        this: *mut ::std::os::raw::c_void,
        rayResult: *mut btCollisionWorld_LocalRayResult,
        normalInWorldSpace: bool,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld24ClosestRayResultCallback15addSingleResultERNS_14LocalRayResultEb"]
    pub fn btCollisionWorld_ClosestRayResultCallback_addSingleResult(
        this: *mut ::std::os::raw::c_void,
        rayResult: *mut btCollisionWorld_LocalRayResult,
        normalInWorldSpace: bool,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld24AllHitsRayResultCallback15addSingleResultERNS_14LocalRayResultEb"]
    pub fn btCollisionWorld_AllHitsRayResultCallback_addSingleResult(
        this: *mut ::std::os::raw::c_void,
        rayResult: *mut btCollisionWorld_LocalRayResult,
        normalInWorldSpace: bool,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld20ConvexResultCallbackD0Ev"]
    pub fn btCollisionWorld_ConvexResultCallback_ConvexResultCallback_destructor(
        this: *mut btCollisionWorld_ConvexResultCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionWorld20ConvexResultCallback14needsCollisionEP17btBroadphaseProxy"]
    pub fn btCollisionWorld_ConvexResultCallback_needsCollision(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld20ConvexResultCallback15addSingleResultERNS_17LocalConvexResultEb"]
    pub fn btCollisionWorld_ConvexResultCallback_addSingleResult(
        this: *mut ::std::os::raw::c_void,
        convexResult: *mut btCollisionWorld_LocalConvexResult,
        normalInWorldSpace: bool,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld27ClosestConvexResultCallback15addSingleResultERNS_17LocalConvexResultEb"]
    pub fn btCollisionWorld_ClosestConvexResultCallback_addSingleResult(
        this: *mut ::std::os::raw::c_void,
        convexResult: *mut btCollisionWorld_LocalConvexResult,
        normalInWorldSpace: bool,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld21ContactResultCallbackD0Ev"]
    pub fn btCollisionWorld_ContactResultCallback_ContactResultCallback_destructor(
        this: *mut btCollisionWorld_ContactResultCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionWorld21ContactResultCallback14needsCollisionEP17btBroadphaseProxy"]
    pub fn btCollisionWorld_ContactResultCallback_needsCollision(
        this: *mut ::std::os::raw::c_void,
        proxy0: *mut btBroadphaseProxy,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld21ContactResultCallback15addSingleResultER15btManifoldPointPK24btCollisionObjectWrapperiiS5_ii"]
    pub fn btCollisionWorld_ContactResultCallback_addSingleResult(
        this: *mut ::std::os::raw::c_void,
        cp: *mut btManifoldPoint,
        colObj0Wrap: *const btCollisionObjectWrapper,
        partId0: ::std::os::raw::c_int,
        index0: ::std::os::raw::c_int,
        colObj1Wrap: *const btCollisionObjectWrapper,
        partId1: ::std::os::raw::c_int,
        index1: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {

    /// rayTest performs a raycast on all objects in the btCollisionWorld, and calls the resultCallback
    /// /// This allows for several queries: first hit, all hits, any hit, dependent on the value returned by the callback.

    #[link_name = "\u{1}_ZNK16btCollisionWorld7rayTestERK9btVector3S2_RNS_17RayResultCallbackE"]
    pub fn btCollisionWorld_rayTest(
        this: *mut ::std::os::raw::c_void,
        rayFromWorld: *const btVector3,
        rayToWorld: *const btVector3,
        resultCallback: *mut btCollisionWorld_RayResultCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld18addCollisionObjectEP17btCollisionObjectii"]
    pub fn btCollisionWorld_addCollisionObject(
        this: *mut ::std::os::raw::c_void,
        collisionObject: *mut btCollisionObject,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld21removeCollisionObjectEP17btCollisionObject"]
    pub fn btCollisionWorld_removeCollisionObject(
        this: *mut ::std::os::raw::c_void,
        collisionObject: *mut btCollisionObject,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionWorld33performDiscreteCollisionDetectionEv"]
    pub fn btCollisionWorld_performDiscreteCollisionDetection(this: *mut ::std::os::raw::c_void);
}
extern "C" {

    /// Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (Bullet/Demos/SerializeDemo)

    #[link_name = "\u{1}_ZN16btCollisionWorld9serializeEP12btSerializer"]
    pub fn btCollisionWorld_serialize(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
#[repr(C)]
pub struct btCollisionShape__bindgen_vtable(::std::os::raw::c_void);
/// The btCollisionShape class provides an interface for collision shapes that can be shared among btCollisionObjects.
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionShape {
    pub vtable_: *const btCollisionShape__bindgen_vtable,
    pub m_shapeType: ::std::os::raw::c_int,
    pub m_userPointer: *mut ::std::os::raw::c_void,
    pub m_userIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btCollisionShape() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionShape>(),
        32usize,
        concat!("Size of: ", stringify!(btCollisionShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btCollisionShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionShape)).m_shapeType as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionShape),
            "::",
            stringify!(m_shapeType)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionShape)).m_userPointer as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionShape),
            "::",
            stringify!(m_userPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionShape)).m_userIndex as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionShape),
            "::",
            stringify!(m_userIndex)
        )
    );
}
extern "C" {

    /// calculateTemporalAabb calculates the enclosing aabb for the moving object over interval [0..timeStep)
    /// ///result is conservative

    #[link_name = "\u{1}_ZNK16btCollisionShape21calculateTemporalAabbERK11btTransformRK9btVector3S5_dRS3_S6_"]
    pub fn btCollisionShape_calculateTemporalAabb(
        this: *const btCollisionShape,
        curTrans: *const btTransform,
        linvel: *const btVector3,
        angvel: *const btVector3,
        timeStep: btScalar,
        temporalAabbMin: *mut btVector3,
        temporalAabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape12isPolyhedralEv"]
    pub fn btCollisionShape_isPolyhedral(this: *const btCollisionShape) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape10isConvex2dEv"]
    pub fn btCollisionShape_isConvex2d(this: *const btCollisionShape) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape8isConvexEv"]
    pub fn btCollisionShape_isConvex(this: *const btCollisionShape) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape11isNonMovingEv"]
    pub fn btCollisionShape_isNonMoving(this: *const btCollisionShape) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape9isConcaveEv"]
    pub fn btCollisionShape_isConcave(this: *const btCollisionShape) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape10isCompoundEv"]
    pub fn btCollisionShape_isCompound(this: *const btCollisionShape) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape10isSoftBodyEv"]
    pub fn btCollisionShape_isSoftBody(this: *const btCollisionShape) -> bool;
}
extern "C" {

    /// isInfinite is used to catch simulation error (aabb check)

    #[link_name = "\u{1}_ZNK16btCollisionShape10isInfiniteEv"]
    pub fn btCollisionShape_isInfinite(this: *const btCollisionShape) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape12getShapeTypeEv"]
    pub fn btCollisionShape_getShapeType(this: *const btCollisionShape) -> ::std::os::raw::c_int;
}
extern "C" {

    /// optional user data pointer

    #[link_name = "\u{1}_ZN16btCollisionShape14setUserPointerEPv"]
    pub fn btCollisionShape_setUserPointer(
        this: *mut btCollisionShape,
        userPtr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape14getUserPointerEv"]
    pub fn btCollisionShape_getUserPointer(
        this: *const btCollisionShape,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionShape12setUserIndexEi"]
    pub fn btCollisionShape_setUserIndex(this: *mut btCollisionShape, index: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape12getUserIndexEv"]
    pub fn btCollisionShape_getUserIndex(this: *const btCollisionShape) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionShapeC2Ev"]
    pub fn btCollisionShape_btCollisionShape(this: *mut btCollisionShape);
}
impl btCollisionShape {
    #[inline]
    pub unsafe fn calculateTemporalAabb(
        &self,
        curTrans: *const btTransform,
        linvel: *const btVector3,
        angvel: *const btVector3,
        timeStep: btScalar,
        temporalAabbMin: *mut btVector3,
        temporalAabbMax: *mut btVector3,
    ) {
        btCollisionShape_calculateTemporalAabb(
            self,
            curTrans,
            linvel,
            angvel,
            timeStep,
            temporalAabbMin,
            temporalAabbMax,
        )
    }
    #[inline]
    pub unsafe fn isPolyhedral(&self) -> bool {
        btCollisionShape_isPolyhedral(self)
    }
    #[inline]
    pub unsafe fn isConvex2d(&self) -> bool {
        btCollisionShape_isConvex2d(self)
    }
    #[inline]
    pub unsafe fn isConvex(&self) -> bool {
        btCollisionShape_isConvex(self)
    }
    #[inline]
    pub unsafe fn isNonMoving(&self) -> bool {
        btCollisionShape_isNonMoving(self)
    }
    #[inline]
    pub unsafe fn isConcave(&self) -> bool {
        btCollisionShape_isConcave(self)
    }
    #[inline]
    pub unsafe fn isCompound(&self) -> bool {
        btCollisionShape_isCompound(self)
    }
    #[inline]
    pub unsafe fn isSoftBody(&self) -> bool {
        btCollisionShape_isSoftBody(self)
    }
    #[inline]
    pub unsafe fn isInfinite(&self) -> bool {
        btCollisionShape_isInfinite(self)
    }
    #[inline]
    pub unsafe fn getShapeType(&self) -> ::std::os::raw::c_int {
        btCollisionShape_getShapeType(self)
    }
    #[inline]
    pub unsafe fn setUserPointer(&mut self, userPtr: *mut ::std::os::raw::c_void) {
        btCollisionShape_setUserPointer(self, userPtr)
    }
    #[inline]
    pub unsafe fn getUserPointer(&self) -> *mut ::std::os::raw::c_void {
        btCollisionShape_getUserPointer(self)
    }
    #[inline]
    pub unsafe fn setUserIndex(&mut self, index: ::std::os::raw::c_int) {
        btCollisionShape_setUserIndex(self, index)
    }
    #[inline]
    pub unsafe fn getUserIndex(&self) -> ::std::os::raw::c_int {
        btCollisionShape_getUserIndex(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionShape_btCollisionShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionShapeD0Ev"]
    pub fn btCollisionShape_btCollisionShape_destructor(this: *mut btCollisionShape);
}
extern "C" {

    /// getAabb returns the axis aligned bounding box in the coordinate frame of the given transform t.

    #[link_name = "\u{1}_ZNK16btCollisionShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btCollisionShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape17getBoundingSphereER9btVector3Rd"]
    pub fn btCollisionShape_getBoundingSphere(
        this: *mut ::std::os::raw::c_void,
        center: *mut btVector3,
        radius: *mut btScalar,
    );
}
extern "C" {

    /// getAngularMotionDisc returns the maximum radius needed for Conservative Advancement to handle time-of-impact with rotations.

    #[link_name = "\u{1}_ZNK16btCollisionShape20getAngularMotionDiscEv"]
    pub fn btCollisionShape_getAngularMotionDisc(this: *mut ::std::os::raw::c_void) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape27getContactBreakingThresholdEd"]
    pub fn btCollisionShape_getContactBreakingThreshold(
        this: *mut ::std::os::raw::c_void,
        defaultContactThresholdFactor: btScalar,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionShape15setLocalScalingERK9btVector3"]
    pub fn btCollisionShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape15getLocalScalingEv"]
    pub fn btCollisionShape_getLocalScaling(this: *mut ::std::os::raw::c_void) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape21calculateLocalInertiaEdR9btVector3"]
    pub fn btCollisionShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape7getNameEv"]
    pub fn btCollisionShape_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {

    /// the getAnisotropicRollingFrictionDirection can be used in combination with setAnisotropicFriction
    /// ///See Bullet/Demos/RollingFrictionDemo for an example

    #[link_name = "\u{1}_ZNK16btCollisionShape38getAnisotropicRollingFrictionDirectionEv"]
    pub fn btCollisionShape_getAnisotropicRollingFrictionDirection(
        this: *mut ::std::os::raw::c_void,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCollisionShape9setMarginEd"]
    pub fn btCollisionShape_setMargin(this: *mut ::std::os::raw::c_void, margin: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape9getMarginEv"]
    pub fn btCollisionShape_getMargin(this: *mut ::std::os::raw::c_void) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape28calculateSerializeBufferSizeEv"]
    pub fn btCollisionShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK16btCollisionShape9serializeEPvP12btSerializer"]
    pub fn btCollisionShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCollisionShape20serializeSingleShapeEP12btSerializer"]
    pub fn btCollisionShape_serializeSingleShape(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionShapeData {
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_shapeType: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btCollisionShapeData() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionShapeData>(),
        16usize,
        concat!("Size of: ", stringify!(btCollisionShapeData))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionShapeData>(),
        8usize,
        concat!("Alignment of ", stringify!(btCollisionShapeData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionShapeData)).m_name as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionShapeData),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionShapeData)).m_shapeType as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionShapeData),
            "::",
            stringify!(m_shapeType)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionShapeData)).m_padding as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionShapeData),
            "::",
            stringify!(m_padding)
        )
    );
}
/// The btConvexShape is an abstract shape interface, implemented by all convex shapes such as btBoxShape, btConvexHullShape etc.
/// It describes general convex shapes using the localGetSupportingVertex interface, used by collision detectors such as btGjkPairDetector.
#[repr(C)]
#[derive(Debug)]
pub struct btConvexShape {
    pub _base: btCollisionShape,
}
#[test]
fn bindgen_test_layout_btConvexShape() {
    assert_eq!(
        ::std::mem::size_of::<btConvexShape>(),
        32usize,
        concat!("Size of: ", stringify!(btConvexShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btConvexShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btConvexShape))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btConvexShape44localGetSupportVertexWithoutMarginNonVirtualERK9btVector3"]
    pub fn btConvexShape_localGetSupportVertexWithoutMarginNonVirtual(
        this: *const btConvexShape,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btConvexShape31localGetSupportVertexNonVirtualERK9btVector3"]
    pub fn btConvexShape_localGetSupportVertexNonVirtual(
        this: *const btConvexShape,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btConvexShape19getMarginNonVirtualEv"]
    pub fn btConvexShape_getMarginNonVirtual(this: *const btConvexShape) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btConvexShape17getAabbNonVirtualERK11btTransformR9btVector3S4_"]
    pub fn btConvexShape_getAabbNonVirtual(
        this: *const btConvexShape,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13btConvexShapeC2Ev"]
    pub fn btConvexShape_btConvexShape(this: *mut btConvexShape);
}
impl btConvexShape {
    #[inline]
    pub unsafe fn localGetSupportVertexWithoutMarginNonVirtual(
        &self,
        vec: *const btVector3,
    ) -> btVector3 {
        btConvexShape_localGetSupportVertexWithoutMarginNonVirtual(self, vec)
    }
    #[inline]
    pub unsafe fn localGetSupportVertexNonVirtual(&self, vec: *const btVector3) -> btVector3 {
        btConvexShape_localGetSupportVertexNonVirtual(self, vec)
    }
    #[inline]
    pub unsafe fn getMarginNonVirtual(&self) -> btScalar {
        btConvexShape_getMarginNonVirtual(self)
    }
    #[inline]
    pub unsafe fn getAabbNonVirtual(
        &self,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    ) {
        btConvexShape_getAabbNonVirtual(self, t, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexShape_btConvexShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN13btConvexShapeD0Ev"]
    pub fn btConvexShape_btConvexShape_destructor(this: *mut btConvexShape);
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btConvexShape24localGetSupportingVertexERK9btVector3"]
    pub fn btConvexShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btConvexShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
    pub fn btConvexShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btConvexShape7projectERK11btTransformRK9btVector3RdS6_RS3_S7_"]
    pub fn btConvexShape_project(
        this: *mut ::std::os::raw::c_void,
        trans: *const btTransform,
        dir: *const btVector3,
        minProj: *mut btScalar,
        maxProj: *mut btScalar,
        witnesPtMin: *mut btVector3,
        witnesPtMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btConvexShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
    pub fn btConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version

    #[link_name = "\u{1}_ZNK13btConvexShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btConvexShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btConvexShape11getAabbSlowERK11btTransformR9btVector3S4_"]
    pub fn btConvexShape_getAabbSlow(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13btConvexShape15setLocalScalingERK9btVector3"]
    pub fn btConvexShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btConvexShape15getLocalScalingEv"]
    pub fn btConvexShape_getLocalScaling(this: *mut ::std::os::raw::c_void) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN13btConvexShape9setMarginEd"]
    pub fn btConvexShape_setMargin(this: *mut ::std::os::raw::c_void, margin: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btConvexShape9getMarginEv"]
    pub fn btConvexShape_getMargin(this: *mut ::std::os::raw::c_void) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btConvexShape36getNumPreferredPenetrationDirectionsEv"]
    pub fn btConvexShape_getNumPreferredPenetrationDirections(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btConvexShape32getPreferredPenetrationDirectionEiR9btVector3"]
    pub fn btConvexShape_getPreferredPenetrationDirection(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
        penetrationVector: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z10AabbExpandR9btVector3S0_RKS_S2_"]
    pub fn AabbExpand(
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
        expansionMin: *const btVector3,
        expansionMax: *const btVector3,
    );
}
extern "C" {

    /// conservative test for overlap between two aabbs

    #[link_name = "\u{1}_Z21TestPointAgainstAabb2RK9btVector3S1_S1_"]
    pub fn TestPointAgainstAabb2(
        aabbMin1: *const btVector3,
        aabbMax1: *const btVector3,
        point: *const btVector3,
    ) -> bool;
}
extern "C" {

    /// conservative test for overlap between two aabbs

    #[link_name = "\u{1}_Z20TestAabbAgainstAabb2RK9btVector3S1_S1_S1_"]
    pub fn TestAabbAgainstAabb2(
        aabbMin1: *const btVector3,
        aabbMax1: *const btVector3,
        aabbMin2: *const btVector3,
        aabbMax2: *const btVector3,
    ) -> bool;
}
extern "C" {

    /// conservative test for overlap between triangle and aabb

    #[link_name = "\u{1}_Z24TestTriangleAgainstAabb2PK9btVector3RS0_S2_"]
    pub fn TestTriangleAgainstAabb2(
        vertices: *const btVector3,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z9btOutcodeRK9btVector3S1_"]
    pub fn btOutcode(p: *const btVector3, halfExtent: *const btVector3) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Z10btRayAabb2RK9btVector3S1_PKjPS0_Rddd"]
    pub fn btRayAabb2(
        rayFrom: *const btVector3,
        rayInvDirection: *const btVector3,
        raySign: *const ::std::os::raw::c_uint,
        bounds: *const btVector3,
        tmin: *mut btScalar,
        lambda_min: btScalar,
        lambda_max: btScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z9btRayAabbRK9btVector3S1_S1_S1_RdRS_"]
    pub fn btRayAabb(
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        param: *mut btScalar,
        normal: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z15btTransformAabbRK9btVector3dRK11btTransformRS_S5_"]
    pub fn btTransformAabb(
        halfExtents: *const btVector3,
        margin: btScalar,
        t: *const btTransform,
        aabbMinOut: *mut btVector3,
        aabbMaxOut: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z15btTransformAabbRK9btVector3S1_dRK11btTransformRS_S5_"]
    pub fn btTransformAabb1(
        localAabbMin: *const btVector3,
        localAabbMax: *const btVector3,
        margin: btScalar,
        trans: *const btTransform,
        aabbMinOut: *mut btVector3,
        aabbMaxOut: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z37testQuantizedAabbAgainstQuantizedAabbPKtS0_S0_S0_"]
    pub fn testQuantizedAabbAgainstQuantizedAabb(
        aabbMin1: *const ::std::os::raw::c_ushort,
        aabbMax1: *const ::std::os::raw::c_ushort,
        aabbMin2: *const ::std::os::raw::c_ushort,
        aabbMax2: *const ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_uint;
}
/// The btConvexInternalShape is an internal base class, shared by most convex shape implementations.
/// The btConvexInternalShape uses a default collision margin set to CONVEX_DISTANCE_MARGIN.
/// This collision margin used by Gjk and some other algorithms, see also btCollisionMargin.h
/// Note that when creating small shapes (derived from btConvexInternalShape),
/// you need to make sure to set a smaller collision margin, using the 'setMargin' API
/// There is a automatic mechanism 'setSafeMargin' used by btBoxShape and btCylinderShape
#[repr(C)]
#[derive(Debug)]
pub struct btConvexInternalShape {
    pub _base: btConvexShape,
    pub m_localScaling: btVector3,
    pub m_implicitShapeDimensions: btVector3,
    pub m_collisionMargin: btScalar,
    pub m_padding: btScalar,
}
#[test]
fn bindgen_test_layout_btConvexInternalShape() {
    assert_eq!(
        ::std::mem::size_of::<btConvexInternalShape>(),
        112usize,
        concat!("Size of: ", stringify!(btConvexInternalShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btConvexInternalShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btConvexInternalShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConvexInternalShape)).m_localScaling as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexInternalShape),
            "::",
            stringify!(m_localScaling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConvexInternalShape)).m_implicitShapeDimensions as *const _ as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexInternalShape),
            "::",
            stringify!(m_implicitShapeDimensions)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConvexInternalShape)).m_collisionMargin as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexInternalShape),
            "::",
            stringify!(m_collisionMargin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConvexInternalShape)).m_padding as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexInternalShape),
            "::",
            stringify!(m_padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConvexInternalShape26getImplicitShapeDimensionsEv"]
    pub fn btConvexInternalShape_getImplicitShapeDimensions(
        this: *const btConvexInternalShape,
    ) -> *const btVector3;
}
extern "C" {

    /// warning: use setImplicitShapeDimensions with care
    /// ///changing a collision shape while the body is in the world is not recommended,
    /// ///it is best to remove the body from the world, then make the change, and re-add it
    /// ///alternatively flush the contact points, see documentation for 'cleanProxyFromPairs'

    #[link_name = "\u{1}_ZN21btConvexInternalShape26setImplicitShapeDimensionsERK9btVector3"]
    pub fn btConvexInternalShape_setImplicitShapeDimensions(
        this: *mut btConvexInternalShape,
        dimensions: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConvexInternalShape13setSafeMarginEdd"]
    pub fn btConvexInternalShape_setSafeMargin(
        this: *mut btConvexInternalShape,
        minDimension: btScalar,
        defaultMarginMultiplier: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConvexInternalShape13setSafeMarginERK9btVector3d"]
    pub fn btConvexInternalShape_setSafeMargin1(
        this: *mut btConvexInternalShape,
        halfExtents: *const btVector3,
        defaultMarginMultiplier: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConvexInternalShape17getLocalScalingNVEv"]
    pub fn btConvexInternalShape_getLocalScalingNV(
        this: *const btConvexInternalShape,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConvexInternalShape11getMarginNVEv"]
    pub fn btConvexInternalShape_getMarginNV(this: *const btConvexInternalShape) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConvexInternalShapeC2Ev"]
    pub fn btConvexInternalShape_btConvexInternalShape(this: *mut btConvexInternalShape);
}
impl btConvexInternalShape {
    #[inline]
    pub unsafe fn getImplicitShapeDimensions(&self) -> *const btVector3 {
        btConvexInternalShape_getImplicitShapeDimensions(self)
    }
    #[inline]
    pub unsafe fn setImplicitShapeDimensions(&mut self, dimensions: *const btVector3) {
        btConvexInternalShape_setImplicitShapeDimensions(self, dimensions)
    }
    #[inline]
    pub unsafe fn setSafeMargin(
        &mut self,
        minDimension: btScalar,
        defaultMarginMultiplier: btScalar,
    ) {
        btConvexInternalShape_setSafeMargin(self, minDimension, defaultMarginMultiplier)
    }
    #[inline]
    pub unsafe fn setSafeMargin1(
        &mut self,
        halfExtents: *const btVector3,
        defaultMarginMultiplier: btScalar,
    ) {
        btConvexInternalShape_setSafeMargin1(self, halfExtents, defaultMarginMultiplier)
    }
    #[inline]
    pub unsafe fn getLocalScalingNV(&self) -> *const btVector3 {
        btConvexInternalShape_getLocalScalingNV(self)
    }
    #[inline]
    pub unsafe fn getMarginNV(&self) -> btScalar {
        btConvexInternalShape_getMarginNV(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexInternalShape_btConvexInternalShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConvexInternalShapeD0Ev"]
    pub fn btConvexInternalShape_btConvexInternalShape_destructor(this: *mut btConvexInternalShape);
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConvexInternalShape24localGetSupportingVertexERK9btVector3"]
    pub fn btConvexInternalShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {

    /// getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version

    #[link_name = "\u{1}_ZNK21btConvexInternalShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btConvexInternalShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConvexInternalShape11getAabbSlowERK11btTransformR9btVector3S4_"]
    pub fn btConvexInternalShape_getAabbSlow(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConvexInternalShape15setLocalScalingERK9btVector3"]
    pub fn btConvexInternalShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConvexInternalShape15getLocalScalingEv"]
    pub fn btConvexInternalShape_getLocalScaling(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConvexInternalShape9setMarginEd"]
    pub fn btConvexInternalShape_setMargin(this: *mut ::std::os::raw::c_void, margin: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConvexInternalShape9getMarginEv"]
    pub fn btConvexInternalShape_getMargin(this: *mut ::std::os::raw::c_void) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConvexInternalShape36getNumPreferredPenetrationDirectionsEv"]
    pub fn btConvexInternalShape_getNumPreferredPenetrationDirections(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConvexInternalShape32getPreferredPenetrationDirectionEiR9btVector3"]
    pub fn btConvexInternalShape_getPreferredPenetrationDirection(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
        penetrationVector: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConvexInternalShape28calculateSerializeBufferSizeEv"]
    pub fn btConvexInternalShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK21btConvexInternalShape9serializeEPvP12btSerializer"]
    pub fn btConvexInternalShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConvexInternalShapeData {
    pub m_collisionShapeData: btCollisionShapeData,
    pub m_localScaling: btVector3FloatData,
    pub m_implicitShapeDimensions: btVector3FloatData,
    pub m_collisionMargin: f32,
    pub m_padding: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btConvexInternalShapeData() {
    assert_eq!(
        ::std::mem::size_of::<btConvexInternalShapeData>(),
        56usize,
        concat!("Size of: ", stringify!(btConvexInternalShapeData))
    );
    assert_eq!(
        ::std::mem::align_of::<btConvexInternalShapeData>(),
        8usize,
        concat!("Alignment of ", stringify!(btConvexInternalShapeData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConvexInternalShapeData)).m_collisionShapeData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexInternalShapeData),
            "::",
            stringify!(m_collisionShapeData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConvexInternalShapeData)).m_localScaling as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexInternalShapeData),
            "::",
            stringify!(m_localScaling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConvexInternalShapeData)).m_implicitShapeDimensions as *const _
                as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexInternalShapeData),
            "::",
            stringify!(m_implicitShapeDimensions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConvexInternalShapeData)).m_collisionMargin as *const _ as usize
        },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexInternalShapeData),
            "::",
            stringify!(m_collisionMargin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConvexInternalShapeData)).m_padding as *const _ as usize },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexInternalShapeData),
            "::",
            stringify!(m_padding)
        )
    );
}
/// btConvexInternalAabbCachingShape adds local aabb caching for convex shapes, to avoid expensive bounding box calculations
#[repr(C)]
#[derive(Debug)]
pub struct btConvexInternalAabbCachingShape {
    pub _base: btConvexInternalShape,
    pub m_localAabbMin: btVector3,
    pub m_localAabbMax: btVector3,
    pub m_isLocalAabbValid: bool,
}
#[test]
fn bindgen_test_layout_btConvexInternalAabbCachingShape() {
    assert_eq!(
        ::std::mem::size_of::<btConvexInternalAabbCachingShape>(),
        184usize,
        concat!("Size of: ", stringify!(btConvexInternalAabbCachingShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btConvexInternalAabbCachingShape>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btConvexInternalAabbCachingShape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConvexInternalAabbCachingShape)).m_localAabbMin as *const _ as usize
        },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexInternalAabbCachingShape),
            "::",
            stringify!(m_localAabbMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConvexInternalAabbCachingShape)).m_localAabbMax as *const _ as usize
        },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexInternalAabbCachingShape),
            "::",
            stringify!(m_localAabbMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConvexInternalAabbCachingShape)).m_isLocalAabbValid as *const _
                as usize
        },
        176usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexInternalAabbCachingShape),
            "::",
            stringify!(m_isLocalAabbValid)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN32btConvexInternalAabbCachingShape18setCachedLocalAabbERK9btVector3S2_"]
    pub fn btConvexInternalAabbCachingShape_setCachedLocalAabb(
        this: *mut btConvexInternalAabbCachingShape,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK32btConvexInternalAabbCachingShape18getCachedLocalAabbER9btVector3S1_"]
    pub fn btConvexInternalAabbCachingShape_getCachedLocalAabb(
        this: *const btConvexInternalAabbCachingShape,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK32btConvexInternalAabbCachingShape17getNonvirtualAabbERK11btTransformR9btVector3S4_d"]
    pub fn btConvexInternalAabbCachingShape_getNonvirtualAabb(
        this: *const btConvexInternalAabbCachingShape,
        trans: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
        margin: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN32btConvexInternalAabbCachingShape15recalcLocalAabbEv"]
    pub fn btConvexInternalAabbCachingShape_recalcLocalAabb(
        this: *mut btConvexInternalAabbCachingShape,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN32btConvexInternalAabbCachingShapeC2Ev"]
    pub fn btConvexInternalAabbCachingShape_btConvexInternalAabbCachingShape(
        this: *mut btConvexInternalAabbCachingShape,
    );
}
impl btConvexInternalAabbCachingShape {
    #[inline]
    pub unsafe fn setCachedLocalAabb(
        &mut self,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) {
        btConvexInternalAabbCachingShape_setCachedLocalAabb(self, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn getCachedLocalAabb(&self, aabbMin: *mut btVector3, aabbMax: *mut btVector3) {
        btConvexInternalAabbCachingShape_getCachedLocalAabb(self, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn getNonvirtualAabb(
        &self,
        trans: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
        margin: btScalar,
    ) {
        btConvexInternalAabbCachingShape_getNonvirtualAabb(self, trans, aabbMin, aabbMax, margin)
    }
    #[inline]
    pub unsafe fn recalcLocalAabb(&mut self) {
        btConvexInternalAabbCachingShape_recalcLocalAabb(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexInternalAabbCachingShape_btConvexInternalAabbCachingShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN32btConvexInternalAabbCachingShape15setLocalScalingERK9btVector3"]
    pub fn btConvexInternalAabbCachingShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK32btConvexInternalAabbCachingShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btConvexInternalAabbCachingShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConvexPolyhedron {
    _unused: [u8; 0],
}
/// The btPolyhedralConvexShape is an internal interface class for polyhedral convex shapes.
#[repr(C)]
#[derive(Debug)]
pub struct btPolyhedralConvexShape {
    pub _base: btConvexInternalShape,
    pub m_polyhedron: *mut btConvexPolyhedron,
}
#[test]
fn bindgen_test_layout_btPolyhedralConvexShape() {
    assert_eq!(
        ::std::mem::size_of::<btPolyhedralConvexShape>(),
        120usize,
        concat!("Size of: ", stringify!(btPolyhedralConvexShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btPolyhedralConvexShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btPolyhedralConvexShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPolyhedralConvexShape)).m_polyhedron as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPolyhedralConvexShape),
            "::",
            stringify!(m_polyhedron)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPolyhedralConvexShape19getConvexPolyhedronEv"]
    pub fn btPolyhedralConvexShape_getConvexPolyhedron(
        this: *const btPolyhedralConvexShape,
    ) -> *const btConvexPolyhedron;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btPolyhedralConvexShapeC2Ev"]
    pub fn btPolyhedralConvexShape_btPolyhedralConvexShape(this: *mut btPolyhedralConvexShape);
}
impl btPolyhedralConvexShape {
    #[inline]
    pub unsafe fn getConvexPolyhedron(&self) -> *const btConvexPolyhedron {
        btPolyhedralConvexShape_getConvexPolyhedron(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btPolyhedralConvexShape_btPolyhedralConvexShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN23btPolyhedralConvexShapeD0Ev"]
    pub fn btPolyhedralConvexShape_btPolyhedralConvexShape_destructor(
        this: *mut btPolyhedralConvexShape,
    );
}
extern "C" {

    /// optional method mainly used to generate multiple contact points by clipping polyhedral features (faces/edges)
    /// ///experimental/work-in-progress

    #[link_name = "\u{1}_ZN23btPolyhedralConvexShape28initializePolyhedralFeaturesEi"]
    pub fn btPolyhedralConvexShape_initializePolyhedralFeatures(
        this: *mut ::std::os::raw::c_void,
        shiftVerticesByMargin: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPolyhedralConvexShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
    pub fn btPolyhedralConvexShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPolyhedralConvexShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
    pub fn btPolyhedralConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPolyhedralConvexShape21calculateLocalInertiaEdR9btVector3"]
    pub fn btPolyhedralConvexShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPolyhedralConvexShape14getNumVerticesEv"]
    pub fn btPolyhedralConvexShape_getNumVertices(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPolyhedralConvexShape11getNumEdgesEv"]
    pub fn btPolyhedralConvexShape_getNumEdges(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPolyhedralConvexShape7getEdgeEiR9btVector3S1_"]
    pub fn btPolyhedralConvexShape_getEdge(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        pa: *mut btVector3,
        pb: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPolyhedralConvexShape9getVertexEiR9btVector3"]
    pub fn btPolyhedralConvexShape_getVertex(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        vtx: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPolyhedralConvexShape12getNumPlanesEv"]
    pub fn btPolyhedralConvexShape_getNumPlanes(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPolyhedralConvexShape8getPlaneER9btVector3S1_i"]
    pub fn btPolyhedralConvexShape_getPlane(
        this: *mut ::std::os::raw::c_void,
        planeNormal: *mut btVector3,
        planeSupport: *mut btVector3,
        i: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPolyhedralConvexShape8isInsideERK9btVector3d"]
    pub fn btPolyhedralConvexShape_isInside(
        this: *mut ::std::os::raw::c_void,
        pt: *const btVector3,
        tolerance: btScalar,
    ) -> bool;
}
/// The btPolyhedralConvexAabbCachingShape adds aabb caching to the btPolyhedralConvexShape
#[repr(C)]
#[derive(Debug)]
pub struct btPolyhedralConvexAabbCachingShape {
    pub _base: btPolyhedralConvexShape,
    pub m_localAabbMin: btVector3,
    pub m_localAabbMax: btVector3,
    pub m_isLocalAabbValid: bool,
}
#[test]
fn bindgen_test_layout_btPolyhedralConvexAabbCachingShape() {
    assert_eq!(
        ::std::mem::size_of::<btPolyhedralConvexAabbCachingShape>(),
        192usize,
        concat!("Size of: ", stringify!(btPolyhedralConvexAabbCachingShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btPolyhedralConvexAabbCachingShape>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btPolyhedralConvexAabbCachingShape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPolyhedralConvexAabbCachingShape)).m_localAabbMin as *const _ as usize
        },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPolyhedralConvexAabbCachingShape),
            "::",
            stringify!(m_localAabbMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPolyhedralConvexAabbCachingShape)).m_localAabbMax as *const _ as usize
        },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPolyhedralConvexAabbCachingShape),
            "::",
            stringify!(m_localAabbMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPolyhedralConvexAabbCachingShape)).m_isLocalAabbValid as *const _
                as usize
        },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPolyhedralConvexAabbCachingShape),
            "::",
            stringify!(m_isLocalAabbValid)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN34btPolyhedralConvexAabbCachingShape18setCachedLocalAabbERK9btVector3S2_"]
    pub fn btPolyhedralConvexAabbCachingShape_setCachedLocalAabb(
        this: *mut btPolyhedralConvexAabbCachingShape,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK34btPolyhedralConvexAabbCachingShape18getCachedLocalAabbER9btVector3S1_"]
    pub fn btPolyhedralConvexAabbCachingShape_getCachedLocalAabb(
        this: *const btPolyhedralConvexAabbCachingShape,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK34btPolyhedralConvexAabbCachingShape17getNonvirtualAabbERK11btTransformR9btVector3S4_d"]
    pub fn btPolyhedralConvexAabbCachingShape_getNonvirtualAabb(
        this: *const btPolyhedralConvexAabbCachingShape,
        trans: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
        margin: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN34btPolyhedralConvexAabbCachingShape15recalcLocalAabbEv"]
    pub fn btPolyhedralConvexAabbCachingShape_recalcLocalAabb(
        this: *mut btPolyhedralConvexAabbCachingShape,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN34btPolyhedralConvexAabbCachingShapeC2Ev"]
    pub fn btPolyhedralConvexAabbCachingShape_btPolyhedralConvexAabbCachingShape(
        this: *mut btPolyhedralConvexAabbCachingShape,
    );
}
impl btPolyhedralConvexAabbCachingShape {
    #[inline]
    pub unsafe fn setCachedLocalAabb(
        &mut self,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) {
        btPolyhedralConvexAabbCachingShape_setCachedLocalAabb(self, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn getCachedLocalAabb(&self, aabbMin: *mut btVector3, aabbMax: *mut btVector3) {
        btPolyhedralConvexAabbCachingShape_getCachedLocalAabb(self, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn getNonvirtualAabb(
        &self,
        trans: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
        margin: btScalar,
    ) {
        btPolyhedralConvexAabbCachingShape_getNonvirtualAabb(self, trans, aabbMin, aabbMax, margin)
    }
    #[inline]
    pub unsafe fn recalcLocalAabb(&mut self) {
        btPolyhedralConvexAabbCachingShape_recalcLocalAabb(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btPolyhedralConvexAabbCachingShape_btPolyhedralConvexAabbCachingShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN34btPolyhedralConvexAabbCachingShape15setLocalScalingERK9btVector3"]
    pub fn btPolyhedralConvexAabbCachingShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK34btPolyhedralConvexAabbCachingShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btPolyhedralConvexAabbCachingShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
/// The btBoxShape is a box primitive around the origin, its sides axis aligned with length specified by half extents, in local shape coordinates. When used as part of a btCollisionObject or btRigidBody it will be an oriented box in world space.
#[repr(C)]
#[derive(Debug)]
pub struct btBoxShape {
    pub _base: btPolyhedralConvexShape,
}
#[test]
fn bindgen_test_layout_btBoxShape() {
    assert_eq!(
        ::std::mem::size_of::<btBoxShape>(),
        120usize,
        concat!("Size of: ", stringify!(btBoxShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btBoxShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btBoxShape))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape24getHalfExtentsWithMarginEv"]
    pub fn btBoxShape_getHalfExtentsWithMargin(this: *const btBoxShape) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape27getHalfExtentsWithoutMarginEv"]
    pub fn btBoxShape_getHalfExtentsWithoutMargin(this: *const btBoxShape) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN10btBoxShapeC1ERK9btVector3"]
    pub fn btBoxShape_btBoxShape(this: *mut btBoxShape, boxHalfExtents: *const btVector3);
}
impl btBoxShape {
    #[inline]
    pub unsafe fn getHalfExtentsWithMargin(&self) -> btVector3 {
        btBoxShape_getHalfExtentsWithMargin(self)
    }
    #[inline]
    pub unsafe fn getHalfExtentsWithoutMargin(&self) -> *const btVector3 {
        btBoxShape_getHalfExtentsWithoutMargin(self)
    }
    #[inline]
    pub unsafe fn new(boxHalfExtents: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBoxShape_btBoxShape(&mut __bindgen_tmp, boxHalfExtents);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape24localGetSupportingVertexERK9btVector3"]
    pub fn btBoxShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
    pub fn btBoxShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
    pub fn btBoxShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10btBoxShape9setMarginEd"]
    pub fn btBoxShape_setMargin(this: *mut ::std::os::raw::c_void, collisionMargin: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN10btBoxShape15setLocalScalingERK9btVector3"]
    pub fn btBoxShape_setLocalScaling(this: *mut ::std::os::raw::c_void, scaling: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btBoxShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape21calculateLocalInertiaEdR9btVector3"]
    pub fn btBoxShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape8getPlaneER9btVector3S1_i"]
    pub fn btBoxShape_getPlane(
        this: *mut ::std::os::raw::c_void,
        planeNormal: *mut btVector3,
        planeSupport: *mut btVector3,
        i: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape12getNumPlanesEv"]
    pub fn btBoxShape_getNumPlanes(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape14getNumVerticesEv"]
    pub fn btBoxShape_getNumVertices(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape11getNumEdgesEv"]
    pub fn btBoxShape_getNumEdges(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape9getVertexEiR9btVector3"]
    pub fn btBoxShape_getVertex(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        vtx: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape16getPlaneEquationER9btVector4i"]
    pub fn btBoxShape_getPlaneEquation(
        this: *mut ::std::os::raw::c_void,
        plane: *mut btVector4,
        i: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape7getEdgeEiR9btVector3S1_"]
    pub fn btBoxShape_getEdge(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        pa: *mut btVector3,
        pb: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape8isInsideERK9btVector3d"]
    pub fn btBoxShape_isInside(
        this: *mut ::std::os::raw::c_void,
        pt: *const btVector3,
        tolerance: btScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape7getNameEv"]
    pub fn btBoxShape_getName(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape36getNumPreferredPenetrationDirectionsEv"]
    pub fn btBoxShape_getNumPreferredPenetrationDirections(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btBoxShape32getPreferredPenetrationDirectionEiR9btVector3"]
    pub fn btBoxShape_getPreferredPenetrationDirection(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
        penetrationVector: *mut btVector3,
    );
}
/// The btSphereShape implements an implicit sphere, centered around a local origin with radius.
#[repr(C)]
#[derive(Debug)]
pub struct btSphereShape {
    pub _base: btConvexInternalShape,
}
#[test]
fn bindgen_test_layout_btSphereShape() {
    assert_eq!(
        ::std::mem::size_of::<btSphereShape>(),
        112usize,
        concat!("Size of: ", stringify!(btSphereShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btSphereShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btSphereShape))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btSphereShape9getRadiusEv"]
    pub fn btSphereShape_getRadius(this: *const btSphereShape) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN13btSphereShape17setUnscaledRadiusEd"]
    pub fn btSphereShape_setUnscaledRadius(this: *mut btSphereShape, radius: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN13btSphereShapeC1Ed"]
    pub fn btSphereShape_btSphereShape(this: *mut btSphereShape, radius: btScalar);
}
impl btSphereShape {
    #[inline]
    pub unsafe fn getRadius(&self) -> btScalar {
        btSphereShape_getRadius(self)
    }
    #[inline]
    pub unsafe fn setUnscaledRadius(&mut self, radius: btScalar) {
        btSphereShape_setUnscaledRadius(self, radius)
    }
    #[inline]
    pub unsafe fn new(radius: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSphereShape_btSphereShape(&mut __bindgen_tmp, radius);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btSphereShape24localGetSupportingVertexERK9btVector3"]
    pub fn btSphereShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btSphereShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
    pub fn btSphereShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btSphereShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
    pub fn btSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btSphereShape21calculateLocalInertiaEdR9btVector3"]
    pub fn btSphereShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btSphereShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btSphereShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btSphereShape7getNameEv"]
    pub fn btSphereShape_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN13btSphereShape9setMarginEd"]
    pub fn btSphereShape_setMargin(this: *mut ::std::os::raw::c_void, margin: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK13btSphereShape9getMarginEv"]
    pub fn btSphereShape_getMargin(this: *mut ::std::os::raw::c_void) -> btScalar;
}
/// The btCapsuleShape represents a capsule around the Y axis, there is also the btCapsuleShapeX aligned around the X axis and btCapsuleShapeZ around the Z axis.
/// The total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
/// The btCapsuleShape is a convex hull of two spheres. The btMultiSphereShape is a more general collision shape that takes the convex hull of multiple sphere, so it can also represent a capsule when just using two spheres.
#[repr(C)]
#[derive(Debug)]
pub struct btCapsuleShape {
    pub _base: btConvexInternalShape,
    pub m_upAxis: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btCapsuleShape() {
    assert_eq!(
        ::std::mem::size_of::<btCapsuleShape>(),
        120usize,
        concat!("Size of: ", stringify!(btCapsuleShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btCapsuleShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btCapsuleShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCapsuleShape)).m_upAxis as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCapsuleShape),
            "::",
            stringify!(m_upAxis)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btCapsuleShape9getUpAxisEv"]
    pub fn btCapsuleShape_getUpAxis(this: *const btCapsuleShape) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btCapsuleShape9getRadiusEv"]
    pub fn btCapsuleShape_getRadius(this: *const btCapsuleShape) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btCapsuleShape13getHalfHeightEv"]
    pub fn btCapsuleShape_getHalfHeight(this: *const btCapsuleShape) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN14btCapsuleShape16deSerializeFloatEP18btCapsuleShapeData"]
    pub fn btCapsuleShape_deSerializeFloat(
        this: *mut btCapsuleShape,
        dataBuffer: *mut btCapsuleShapeData,
    );
}
extern "C" {

    /// only used for btCapsuleShapeZ and btCapsuleShapeX subclasses.

    #[link_name = "\u{1}_ZN14btCapsuleShapeC1Ev"]
    pub fn btCapsuleShape_btCapsuleShape(this: *mut btCapsuleShape);
}
extern "C" {
    #[link_name = "\u{1}_ZN14btCapsuleShapeC1Edd"]
    pub fn btCapsuleShape_btCapsuleShape1(
        this: *mut btCapsuleShape,
        radius: btScalar,
        height: btScalar,
    );
}
impl btCapsuleShape {
    #[inline]
    pub unsafe fn getUpAxis(&self) -> ::std::os::raw::c_int {
        btCapsuleShape_getUpAxis(self)
    }
    #[inline]
    pub unsafe fn getRadius(&self) -> btScalar {
        btCapsuleShape_getRadius(self)
    }
    #[inline]
    pub unsafe fn getHalfHeight(&self) -> btScalar {
        btCapsuleShape_getHalfHeight(self)
    }
    #[inline]
    pub unsafe fn deSerializeFloat(&mut self, dataBuffer: *mut btCapsuleShapeData) {
        btCapsuleShape_deSerializeFloat(self, dataBuffer)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCapsuleShape_btCapsuleShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(radius: btScalar, height: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCapsuleShape_btCapsuleShape1(&mut __bindgen_tmp, radius, height);
        __bindgen_tmp
    }
}
extern "C" {

    /// CollisionShape Interface

    #[link_name = "\u{1}_ZNK14btCapsuleShape21calculateLocalInertiaEdR9btVector3"]
    pub fn btCapsuleShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {

    /// btConvexShape Interface

    #[link_name = "\u{1}_ZNK14btCapsuleShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
    pub fn btCapsuleShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btCapsuleShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
    pub fn btCapsuleShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btCapsuleShape9setMarginEd"]
    pub fn btCapsuleShape_setMargin(this: *mut ::std::os::raw::c_void, collisionMargin: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btCapsuleShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btCapsuleShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btCapsuleShape7getNameEv"]
    pub fn btCapsuleShape_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN14btCapsuleShape15setLocalScalingERK9btVector3"]
    pub fn btCapsuleShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btCapsuleShape38getAnisotropicRollingFrictionDirectionEv"]
    pub fn btCapsuleShape_getAnisotropicRollingFrictionDirection(
        this: *mut ::std::os::raw::c_void,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btCapsuleShape28calculateSerializeBufferSizeEv"]
    pub fn btCapsuleShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK14btCapsuleShape9serializeEPvP12btSerializer"]
    pub fn btCapsuleShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// btCapsuleShapeX represents a capsule around the Z axis
/// the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
#[repr(C)]
#[derive(Debug)]
pub struct btCapsuleShapeX {
    pub _base: btCapsuleShape,
}
#[test]
fn bindgen_test_layout_btCapsuleShapeX() {
    assert_eq!(
        ::std::mem::size_of::<btCapsuleShapeX>(),
        120usize,
        concat!("Size of: ", stringify!(btCapsuleShapeX))
    );
    assert_eq!(
        ::std::mem::align_of::<btCapsuleShapeX>(),
        8usize,
        concat!("Alignment of ", stringify!(btCapsuleShapeX))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCapsuleShapeXC1Edd"]
    pub fn btCapsuleShapeX_btCapsuleShapeX(
        this: *mut btCapsuleShapeX,
        radius: btScalar,
        height: btScalar,
    );
}
impl btCapsuleShapeX {
    #[inline]
    pub unsafe fn new(radius: btScalar, height: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCapsuleShapeX_btCapsuleShapeX(&mut __bindgen_tmp, radius, height);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCapsuleShapeX7getNameEv"]
    pub fn btCapsuleShapeX_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
/// btCapsuleShapeZ represents a capsule around the Z axis
/// the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
#[repr(C)]
#[derive(Debug)]
pub struct btCapsuleShapeZ {
    pub _base: btCapsuleShape,
}
#[test]
fn bindgen_test_layout_btCapsuleShapeZ() {
    assert_eq!(
        ::std::mem::size_of::<btCapsuleShapeZ>(),
        120usize,
        concat!("Size of: ", stringify!(btCapsuleShapeZ))
    );
    assert_eq!(
        ::std::mem::align_of::<btCapsuleShapeZ>(),
        8usize,
        concat!("Alignment of ", stringify!(btCapsuleShapeZ))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCapsuleShapeZC1Edd"]
    pub fn btCapsuleShapeZ_btCapsuleShapeZ(
        this: *mut btCapsuleShapeZ,
        radius: btScalar,
        height: btScalar,
    );
}
impl btCapsuleShapeZ {
    #[inline]
    pub unsafe fn new(radius: btScalar, height: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCapsuleShapeZ_btCapsuleShapeZ(&mut __bindgen_tmp, radius, height);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCapsuleShapeZ7getNameEv"]
    pub fn btCapsuleShapeZ_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCapsuleShapeData {
    pub m_convexInternalShapeData: btConvexInternalShapeData,
    pub m_upAxis: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btCapsuleShapeData() {
    assert_eq!(
        ::std::mem::size_of::<btCapsuleShapeData>(),
        64usize,
        concat!("Size of: ", stringify!(btCapsuleShapeData))
    );
    assert_eq!(
        ::std::mem::align_of::<btCapsuleShapeData>(),
        8usize,
        concat!("Alignment of ", stringify!(btCapsuleShapeData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCapsuleShapeData)).m_convexInternalShapeData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCapsuleShapeData),
            "::",
            stringify!(m_convexInternalShapeData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCapsuleShapeData)).m_upAxis as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCapsuleShapeData),
            "::",
            stringify!(m_upAxis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCapsuleShapeData)).m_padding as *const _ as usize },
        60usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCapsuleShapeData),
            "::",
            stringify!(m_padding)
        )
    );
}
/// The btCylinderShape class implements a cylinder shape primitive, centered around the origin. Its central axis aligned with the Y axis. btCylinderShapeX is aligned with the X axis and btCylinderShapeZ around the Z axis.
#[repr(C)]
#[derive(Debug)]
pub struct btCylinderShape {
    pub _base: btConvexInternalShape,
    pub m_upAxis: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btCylinderShape() {
    assert_eq!(
        ::std::mem::size_of::<btCylinderShape>(),
        120usize,
        concat!("Size of: ", stringify!(btCylinderShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btCylinderShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btCylinderShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCylinderShape)).m_upAxis as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCylinderShape),
            "::",
            stringify!(m_upAxis)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCylinderShape24getHalfExtentsWithMarginEv"]
    pub fn btCylinderShape_getHalfExtentsWithMargin(this: *const btCylinderShape) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCylinderShape27getHalfExtentsWithoutMarginEv"]
    pub fn btCylinderShape_getHalfExtentsWithoutMargin(
        this: *const btCylinderShape,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCylinderShape9getUpAxisEv"]
    pub fn btCylinderShape_getUpAxis(this: *const btCylinderShape) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCylinderShapeC1ERK9btVector3"]
    pub fn btCylinderShape_btCylinderShape(
        this: *mut btCylinderShape,
        halfExtents: *const btVector3,
    );
}
impl btCylinderShape {
    #[inline]
    pub unsafe fn getHalfExtentsWithMargin(&self) -> btVector3 {
        btCylinderShape_getHalfExtentsWithMargin(self)
    }
    #[inline]
    pub unsafe fn getHalfExtentsWithoutMargin(&self) -> *const btVector3 {
        btCylinderShape_getHalfExtentsWithoutMargin(self)
    }
    #[inline]
    pub unsafe fn getUpAxis(&self) -> ::std::os::raw::c_int {
        btCylinderShape_getUpAxis(self)
    }
    #[inline]
    pub unsafe fn new(halfExtents: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCylinderShape_btCylinderShape(&mut __bindgen_tmp, halfExtents);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCylinderShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btCylinderShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCylinderShape21calculateLocalInertiaEdR9btVector3"]
    pub fn btCylinderShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCylinderShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
    pub fn btCylinderShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCylinderShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
    pub fn btCylinderShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCylinderShape9setMarginEd"]
    pub fn btCylinderShape_setMargin(this: *mut ::std::os::raw::c_void, collisionMargin: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCylinderShape24localGetSupportingVertexERK9btVector3"]
    pub fn btCylinderShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCylinderShape38getAnisotropicRollingFrictionDirectionEv"]
    pub fn btCylinderShape_getAnisotropicRollingFrictionDirection(
        this: *mut ::std::os::raw::c_void,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCylinderShape9getRadiusEv"]
    pub fn btCylinderShape_getRadius(this: *mut ::std::os::raw::c_void) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCylinderShape15setLocalScalingERK9btVector3"]
    pub fn btCylinderShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCylinderShape7getNameEv"]
    pub fn btCylinderShape_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCylinderShape28calculateSerializeBufferSizeEv"]
    pub fn btCylinderShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK15btCylinderShape9serializeEPvP12btSerializer"]
    pub fn btCylinderShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct btCylinderShapeX {
    pub _base: btCylinderShape,
}
#[test]
fn bindgen_test_layout_btCylinderShapeX() {
    assert_eq!(
        ::std::mem::size_of::<btCylinderShapeX>(),
        120usize,
        concat!("Size of: ", stringify!(btCylinderShapeX))
    );
    assert_eq!(
        ::std::mem::align_of::<btCylinderShapeX>(),
        8usize,
        concat!("Alignment of ", stringify!(btCylinderShapeX))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCylinderShapeXC1ERK9btVector3"]
    pub fn btCylinderShapeX_btCylinderShapeX(
        this: *mut btCylinderShapeX,
        halfExtents: *const btVector3,
    );
}
impl btCylinderShapeX {
    #[inline]
    pub unsafe fn new(halfExtents: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCylinderShapeX_btCylinderShapeX(&mut __bindgen_tmp, halfExtents);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCylinderShapeX37localGetSupportingVertexWithoutMarginERK9btVector3"]
    pub fn btCylinderShapeX_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCylinderShapeX49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
    pub fn btCylinderShapeX_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCylinderShapeX7getNameEv"]
    pub fn btCylinderShapeX_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCylinderShapeX9getRadiusEv"]
    pub fn btCylinderShapeX_getRadius(this: *mut ::std::os::raw::c_void) -> btScalar;
}
#[repr(C)]
#[derive(Debug)]
pub struct btCylinderShapeZ {
    pub _base: btCylinderShape,
}
#[test]
fn bindgen_test_layout_btCylinderShapeZ() {
    assert_eq!(
        ::std::mem::size_of::<btCylinderShapeZ>(),
        120usize,
        concat!("Size of: ", stringify!(btCylinderShapeZ))
    );
    assert_eq!(
        ::std::mem::align_of::<btCylinderShapeZ>(),
        8usize,
        concat!("Alignment of ", stringify!(btCylinderShapeZ))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btCylinderShapeZC1ERK9btVector3"]
    pub fn btCylinderShapeZ_btCylinderShapeZ(
        this: *mut btCylinderShapeZ,
        halfExtents: *const btVector3,
    );
}
impl btCylinderShapeZ {
    #[inline]
    pub unsafe fn new(halfExtents: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCylinderShapeZ_btCylinderShapeZ(&mut __bindgen_tmp, halfExtents);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCylinderShapeZ37localGetSupportingVertexWithoutMarginERK9btVector3"]
    pub fn btCylinderShapeZ_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCylinderShapeZ49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
    pub fn btCylinderShapeZ_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCylinderShapeZ7getNameEv"]
    pub fn btCylinderShapeZ_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btCylinderShapeZ9getRadiusEv"]
    pub fn btCylinderShapeZ_getRadius(this: *mut ::std::os::raw::c_void) -> btScalar;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCylinderShapeData {
    pub m_convexInternalShapeData: btConvexInternalShapeData,
    pub m_upAxis: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btCylinderShapeData() {
    assert_eq!(
        ::std::mem::size_of::<btCylinderShapeData>(),
        64usize,
        concat!("Size of: ", stringify!(btCylinderShapeData))
    );
    assert_eq!(
        ::std::mem::align_of::<btCylinderShapeData>(),
        8usize,
        concat!("Alignment of ", stringify!(btCylinderShapeData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCylinderShapeData)).m_convexInternalShapeData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCylinderShapeData),
            "::",
            stringify!(m_convexInternalShapeData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCylinderShapeData)).m_upAxis as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCylinderShapeData),
            "::",
            stringify!(m_upAxis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCylinderShapeData)).m_padding as *const _ as usize },
        60usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCylinderShapeData),
            "::",
            stringify!(m_padding)
        )
    );
}
/// The btConeShape implements a cone shape primitive, centered around the origin and aligned with the Y axis. The btConeShapeX is aligned around the X axis and btConeShapeZ around the Z axis.
#[repr(C)]
#[derive(Debug)]
pub struct btConeShape {
    pub _base: btConvexInternalShape,
    pub m_sinAngle: btScalar,
    pub m_radius: btScalar,
    pub m_height: btScalar,
    pub m_coneIndices: [::std::os::raw::c_int; 3usize],
}
#[test]
fn bindgen_test_layout_btConeShape() {
    assert_eq!(
        ::std::mem::size_of::<btConeShape>(),
        152usize,
        concat!("Size of: ", stringify!(btConeShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btConeShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btConeShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeShape)).m_sinAngle as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeShape),
            "::",
            stringify!(m_sinAngle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeShape)).m_radius as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeShape),
            "::",
            stringify!(m_radius)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeShape)).m_height as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeShape),
            "::",
            stringify!(m_height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeShape)).m_coneIndices as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeShape),
            "::",
            stringify!(m_coneIndices)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btConeShape9getRadiusEv"]
    pub fn btConeShape_getRadius(this: *const btConeShape) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btConeShape9getHeightEv"]
    pub fn btConeShape_getHeight(this: *const btConeShape) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btConeShape9setRadiusEd"]
    pub fn btConeShape_setRadius(this: *mut btConeShape, radius: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btConeShape9setHeightEd"]
    pub fn btConeShape_setHeight(this: *mut btConeShape, height: btScalar);
}
extern "C" {

    /// choose upAxis index

    #[link_name = "\u{1}_ZN11btConeShape14setConeUpIndexEi"]
    pub fn btConeShape_setConeUpIndex(this: *mut btConeShape, upIndex: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btConeShape14getConeUpIndexEv"]
    pub fn btConeShape_getConeUpIndex(this: *const btConeShape) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btConeShapeC1Edd"]
    pub fn btConeShape_btConeShape(this: *mut btConeShape, radius: btScalar, height: btScalar);
}
impl btConeShape {
    #[inline]
    pub unsafe fn getRadius(&self) -> btScalar {
        btConeShape_getRadius(self)
    }
    #[inline]
    pub unsafe fn getHeight(&self) -> btScalar {
        btConeShape_getHeight(self)
    }
    #[inline]
    pub unsafe fn setRadius(&mut self, radius: btScalar) {
        btConeShape_setRadius(self, radius)
    }
    #[inline]
    pub unsafe fn setHeight(&mut self, height: btScalar) {
        btConeShape_setHeight(self, height)
    }
    #[inline]
    pub unsafe fn setConeUpIndex(&mut self, upIndex: ::std::os::raw::c_int) {
        btConeShape_setConeUpIndex(self, upIndex)
    }
    #[inline]
    pub unsafe fn getConeUpIndex(&self) -> ::std::os::raw::c_int {
        btConeShape_getConeUpIndex(self)
    }
    #[inline]
    pub unsafe fn new(radius: btScalar, height: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConeShape_btConeShape(&mut __bindgen_tmp, radius, height);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btConeShape24localGetSupportingVertexERK9btVector3"]
    pub fn btConeShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btConeShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
    pub fn btConeShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btConeShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
    pub fn btConeShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btConeShape21calculateLocalInertiaEdR9btVector3"]
    pub fn btConeShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btConeShape7getNameEv"]
    pub fn btConeShape_getName(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btConeShape38getAnisotropicRollingFrictionDirectionEv"]
    pub fn btConeShape_getAnisotropicRollingFrictionDirection(
        this: *mut ::std::os::raw::c_void,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btConeShape15setLocalScalingERK9btVector3"]
    pub fn btConeShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btConeShape28calculateSerializeBufferSizeEv"]
    pub fn btConeShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK11btConeShape9serializeEPvP12btSerializer"]
    pub fn btConeShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// btConeShape implements a Cone shape, around the X axis
#[repr(C)]
#[derive(Debug)]
pub struct btConeShapeX {
    pub _base: btConeShape,
}
#[test]
fn bindgen_test_layout_btConeShapeX() {
    assert_eq!(
        ::std::mem::size_of::<btConeShapeX>(),
        152usize,
        concat!("Size of: ", stringify!(btConeShapeX))
    );
    assert_eq!(
        ::std::mem::align_of::<btConeShapeX>(),
        8usize,
        concat!("Alignment of ", stringify!(btConeShapeX))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btConeShapeXC1Edd"]
    pub fn btConeShapeX_btConeShapeX(this: *mut btConeShapeX, radius: btScalar, height: btScalar);
}
impl btConeShapeX {
    #[inline]
    pub unsafe fn new(radius: btScalar, height: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConeShapeX_btConeShapeX(&mut __bindgen_tmp, radius, height);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btConeShapeX38getAnisotropicRollingFrictionDirectionEv"]
    pub fn btConeShapeX_getAnisotropicRollingFrictionDirection(
        this: *mut ::std::os::raw::c_void,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btConeShapeX7getNameEv"]
    pub fn btConeShapeX_getName(this: *mut ::std::os::raw::c_void)
        -> *const ::std::os::raw::c_char;
}
/// btConeShapeZ implements a Cone shape, around the Z axis
#[repr(C)]
#[derive(Debug)]
pub struct btConeShapeZ {
    pub _base: btConeShape,
}
#[test]
fn bindgen_test_layout_btConeShapeZ() {
    assert_eq!(
        ::std::mem::size_of::<btConeShapeZ>(),
        152usize,
        concat!("Size of: ", stringify!(btConeShapeZ))
    );
    assert_eq!(
        ::std::mem::align_of::<btConeShapeZ>(),
        8usize,
        concat!("Alignment of ", stringify!(btConeShapeZ))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btConeShapeZC1Edd"]
    pub fn btConeShapeZ_btConeShapeZ(this: *mut btConeShapeZ, radius: btScalar, height: btScalar);
}
impl btConeShapeZ {
    #[inline]
    pub unsafe fn new(radius: btScalar, height: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConeShapeZ_btConeShapeZ(&mut __bindgen_tmp, radius, height);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btConeShapeZ38getAnisotropicRollingFrictionDirectionEv"]
    pub fn btConeShapeZ_getAnisotropicRollingFrictionDirection(
        this: *mut ::std::os::raw::c_void,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btConeShapeZ7getNameEv"]
    pub fn btConeShapeZ_getName(this: *mut ::std::os::raw::c_void)
        -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConeShapeData {
    pub m_convexInternalShapeData: btConvexInternalShapeData,
    pub m_upIndex: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btConeShapeData() {
    assert_eq!(
        ::std::mem::size_of::<btConeShapeData>(),
        64usize,
        concat!("Size of: ", stringify!(btConeShapeData))
    );
    assert_eq!(
        ::std::mem::align_of::<btConeShapeData>(),
        8usize,
        concat!("Alignment of ", stringify!(btConeShapeData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeShapeData)).m_convexInternalShapeData as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeShapeData),
            "::",
            stringify!(m_convexInternalShapeData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeShapeData)).m_upIndex as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeShapeData),
            "::",
            stringify!(m_upIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeShapeData)).m_padding as *const _ as usize },
        60usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeShapeData),
            "::",
            stringify!(m_padding)
        )
    );
}
#[repr(C)]
pub struct btTriangleCallback__bindgen_vtable(::std::os::raw::c_void);
/// The btTriangleCallback provides a callback for each overlapping triangle when calling processAllTriangles.
/// This callback is called by processAllTriangles for all btConcaveShape derived class, such as  btBvhTriangleMeshShape, btStaticPlaneShape and btHeightfieldTerrainShape.
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleCallback {
    pub vtable_: *const btTriangleCallback__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btTriangleCallback() {
    assert_eq!(
        ::std::mem::size_of::<btTriangleCallback>(),
        8usize,
        concat!("Size of: ", stringify!(btTriangleCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<btTriangleCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(btTriangleCallback))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btTriangleCallbackD0Ev"]
    pub fn btTriangleCallback_btTriangleCallback_destructor(this: *mut btTriangleCallback);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btTriangleCallback15processTriangleEP9btVector3ii"]
    pub fn btTriangleCallback_processTriangle(
        this: *mut ::std::os::raw::c_void,
        triangle: *mut btVector3,
        partId: ::std::os::raw::c_int,
        triangleIndex: ::std::os::raw::c_int,
    );
}
#[repr(C)]
pub struct btInternalTriangleIndexCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btInternalTriangleIndexCallback {
    pub vtable_: *const btInternalTriangleIndexCallback__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btInternalTriangleIndexCallback() {
    assert_eq!(
        ::std::mem::size_of::<btInternalTriangleIndexCallback>(),
        8usize,
        concat!("Size of: ", stringify!(btInternalTriangleIndexCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<btInternalTriangleIndexCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(btInternalTriangleIndexCallback))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN31btInternalTriangleIndexCallbackD0Ev"]
    pub fn btInternalTriangleIndexCallback_btInternalTriangleIndexCallback_destructor(
        this: *mut btInternalTriangleIndexCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN31btInternalTriangleIndexCallback28internalProcessTriangleIndexEP9btVector3ii"]
    pub fn btInternalTriangleIndexCallback_internalProcessTriangleIndex(
        this: *mut ::std::os::raw::c_void,
        triangle: *mut btVector3,
        partId: ::std::os::raw::c_int,
        triangleIndex: ::std::os::raw::c_int,
    );
}
pub const PHY_ScalarType_PHY_FLOAT: PHY_ScalarType = 0;
pub const PHY_ScalarType_PHY_DOUBLE: PHY_ScalarType = 1;
pub const PHY_ScalarType_PHY_INTEGER: PHY_ScalarType = 2;
pub const PHY_ScalarType_PHY_SHORT: PHY_ScalarType = 3;
pub const PHY_ScalarType_PHY_FIXEDPOINT88: PHY_ScalarType = 4;
pub const PHY_ScalarType_PHY_UCHAR: PHY_ScalarType = 5;
pub type PHY_ScalarType = ::std::os::raw::c_uint;
/// The btConcaveShape class provides an interface for non-moving (static) concave shapes.
/// It has been implemented by the btStaticPlaneShape, btBvhTriangleMeshShape and btHeightfieldTerrainShape.
#[repr(C)]
#[derive(Debug)]
pub struct btConcaveShape {
    pub _base: btCollisionShape,
    pub m_collisionMargin: btScalar,
}
#[test]
fn bindgen_test_layout_btConcaveShape() {
    assert_eq!(
        ::std::mem::size_of::<btConcaveShape>(),
        40usize,
        concat!("Size of: ", stringify!(btConcaveShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btConcaveShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btConcaveShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConcaveShape)).m_collisionMargin as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConcaveShape),
            "::",
            stringify!(m_collisionMargin)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btConcaveShapeC2Ev"]
    pub fn btConcaveShape_btConcaveShape(this: *mut btConcaveShape);
}
impl btConcaveShape {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConcaveShape_btConcaveShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN14btConcaveShapeD0Ev"]
    pub fn btConcaveShape_btConcaveShape_destructor(this: *mut btConcaveShape);
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btConcaveShape19processAllTrianglesEP18btTriangleCallbackRK9btVector3S4_"]
    pub fn btConcaveShape_processAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btConcaveShape9getMarginEv"]
    pub fn btConcaveShape_getMargin(this: *mut ::std::os::raw::c_void) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN14btConcaveShape9setMarginEd"]
    pub fn btConcaveShape_setMargin(this: *mut ::std::os::raw::c_void, collisionMargin: btScalar);
}
/// The btStaticPlaneShape simulates an infinite non-moving (static) collision plane.
#[repr(C)]
#[derive(Debug)]
pub struct btStaticPlaneShape {
    pub _base: btConcaveShape,
    pub m_localAabbMin: btVector3,
    pub m_localAabbMax: btVector3,
    pub m_planeNormal: btVector3,
    pub m_planeConstant: btScalar,
    pub m_localScaling: btVector3,
}
#[test]
fn bindgen_test_layout_btStaticPlaneShape() {
    assert_eq!(
        ::std::mem::size_of::<btStaticPlaneShape>(),
        176usize,
        concat!("Size of: ", stringify!(btStaticPlaneShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btStaticPlaneShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btStaticPlaneShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStaticPlaneShape)).m_localAabbMin as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStaticPlaneShape),
            "::",
            stringify!(m_localAabbMin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStaticPlaneShape)).m_localAabbMax as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStaticPlaneShape),
            "::",
            stringify!(m_localAabbMax)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStaticPlaneShape)).m_planeNormal as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStaticPlaneShape),
            "::",
            stringify!(m_planeNormal)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStaticPlaneShape)).m_planeConstant as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStaticPlaneShape),
            "::",
            stringify!(m_planeConstant)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStaticPlaneShape)).m_localScaling as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStaticPlaneShape),
            "::",
            stringify!(m_localScaling)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btStaticPlaneShape14getPlaneNormalEv"]
    pub fn btStaticPlaneShape_getPlaneNormal(this: *const btStaticPlaneShape) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btStaticPlaneShape16getPlaneConstantEv"]
    pub fn btStaticPlaneShape_getPlaneConstant(this: *const btStaticPlaneShape) -> *const btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btStaticPlaneShapeC1ERK9btVector3d"]
    pub fn btStaticPlaneShape_btStaticPlaneShape(
        this: *mut btStaticPlaneShape,
        planeNormal: *const btVector3,
        planeConstant: btScalar,
    );
}
impl btStaticPlaneShape {
    #[inline]
    pub unsafe fn getPlaneNormal(&self) -> *const btVector3 {
        btStaticPlaneShape_getPlaneNormal(self)
    }
    #[inline]
    pub unsafe fn getPlaneConstant(&self) -> *const btScalar {
        btStaticPlaneShape_getPlaneConstant(self)
    }
    #[inline]
    pub unsafe fn new(planeNormal: *const btVector3, planeConstant: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btStaticPlaneShape_btStaticPlaneShape(&mut __bindgen_tmp, planeNormal, planeConstant);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN18btStaticPlaneShapeD0Ev"]
    pub fn btStaticPlaneShape_btStaticPlaneShape_destructor(this: *mut btStaticPlaneShape);
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btStaticPlaneShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btStaticPlaneShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btStaticPlaneShape19processAllTrianglesEP18btTriangleCallbackRK9btVector3S4_"]
    pub fn btStaticPlaneShape_processAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btStaticPlaneShape21calculateLocalInertiaEdR9btVector3"]
    pub fn btStaticPlaneShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btStaticPlaneShape15setLocalScalingERK9btVector3"]
    pub fn btStaticPlaneShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btStaticPlaneShape15getLocalScalingEv"]
    pub fn btStaticPlaneShape_getLocalScaling(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btStaticPlaneShape7getNameEv"]
    pub fn btStaticPlaneShape_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btStaticPlaneShape28calculateSerializeBufferSizeEv"]
    pub fn btStaticPlaneShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK18btStaticPlaneShape9serializeEPvP12btSerializer"]
    pub fn btStaticPlaneShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btStaticPlaneShapeData {
    pub m_collisionShapeData: btCollisionShapeData,
    pub m_localScaling: btVector3FloatData,
    pub m_planeNormal: btVector3FloatData,
    pub m_planeConstant: f32,
    pub m_pad: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btStaticPlaneShapeData() {
    assert_eq!(
        ::std::mem::size_of::<btStaticPlaneShapeData>(),
        56usize,
        concat!("Size of: ", stringify!(btStaticPlaneShapeData))
    );
    assert_eq!(
        ::std::mem::align_of::<btStaticPlaneShapeData>(),
        8usize,
        concat!("Alignment of ", stringify!(btStaticPlaneShapeData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btStaticPlaneShapeData)).m_collisionShapeData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStaticPlaneShapeData),
            "::",
            stringify!(m_collisionShapeData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStaticPlaneShapeData)).m_localScaling as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStaticPlaneShapeData),
            "::",
            stringify!(m_localScaling)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStaticPlaneShapeData)).m_planeNormal as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStaticPlaneShapeData),
            "::",
            stringify!(m_planeNormal)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStaticPlaneShapeData)).m_planeConstant as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStaticPlaneShapeData),
            "::",
            stringify!(m_planeConstant)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStaticPlaneShapeData)).m_pad as *const _ as usize },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStaticPlaneShapeData),
            "::",
            stringify!(m_pad)
        )
    );
}
/// The btConvexHullShape implements an implicit convex hull of an array of vertices.
/// Bullet provides a general and fast collision detector for convex shapes based on GJK and EPA using localGetSupportingVertex.
#[repr(C)]
#[derive(Debug)]
pub struct btConvexHullShape {
    pub _base: btPolyhedralConvexAabbCachingShape,
    pub m_unscaledPoints: btAlignedObjectArray<btVector3>,
}
#[test]
fn bindgen_test_layout_btConvexHullShape() {
    assert_eq!(
        ::std::mem::size_of::<btConvexHullShape>(),
        224usize,
        concat!("Size of: ", stringify!(btConvexHullShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btConvexHullShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btConvexHullShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConvexHullShape)).m_unscaledPoints as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexHullShape),
            "::",
            stringify!(m_unscaledPoints)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btConvexHullShape8addPointERK9btVector3b"]
    pub fn btConvexHullShape_addPoint(
        this: *mut btConvexHullShape,
        point: *const btVector3,
        recalculateLocalAabb: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btConvexHullShape17getUnscaledPointsEv"]
    pub fn btConvexHullShape_getUnscaledPoints(this: *mut btConvexHullShape) -> *mut btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape17getUnscaledPointsEv"]
    pub fn btConvexHullShape_getUnscaledPoints1(this: *const btConvexHullShape)
        -> *const btVector3;
}
extern "C" {

    /// getPoints is obsolete, please use getUnscaledPoints

    #[link_name = "\u{1}_ZNK17btConvexHullShape9getPointsEv"]
    pub fn btConvexHullShape_getPoints(this: *const btConvexHullShape) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btConvexHullShape18optimizeConvexHullEv"]
    pub fn btConvexHullShape_optimizeConvexHull(this: *mut btConvexHullShape);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape14getScaledPointEi"]
    pub fn btConvexHullShape_getScaledPoint(
        this: *const btConvexHullShape,
        i: ::std::os::raw::c_int,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape12getNumPointsEv"]
    pub fn btConvexHullShape_getNumPoints(this: *const btConvexHullShape) -> ::std::os::raw::c_int;
}
extern "C" {

    /// this constructor optionally takes in a pointer to points. Each point is assumed to be 3 consecutive btScalar (x,y,z), the striding defines the number of bytes between each point, in memory.
    /// ///It is easier to not pass any points in the constructor, and just add one point at a time, using addPoint.
    /// ///btConvexHullShape make an internal copy of the points.

    #[link_name = "\u{1}_ZN17btConvexHullShapeC1EPKdii"]
    pub fn btConvexHullShape_btConvexHullShape(
        this: *mut btConvexHullShape,
        points: *const btScalar,
        numPoints: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    );
}
impl btConvexHullShape {
    #[inline]
    pub unsafe fn addPoint(&mut self, point: *const btVector3, recalculateLocalAabb: bool) {
        btConvexHullShape_addPoint(self, point, recalculateLocalAabb)
    }
    #[inline]
    pub unsafe fn getUnscaledPoints(&mut self) -> *mut btVector3 {
        btConvexHullShape_getUnscaledPoints(self)
    }
    #[inline]
    pub unsafe fn getUnscaledPoints1(&self) -> *const btVector3 {
        btConvexHullShape_getUnscaledPoints1(self)
    }
    #[inline]
    pub unsafe fn getPoints(&self) -> *const btVector3 {
        btConvexHullShape_getPoints(self)
    }
    #[inline]
    pub unsafe fn optimizeConvexHull(&mut self) {
        btConvexHullShape_optimizeConvexHull(self)
    }
    #[inline]
    pub unsafe fn getScaledPoint(&self, i: ::std::os::raw::c_int) -> btVector3 {
        btConvexHullShape_getScaledPoint(self, i)
    }
    #[inline]
    pub unsafe fn getNumPoints(&self) -> ::std::os::raw::c_int {
        btConvexHullShape_getNumPoints(self)
    }
    #[inline]
    pub unsafe fn new(
        points: *const btScalar,
        numPoints: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexHullShape_btConvexHullShape(&mut __bindgen_tmp, points, numPoints, stride);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape24localGetSupportingVertexERK9btVector3"]
    pub fn btConvexHullShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
    pub fn btConvexHullShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
    pub fn btConvexHullShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape7projectERK11btTransformRK9btVector3RdS6_RS3_S7_"]
    pub fn btConvexHullShape_project(
        this: *mut ::std::os::raw::c_void,
        trans: *const btTransform,
        dir: *const btVector3,
        minProj: *mut btScalar,
        maxProj: *mut btScalar,
        witnesPtMin: *mut btVector3,
        witnesPtMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape7getNameEv"]
    pub fn btConvexHullShape_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape14getNumVerticesEv"]
    pub fn btConvexHullShape_getNumVertices(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape11getNumEdgesEv"]
    pub fn btConvexHullShape_getNumEdges(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape7getEdgeEiR9btVector3S1_"]
    pub fn btConvexHullShape_getEdge(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        pa: *mut btVector3,
        pb: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape9getVertexEiR9btVector3"]
    pub fn btConvexHullShape_getVertex(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        vtx: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape12getNumPlanesEv"]
    pub fn btConvexHullShape_getNumPlanes(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape8getPlaneER9btVector3S1_i"]
    pub fn btConvexHullShape_getPlane(
        this: *mut ::std::os::raw::c_void,
        planeNormal: *mut btVector3,
        planeSupport: *mut btVector3,
        i: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape8isInsideERK9btVector3d"]
    pub fn btConvexHullShape_isInside(
        this: *mut ::std::os::raw::c_void,
        pt: *const btVector3,
        tolerance: btScalar,
    ) -> bool;
}
extern "C" {

    /// in case we receive negative scaling

    #[link_name = "\u{1}_ZN17btConvexHullShape15setLocalScalingERK9btVector3"]
    pub fn btConvexHullShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btConvexHullShape28calculateSerializeBufferSizeEv"]
    pub fn btConvexHullShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK17btConvexHullShape9serializeEPvP12btSerializer"]
    pub fn btConvexHullShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConvexHullShapeData {
    pub m_convexInternalShapeData: btConvexInternalShapeData,
    pub m_unscaledPointsFloatPtr: *mut btVector3FloatData,
    pub m_unscaledPointsDoublePtr: *mut btVector3DoubleData,
    pub m_numUnscaledPoints: ::std::os::raw::c_int,
    pub m_padding3: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btConvexHullShapeData() {
    assert_eq!(
        ::std::mem::size_of::<btConvexHullShapeData>(),
        80usize,
        concat!("Size of: ", stringify!(btConvexHullShapeData))
    );
    assert_eq!(
        ::std::mem::align_of::<btConvexHullShapeData>(),
        8usize,
        concat!("Alignment of ", stringify!(btConvexHullShapeData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConvexHullShapeData)).m_convexInternalShapeData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexHullShapeData),
            "::",
            stringify!(m_convexInternalShapeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConvexHullShapeData)).m_unscaledPointsFloatPtr as *const _ as usize
        },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexHullShapeData),
            "::",
            stringify!(m_unscaledPointsFloatPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConvexHullShapeData)).m_unscaledPointsDoublePtr as *const _ as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexHullShapeData),
            "::",
            stringify!(m_unscaledPointsDoublePtr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConvexHullShapeData)).m_numUnscaledPoints as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexHullShapeData),
            "::",
            stringify!(m_numUnscaledPoints)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConvexHullShapeData)).m_padding3 as *const _ as usize },
        76usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexHullShapeData),
            "::",
            stringify!(m_padding3)
        )
    );
}
#[repr(C)]
pub struct btStridingMeshInterface__bindgen_vtable(::std::os::raw::c_void);
/// The btStridingMeshInterface is the interface class for high performance generic access to triangle meshes, used in combination with btBvhTriangleMeshShape and some other collision shapes.
/// Using index striding of 3*sizeof(integer) it can use triangle arrays, using index striding of 1*sizeof(integer) it can handle triangle strips.
/// It allows for sharing graphics and collision meshes. Also it provides locking/unlocking of graphics meshes that are in gpu memory.
#[repr(C)]
#[derive(Debug)]
pub struct btStridingMeshInterface {
    pub vtable_: *const btStridingMeshInterface__bindgen_vtable,
    pub m_scaling: btVector3,
}
#[test]
fn bindgen_test_layout_btStridingMeshInterface() {
    assert_eq!(
        ::std::mem::size_of::<btStridingMeshInterface>(),
        40usize,
        concat!("Size of: ", stringify!(btStridingMeshInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<btStridingMeshInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(btStridingMeshInterface))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStridingMeshInterface)).m_scaling as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStridingMeshInterface),
            "::",
            stringify!(m_scaling)
        )
    );
}
extern "C" {

    /// brute force method to calculate aabb

    #[link_name = "\u{1}_ZN23btStridingMeshInterface23calculateAabbBruteForceER9btVector3S1_"]
    pub fn btStridingMeshInterface_calculateAabbBruteForce(
        this: *mut btStridingMeshInterface,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btStridingMeshInterface10getScalingEv"]
    pub fn btStridingMeshInterface_getScaling(
        this: *const btStridingMeshInterface,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btStridingMeshInterface10setScalingERK9btVector3"]
    pub fn btStridingMeshInterface_setScaling(
        this: *mut btStridingMeshInterface,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btStridingMeshInterfaceC2Ev"]
    pub fn btStridingMeshInterface_btStridingMeshInterface(this: *mut btStridingMeshInterface);
}
impl btStridingMeshInterface {
    #[inline]
    pub unsafe fn calculateAabbBruteForce(
        &mut self,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    ) {
        btStridingMeshInterface_calculateAabbBruteForce(self, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn getScaling(&self) -> *const btVector3 {
        btStridingMeshInterface_getScaling(self)
    }
    #[inline]
    pub unsafe fn setScaling(&mut self, scaling: *const btVector3) {
        btStridingMeshInterface_setScaling(self, scaling)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btStridingMeshInterface_btStridingMeshInterface(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN23btStridingMeshInterfaceD0Ev"]
    pub fn btStridingMeshInterface_btStridingMeshInterface_destructor(
        this: *mut btStridingMeshInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btStridingMeshInterface27InternalProcessAllTrianglesEP31btInternalTriangleIndexCallbackRK9btVector3S4_"]
    pub fn btStridingMeshInterface_InternalProcessAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btInternalTriangleIndexCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {

    /// get read and write access to a subpart of a triangle mesh
    /// /// this subpart has a continuous array of vertices and indices
    /// /// in this way the mesh can be handled as chunks of memory with striding
    /// /// very similar to OpenGL vertexarray support
    /// /// make a call to unLockVertexBase when the read and write access is finished

    #[link_name = "\u{1}_ZN23btStridingMeshInterface24getLockedVertexIndexBaseEPPhRiR14PHY_ScalarTypeS2_S1_S2_S2_S4_i"]
    pub fn btStridingMeshInterface_getLockedVertexIndexBase(
        this: *mut ::std::os::raw::c_void,
        vertexbase: *mut *mut ::std::os::raw::c_uchar,
        numverts: *mut ::std::os::raw::c_int,
        type_: *mut PHY_ScalarType,
        stride: *mut ::std::os::raw::c_int,
        indexbase: *mut *mut ::std::os::raw::c_uchar,
        indexstride: *mut ::std::os::raw::c_int,
        numfaces: *mut ::std::os::raw::c_int,
        indicestype: *mut PHY_ScalarType,
        subpart: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btStridingMeshInterface32getLockedReadOnlyVertexIndexBaseEPPKhRiR14PHY_ScalarTypeS3_S2_S3_S3_S5_i"]
    pub fn btStridingMeshInterface_getLockedReadOnlyVertexIndexBase(
        this: *mut ::std::os::raw::c_void,
        vertexbase: *mut *const ::std::os::raw::c_uchar,
        numverts: *mut ::std::os::raw::c_int,
        type_: *mut PHY_ScalarType,
        stride: *mut ::std::os::raw::c_int,
        indexbase: *mut *const ::std::os::raw::c_uchar,
        indexstride: *mut ::std::os::raw::c_int,
        numfaces: *mut ::std::os::raw::c_int,
        indicestype: *mut PHY_ScalarType,
        subpart: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// unLockVertexBase finishes the access to a subpart of the triangle mesh
    /// /// make a call to unLockVertexBase when the read and write access (using getLockedVertexIndexBase) is finished

    #[link_name = "\u{1}_ZN23btStridingMeshInterface16unLockVertexBaseEi"]
    pub fn btStridingMeshInterface_unLockVertexBase(
        this: *mut ::std::os::raw::c_void,
        subpart: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btStridingMeshInterface24unLockReadOnlyVertexBaseEi"]
    pub fn btStridingMeshInterface_unLockReadOnlyVertexBase(
        this: *mut ::std::os::raw::c_void,
        subpart: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// getNumSubParts returns the number of seperate subparts
    /// /// each subpart has a continuous array of vertices and indices

    #[link_name = "\u{1}_ZNK23btStridingMeshInterface14getNumSubPartsEv"]
    pub fn btStridingMeshInterface_getNumSubParts(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btStridingMeshInterface19preallocateVerticesEi"]
    pub fn btStridingMeshInterface_preallocateVertices(
        this: *mut ::std::os::raw::c_void,
        numverts: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btStridingMeshInterface18preallocateIndicesEi"]
    pub fn btStridingMeshInterface_preallocateIndices(
        this: *mut ::std::os::raw::c_void,
        numindices: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btStridingMeshInterface14hasPremadeAabbEv"]
    pub fn btStridingMeshInterface_hasPremadeAabb(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btStridingMeshInterface14setPremadeAabbERK9btVector3S2_"]
    pub fn btStridingMeshInterface_setPremadeAabb(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btStridingMeshInterface14getPremadeAabbEP9btVector3S1_"]
    pub fn btStridingMeshInterface_getPremadeAabb(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btStridingMeshInterface28calculateSerializeBufferSizeEv"]
    pub fn btStridingMeshInterface_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK23btStridingMeshInterface9serializeEPvP12btSerializer"]
    pub fn btStridingMeshInterface_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btIntIndexData {
    pub m_value: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btIntIndexData() {
    assert_eq!(
        ::std::mem::size_of::<btIntIndexData>(),
        4usize,
        concat!("Size of: ", stringify!(btIntIndexData))
    );
    assert_eq!(
        ::std::mem::align_of::<btIntIndexData>(),
        4usize,
        concat!("Alignment of ", stringify!(btIntIndexData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btIntIndexData)).m_value as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIntIndexData),
            "::",
            stringify!(m_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btShortIntIndexData {
    pub m_value: ::std::os::raw::c_short,
    pub m_pad: [::std::os::raw::c_char; 2usize],
}
#[test]
fn bindgen_test_layout_btShortIntIndexData() {
    assert_eq!(
        ::std::mem::size_of::<btShortIntIndexData>(),
        4usize,
        concat!("Size of: ", stringify!(btShortIntIndexData))
    );
    assert_eq!(
        ::std::mem::align_of::<btShortIntIndexData>(),
        2usize,
        concat!("Alignment of ", stringify!(btShortIntIndexData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btShortIntIndexData)).m_value as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btShortIntIndexData),
            "::",
            stringify!(m_value)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btShortIntIndexData)).m_pad as *const _ as usize },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(btShortIntIndexData),
            "::",
            stringify!(m_pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btShortIntIndexTripletData {
    pub m_values: [::std::os::raw::c_short; 3usize],
    pub m_pad: [::std::os::raw::c_char; 2usize],
}
#[test]
fn bindgen_test_layout_btShortIntIndexTripletData() {
    assert_eq!(
        ::std::mem::size_of::<btShortIntIndexTripletData>(),
        8usize,
        concat!("Size of: ", stringify!(btShortIntIndexTripletData))
    );
    assert_eq!(
        ::std::mem::align_of::<btShortIntIndexTripletData>(),
        2usize,
        concat!("Alignment of ", stringify!(btShortIntIndexTripletData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btShortIntIndexTripletData)).m_values as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btShortIntIndexTripletData),
            "::",
            stringify!(m_values)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btShortIntIndexTripletData)).m_pad as *const _ as usize },
        6usize,
        concat!(
            "Alignment of field: ",
            stringify!(btShortIntIndexTripletData),
            "::",
            stringify!(m_pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCharIndexTripletData {
    pub m_values: [::std::os::raw::c_uchar; 3usize],
    pub m_pad: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_btCharIndexTripletData() {
    assert_eq!(
        ::std::mem::size_of::<btCharIndexTripletData>(),
        4usize,
        concat!("Size of: ", stringify!(btCharIndexTripletData))
    );
    assert_eq!(
        ::std::mem::align_of::<btCharIndexTripletData>(),
        1usize,
        concat!("Alignment of ", stringify!(btCharIndexTripletData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCharIndexTripletData)).m_values as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCharIndexTripletData),
            "::",
            stringify!(m_values)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCharIndexTripletData)).m_pad as *const _ as usize },
        3usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCharIndexTripletData),
            "::",
            stringify!(m_pad)
        )
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMeshPartData {
    pub m_vertices3f: *mut btVector3FloatData,
    pub m_vertices3d: *mut btVector3DoubleData,
    pub m_indices32: *mut btIntIndexData,
    pub m_3indices16: *mut btShortIntIndexTripletData,
    pub m_3indices8: *mut btCharIndexTripletData,
    pub m_indices16: *mut btShortIntIndexData,
    pub m_numTriangles: ::std::os::raw::c_int,
    pub m_numVertices: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btMeshPartData() {
    assert_eq!(
        ::std::mem::size_of::<btMeshPartData>(),
        56usize,
        concat!("Size of: ", stringify!(btMeshPartData))
    );
    assert_eq!(
        ::std::mem::align_of::<btMeshPartData>(),
        8usize,
        concat!("Alignment of ", stringify!(btMeshPartData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btMeshPartData)).m_vertices3f as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMeshPartData),
            "::",
            stringify!(m_vertices3f)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btMeshPartData)).m_vertices3d as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMeshPartData),
            "::",
            stringify!(m_vertices3d)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btMeshPartData)).m_indices32 as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMeshPartData),
            "::",
            stringify!(m_indices32)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btMeshPartData)).m_3indices16 as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMeshPartData),
            "::",
            stringify!(m_3indices16)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btMeshPartData)).m_3indices8 as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMeshPartData),
            "::",
            stringify!(m_3indices8)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btMeshPartData)).m_indices16 as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMeshPartData),
            "::",
            stringify!(m_indices16)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btMeshPartData)).m_numTriangles as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMeshPartData),
            "::",
            stringify!(m_numTriangles)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btMeshPartData)).m_numVertices as *const _ as usize },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMeshPartData),
            "::",
            stringify!(m_numVertices)
        )
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btStridingMeshInterfaceData {
    pub m_meshPartsPtr: *mut btMeshPartData,
    pub m_scaling: btVector3FloatData,
    pub m_numMeshParts: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btStridingMeshInterfaceData() {
    assert_eq!(
        ::std::mem::size_of::<btStridingMeshInterfaceData>(),
        32usize,
        concat!("Size of: ", stringify!(btStridingMeshInterfaceData))
    );
    assert_eq!(
        ::std::mem::align_of::<btStridingMeshInterfaceData>(),
        8usize,
        concat!("Alignment of ", stringify!(btStridingMeshInterfaceData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btStridingMeshInterfaceData)).m_meshPartsPtr as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStridingMeshInterfaceData),
            "::",
            stringify!(m_meshPartsPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStridingMeshInterfaceData)).m_scaling as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStridingMeshInterfaceData),
            "::",
            stringify!(m_scaling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btStridingMeshInterfaceData)).m_numMeshParts as *const _ as usize
        },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStridingMeshInterfaceData),
            "::",
            stringify!(m_numMeshParts)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btStridingMeshInterfaceData)).m_padding as *const _ as usize },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(btStridingMeshInterfaceData),
            "::",
            stringify!(m_padding)
        )
    );
}
/// The btIndexedMesh indexes a single vertex and index array. Multiple btIndexedMesh objects can be passed into a btTriangleIndexVertexArray using addIndexedMesh.
/// Instead of the number of indices, we pass the number of triangles.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btIndexedMesh {
    pub m_numTriangles: ::std::os::raw::c_int,
    pub m_triangleIndexBase: *const ::std::os::raw::c_uchar,
    pub m_triangleIndexStride: ::std::os::raw::c_int,
    pub m_numVertices: ::std::os::raw::c_int,
    pub m_vertexBase: *const ::std::os::raw::c_uchar,
    pub m_vertexStride: ::std::os::raw::c_int,
    pub m_indexType: PHY_ScalarType,
    pub m_vertexType: PHY_ScalarType,
}
#[test]
fn bindgen_test_layout_btIndexedMesh() {
    assert_eq!(
        ::std::mem::size_of::<btIndexedMesh>(),
        48usize,
        concat!("Size of: ", stringify!(btIndexedMesh))
    );
    assert_eq!(
        ::std::mem::align_of::<btIndexedMesh>(),
        8usize,
        concat!("Alignment of ", stringify!(btIndexedMesh))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btIndexedMesh)).m_numTriangles as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIndexedMesh),
            "::",
            stringify!(m_numTriangles)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btIndexedMesh)).m_triangleIndexBase as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIndexedMesh),
            "::",
            stringify!(m_triangleIndexBase)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btIndexedMesh)).m_triangleIndexStride as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIndexedMesh),
            "::",
            stringify!(m_triangleIndexStride)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btIndexedMesh)).m_numVertices as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIndexedMesh),
            "::",
            stringify!(m_numVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btIndexedMesh)).m_vertexBase as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIndexedMesh),
            "::",
            stringify!(m_vertexBase)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btIndexedMesh)).m_vertexStride as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIndexedMesh),
            "::",
            stringify!(m_vertexStride)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btIndexedMesh)).m_indexType as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIndexedMesh),
            "::",
            stringify!(m_indexType)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btIndexedMesh)).m_vertexType as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIndexedMesh),
            "::",
            stringify!(m_vertexType)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13btIndexedMeshC1Ev"]
    pub fn btIndexedMesh_btIndexedMesh(this: *mut btIndexedMesh);
}
impl btIndexedMesh {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btIndexedMesh_btIndexedMesh(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
pub type IndexedMeshArray = btAlignedObjectArray<btIndexedMesh>;
/// The btTriangleIndexVertexArray allows to access multiple triangle meshes, by indexing into existing triangle/index arrays.
/// Additional meshes can be added using addIndexedMesh
/// No duplcate is made of the vertex/index data, it only indexes into external vertex/index arrays.
/// So keep those arrays around during the lifetime of this btTriangleIndexVertexArray.
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleIndexVertexArray {
    pub _base: btStridingMeshInterface,
    pub m_indexedMeshes: IndexedMeshArray,
    pub m_pad: [::std::os::raw::c_int; 2usize],
    pub m_hasAabb: ::std::os::raw::c_int,
    pub m_aabbMin: btVector3,
    pub m_aabbMax: btVector3,
}
#[test]
fn bindgen_test_layout_btTriangleIndexVertexArray() {
    assert_eq!(
        ::std::mem::size_of::<btTriangleIndexVertexArray>(),
        152usize,
        concat!("Size of: ", stringify!(btTriangleIndexVertexArray))
    );
    assert_eq!(
        ::std::mem::align_of::<btTriangleIndexVertexArray>(),
        8usize,
        concat!("Alignment of ", stringify!(btTriangleIndexVertexArray))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTriangleIndexVertexArray)).m_indexedMeshes as *const _ as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleIndexVertexArray),
            "::",
            stringify!(m_indexedMeshes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleIndexVertexArray)).m_pad as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleIndexVertexArray),
            "::",
            stringify!(m_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleIndexVertexArray)).m_hasAabb as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleIndexVertexArray),
            "::",
            stringify!(m_hasAabb)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleIndexVertexArray)).m_aabbMin as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleIndexVertexArray),
            "::",
            stringify!(m_aabbMin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleIndexVertexArray)).m_aabbMax as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleIndexVertexArray),
            "::",
            stringify!(m_aabbMax)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN26btTriangleIndexVertexArray14addIndexedMeshERK13btIndexedMesh14PHY_ScalarType"]
    pub fn btTriangleIndexVertexArray_addIndexedMesh(
        this: *mut btTriangleIndexVertexArray,
        mesh: *const btIndexedMesh,
        indexType: PHY_ScalarType,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN26btTriangleIndexVertexArray19getIndexedMeshArrayEv"]
    pub fn btTriangleIndexVertexArray_getIndexedMeshArray(
        this: *mut btTriangleIndexVertexArray,
    ) -> *mut IndexedMeshArray;
}
extern "C" {
    #[link_name = "\u{1}_ZNK26btTriangleIndexVertexArray19getIndexedMeshArrayEv"]
    pub fn btTriangleIndexVertexArray_getIndexedMeshArray1(
        this: *const btTriangleIndexVertexArray,
    ) -> *const IndexedMeshArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN26btTriangleIndexVertexArrayC1Ev"]
    pub fn btTriangleIndexVertexArray_btTriangleIndexVertexArray(
        this: *mut btTriangleIndexVertexArray,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN26btTriangleIndexVertexArrayC1EiPiiiPdi"]
    pub fn btTriangleIndexVertexArray_btTriangleIndexVertexArray1(
        this: *mut btTriangleIndexVertexArray,
        numTriangles: ::std::os::raw::c_int,
        triangleIndexBase: *mut ::std::os::raw::c_int,
        triangleIndexStride: ::std::os::raw::c_int,
        numVertices: ::std::os::raw::c_int,
        vertexBase: *mut btScalar,
        vertexStride: ::std::os::raw::c_int,
    );
}
impl btTriangleIndexVertexArray {
    #[inline]
    pub unsafe fn addIndexedMesh(&mut self, mesh: *const btIndexedMesh, indexType: PHY_ScalarType) {
        btTriangleIndexVertexArray_addIndexedMesh(self, mesh, indexType)
    }
    #[inline]
    pub unsafe fn getIndexedMeshArray(&mut self) -> *mut IndexedMeshArray {
        btTriangleIndexVertexArray_getIndexedMeshArray(self)
    }
    #[inline]
    pub unsafe fn getIndexedMeshArray1(&self) -> *const IndexedMeshArray {
        btTriangleIndexVertexArray_getIndexedMeshArray1(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTriangleIndexVertexArray_btTriangleIndexVertexArray(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        numTriangles: ::std::os::raw::c_int,
        triangleIndexBase: *mut ::std::os::raw::c_int,
        triangleIndexStride: ::std::os::raw::c_int,
        numVertices: ::std::os::raw::c_int,
        vertexBase: *mut btScalar,
        vertexStride: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTriangleIndexVertexArray_btTriangleIndexVertexArray1(
            &mut __bindgen_tmp,
            numTriangles,
            triangleIndexBase,
            triangleIndexStride,
            numVertices,
            vertexBase,
            vertexStride,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN26btTriangleIndexVertexArrayD0Ev"]
    pub fn btTriangleIndexVertexArray_btTriangleIndexVertexArray_destructor(
        this: *mut btTriangleIndexVertexArray,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN26btTriangleIndexVertexArray24getLockedVertexIndexBaseEPPhRiR14PHY_ScalarTypeS2_S1_S2_S2_S4_i"]
    pub fn btTriangleIndexVertexArray_getLockedVertexIndexBase(
        this: *mut ::std::os::raw::c_void,
        vertexbase: *mut *mut ::std::os::raw::c_uchar,
        numverts: *mut ::std::os::raw::c_int,
        type_: *mut PHY_ScalarType,
        vertexStride: *mut ::std::os::raw::c_int,
        indexbase: *mut *mut ::std::os::raw::c_uchar,
        indexstride: *mut ::std::os::raw::c_int,
        numfaces: *mut ::std::os::raw::c_int,
        indicestype: *mut PHY_ScalarType,
        subpart: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK26btTriangleIndexVertexArray32getLockedReadOnlyVertexIndexBaseEPPKhRiR14PHY_ScalarTypeS3_S2_S3_S3_S5_i"]
    pub fn btTriangleIndexVertexArray_getLockedReadOnlyVertexIndexBase(
        this: *mut ::std::os::raw::c_void,
        vertexbase: *mut *const ::std::os::raw::c_uchar,
        numverts: *mut ::std::os::raw::c_int,
        type_: *mut PHY_ScalarType,
        vertexStride: *mut ::std::os::raw::c_int,
        indexbase: *mut *const ::std::os::raw::c_uchar,
        indexstride: *mut ::std::os::raw::c_int,
        numfaces: *mut ::std::os::raw::c_int,
        indicestype: *mut PHY_ScalarType,
        subpart: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// unLockVertexBase finishes the access to a subpart of the triangle mesh
    /// /// make a call to unLockVertexBase when the read and write access (using getLockedVertexIndexBase) is finished

    #[link_name = "\u{1}_ZN26btTriangleIndexVertexArray16unLockVertexBaseEi"]
    pub fn btTriangleIndexVertexArray_unLockVertexBase(
        this: *mut ::std::os::raw::c_void,
        subpart: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK26btTriangleIndexVertexArray24unLockReadOnlyVertexBaseEi"]
    pub fn btTriangleIndexVertexArray_unLockReadOnlyVertexBase(
        this: *mut ::std::os::raw::c_void,
        subpart: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// getNumSubParts returns the number of seperate subparts
    /// /// each subpart has a continuous array of vertices and indices

    #[link_name = "\u{1}_ZNK26btTriangleIndexVertexArray14getNumSubPartsEv"]
    pub fn btTriangleIndexVertexArray_getNumSubParts(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN26btTriangleIndexVertexArray19preallocateVerticesEi"]
    pub fn btTriangleIndexVertexArray_preallocateVertices(
        this: *mut ::std::os::raw::c_void,
        numverts: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN26btTriangleIndexVertexArray18preallocateIndicesEi"]
    pub fn btTriangleIndexVertexArray_preallocateIndices(
        this: *mut ::std::os::raw::c_void,
        numindices: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK26btTriangleIndexVertexArray14hasPremadeAabbEv"]
    pub fn btTriangleIndexVertexArray_hasPremadeAabb(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK26btTriangleIndexVertexArray14setPremadeAabbERK9btVector3S2_"]
    pub fn btTriangleIndexVertexArray_setPremadeAabb(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK26btTriangleIndexVertexArray14getPremadeAabbEP9btVector3S1_"]
    pub fn btTriangleIndexVertexArray_getPremadeAabb(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
/// The btTriangleMesh class is a convenience class derived from btTriangleIndexVertexArray, that provides storage for a concave triangle mesh. It can be used as data for the btBvhTriangleMeshShape.
/// It allows either 32bit or 16bit indices, and 4 (x-y-z-w) or 3 (x-y-z) component vertices.
/// If you want to share triangle/index data between graphics mesh and collision mesh (btBvhTriangleMeshShape), you can directly use btTriangleIndexVertexArray or derive your own class from btStridingMeshInterface.
/// Performance of btTriangleMesh and btTriangleIndexVertexArray used in a btBvhTriangleMeshShape is the same.
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleMesh {
    pub _base: btTriangleIndexVertexArray,
    pub m_4componentVertices: btAlignedObjectArray<btVector3>,
    pub m_3componentVertices: btAlignedObjectArray<btScalar>,
    pub m_32bitIndices: btAlignedObjectArray<::std::os::raw::c_uint>,
    pub m_16bitIndices: btAlignedObjectArray<::std::os::raw::c_ushort>,
    pub m_use32bitIndices: bool,
    pub m_use4componentVertices: bool,
    pub m_weldingThreshold: btScalar,
}
#[test]
fn bindgen_test_layout_btTriangleMesh() {
    assert_eq!(
        ::std::mem::size_of::<btTriangleMesh>(),
        296usize,
        concat!("Size of: ", stringify!(btTriangleMesh))
    );
    assert_eq!(
        ::std::mem::align_of::<btTriangleMesh>(),
        8usize,
        concat!("Alignment of ", stringify!(btTriangleMesh))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleMesh)).m_4componentVertices as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMesh),
            "::",
            stringify!(m_4componentVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleMesh)).m_3componentVertices as *const _ as usize },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMesh),
            "::",
            stringify!(m_3componentVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleMesh)).m_32bitIndices as *const _ as usize },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMesh),
            "::",
            stringify!(m_32bitIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleMesh)).m_16bitIndices as *const _ as usize },
        248usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMesh),
            "::",
            stringify!(m_16bitIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleMesh)).m_use32bitIndices as *const _ as usize },
        280usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMesh),
            "::",
            stringify!(m_use32bitIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleMesh)).m_use4componentVertices as *const _ as usize },
        281usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMesh),
            "::",
            stringify!(m_use4componentVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleMesh)).m_weldingThreshold as *const _ as usize },
        288usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMesh),
            "::",
            stringify!(m_weldingThreshold)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btTriangleMesh18getUse32bitIndicesEv"]
    pub fn btTriangleMesh_getUse32bitIndices(this: *const btTriangleMesh) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btTriangleMesh24getUse4componentVerticesEv"]
    pub fn btTriangleMesh_getUse4componentVertices(this: *const btTriangleMesh) -> bool;
}
extern "C" {

    /// By default addTriangle won't search for duplicate vertices, because the search is very slow for large triangle meshes.
    /// ///In general it is better to directly use btTriangleIndexVertexArray instead.

    #[link_name = "\u{1}_ZN14btTriangleMesh11addTriangleERK9btVector3S2_S2_b"]
    pub fn btTriangleMesh_addTriangle(
        this: *mut btTriangleMesh,
        vertex0: *const btVector3,
        vertex1: *const btVector3,
        vertex2: *const btVector3,
        removeDuplicateVertices: bool,
    );
}
extern "C" {

    /// Add a triangle using its indices. Make sure the indices are pointing within the vertices array, so add the vertices first (and to be sure, avoid removal of duplicate vertices)

    #[link_name = "\u{1}_ZN14btTriangleMesh18addTriangleIndicesEiii"]
    pub fn btTriangleMesh_addTriangleIndices(
        this: *mut btTriangleMesh,
        index1: ::std::os::raw::c_int,
        index2: ::std::os::raw::c_int,
        index3: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btTriangleMesh15getNumTrianglesEv"]
    pub fn btTriangleMesh_getNumTriangles(this: *const btTriangleMesh) -> ::std::os::raw::c_int;
}
extern "C" {

    /// findOrAddVertex is an internal method, use addTriangle instead

    #[link_name = "\u{1}_ZN14btTriangleMesh15findOrAddVertexERK9btVector3b"]
    pub fn btTriangleMesh_findOrAddVertex(
        this: *mut btTriangleMesh,
        vertex: *const btVector3,
        removeDuplicateVertices: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// addIndex is an internal method, use addTriangle instead

    #[link_name = "\u{1}_ZN14btTriangleMesh8addIndexEi"]
    pub fn btTriangleMesh_addIndex(this: *mut btTriangleMesh, index: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN14btTriangleMeshC1Ebb"]
    pub fn btTriangleMesh_btTriangleMesh(
        this: *mut btTriangleMesh,
        use32bitIndices: bool,
        use4componentVertices: bool,
    );
}
impl btTriangleMesh {
    #[inline]
    pub unsafe fn getUse32bitIndices(&self) -> bool {
        btTriangleMesh_getUse32bitIndices(self)
    }
    #[inline]
    pub unsafe fn getUse4componentVertices(&self) -> bool {
        btTriangleMesh_getUse4componentVertices(self)
    }
    #[inline]
    pub unsafe fn addTriangle(
        &mut self,
        vertex0: *const btVector3,
        vertex1: *const btVector3,
        vertex2: *const btVector3,
        removeDuplicateVertices: bool,
    ) {
        btTriangleMesh_addTriangle(self, vertex0, vertex1, vertex2, removeDuplicateVertices)
    }
    #[inline]
    pub unsafe fn addTriangleIndices(
        &mut self,
        index1: ::std::os::raw::c_int,
        index2: ::std::os::raw::c_int,
        index3: ::std::os::raw::c_int,
    ) {
        btTriangleMesh_addTriangleIndices(self, index1, index2, index3)
    }
    #[inline]
    pub unsafe fn getNumTriangles(&self) -> ::std::os::raw::c_int {
        btTriangleMesh_getNumTriangles(self)
    }
    #[inline]
    pub unsafe fn findOrAddVertex(
        &mut self,
        vertex: *const btVector3,
        removeDuplicateVertices: bool,
    ) -> ::std::os::raw::c_int {
        btTriangleMesh_findOrAddVertex(self, vertex, removeDuplicateVertices)
    }
    #[inline]
    pub unsafe fn addIndex(&mut self, index: ::std::os::raw::c_int) {
        btTriangleMesh_addIndex(self, index)
    }
    #[inline]
    pub unsafe fn new(use32bitIndices: bool, use4componentVertices: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTriangleMesh_btTriangleMesh(&mut __bindgen_tmp, use32bitIndices, use4componentVertices);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN14btTriangleMesh19preallocateVerticesEi"]
    pub fn btTriangleMesh_preallocateVertices(
        this: *mut ::std::os::raw::c_void,
        numverts: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btTriangleMesh18preallocateIndicesEi"]
    pub fn btTriangleMesh_preallocateIndices(
        this: *mut ::std::os::raw::c_void,
        numindices: ::std::os::raw::c_int,
    );
}
/// The btConvexTriangleMeshShape is a convex hull of a triangle mesh, but the performance is not as good as btConvexHullShape.
/// A small benefit of this class is that it uses the btStridingMeshInterface, so you can avoid the duplication of the triangle mesh data. Nevertheless, most users should use the much better performing btConvexHullShape instead.
#[repr(C)]
#[derive(Debug)]
pub struct btConvexTriangleMeshShape {
    pub _base: btPolyhedralConvexAabbCachingShape,
    pub m_stridingMesh: *mut btStridingMeshInterface,
}
#[test]
fn bindgen_test_layout_btConvexTriangleMeshShape() {
    assert_eq!(
        ::std::mem::size_of::<btConvexTriangleMeshShape>(),
        200usize,
        concat!("Size of: ", stringify!(btConvexTriangleMeshShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btConvexTriangleMeshShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btConvexTriangleMeshShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConvexTriangleMeshShape)).m_stridingMesh as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConvexTriangleMeshShape),
            "::",
            stringify!(m_stridingMesh)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN25btConvexTriangleMeshShape16getMeshInterfaceEv"]
    pub fn btConvexTriangleMeshShape_getMeshInterface(
        this: *mut btConvexTriangleMeshShape,
    ) -> *mut btStridingMeshInterface;
}
extern "C" {
    #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape16getMeshInterfaceEv"]
    pub fn btConvexTriangleMeshShape_getMeshInterface1(
        this: *const btConvexTriangleMeshShape,
    ) -> *const btStridingMeshInterface;
}
extern "C" {

    /// computes the exact moment of inertia and the transform from the coordinate system defined by the principal axes of the moment of inertia
    /// ///and the center of mass to the current coordinate system. A mass of 1 is assumed, for other masses just multiply the computed "inertia"
    /// ///by the mass. The resulting transform "principal" has to be applied inversely to the mesh in order for the local coordinate system of the
    /// ///shape to be centered at the center of mass and to coincide with the principal axes. This also necessitates a correction of the world transform
    /// ///of the collision object by the principal transform. This method also computes the volume of the convex mesh.

    #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape31calculatePrincipalAxisTransformER11btTransformR9btVector3Rd"]
    pub fn btConvexTriangleMeshShape_calculatePrincipalAxisTransform(
        this: *const btConvexTriangleMeshShape,
        principal: *mut btTransform,
        inertia: *mut btVector3,
        volume: *mut btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN25btConvexTriangleMeshShapeC1EP23btStridingMeshInterfaceb"]
    pub fn btConvexTriangleMeshShape_btConvexTriangleMeshShape(
        this: *mut btConvexTriangleMeshShape,
        meshInterface: *mut btStridingMeshInterface,
        calcAabb: bool,
    );
}
impl btConvexTriangleMeshShape {
    #[inline]
    pub unsafe fn getMeshInterface(&mut self) -> *mut btStridingMeshInterface {
        btConvexTriangleMeshShape_getMeshInterface(self)
    }
    #[inline]
    pub unsafe fn getMeshInterface1(&self) -> *const btStridingMeshInterface {
        btConvexTriangleMeshShape_getMeshInterface1(self)
    }
    #[inline]
    pub unsafe fn calculatePrincipalAxisTransform(
        &self,
        principal: *mut btTransform,
        inertia: *mut btVector3,
        volume: *mut btScalar,
    ) {
        btConvexTriangleMeshShape_calculatePrincipalAxisTransform(self, principal, inertia, volume)
    }
    #[inline]
    pub unsafe fn new(meshInterface: *mut btStridingMeshInterface, calcAabb: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConvexTriangleMeshShape_btConvexTriangleMeshShape(
            &mut __bindgen_tmp,
            meshInterface,
            calcAabb,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape24localGetSupportingVertexERK9btVector3"]
    pub fn btConvexTriangleMeshShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
    pub fn btConvexTriangleMeshShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
    pub fn btConvexTriangleMeshShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape7getNameEv"]
    pub fn btConvexTriangleMeshShape_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape14getNumVerticesEv"]
    pub fn btConvexTriangleMeshShape_getNumVertices(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape11getNumEdgesEv"]
    pub fn btConvexTriangleMeshShape_getNumEdges(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape7getEdgeEiR9btVector3S1_"]
    pub fn btConvexTriangleMeshShape_getEdge(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        pa: *mut btVector3,
        pb: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape9getVertexEiR9btVector3"]
    pub fn btConvexTriangleMeshShape_getVertex(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        vtx: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape12getNumPlanesEv"]
    pub fn btConvexTriangleMeshShape_getNumPlanes(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape8getPlaneER9btVector3S1_i"]
    pub fn btConvexTriangleMeshShape_getPlane(
        this: *mut ::std::os::raw::c_void,
        planeNormal: *mut btVector3,
        planeSupport: *mut btVector3,
        i: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape8isInsideERK9btVector3d"]
    pub fn btConvexTriangleMeshShape_isInside(
        this: *mut ::std::os::raw::c_void,
        pt: *const btVector3,
        tolerance: btScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN25btConvexTriangleMeshShape15setLocalScalingERK9btVector3"]
    pub fn btConvexTriangleMeshShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK25btConvexTriangleMeshShape15getLocalScalingEv"]
    pub fn btConvexTriangleMeshShape_getLocalScaling(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btVector3;
}
/// The btTriangleMeshShape is an internal concave triangle mesh interface. Don't use this class directly, use btBvhTriangleMeshShape instead.
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleMeshShape {
    pub _base: btConcaveShape,
    pub m_localAabbMin: btVector3,
    pub m_localAabbMax: btVector3,
    pub m_meshInterface: *mut btStridingMeshInterface,
}
#[test]
fn bindgen_test_layout_btTriangleMeshShape() {
    assert_eq!(
        ::std::mem::size_of::<btTriangleMeshShape>(),
        112usize,
        concat!("Size of: ", stringify!(btTriangleMeshShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btTriangleMeshShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btTriangleMeshShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleMeshShape)).m_localAabbMin as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMeshShape),
            "::",
            stringify!(m_localAabbMin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleMeshShape)).m_localAabbMax as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMeshShape),
            "::",
            stringify!(m_localAabbMax)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleMeshShape)).m_meshInterface as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMeshShape),
            "::",
            stringify!(m_meshInterface)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19btTriangleMeshShape15recalcLocalAabbEv"]
    pub fn btTriangleMeshShape_recalcLocalAabb(this: *mut btTriangleMeshShape);
}
extern "C" {
    #[link_name = "\u{1}_ZN19btTriangleMeshShape16getMeshInterfaceEv"]
    pub fn btTriangleMeshShape_getMeshInterface(
        this: *mut btTriangleMeshShape,
    ) -> *mut btStridingMeshInterface;
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btTriangleMeshShape16getMeshInterfaceEv"]
    pub fn btTriangleMeshShape_getMeshInterface1(
        this: *const btTriangleMeshShape,
    ) -> *const btStridingMeshInterface;
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btTriangleMeshShape15getLocalAabbMinEv"]
    pub fn btTriangleMeshShape_getLocalAabbMin(
        this: *const btTriangleMeshShape,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btTriangleMeshShape15getLocalAabbMaxEv"]
    pub fn btTriangleMeshShape_getLocalAabbMax(
        this: *const btTriangleMeshShape,
    ) -> *const btVector3;
}
extern "C" {

    /// btTriangleMeshShape constructor has been disabled/protected, so that users will not mistakenly use this class.
    /// ///Don't use btTriangleMeshShape but use btBvhTriangleMeshShape instead!

    #[link_name = "\u{1}_ZN19btTriangleMeshShapeC1EP23btStridingMeshInterface"]
    pub fn btTriangleMeshShape_btTriangleMeshShape(
        this: *mut btTriangleMeshShape,
        meshInterface: *mut btStridingMeshInterface,
    );
}
impl btTriangleMeshShape {
    #[inline]
    pub unsafe fn recalcLocalAabb(&mut self) {
        btTriangleMeshShape_recalcLocalAabb(self)
    }
    #[inline]
    pub unsafe fn getMeshInterface(&mut self) -> *mut btStridingMeshInterface {
        btTriangleMeshShape_getMeshInterface(self)
    }
    #[inline]
    pub unsafe fn getMeshInterface1(&self) -> *const btStridingMeshInterface {
        btTriangleMeshShape_getMeshInterface1(self)
    }
    #[inline]
    pub unsafe fn getLocalAabbMin(&self) -> *const btVector3 {
        btTriangleMeshShape_getLocalAabbMin(self)
    }
    #[inline]
    pub unsafe fn getLocalAabbMax(&self) -> *const btVector3 {
        btTriangleMeshShape_getLocalAabbMax(self)
    }
    #[inline]
    pub unsafe fn new(meshInterface: *mut btStridingMeshInterface) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTriangleMeshShape_btTriangleMeshShape(&mut __bindgen_tmp, meshInterface);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN19btTriangleMeshShapeD0Ev"]
    pub fn btTriangleMeshShape_btTriangleMeshShape_destructor(this: *mut btTriangleMeshShape);
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btTriangleMeshShape24localGetSupportingVertexERK9btVector3"]
    pub fn btTriangleMeshShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btTriangleMeshShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
    pub fn btTriangleMeshShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btTriangleMeshShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btTriangleMeshShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btTriangleMeshShape19processAllTrianglesEP18btTriangleCallbackRK9btVector3S4_"]
    pub fn btTriangleMeshShape_processAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btTriangleMeshShape21calculateLocalInertiaEdR9btVector3"]
    pub fn btTriangleMeshShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19btTriangleMeshShape15setLocalScalingERK9btVector3"]
    pub fn btTriangleMeshShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btTriangleMeshShape15getLocalScalingEv"]
    pub fn btTriangleMeshShape_getLocalScaling(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btTriangleMeshShape7getNameEv"]
    pub fn btTriangleMeshShape_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
/// btQuantizedBvhNode is a compressed aabb node, 16 bytes.
/// Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuantizedBvhNode {
    pub m_quantizedAabbMin: [::std::os::raw::c_ushort; 3usize],
    pub m_quantizedAabbMax: [::std::os::raw::c_ushort; 3usize],
    pub m_escapeIndexOrTriangleIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btQuantizedBvhNode() {
    assert_eq!(
        ::std::mem::size_of::<btQuantizedBvhNode>(),
        16usize,
        concat!("Size of: ", stringify!(btQuantizedBvhNode))
    );
    assert_eq!(
        ::std::mem::align_of::<btQuantizedBvhNode>(),
        4usize,
        concat!("Alignment of ", stringify!(btQuantizedBvhNode))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhNode)).m_quantizedAabbMin as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhNode),
            "::",
            stringify!(m_quantizedAabbMin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhNode)).m_quantizedAabbMax as *const _ as usize },
        6usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhNode),
            "::",
            stringify!(m_quantizedAabbMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btQuantizedBvhNode)).m_escapeIndexOrTriangleIndex as *const _ as usize
        },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhNode),
            "::",
            stringify!(m_escapeIndexOrTriangleIndex)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btQuantizedBvhNode10isLeafNodeEv"]
    pub fn btQuantizedBvhNode_isLeafNode(this: *const btQuantizedBvhNode) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btQuantizedBvhNode14getEscapeIndexEv"]
    pub fn btQuantizedBvhNode_getEscapeIndex(
        this: *const btQuantizedBvhNode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btQuantizedBvhNode16getTriangleIndexEv"]
    pub fn btQuantizedBvhNode_getTriangleIndex(
        this: *const btQuantizedBvhNode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btQuantizedBvhNode9getPartIdEv"]
    pub fn btQuantizedBvhNode_getPartId(this: *const btQuantizedBvhNode) -> ::std::os::raw::c_int;
}
impl btQuantizedBvhNode {
    #[inline]
    pub unsafe fn isLeafNode(&self) -> bool {
        btQuantizedBvhNode_isLeafNode(self)
    }
    #[inline]
    pub unsafe fn getEscapeIndex(&self) -> ::std::os::raw::c_int {
        btQuantizedBvhNode_getEscapeIndex(self)
    }
    #[inline]
    pub unsafe fn getTriangleIndex(&self) -> ::std::os::raw::c_int {
        btQuantizedBvhNode_getTriangleIndex(self)
    }
    #[inline]
    pub unsafe fn getPartId(&self) -> ::std::os::raw::c_int {
        btQuantizedBvhNode_getPartId(self)
    }
}
/// btOptimizedBvhNode contains both internal and leaf node information.
/// Total node size is 44 bytes / node. You can use the compressed version of 16 bytes.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btOptimizedBvhNode {
    pub m_aabbMinOrg: btVector3,
    pub m_aabbMaxOrg: btVector3,
    pub m_escapeIndex: ::std::os::raw::c_int,
    pub m_subPart: ::std::os::raw::c_int,
    pub m_triangleIndex: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout_btOptimizedBvhNode() {
    assert_eq!(
        ::std::mem::size_of::<btOptimizedBvhNode>(),
        96usize,
        concat!("Size of: ", stringify!(btOptimizedBvhNode))
    );
    assert_eq!(
        ::std::mem::align_of::<btOptimizedBvhNode>(),
        8usize,
        concat!("Alignment of ", stringify!(btOptimizedBvhNode))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNode)).m_aabbMinOrg as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNode),
            "::",
            stringify!(m_aabbMinOrg)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNode)).m_aabbMaxOrg as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNode),
            "::",
            stringify!(m_aabbMaxOrg)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNode)).m_escapeIndex as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNode),
            "::",
            stringify!(m_escapeIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNode)).m_subPart as *const _ as usize },
        68usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNode),
            "::",
            stringify!(m_subPart)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNode)).m_triangleIndex as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNode),
            "::",
            stringify!(m_triangleIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNode)).m_padding as *const _ as usize },
        76usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNode),
            "::",
            stringify!(m_padding)
        )
    );
}
/// btBvhSubtreeInfo provides info to gather a subtree of limited size
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btBvhSubtreeInfo {
    pub m_quantizedAabbMin: [::std::os::raw::c_ushort; 3usize],
    pub m_quantizedAabbMax: [::std::os::raw::c_ushort; 3usize],
    pub m_rootNodeIndex: ::std::os::raw::c_int,
    pub m_subtreeSize: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_int; 3usize],
}
#[test]
fn bindgen_test_layout_btBvhSubtreeInfo() {
    assert_eq!(
        ::std::mem::size_of::<btBvhSubtreeInfo>(),
        32usize,
        concat!("Size of: ", stringify!(btBvhSubtreeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<btBvhSubtreeInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(btBvhSubtreeInfo))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBvhSubtreeInfo)).m_quantizedAabbMin as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBvhSubtreeInfo),
            "::",
            stringify!(m_quantizedAabbMin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBvhSubtreeInfo)).m_quantizedAabbMax as *const _ as usize },
        6usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBvhSubtreeInfo),
            "::",
            stringify!(m_quantizedAabbMax)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBvhSubtreeInfo)).m_rootNodeIndex as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBvhSubtreeInfo),
            "::",
            stringify!(m_rootNodeIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBvhSubtreeInfo)).m_subtreeSize as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBvhSubtreeInfo),
            "::",
            stringify!(m_subtreeSize)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBvhSubtreeInfo)).m_padding as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBvhSubtreeInfo),
            "::",
            stringify!(m_padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btBvhSubtreeInfo23setAabbFromQuantizeNodeERK18btQuantizedBvhNode"]
    pub fn btBvhSubtreeInfo_setAabbFromQuantizeNode(
        this: *mut btBvhSubtreeInfo,
        quantizedNode: *const btQuantizedBvhNode,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btBvhSubtreeInfoC1Ev"]
    pub fn btBvhSubtreeInfo_btBvhSubtreeInfo(this: *mut btBvhSubtreeInfo);
}
impl btBvhSubtreeInfo {
    #[inline]
    pub unsafe fn setAabbFromQuantizeNode(&mut self, quantizedNode: *const btQuantizedBvhNode) {
        btBvhSubtreeInfo_setAabbFromQuantizeNode(self, quantizedNode)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBvhSubtreeInfo_btBvhSubtreeInfo(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct btNodeOverlapCallback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btNodeOverlapCallback {
    pub vtable_: *const btNodeOverlapCallback__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btNodeOverlapCallback() {
    assert_eq!(
        ::std::mem::size_of::<btNodeOverlapCallback>(),
        8usize,
        concat!("Size of: ", stringify!(btNodeOverlapCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<btNodeOverlapCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(btNodeOverlapCallback))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btNodeOverlapCallbackD0Ev"]
    pub fn btNodeOverlapCallback_btNodeOverlapCallback_destructor(this: *mut btNodeOverlapCallback);
}
extern "C" {
    #[link_name = "\u{1}_ZN21btNodeOverlapCallback11processNodeEii"]
    pub fn btNodeOverlapCallback_processNode(
        this: *mut ::std::os::raw::c_void,
        subPart: ::std::os::raw::c_int,
        triangleIndex: ::std::os::raw::c_int,
    );
}
/// for code readability:
pub type NodeArray = btAlignedObjectArray<btOptimizedBvhNode>;
pub type QuantizedNodeArray = btAlignedObjectArray<btQuantizedBvhNode>;
pub type BvhSubtreeInfoArray = btAlignedObjectArray<btBvhSubtreeInfo>;
#[repr(C)]
pub struct btQuantizedBvh__bindgen_vtable(::std::os::raw::c_void);
/// The btQuantizedBvh class stores an AABB tree that can be quickly traversed on CPU and Cell SPU.
/// It is used by the btBvhTriangleMeshShape as midphase.
/// It is recommended to use quantization for better performance and lower memory requirements.
#[repr(C)]
#[derive(Debug)]
pub struct btQuantizedBvh {
    pub vtable_: *const btQuantizedBvh__bindgen_vtable,
    pub m_bvhAabbMin: btVector3,
    pub m_bvhAabbMax: btVector3,
    pub m_bvhQuantization: btVector3,
    pub m_bulletVersion: ::std::os::raw::c_int,
    pub m_curNodeIndex: ::std::os::raw::c_int,
    pub m_useQuantization: bool,
    pub m_leafNodes: NodeArray,
    pub m_contiguousNodes: NodeArray,
    pub m_quantizedLeafNodes: QuantizedNodeArray,
    pub m_quantizedContiguousNodes: QuantizedNodeArray,
    pub m_traversalMode: btQuantizedBvh_btTraversalMode,
    pub m_SubtreeHeaders: BvhSubtreeInfoArray,
    pub m_subtreeHeaderCount: ::std::os::raw::c_int,
}
pub const btQuantizedBvh_btTraversalMode_TRAVERSAL_STACKLESS: btQuantizedBvh_btTraversalMode = 0;
pub const btQuantizedBvh_btTraversalMode_TRAVERSAL_STACKLESS_CACHE_FRIENDLY : btQuantizedBvh_btTraversalMode = 1 ;
pub const btQuantizedBvh_btTraversalMode_TRAVERSAL_RECURSIVE: btQuantizedBvh_btTraversalMode = 2;
pub type btQuantizedBvh_btTraversalMode = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_btQuantizedBvh() {
    assert_eq!(
        ::std::mem::size_of::<btQuantizedBvh>(),
        296usize,
        concat!("Size of: ", stringify!(btQuantizedBvh))
    );
    assert_eq!(
        ::std::mem::align_of::<btQuantizedBvh>(),
        8usize,
        concat!("Alignment of ", stringify!(btQuantizedBvh))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvh)).m_bvhAabbMin as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvh),
            "::",
            stringify!(m_bvhAabbMin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvh)).m_bvhAabbMax as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvh),
            "::",
            stringify!(m_bvhAabbMax)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvh)).m_bvhQuantization as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvh),
            "::",
            stringify!(m_bvhQuantization)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvh)).m_bulletVersion as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvh),
            "::",
            stringify!(m_bulletVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvh)).m_curNodeIndex as *const _ as usize },
        108usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvh),
            "::",
            stringify!(m_curNodeIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvh)).m_useQuantization as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvh),
            "::",
            stringify!(m_useQuantization)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvh)).m_leafNodes as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvh),
            "::",
            stringify!(m_leafNodes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvh)).m_contiguousNodes as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvh),
            "::",
            stringify!(m_contiguousNodes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvh)).m_quantizedLeafNodes as *const _ as usize },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvh),
            "::",
            stringify!(m_quantizedLeafNodes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvh)).m_quantizedContiguousNodes as *const _ as usize },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvh),
            "::",
            stringify!(m_quantizedContiguousNodes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvh)).m_traversalMode as *const _ as usize },
        248usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvh),
            "::",
            stringify!(m_traversalMode)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvh)).m_SubtreeHeaders as *const _ as usize },
        256usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvh),
            "::",
            stringify!(m_SubtreeHeaders)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvh)).m_subtreeHeaderCount as *const _ as usize },
        288usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvh),
            "::",
            stringify!(m_subtreeHeaderCount)
        )
    );
}
extern "C" {

    /// two versions, one for quantized and normal nodes. This allows code-reuse while maintaining readability (no template/macro!)
    /// ///this might be refactored into a virtual, it is usually not calculated at run-time

    #[link_name = "\u{1}_ZN14btQuantizedBvh22setInternalNodeAabbMinEiRK9btVector3"]
    pub fn btQuantizedBvh_setInternalNodeAabbMin(
        this: *mut btQuantizedBvh,
        nodeIndex: ::std::os::raw::c_int,
        aabbMin: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh22setInternalNodeAabbMaxEiRK9btVector3"]
    pub fn btQuantizedBvh_setInternalNodeAabbMax(
        this: *mut btQuantizedBvh,
        nodeIndex: ::std::os::raw::c_int,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btQuantizedBvh10getAabbMinEi"]
    pub fn btQuantizedBvh_getAabbMin(
        this: *const btQuantizedBvh,
        nodeIndex: ::std::os::raw::c_int,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btQuantizedBvh10getAabbMaxEi"]
    pub fn btQuantizedBvh_getAabbMax(
        this: *const btQuantizedBvh,
        nodeIndex: ::std::os::raw::c_int,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh26setInternalNodeEscapeIndexEii"]
    pub fn btQuantizedBvh_setInternalNodeEscapeIndex(
        this: *mut btQuantizedBvh,
        nodeIndex: ::std::os::raw::c_int,
        escapeIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh21mergeInternalNodeAabbEiRK9btVector3S2_"]
    pub fn btQuantizedBvh_mergeInternalNodeAabb(
        this: *mut btQuantizedBvh,
        nodeIndex: ::std::os::raw::c_int,
        newAabbMin: *const btVector3,
        newAabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh13swapLeafNodesEii"]
    pub fn btQuantizedBvh_swapLeafNodes(
        this: *mut btQuantizedBvh,
        firstIndex: ::std::os::raw::c_int,
        secondIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh30assignInternalNodeFromLeafNodeEii"]
    pub fn btQuantizedBvh_assignInternalNodeFromLeafNode(
        this: *mut btQuantizedBvh,
        internalNode: ::std::os::raw::c_int,
        leafNodeIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh9buildTreeEii"]
    pub fn btQuantizedBvh_buildTree(
        this: *mut btQuantizedBvh,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh17calcSplittingAxisEii"]
    pub fn btQuantizedBvh_calcSplittingAxis(
        this: *mut btQuantizedBvh,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh25sortAndCalcSplittingIndexEiii"]
    pub fn btQuantizedBvh_sortAndCalcSplittingIndex(
        this: *mut btQuantizedBvh,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
        splitAxis: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btQuantizedBvh17walkStacklessTreeEP21btNodeOverlapCallbackRK9btVector3S4_"]
    pub fn btQuantizedBvh_walkStacklessTree(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btQuantizedBvh36walkStacklessQuantizedTreeAgainstRayEP21btNodeOverlapCallbackRK9btVector3S4_S4_S4_ii"]
    pub fn btQuantizedBvh_walkStacklessQuantizedTreeAgainstRay(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        startNodeIndex: ::std::os::raw::c_int,
        endNodeIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btQuantizedBvh26walkStacklessQuantizedTreeEP21btNodeOverlapCallbackPtS2_ii"]
    pub fn btQuantizedBvh_walkStacklessQuantizedTree(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
        quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
        startNodeIndex: ::std::os::raw::c_int,
        endNodeIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btQuantizedBvh27walkStacklessTreeAgainstRayEP21btNodeOverlapCallbackRK9btVector3S4_S4_S4_ii"]
    pub fn btQuantizedBvh_walkStacklessTreeAgainstRay(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        startNodeIndex: ::std::os::raw::c_int,
        endNodeIndex: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// tree traversal designed for small-memory processors like PS3 SPU

    #[link_name = "\u{1}_ZNK14btQuantizedBvh39walkStacklessQuantizedTreeCacheFriendlyEP21btNodeOverlapCallbackPtS2_"]
    pub fn btQuantizedBvh_walkStacklessQuantizedTreeCacheFriendly(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
        quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
    );
}
extern "C" {

    /// use the 16-byte stackless 'skipindex' node tree to do a recursive traversal

    #[link_name = "\u{1}_ZNK14btQuantizedBvh42walkRecursiveQuantizedTreeAgainstQueryAabbEPK18btQuantizedBvhNodeP21btNodeOverlapCallbackPtS5_"]
    pub fn btQuantizedBvh_walkRecursiveQuantizedTreeAgainstQueryAabb(
        this: *const btQuantizedBvh,
        currentNode: *const btQuantizedBvhNode,
        nodeCallback: *mut btNodeOverlapCallback,
        quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
        quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
    );
}
extern "C" {

    /// use the 16-byte stackless 'skipindex' node tree to do a recursive traversal

    #[link_name = "\u{1}_ZNK14btQuantizedBvh46walkRecursiveQuantizedTreeAgainstQuantizedTreeEPK18btQuantizedBvhNodeS2_P21btNodeOverlapCallback"]
    pub fn btQuantizedBvh_walkRecursiveQuantizedTreeAgainstQuantizedTree(
        this: *const btQuantizedBvh,
        treeNodeA: *const btQuantizedBvhNode,
        treeNodeB: *const btQuantizedBvhNode,
        nodeCallback: *mut btNodeOverlapCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh20updateSubtreeHeadersEii"]
    pub fn btQuantizedBvh_updateSubtreeHeaders(
        this: *mut btQuantizedBvh,
        leftChildNodexIndex: ::std::os::raw::c_int,
        rightChildNodexIndex: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// ***************************************** expert/internal use only *************************

    #[link_name = "\u{1}_ZN14btQuantizedBvh21setQuantizationValuesERK9btVector3S2_d"]
    pub fn btQuantizedBvh_setQuantizationValues(
        this: *mut btQuantizedBvh,
        bvhAabbMin: *const btVector3,
        bvhAabbMax: *const btVector3,
        quantizationMargin: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh16getLeafNodeArrayEv"]
    pub fn btQuantizedBvh_getLeafNodeArray(this: *mut btQuantizedBvh) -> *mut QuantizedNodeArray;
}
extern "C" {

    /// buildInternal is expert use only: assumes that setQuantizationValues and LeafNodeArray are initialized

    #[link_name = "\u{1}_ZN14btQuantizedBvh13buildInternalEv"]
    pub fn btQuantizedBvh_buildInternal(this: *mut btQuantizedBvh);
}
extern "C" {

    /// ***************************************** expert/internal use only *************************

    #[link_name = "\u{1}_ZNK14btQuantizedBvh26reportAabbOverlappingNodexEP21btNodeOverlapCallbackRK9btVector3S4_"]
    pub fn btQuantizedBvh_reportAabbOverlappingNodex(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btQuantizedBvh25reportRayOverlappingNodexEP21btNodeOverlapCallbackRK9btVector3S4_"]
    pub fn btQuantizedBvh_reportRayOverlappingNodex(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btQuantizedBvh29reportBoxCastOverlappingNodexEP21btNodeOverlapCallbackRK9btVector3S4_S4_S4_"]
    pub fn btQuantizedBvh_reportBoxCastOverlappingNodex(
        this: *const btQuantizedBvh,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btQuantizedBvh8quantizeEPtRK9btVector3i"]
    pub fn btQuantizedBvh_quantize(
        this: *const btQuantizedBvh,
        out: *mut ::std::os::raw::c_ushort,
        point: *const btVector3,
        isMax: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btQuantizedBvh17quantizeWithClampEPtRK9btVector3i"]
    pub fn btQuantizedBvh_quantizeWithClamp(
        this: *const btQuantizedBvh,
        out: *mut ::std::os::raw::c_ushort,
        point2: *const btVector3,
        isMax: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btQuantizedBvh10unQuantizeEPKt"]
    pub fn btQuantizedBvh_unQuantize(
        this: *const btQuantizedBvh,
        vecIn: *const ::std::os::raw::c_ushort,
    ) -> btVector3;
}
extern "C" {

    /// setTraversalMode let's you choose between stackless, recursive or stackless cache friendly tree traversal. Note this is only implemented for quantized trees.

    #[link_name = "\u{1}_ZN14btQuantizedBvh16setTraversalModeENS_15btTraversalModeE"]
    pub fn btQuantizedBvh_setTraversalMode(
        this: *mut btQuantizedBvh,
        traversalMode: btQuantizedBvh_btTraversalMode,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh21getQuantizedNodeArrayEv"]
    pub fn btQuantizedBvh_getQuantizedNodeArray(
        this: *mut btQuantizedBvh,
    ) -> *mut QuantizedNodeArray;
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh19getSubtreeInfoArrayEv"]
    pub fn btQuantizedBvh_getSubtreeInfoArray(
        this: *mut btQuantizedBvh,
    ) -> *mut BvhSubtreeInfoArray;
}
extern "C" {

    /// Calculate space needed to store BVH for serialization

    #[link_name = "\u{1}_ZNK14btQuantizedBvh28calculateSerializeBufferSizeEv"]
    pub fn btQuantizedBvh_calculateSerializeBufferSize(
        this: *const btQuantizedBvh,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {

    /// deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'

    #[link_name = "\u{1}_ZN14btQuantizedBvh18deSerializeInPlaceEPvjb"]
    pub fn btQuantizedBvh_deSerializeInPlace(
        i_alignedDataBuffer: *mut ::std::os::raw::c_void,
        i_dataBufferSize: ::std::os::raw::c_uint,
        i_swapEndian: bool,
    ) -> *mut btQuantizedBvh;
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh32getAlignmentSerializationPaddingEv"]
    pub fn btQuantizedBvh_getAlignmentSerializationPadding() -> ::std::os::raw::c_uint;
}
extern "C" {

    ///

    #[link_name = "\u{1}_ZN14btQuantizedBvh11isQuantizedEv"]
    pub fn btQuantizedBvh_isQuantized(this: *mut btQuantizedBvh) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvhC1Ev"]
    pub fn btQuantizedBvh_btQuantizedBvh(this: *mut btQuantizedBvh);
}
impl btQuantizedBvh {
    #[inline]
    pub unsafe fn setInternalNodeAabbMin(
        &mut self,
        nodeIndex: ::std::os::raw::c_int,
        aabbMin: *const btVector3,
    ) {
        btQuantizedBvh_setInternalNodeAabbMin(self, nodeIndex, aabbMin)
    }
    #[inline]
    pub unsafe fn setInternalNodeAabbMax(
        &mut self,
        nodeIndex: ::std::os::raw::c_int,
        aabbMax: *const btVector3,
    ) {
        btQuantizedBvh_setInternalNodeAabbMax(self, nodeIndex, aabbMax)
    }
    #[inline]
    pub unsafe fn getAabbMin(&self, nodeIndex: ::std::os::raw::c_int) -> btVector3 {
        btQuantizedBvh_getAabbMin(self, nodeIndex)
    }
    #[inline]
    pub unsafe fn getAabbMax(&self, nodeIndex: ::std::os::raw::c_int) -> btVector3 {
        btQuantizedBvh_getAabbMax(self, nodeIndex)
    }
    #[inline]
    pub unsafe fn setInternalNodeEscapeIndex(
        &mut self,
        nodeIndex: ::std::os::raw::c_int,
        escapeIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_setInternalNodeEscapeIndex(self, nodeIndex, escapeIndex)
    }
    #[inline]
    pub unsafe fn mergeInternalNodeAabb(
        &mut self,
        nodeIndex: ::std::os::raw::c_int,
        newAabbMin: *const btVector3,
        newAabbMax: *const btVector3,
    ) {
        btQuantizedBvh_mergeInternalNodeAabb(self, nodeIndex, newAabbMin, newAabbMax)
    }
    #[inline]
    pub unsafe fn swapLeafNodes(
        &mut self,
        firstIndex: ::std::os::raw::c_int,
        secondIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_swapLeafNodes(self, firstIndex, secondIndex)
    }
    #[inline]
    pub unsafe fn assignInternalNodeFromLeafNode(
        &mut self,
        internalNode: ::std::os::raw::c_int,
        leafNodeIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_assignInternalNodeFromLeafNode(self, internalNode, leafNodeIndex)
    }
    #[inline]
    pub unsafe fn buildTree(
        &mut self,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_buildTree(self, startIndex, endIndex)
    }
    #[inline]
    pub unsafe fn calcSplittingAxis(
        &mut self,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btQuantizedBvh_calcSplittingAxis(self, startIndex, endIndex)
    }
    #[inline]
    pub unsafe fn sortAndCalcSplittingIndex(
        &mut self,
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
        splitAxis: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btQuantizedBvh_sortAndCalcSplittingIndex(self, startIndex, endIndex, splitAxis)
    }
    #[inline]
    pub unsafe fn walkStacklessTree(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) {
        btQuantizedBvh_walkStacklessTree(self, nodeCallback, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn walkStacklessQuantizedTreeAgainstRay(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        startNodeIndex: ::std::os::raw::c_int,
        endNodeIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_walkStacklessQuantizedTreeAgainstRay(
            self,
            nodeCallback,
            raySource,
            rayTarget,
            aabbMin,
            aabbMax,
            startNodeIndex,
            endNodeIndex,
        )
    }
    #[inline]
    pub unsafe fn walkStacklessQuantizedTree(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
        quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
        startNodeIndex: ::std::os::raw::c_int,
        endNodeIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_walkStacklessQuantizedTree(
            self,
            nodeCallback,
            quantizedQueryAabbMin,
            quantizedQueryAabbMax,
            startNodeIndex,
            endNodeIndex,
        )
    }
    #[inline]
    pub unsafe fn walkStacklessTreeAgainstRay(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        startNodeIndex: ::std::os::raw::c_int,
        endNodeIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_walkStacklessTreeAgainstRay(
            self,
            nodeCallback,
            raySource,
            rayTarget,
            aabbMin,
            aabbMax,
            startNodeIndex,
            endNodeIndex,
        )
    }
    #[inline]
    pub unsafe fn walkStacklessQuantizedTreeCacheFriendly(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
        quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
    ) {
        btQuantizedBvh_walkStacklessQuantizedTreeCacheFriendly(
            self,
            nodeCallback,
            quantizedQueryAabbMin,
            quantizedQueryAabbMax,
        )
    }
    #[inline]
    pub unsafe fn walkRecursiveQuantizedTreeAgainstQueryAabb(
        &self,
        currentNode: *const btQuantizedBvhNode,
        nodeCallback: *mut btNodeOverlapCallback,
        quantizedQueryAabbMin: *mut ::std::os::raw::c_ushort,
        quantizedQueryAabbMax: *mut ::std::os::raw::c_ushort,
    ) {
        btQuantizedBvh_walkRecursiveQuantizedTreeAgainstQueryAabb(
            self,
            currentNode,
            nodeCallback,
            quantizedQueryAabbMin,
            quantizedQueryAabbMax,
        )
    }
    #[inline]
    pub unsafe fn walkRecursiveQuantizedTreeAgainstQuantizedTree(
        &self,
        treeNodeA: *const btQuantizedBvhNode,
        treeNodeB: *const btQuantizedBvhNode,
        nodeCallback: *mut btNodeOverlapCallback,
    ) {
        btQuantizedBvh_walkRecursiveQuantizedTreeAgainstQuantizedTree(
            self,
            treeNodeA,
            treeNodeB,
            nodeCallback,
        )
    }
    #[inline]
    pub unsafe fn updateSubtreeHeaders(
        &mut self,
        leftChildNodexIndex: ::std::os::raw::c_int,
        rightChildNodexIndex: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_updateSubtreeHeaders(self, leftChildNodexIndex, rightChildNodexIndex)
    }
    #[inline]
    pub unsafe fn setQuantizationValues(
        &mut self,
        bvhAabbMin: *const btVector3,
        bvhAabbMax: *const btVector3,
        quantizationMargin: btScalar,
    ) {
        btQuantizedBvh_setQuantizationValues(self, bvhAabbMin, bvhAabbMax, quantizationMargin)
    }
    #[inline]
    pub unsafe fn getLeafNodeArray(&mut self) -> *mut QuantizedNodeArray {
        btQuantizedBvh_getLeafNodeArray(self)
    }
    #[inline]
    pub unsafe fn buildInternal(&mut self) {
        btQuantizedBvh_buildInternal(self)
    }
    #[inline]
    pub unsafe fn reportAabbOverlappingNodex(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) {
        btQuantizedBvh_reportAabbOverlappingNodex(self, nodeCallback, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn reportRayOverlappingNodex(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
    ) {
        btQuantizedBvh_reportRayOverlappingNodex(self, nodeCallback, raySource, rayTarget)
    }
    #[inline]
    pub unsafe fn reportBoxCastOverlappingNodex(
        &self,
        nodeCallback: *mut btNodeOverlapCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) {
        btQuantizedBvh_reportBoxCastOverlappingNodex(
            self,
            nodeCallback,
            raySource,
            rayTarget,
            aabbMin,
            aabbMax,
        )
    }
    #[inline]
    pub unsafe fn quantize(
        &self,
        out: *mut ::std::os::raw::c_ushort,
        point: *const btVector3,
        isMax: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_quantize(self, out, point, isMax)
    }
    #[inline]
    pub unsafe fn quantizeWithClamp(
        &self,
        out: *mut ::std::os::raw::c_ushort,
        point2: *const btVector3,
        isMax: ::std::os::raw::c_int,
    ) {
        btQuantizedBvh_quantizeWithClamp(self, out, point2, isMax)
    }
    #[inline]
    pub unsafe fn unQuantize(&self, vecIn: *const ::std::os::raw::c_ushort) -> btVector3 {
        btQuantizedBvh_unQuantize(self, vecIn)
    }
    #[inline]
    pub unsafe fn setTraversalMode(&mut self, traversalMode: btQuantizedBvh_btTraversalMode) {
        btQuantizedBvh_setTraversalMode(self, traversalMode)
    }
    #[inline]
    pub unsafe fn getQuantizedNodeArray(&mut self) -> *mut QuantizedNodeArray {
        btQuantizedBvh_getQuantizedNodeArray(self)
    }
    #[inline]
    pub unsafe fn getSubtreeInfoArray(&mut self) -> *mut BvhSubtreeInfoArray {
        btQuantizedBvh_getSubtreeInfoArray(self)
    }
    #[inline]
    pub unsafe fn calculateSerializeBufferSize(&self) -> ::std::os::raw::c_uint {
        btQuantizedBvh_calculateSerializeBufferSize(self)
    }
    #[inline]
    pub unsafe fn deSerializeInPlace(
        i_alignedDataBuffer: *mut ::std::os::raw::c_void,
        i_dataBufferSize: ::std::os::raw::c_uint,
        i_swapEndian: bool,
    ) -> *mut btQuantizedBvh {
        btQuantizedBvh_deSerializeInPlace(i_alignedDataBuffer, i_dataBufferSize, i_swapEndian)
    }
    #[inline]
    pub unsafe fn getAlignmentSerializationPadding() -> ::std::os::raw::c_uint {
        btQuantizedBvh_getAlignmentSerializationPadding()
    }
    #[inline]
    pub unsafe fn isQuantized(&mut self) -> bool {
        btQuantizedBvh_isQuantized(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btQuantizedBvh_btQuantizedBvh(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvhD0Ev"]
    pub fn btQuantizedBvh_btQuantizedBvh_destructor(this: *mut btQuantizedBvh);
}
extern "C" {

    /// Data buffer MUST be 16 byte aligned

    #[link_name = "\u{1}_ZNK14btQuantizedBvh9serializeEPvjb"]
    pub fn btQuantizedBvh_serialize(
        this: *mut ::std::os::raw::c_void,
        o_alignedDataBuffer: *mut ::std::os::raw::c_void,
        i_dataBufferSize: ::std::os::raw::c_uint,
        i_swapEndian: bool,
    ) -> bool;
}
extern "C" {

    ///

    #[link_name = "\u{1}_ZNK14btQuantizedBvh31calculateSerializeBufferSizeNewEv"]
    pub fn btQuantizedBvh_calculateSerializeBufferSizeNew(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK14btQuantizedBvh9serializeEPvP12btSerializer"]
    pub fn btQuantizedBvh_serialize1(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh16deSerializeFloatER23btQuantizedBvhFloatData"]
    pub fn btQuantizedBvh_deSerializeFloat(
        this: *mut ::std::os::raw::c_void,
        quantizedBvhFloatData: *mut btQuantizedBvhFloatData,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btQuantizedBvh17deSerializeDoubleER24btQuantizedBvhDoubleData"]
    pub fn btQuantizedBvh_deSerializeDouble(
        this: *mut ::std::os::raw::c_void,
        quantizedBvhDoubleData: *mut btQuantizedBvhDoubleData,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btBvhSubtreeInfoData {
    pub m_rootNodeIndex: ::std::os::raw::c_int,
    pub m_subtreeSize: ::std::os::raw::c_int,
    pub m_quantizedAabbMin: [::std::os::raw::c_ushort; 3usize],
    pub m_quantizedAabbMax: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout_btBvhSubtreeInfoData() {
    assert_eq!(
        ::std::mem::size_of::<btBvhSubtreeInfoData>(),
        20usize,
        concat!("Size of: ", stringify!(btBvhSubtreeInfoData))
    );
    assert_eq!(
        ::std::mem::align_of::<btBvhSubtreeInfoData>(),
        4usize,
        concat!("Alignment of ", stringify!(btBvhSubtreeInfoData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBvhSubtreeInfoData)).m_rootNodeIndex as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBvhSubtreeInfoData),
            "::",
            stringify!(m_rootNodeIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBvhSubtreeInfoData)).m_subtreeSize as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBvhSubtreeInfoData),
            "::",
            stringify!(m_subtreeSize)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBvhSubtreeInfoData)).m_quantizedAabbMin as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBvhSubtreeInfoData),
            "::",
            stringify!(m_quantizedAabbMin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBvhSubtreeInfoData)).m_quantizedAabbMax as *const _ as usize },
        14usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBvhSubtreeInfoData),
            "::",
            stringify!(m_quantizedAabbMax)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btOptimizedBvhNodeFloatData {
    pub m_aabbMinOrg: btVector3FloatData,
    pub m_aabbMaxOrg: btVector3FloatData,
    pub m_escapeIndex: ::std::os::raw::c_int,
    pub m_subPart: ::std::os::raw::c_int,
    pub m_triangleIndex: ::std::os::raw::c_int,
    pub m_pad: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btOptimizedBvhNodeFloatData() {
    assert_eq!(
        ::std::mem::size_of::<btOptimizedBvhNodeFloatData>(),
        48usize,
        concat!("Size of: ", stringify!(btOptimizedBvhNodeFloatData))
    );
    assert_eq!(
        ::std::mem::align_of::<btOptimizedBvhNodeFloatData>(),
        4usize,
        concat!("Alignment of ", stringify!(btOptimizedBvhNodeFloatData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNodeFloatData)).m_aabbMinOrg as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNodeFloatData),
            "::",
            stringify!(m_aabbMinOrg)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNodeFloatData)).m_aabbMaxOrg as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNodeFloatData),
            "::",
            stringify!(m_aabbMaxOrg)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNodeFloatData)).m_escapeIndex as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNodeFloatData),
            "::",
            stringify!(m_escapeIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNodeFloatData)).m_subPart as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNodeFloatData),
            "::",
            stringify!(m_subPart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btOptimizedBvhNodeFloatData)).m_triangleIndex as *const _ as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNodeFloatData),
            "::",
            stringify!(m_triangleIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNodeFloatData)).m_pad as *const _ as usize },
        44usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNodeFloatData),
            "::",
            stringify!(m_pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btOptimizedBvhNodeDoubleData {
    pub m_aabbMinOrg: btVector3DoubleData,
    pub m_aabbMaxOrg: btVector3DoubleData,
    pub m_escapeIndex: ::std::os::raw::c_int,
    pub m_subPart: ::std::os::raw::c_int,
    pub m_triangleIndex: ::std::os::raw::c_int,
    pub m_pad: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btOptimizedBvhNodeDoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btOptimizedBvhNodeDoubleData>(),
        80usize,
        concat!("Size of: ", stringify!(btOptimizedBvhNodeDoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btOptimizedBvhNodeDoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btOptimizedBvhNodeDoubleData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNodeDoubleData)).m_aabbMinOrg as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNodeDoubleData),
            "::",
            stringify!(m_aabbMinOrg)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNodeDoubleData)).m_aabbMaxOrg as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNodeDoubleData),
            "::",
            stringify!(m_aabbMaxOrg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btOptimizedBvhNodeDoubleData)).m_escapeIndex as *const _ as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNodeDoubleData),
            "::",
            stringify!(m_escapeIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNodeDoubleData)).m_subPart as *const _ as usize },
        68usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNodeDoubleData),
            "::",
            stringify!(m_subPart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btOptimizedBvhNodeDoubleData)).m_triangleIndex as *const _ as usize
        },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNodeDoubleData),
            "::",
            stringify!(m_triangleIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btOptimizedBvhNodeDoubleData)).m_pad as *const _ as usize },
        76usize,
        concat!(
            "Alignment of field: ",
            stringify!(btOptimizedBvhNodeDoubleData),
            "::",
            stringify!(m_pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuantizedBvhNodeData {
    pub m_quantizedAabbMin: [::std::os::raw::c_ushort; 3usize],
    pub m_quantizedAabbMax: [::std::os::raw::c_ushort; 3usize],
    pub m_escapeIndexOrTriangleIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btQuantizedBvhNodeData() {
    assert_eq!(
        ::std::mem::size_of::<btQuantizedBvhNodeData>(),
        16usize,
        concat!("Size of: ", stringify!(btQuantizedBvhNodeData))
    );
    assert_eq!(
        ::std::mem::align_of::<btQuantizedBvhNodeData>(),
        4usize,
        concat!("Alignment of ", stringify!(btQuantizedBvhNodeData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhNodeData)).m_quantizedAabbMin as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhNodeData),
            "::",
            stringify!(m_quantizedAabbMin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhNodeData)).m_quantizedAabbMax as *const _ as usize },
        6usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhNodeData),
            "::",
            stringify!(m_quantizedAabbMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btQuantizedBvhNodeData)).m_escapeIndexOrTriangleIndex as *const _
                as usize
        },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhNodeData),
            "::",
            stringify!(m_escapeIndexOrTriangleIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuantizedBvhFloatData {
    pub m_bvhAabbMin: btVector3FloatData,
    pub m_bvhAabbMax: btVector3FloatData,
    pub m_bvhQuantization: btVector3FloatData,
    pub m_curNodeIndex: ::std::os::raw::c_int,
    pub m_useQuantization: ::std::os::raw::c_int,
    pub m_numContiguousLeafNodes: ::std::os::raw::c_int,
    pub m_numQuantizedContiguousNodes: ::std::os::raw::c_int,
    pub m_contiguousNodesPtr: *mut btOptimizedBvhNodeFloatData,
    pub m_quantizedContiguousNodesPtr: *mut btQuantizedBvhNodeData,
    pub m_subTreeInfoPtr: *mut btBvhSubtreeInfoData,
    pub m_traversalMode: ::std::os::raw::c_int,
    pub m_numSubtreeHeaders: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btQuantizedBvhFloatData() {
    assert_eq!(
        ::std::mem::size_of::<btQuantizedBvhFloatData>(),
        96usize,
        concat!("Size of: ", stringify!(btQuantizedBvhFloatData))
    );
    assert_eq!(
        ::std::mem::align_of::<btQuantizedBvhFloatData>(),
        8usize,
        concat!("Alignment of ", stringify!(btQuantizedBvhFloatData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhFloatData)).m_bvhAabbMin as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhFloatData),
            "::",
            stringify!(m_bvhAabbMin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhFloatData)).m_bvhAabbMax as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhFloatData),
            "::",
            stringify!(m_bvhAabbMax)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhFloatData)).m_bvhQuantization as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhFloatData),
            "::",
            stringify!(m_bvhQuantization)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhFloatData)).m_curNodeIndex as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhFloatData),
            "::",
            stringify!(m_curNodeIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhFloatData)).m_useQuantization as *const _ as usize },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhFloatData),
            "::",
            stringify!(m_useQuantization)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btQuantizedBvhFloatData)).m_numContiguousLeafNodes as *const _ as usize
        },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhFloatData),
            "::",
            stringify!(m_numContiguousLeafNodes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btQuantizedBvhFloatData)).m_numQuantizedContiguousNodes as *const _
                as usize
        },
        60usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhFloatData),
            "::",
            stringify!(m_numQuantizedContiguousNodes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btQuantizedBvhFloatData)).m_contiguousNodesPtr as *const _ as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhFloatData),
            "::",
            stringify!(m_contiguousNodesPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btQuantizedBvhFloatData)).m_quantizedContiguousNodesPtr as *const _
                as usize
        },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhFloatData),
            "::",
            stringify!(m_quantizedContiguousNodesPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhFloatData)).m_subTreeInfoPtr as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhFloatData),
            "::",
            stringify!(m_subTreeInfoPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhFloatData)).m_traversalMode as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhFloatData),
            "::",
            stringify!(m_traversalMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btQuantizedBvhFloatData)).m_numSubtreeHeaders as *const _ as usize
        },
        92usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhFloatData),
            "::",
            stringify!(m_numSubtreeHeaders)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btQuantizedBvhDoubleData {
    pub m_bvhAabbMin: btVector3DoubleData,
    pub m_bvhAabbMax: btVector3DoubleData,
    pub m_bvhQuantization: btVector3DoubleData,
    pub m_curNodeIndex: ::std::os::raw::c_int,
    pub m_useQuantization: ::std::os::raw::c_int,
    pub m_numContiguousLeafNodes: ::std::os::raw::c_int,
    pub m_numQuantizedContiguousNodes: ::std::os::raw::c_int,
    pub m_contiguousNodesPtr: *mut btOptimizedBvhNodeDoubleData,
    pub m_quantizedContiguousNodesPtr: *mut btQuantizedBvhNodeData,
    pub m_traversalMode: ::std::os::raw::c_int,
    pub m_numSubtreeHeaders: ::std::os::raw::c_int,
    pub m_subTreeInfoPtr: *mut btBvhSubtreeInfoData,
}
#[test]
fn bindgen_test_layout_btQuantizedBvhDoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btQuantizedBvhDoubleData>(),
        144usize,
        concat!("Size of: ", stringify!(btQuantizedBvhDoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btQuantizedBvhDoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btQuantizedBvhDoubleData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhDoubleData)).m_bvhAabbMin as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhDoubleData),
            "::",
            stringify!(m_bvhAabbMin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhDoubleData)).m_bvhAabbMax as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhDoubleData),
            "::",
            stringify!(m_bvhAabbMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btQuantizedBvhDoubleData)).m_bvhQuantization as *const _ as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhDoubleData),
            "::",
            stringify!(m_bvhQuantization)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhDoubleData)).m_curNodeIndex as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhDoubleData),
            "::",
            stringify!(m_curNodeIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btQuantizedBvhDoubleData)).m_useQuantization as *const _ as usize
        },
        100usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhDoubleData),
            "::",
            stringify!(m_useQuantization)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btQuantizedBvhDoubleData)).m_numContiguousLeafNodes as *const _ as usize
        },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhDoubleData),
            "::",
            stringify!(m_numContiguousLeafNodes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btQuantizedBvhDoubleData)).m_numQuantizedContiguousNodes as *const _
                as usize
        },
        108usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhDoubleData),
            "::",
            stringify!(m_numQuantizedContiguousNodes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btQuantizedBvhDoubleData)).m_contiguousNodesPtr as *const _ as usize
        },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhDoubleData),
            "::",
            stringify!(m_contiguousNodesPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btQuantizedBvhDoubleData)).m_quantizedContiguousNodesPtr as *const _
                as usize
        },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhDoubleData),
            "::",
            stringify!(m_quantizedContiguousNodesPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhDoubleData)).m_traversalMode as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhDoubleData),
            "::",
            stringify!(m_traversalMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btQuantizedBvhDoubleData)).m_numSubtreeHeaders as *const _ as usize
        },
        132usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhDoubleData),
            "::",
            stringify!(m_numSubtreeHeaders)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btQuantizedBvhDoubleData)).m_subTreeInfoPtr as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btQuantizedBvhDoubleData),
            "::",
            stringify!(m_subTreeInfoPtr)
        )
    );
}
/// The btOptimizedBvh extends the btQuantizedBvh to create AABB tree for triangle meshes, through the btStridingMeshInterface.
#[repr(C)]
#[derive(Debug)]
pub struct btOptimizedBvh {
    pub _base: btQuantizedBvh,
}
#[test]
fn bindgen_test_layout_btOptimizedBvh() {
    assert_eq!(
        ::std::mem::size_of::<btOptimizedBvh>(),
        296usize,
        concat!("Size of: ", stringify!(btOptimizedBvh))
    );
    assert_eq!(
        ::std::mem::align_of::<btOptimizedBvh>(),
        8usize,
        concat!("Alignment of ", stringify!(btOptimizedBvh))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btOptimizedBvh5buildEP23btStridingMeshInterfacebRK9btVector3S4_"]
    pub fn btOptimizedBvh_build(
        this: *mut btOptimizedBvh,
        triangles: *mut btStridingMeshInterface,
        useQuantizedAabbCompression: bool,
        bvhAabbMin: *const btVector3,
        bvhAabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btOptimizedBvh5refitEP23btStridingMeshInterfaceRK9btVector3S4_"]
    pub fn btOptimizedBvh_refit(
        this: *mut btOptimizedBvh,
        triangles: *mut btStridingMeshInterface,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btOptimizedBvh12refitPartialEP23btStridingMeshInterfaceRK9btVector3S4_"]
    pub fn btOptimizedBvh_refitPartial(
        this: *mut btOptimizedBvh,
        triangles: *mut btStridingMeshInterface,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btOptimizedBvh14updateBvhNodesEP23btStridingMeshInterfaceiii"]
    pub fn btOptimizedBvh_updateBvhNodes(
        this: *mut btOptimizedBvh,
        meshInterface: *mut btStridingMeshInterface,
        firstNode: ::std::os::raw::c_int,
        endNode: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'

    #[link_name = "\u{1}_ZN14btOptimizedBvh18deSerializeInPlaceEPvjb"]
    pub fn btOptimizedBvh_deSerializeInPlace(
        i_alignedDataBuffer: *mut ::std::os::raw::c_void,
        i_dataBufferSize: ::std::os::raw::c_uint,
        i_swapEndian: bool,
    ) -> *mut btOptimizedBvh;
}
extern "C" {
    #[link_name = "\u{1}_ZN14btOptimizedBvhC1Ev"]
    pub fn btOptimizedBvh_btOptimizedBvh(this: *mut btOptimizedBvh);
}
impl btOptimizedBvh {
    #[inline]
    pub unsafe fn build(
        &mut self,
        triangles: *mut btStridingMeshInterface,
        useQuantizedAabbCompression: bool,
        bvhAabbMin: *const btVector3,
        bvhAabbMax: *const btVector3,
    ) {
        btOptimizedBvh_build(
            self,
            triangles,
            useQuantizedAabbCompression,
            bvhAabbMin,
            bvhAabbMax,
        )
    }
    #[inline]
    pub unsafe fn refit(
        &mut self,
        triangles: *mut btStridingMeshInterface,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) {
        btOptimizedBvh_refit(self, triangles, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn refitPartial(
        &mut self,
        triangles: *mut btStridingMeshInterface,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) {
        btOptimizedBvh_refitPartial(self, triangles, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn updateBvhNodes(
        &mut self,
        meshInterface: *mut btStridingMeshInterface,
        firstNode: ::std::os::raw::c_int,
        endNode: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
    ) {
        btOptimizedBvh_updateBvhNodes(self, meshInterface, firstNode, endNode, index)
    }
    #[inline]
    pub unsafe fn deSerializeInPlace(
        i_alignedDataBuffer: *mut ::std::os::raw::c_void,
        i_dataBufferSize: ::std::os::raw::c_uint,
        i_swapEndian: bool,
    ) -> *mut btOptimizedBvh {
        btOptimizedBvh_deSerializeInPlace(i_alignedDataBuffer, i_dataBufferSize, i_swapEndian)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btOptimizedBvh_btOptimizedBvh(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN14btOptimizedBvhD0Ev"]
    pub fn btOptimizedBvh_btOptimizedBvh_destructor(this: *mut btOptimizedBvh);
}
extern "C" {

    /// Data buffer MUST be 16 byte aligned

    #[link_name = "\u{1}_ZNK14btOptimizedBvh16serializeInPlaceEPvjb"]
    pub fn btOptimizedBvh_serializeInPlace(
        this: *mut ::std::os::raw::c_void,
        o_alignedDataBuffer: *mut ::std::os::raw::c_void,
        i_dataBufferSize: ::std::os::raw::c_uint,
        i_swapEndian: bool,
    ) -> bool;
}
/// very basic hashable string implementation, compatible with btHashMap
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHashString {
    pub m_string: *const ::std::os::raw::c_char,
    pub m_hash: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_btHashString() {
    assert_eq!(
        ::std::mem::size_of::<btHashString>(),
        16usize,
        concat!("Size of: ", stringify!(btHashString))
    );
    assert_eq!(
        ::std::mem::align_of::<btHashString>(),
        8usize,
        concat!("Alignment of ", stringify!(btHashString))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHashString)).m_string as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHashString),
            "::",
            stringify!(m_string)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHashString)).m_hash as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHashString),
            "::",
            stringify!(m_hash)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btHashString7getHashEv"]
    pub fn btHashString_getHash(this: *const btHashString) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btHashString21portableStringCompareEPKcS1_"]
    pub fn btHashString_portableStringCompare(
        this: *const btHashString,
        src: *const ::std::os::raw::c_char,
        dst: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btHashString6equalsERKS_"]
    pub fn btHashString_equals(this: *const btHashString, other: *const btHashString) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btHashStringC1EPKc"]
    pub fn btHashString_btHashString(this: *mut btHashString, name: *const ::std::os::raw::c_char);
}
impl btHashString {
    #[inline]
    pub unsafe fn getHash(&self) -> ::std::os::raw::c_uint {
        btHashString_getHash(self)
    }
    #[inline]
    pub unsafe fn portableStringCompare(
        &self,
        src: *const ::std::os::raw::c_char,
        dst: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        btHashString_portableStringCompare(self, src, dst)
    }
    #[inline]
    pub unsafe fn equals(&self, other: *const btHashString) -> bool {
        btHashString_equals(self, other)
    }
    #[inline]
    pub unsafe fn new(name: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHashString_btHashString(&mut __bindgen_tmp, name);
        __bindgen_tmp
    }
}
pub const BT_HASH_NULL: ::std::os::raw::c_int = -1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHashInt {
    pub m_uid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btHashInt() {
    assert_eq!(
        ::std::mem::size_of::<btHashInt>(),
        4usize,
        concat!("Size of: ", stringify!(btHashInt))
    );
    assert_eq!(
        ::std::mem::align_of::<btHashInt>(),
        4usize,
        concat!("Alignment of ", stringify!(btHashInt))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHashInt)).m_uid as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHashInt),
            "::",
            stringify!(m_uid)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btHashInt7getUid1Ev"]
    pub fn btHashInt_getUid1(this: *const btHashInt) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN9btHashInt7setUid1Ei"]
    pub fn btHashInt_setUid1(this: *mut btHashInt, uid: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btHashInt6equalsERKS_"]
    pub fn btHashInt_equals(this: *const btHashInt, other: *const btHashInt) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btHashInt7getHashEv"]
    pub fn btHashInt_getHash(this: *const btHashInt) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_ZN9btHashIntC1Ev"]
    pub fn btHashInt_btHashInt(this: *mut btHashInt);
}
extern "C" {
    #[link_name = "\u{1}_ZN9btHashIntC1Ei"]
    pub fn btHashInt_btHashInt1(this: *mut btHashInt, uid: ::std::os::raw::c_int);
}
impl btHashInt {
    #[inline]
    pub unsafe fn getUid1(&self) -> ::std::os::raw::c_int {
        btHashInt_getUid1(self)
    }
    #[inline]
    pub unsafe fn setUid1(&mut self, uid: ::std::os::raw::c_int) {
        btHashInt_setUid1(self, uid)
    }
    #[inline]
    pub unsafe fn equals(&self, other: *const btHashInt) -> bool {
        btHashInt_equals(self, other)
    }
    #[inline]
    pub unsafe fn getHash(&self) -> ::std::os::raw::c_uint {
        btHashInt_getHash(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHashInt_btHashInt(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(uid: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHashInt_btHashInt1(&mut __bindgen_tmp, uid);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btHashPtr {
    pub __bindgen_anon_1: btHashPtr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btHashPtr__bindgen_ty_1 {
    pub m_pointer: *const ::std::os::raw::c_void,
    pub m_hashValues: [::std::os::raw::c_uint; 2usize],
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_btHashPtr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btHashPtr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(btHashPtr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<btHashPtr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(btHashPtr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHashPtr__bindgen_ty_1)).m_pointer as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHashPtr__bindgen_ty_1),
            "::",
            stringify!(m_pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHashPtr__bindgen_ty_1)).m_hashValues as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHashPtr__bindgen_ty_1),
            "::",
            stringify!(m_hashValues)
        )
    );
}
#[test]
fn bindgen_test_layout_btHashPtr() {
    assert_eq!(
        ::std::mem::size_of::<btHashPtr>(),
        8usize,
        concat!("Size of: ", stringify!(btHashPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<btHashPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(btHashPtr))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btHashPtr10getPointerEv"]
    pub fn btHashPtr_getPointer(this: *const btHashPtr) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btHashPtr6equalsERKS_"]
    pub fn btHashPtr_equals(this: *const btHashPtr, other: *const btHashPtr) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9btHashPtr7getHashEv"]
    pub fn btHashPtr_getHash(this: *const btHashPtr) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_ZN9btHashPtrC1EPKv"]
    pub fn btHashPtr_btHashPtr(this: *mut btHashPtr, ptr: *const ::std::os::raw::c_void);
}
impl btHashPtr {
    #[inline]
    pub unsafe fn getPointer(&self) -> *const ::std::os::raw::c_void {
        btHashPtr_getPointer(self)
    }
    #[inline]
    pub unsafe fn equals(&self, other: *const btHashPtr) -> bool {
        btHashPtr_equals(self, other)
    }
    #[inline]
    pub unsafe fn getHash(&self) -> ::std::os::raw::c_uint {
        btHashPtr_getHash(self)
    }
    #[inline]
    pub unsafe fn new(ptr: *const ::std::os::raw::c_void) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHashPtr_btHashPtr(&mut __bindgen_tmp, ptr);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHashKeyPtr {
    pub m_uid: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHashKey {
    pub m_uid: ::std::os::raw::c_int,
}
/// The btHashMap template class implements a generic and lightweight hashmap.
/// A basic sample of how to use btHashMap is located in Demos\BasicDemo\main.cpp
#[repr(C)]
#[derive(Debug)]
pub struct btHashMap<Key, Value> {
    pub m_hashTable: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_next: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_valueArray: btAlignedObjectArray<Value>,
    pub m_keyArray: btAlignedObjectArray<Key>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Key>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Value>>,
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rawmemchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: __locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: __locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: __locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: __locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: __locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strverscmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfry(__string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memfrob(__s: *mut ::std::os::raw::c_void, __n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn basename(__filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}sBulletDNAstr"]
    pub static mut sBulletDNAstr: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}sBulletDNAlen"]
    pub static mut sBulletDNAlen: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}sBulletDNAstr64"]
    pub static mut sBulletDNAstr64: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}sBulletDNAlen64"]
    pub static mut sBulletDNAlen64: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Z8btStrLenPKc"]
    pub fn btStrLen(str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btChunk {
    pub m_chunkCode: ::std::os::raw::c_int,
    pub m_length: ::std::os::raw::c_int,
    pub m_oldPtr: *mut ::std::os::raw::c_void,
    pub m_dna_nr: ::std::os::raw::c_int,
    pub m_number: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btChunk() {
    assert_eq!(
        ::std::mem::size_of::<btChunk>(),
        24usize,
        concat!("Size of: ", stringify!(btChunk))
    );
    assert_eq!(
        ::std::mem::align_of::<btChunk>(),
        8usize,
        concat!("Alignment of ", stringify!(btChunk))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btChunk)).m_chunkCode as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btChunk),
            "::",
            stringify!(m_chunkCode)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btChunk)).m_length as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(btChunk),
            "::",
            stringify!(m_length)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btChunk)).m_oldPtr as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btChunk),
            "::",
            stringify!(m_oldPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btChunk)).m_dna_nr as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btChunk),
            "::",
            stringify!(m_dna_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btChunk)).m_number as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(btChunk),
            "::",
            stringify!(m_number)
        )
    );
}
pub const btSerializationFlags_BT_SERIALIZE_NO_BVH: btSerializationFlags = 1;
pub const btSerializationFlags_BT_SERIALIZE_NO_TRIANGLEINFOMAP: btSerializationFlags = 2;
pub const btSerializationFlags_BT_SERIALIZE_NO_DUPLICATE_ASSERT: btSerializationFlags = 4;
pub type btSerializationFlags = ::std::os::raw::c_uint;
#[repr(C)]
pub struct btSerializer__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btSerializer {
    pub vtable_: *const btSerializer__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btSerializer() {
    assert_eq!(
        ::std::mem::size_of::<btSerializer>(),
        8usize,
        concat!("Size of: ", stringify!(btSerializer))
    );
    assert_eq!(
        ::std::mem::align_of::<btSerializer>(),
        8usize,
        concat!("Alignment of ", stringify!(btSerializer))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSerializerD0Ev"]
    pub fn btSerializer_btSerializer_destructor(this: *mut btSerializer);
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSerializer16getBufferPointerEv"]
    pub fn btSerializer_getBufferPointer(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSerializer20getCurrentBufferSizeEv"]
    pub fn btSerializer_getCurrentBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSerializer8allocateEmi"]
    pub fn btSerializer_allocate(
        this: *mut ::std::os::raw::c_void,
        size: usize,
        numElements: ::std::os::raw::c_int,
    ) -> *mut btChunk;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSerializer13finalizeChunkEP7btChunkPKciPv"]
    pub fn btSerializer_finalizeChunk(
        this: *mut ::std::os::raw::c_void,
        chunk: *mut btChunk,
        structType: *const ::std::os::raw::c_char,
        chunkCode: ::std::os::raw::c_int,
        oldPtr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSerializer11findPointerEPv"]
    pub fn btSerializer_findPointer(
        this: *mut ::std::os::raw::c_void,
        oldPtr: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSerializer16getUniquePointerEPv"]
    pub fn btSerializer_getUniquePointer(
        this: *mut ::std::os::raw::c_void,
        oldPtr: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSerializer18startSerializationEv"]
    pub fn btSerializer_startSerialization(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSerializer19finishSerializationEv"]
    pub fn btSerializer_finishSerialization(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSerializer18findNameForPointerEPKv"]
    pub fn btSerializer_findNameForPointer(
        this: *mut ::std::os::raw::c_void,
        ptr: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSerializer22registerNameForPointerEPKvPKc"]
    pub fn btSerializer_registerNameForPointer(
        this: *mut ::std::os::raw::c_void,
        ptr: *const ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSerializer13serializeNameEPKc"]
    pub fn btSerializer_serializeName(
        this: *mut ::std::os::raw::c_void,
        ptr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSerializer21getSerializationFlagsEv"]
    pub fn btSerializer_getSerializationFlags(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSerializer21setSerializationFlagsEi"]
    pub fn btSerializer_setSerializationFlags(
        this: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSerializer12getNumChunksEv"]
    pub fn btSerializer_getNumChunks(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSerializer8getChunkEi"]
    pub fn btSerializer_getChunk(
        this: *mut ::std::os::raw::c_void,
        chunkIndex: ::std::os::raw::c_int,
    ) -> *const btChunk;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btPointerUid {
    pub __bindgen_anon_1: btPointerUid__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btPointerUid__bindgen_ty_1 {
    pub m_ptr: *mut ::std::os::raw::c_void,
    pub m_uniqueIds: [::std::os::raw::c_int; 2usize],
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_btPointerUid__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btPointerUid__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(btPointerUid__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<btPointerUid__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(btPointerUid__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPointerUid__bindgen_ty_1)).m_ptr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPointerUid__bindgen_ty_1),
            "::",
            stringify!(m_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPointerUid__bindgen_ty_1)).m_uniqueIds as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPointerUid__bindgen_ty_1),
            "::",
            stringify!(m_uniqueIds)
        )
    );
}
#[test]
fn bindgen_test_layout_btPointerUid() {
    assert_eq!(
        ::std::mem::size_of::<btPointerUid>(),
        8usize,
        concat!("Size of: ", stringify!(btPointerUid))
    );
    assert_eq!(
        ::std::mem::align_of::<btPointerUid>(),
        8usize,
        concat!("Alignment of ", stringify!(btPointerUid))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btBulletSerializedArrays {
    pub m_bvhsDouble: btAlignedObjectArray<*mut btQuantizedBvhDoubleData>,
    pub m_bvhsFloat: btAlignedObjectArray<*mut btQuantizedBvhFloatData>,
    pub m_colShapeData: btAlignedObjectArray<*mut btCollisionShapeData>,
    pub m_dynamicWorldInfoDataDouble: btAlignedObjectArray<*mut btDynamicsWorldDoubleData>,
    pub m_dynamicWorldInfoDataFloat: btAlignedObjectArray<*mut btDynamicsWorldFloatData>,
    pub m_rigidBodyDataDouble: btAlignedObjectArray<*mut btRigidBodyDoubleData>,
    pub m_rigidBodyDataFloat: btAlignedObjectArray<*mut btRigidBodyFloatData>,
    pub m_collisionObjectDataDouble: btAlignedObjectArray<*mut btCollisionObjectDoubleData>,
    pub m_collisionObjectDataFloat: btAlignedObjectArray<*mut btCollisionObjectFloatData>,
    pub m_constraintDataFloat: btAlignedObjectArray<*mut btTypedConstraintFloatData>,
    pub m_constraintDataDouble: btAlignedObjectArray<*mut btTypedConstraintDoubleData>,
    pub m_constraintData: btAlignedObjectArray<*mut btTypedConstraintData>,
    pub m_softBodyFloatData: btAlignedObjectArray<*mut btSoftBodyFloatData>,
    pub m_softBodyDoubleData: btAlignedObjectArray<*mut btSoftBodyDoubleData>,
}
#[test]
fn bindgen_test_layout_btBulletSerializedArrays() {
    assert_eq!(
        ::std::mem::size_of::<btBulletSerializedArrays>(),
        448usize,
        concat!("Size of: ", stringify!(btBulletSerializedArrays))
    );
    assert_eq!(
        ::std::mem::align_of::<btBulletSerializedArrays>(),
        8usize,
        concat!("Alignment of ", stringify!(btBulletSerializedArrays))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBulletSerializedArrays)).m_bvhsDouble as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBulletSerializedArrays),
            "::",
            stringify!(m_bvhsDouble)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBulletSerializedArrays)).m_bvhsFloat as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBulletSerializedArrays),
            "::",
            stringify!(m_bvhsFloat)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBulletSerializedArrays)).m_colShapeData as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBulletSerializedArrays),
            "::",
            stringify!(m_colShapeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btBulletSerializedArrays)).m_dynamicWorldInfoDataDouble as *const _
                as usize
        },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBulletSerializedArrays),
            "::",
            stringify!(m_dynamicWorldInfoDataDouble)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btBulletSerializedArrays)).m_dynamicWorldInfoDataFloat as *const _
                as usize
        },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBulletSerializedArrays),
            "::",
            stringify!(m_dynamicWorldInfoDataFloat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btBulletSerializedArrays)).m_rigidBodyDataDouble as *const _ as usize
        },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBulletSerializedArrays),
            "::",
            stringify!(m_rigidBodyDataDouble)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btBulletSerializedArrays)).m_rigidBodyDataFloat as *const _ as usize
        },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBulletSerializedArrays),
            "::",
            stringify!(m_rigidBodyDataFloat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btBulletSerializedArrays)).m_collisionObjectDataDouble as *const _
                as usize
        },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBulletSerializedArrays),
            "::",
            stringify!(m_collisionObjectDataDouble)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btBulletSerializedArrays)).m_collisionObjectDataFloat as *const _
                as usize
        },
        256usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBulletSerializedArrays),
            "::",
            stringify!(m_collisionObjectDataFloat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btBulletSerializedArrays)).m_constraintDataFloat as *const _ as usize
        },
        288usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBulletSerializedArrays),
            "::",
            stringify!(m_constraintDataFloat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btBulletSerializedArrays)).m_constraintDataDouble as *const _ as usize
        },
        320usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBulletSerializedArrays),
            "::",
            stringify!(m_constraintDataDouble)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBulletSerializedArrays)).m_constraintData as *const _ as usize },
        352usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBulletSerializedArrays),
            "::",
            stringify!(m_constraintData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btBulletSerializedArrays)).m_softBodyFloatData as *const _ as usize
        },
        384usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBulletSerializedArrays),
            "::",
            stringify!(m_softBodyFloatData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btBulletSerializedArrays)).m_softBodyDoubleData as *const _ as usize
        },
        416usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBulletSerializedArrays),
            "::",
            stringify!(m_softBodyDoubleData)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN24btBulletSerializedArraysC1Ev"]
    pub fn btBulletSerializedArrays_btBulletSerializedArrays(this: *mut btBulletSerializedArrays);
}
impl btBulletSerializedArrays {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBulletSerializedArrays_btBulletSerializedArrays(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
/// The btDefaultSerializer is the main Bullet serialization class.
/// The constructor takes an optional argument for backwards compatibility, it is recommended to leave this empty/zero.
#[repr(C)]
pub struct btDefaultSerializer {
    pub _base: btSerializer,
    pub mTypes: btAlignedObjectArray<*mut ::std::os::raw::c_char>,
    pub mStructs: btAlignedObjectArray<*mut ::std::os::raw::c_short>,
    pub mTlens: btAlignedObjectArray<::std::os::raw::c_short>,
    pub mStructReverse: btHashMap<btHashInt, ::std::os::raw::c_int>,
    pub mTypeLookup: btHashMap<btHashString, ::std::os::raw::c_int>,
    pub m_chunkP: btHashMap<btHashPtr, *mut ::std::os::raw::c_void>,
    pub m_nameMap: btHashMap<btHashPtr, *const ::std::os::raw::c_char>,
    pub m_uniquePointers: btHashMap<btHashPtr, btPointerUid>,
    pub m_uniqueIdGenerator: ::std::os::raw::c_int,
    pub m_totalSize: ::std::os::raw::c_int,
    pub m_buffer: *mut ::std::os::raw::c_uchar,
    pub m_ownsBuffer: bool,
    pub m_currentSize: ::std::os::raw::c_int,
    pub m_dna: *mut ::std::os::raw::c_void,
    pub m_dnaLength: ::std::os::raw::c_int,
    pub m_serializationFlags: ::std::os::raw::c_int,
    pub m_chunkPtrs: btAlignedObjectArray<*mut btChunk>,
    pub m_skipPointers: btHashMap<btHashPtr, *mut ::std::os::raw::c_void>,
}
#[test]
fn bindgen_test_layout_btDefaultSerializer() {
    assert_eq!(
        ::std::mem::size_of::<btDefaultSerializer>(),
        944usize,
        concat!("Size of: ", stringify!(btDefaultSerializer))
    );
    assert_eq!(
        ::std::mem::align_of::<btDefaultSerializer>(),
        8usize,
        concat!("Alignment of ", stringify!(btDefaultSerializer))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).mTypes as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(mTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).mStructs as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(mStructs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).mTlens as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(mTlens)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).mStructReverse as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(mStructReverse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).mTypeLookup as *const _ as usize },
        232usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(mTypeLookup)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).m_chunkP as *const _ as usize },
        360usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(m_chunkP)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).m_nameMap as *const _ as usize },
        488usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(m_nameMap)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).m_uniquePointers as *const _ as usize },
        616usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(m_uniquePointers)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).m_uniqueIdGenerator as *const _ as usize },
        744usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(m_uniqueIdGenerator)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).m_totalSize as *const _ as usize },
        748usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(m_totalSize)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).m_buffer as *const _ as usize },
        752usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(m_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).m_ownsBuffer as *const _ as usize },
        760usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(m_ownsBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).m_currentSize as *const _ as usize },
        764usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(m_currentSize)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).m_dna as *const _ as usize },
        768usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(m_dna)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).m_dnaLength as *const _ as usize },
        776usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(m_dnaLength)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).m_serializationFlags as *const _ as usize },
        780usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(m_serializationFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).m_chunkPtrs as *const _ as usize },
        784usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(m_chunkPtrs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultSerializer)).m_skipPointers as *const _ as usize },
        816usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultSerializer),
            "::",
            stringify!(m_skipPointers)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btDefaultSerializer14getReverseTypeEPKc"]
    pub fn btDefaultSerializer_getReverseType(
        this: *const btDefaultSerializer,
        type_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer7initDNAEPKci"]
    pub fn btDefaultSerializer_initDNA(
        this: *mut btDefaultSerializer,
        bdnaOrg: *const ::std::os::raw::c_char,
        dnalen: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer23getMemoryDnaSizeInBytesEv"]
    pub fn btDefaultSerializer_getMemoryDnaSizeInBytes() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer12getMemoryDnaEv"]
    pub fn btDefaultSerializer_getMemoryDna() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer12insertHeaderEv"]
    pub fn btDefaultSerializer_insertHeader(this: *mut btDefaultSerializer);
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btDefaultSerializer11writeHeaderEPh"]
    pub fn btDefaultSerializer_writeHeader(
        this: *const btDefaultSerializer,
        buffer: *mut ::std::os::raw::c_uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializerC1EiPh"]
    pub fn btDefaultSerializer_btDefaultSerializer(
        this: *mut btDefaultSerializer,
        totalSize: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_uchar,
    );
}
impl btDefaultSerializer {
    #[inline]
    pub unsafe fn getReverseType(
        &self,
        type_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        btDefaultSerializer_getReverseType(self, type_)
    }
    #[inline]
    pub unsafe fn initDNA(
        &mut self,
        bdnaOrg: *const ::std::os::raw::c_char,
        dnalen: ::std::os::raw::c_int,
    ) {
        btDefaultSerializer_initDNA(self, bdnaOrg, dnalen)
    }
    #[inline]
    pub unsafe fn getMemoryDnaSizeInBytes() -> ::std::os::raw::c_int {
        btDefaultSerializer_getMemoryDnaSizeInBytes()
    }
    #[inline]
    pub unsafe fn getMemoryDna() -> *const ::std::os::raw::c_char {
        btDefaultSerializer_getMemoryDna()
    }
    #[inline]
    pub unsafe fn insertHeader(&mut self) {
        btDefaultSerializer_insertHeader(self)
    }
    #[inline]
    pub unsafe fn writeHeader(&self, buffer: *mut ::std::os::raw::c_uchar) {
        btDefaultSerializer_writeHeader(self, buffer)
    }
    #[inline]
    pub unsafe fn new(
        totalSize: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_uchar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDefaultSerializer_btDefaultSerializer(&mut __bindgen_tmp, totalSize, buffer);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer11findPointerEPv"]
    pub fn btDefaultSerializer_findPointer(
        this: *mut ::std::os::raw::c_void,
        oldPtr: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer8writeDNAEv"]
    pub fn btDefaultSerializer_writeDNA(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializerD0Ev"]
    pub fn btDefaultSerializer_btDefaultSerializer_destructor(this: *mut btDefaultSerializer);
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer18startSerializationEv"]
    pub fn btDefaultSerializer_startSerialization(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer19finishSerializationEv"]
    pub fn btDefaultSerializer_finishSerialization(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer16getUniquePointerEPv"]
    pub fn btDefaultSerializer_getUniquePointer(
        this: *mut ::std::os::raw::c_void,
        oldPtr: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btDefaultSerializer16getBufferPointerEv"]
    pub fn btDefaultSerializer_getBufferPointer(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btDefaultSerializer20getCurrentBufferSizeEv"]
    pub fn btDefaultSerializer_getCurrentBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer13finalizeChunkEP7btChunkPKciPv"]
    pub fn btDefaultSerializer_finalizeChunk(
        this: *mut ::std::os::raw::c_void,
        chunk: *mut btChunk,
        structType: *const ::std::os::raw::c_char,
        chunkCode: ::std::os::raw::c_int,
        oldPtr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer13internalAllocEm"]
    pub fn btDefaultSerializer_internalAlloc(
        this: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer8allocateEmi"]
    pub fn btDefaultSerializer_allocate(
        this: *mut ::std::os::raw::c_void,
        size: usize,
        numElements: ::std::os::raw::c_int,
    ) -> *mut btChunk;
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btDefaultSerializer18findNameForPointerEPKv"]
    pub fn btDefaultSerializer_findNameForPointer(
        this: *mut ::std::os::raw::c_void,
        ptr: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer22registerNameForPointerEPKvPKc"]
    pub fn btDefaultSerializer_registerNameForPointer(
        this: *mut ::std::os::raw::c_void,
        ptr: *const ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer13serializeNameEPKc"]
    pub fn btDefaultSerializer_serializeName(
        this: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btDefaultSerializer21getSerializationFlagsEv"]
    pub fn btDefaultSerializer_getSerializationFlags(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN19btDefaultSerializer21setSerializationFlagsEi"]
    pub fn btDefaultSerializer_setSerializationFlags(
        this: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btDefaultSerializer12getNumChunksEv"]
    pub fn btDefaultSerializer_getNumChunks(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK19btDefaultSerializer8getChunkEi"]
    pub fn btDefaultSerializer_getChunk(
        this: *mut ::std::os::raw::c_void,
        chunkIndex: ::std::os::raw::c_int,
    ) -> *const btChunk;
}
/// The btTriangleInfo structure stores information to adjust collision normals to avoid collisions against internal edges
/// it can be generated using
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTriangleInfo {
    pub m_flags: ::std::os::raw::c_int,
    pub m_edgeV0V1Angle: btScalar,
    pub m_edgeV1V2Angle: btScalar,
    pub m_edgeV2V0Angle: btScalar,
}
#[test]
fn bindgen_test_layout_btTriangleInfo() {
    assert_eq!(
        ::std::mem::size_of::<btTriangleInfo>(),
        32usize,
        concat!("Size of: ", stringify!(btTriangleInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<btTriangleInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(btTriangleInfo))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfo)).m_flags as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfo),
            "::",
            stringify!(m_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfo)).m_edgeV0V1Angle as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfo),
            "::",
            stringify!(m_edgeV0V1Angle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfo)).m_edgeV1V2Angle as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfo),
            "::",
            stringify!(m_edgeV1V2Angle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfo)).m_edgeV2V0Angle as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfo),
            "::",
            stringify!(m_edgeV2V0Angle)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14btTriangleInfoC1Ev"]
    pub fn btTriangleInfo_btTriangleInfo(this: *mut btTriangleInfo);
}
impl btTriangleInfo {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTriangleInfo_btTriangleInfo(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
pub type btInternalTriangleInfoMap = btHashMap<btHashInt, btTriangleInfo>;
#[repr(C)]
pub struct btTriangleInfoMap__bindgen_vtable(::std::os::raw::c_void);
/// The btTriangleInfoMap stores edge angle information for some triangles. You can compute this information yourself or using btGenerateInternalEdgeInfo.
#[repr(C)]
#[derive(Debug)]
pub struct btTriangleInfoMap {
    pub vtable_: *const btTriangleInfoMap__bindgen_vtable,
    pub _base: btInternalTriangleInfoMap,
    pub m_convexEpsilon: btScalar,
    /// used to determine if an edge or contact normal is convex, using the dot product
    pub m_planarEpsilon: btScalar,
    /// used to determine if a triangle edge is planar with zero angle
    pub m_equalVertexThreshold: btScalar,
    /// used to compute connectivity: if the distance between two vertices is smaller than m_equalVertexThreshold, they are considered to be 'shared'
    pub m_edgeDistanceThreshold: btScalar,
    /// used to determine edge contacts: if the closest distance between a contact point and an edge is smaller than this distance threshold it is considered to "hit the edge"
    pub m_maxEdgeAngleThreshold: btScalar,
    pub m_zeroAreaThreshold: btScalar,
}
#[test]
fn bindgen_test_layout_btTriangleInfoMap() {
    assert_eq!(
        ::std::mem::size_of::<btTriangleInfoMap>(),
        184usize,
        concat!("Size of: ", stringify!(btTriangleInfoMap))
    );
    assert_eq!(
        ::std::mem::align_of::<btTriangleInfoMap>(),
        8usize,
        concat!("Alignment of ", stringify!(btTriangleInfoMap))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMap)).m_convexEpsilon as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMap),
            "::",
            stringify!(m_convexEpsilon)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMap)).m_planarEpsilon as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMap),
            "::",
            stringify!(m_planarEpsilon)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMap)).m_equalVertexThreshold as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMap),
            "::",
            stringify!(m_equalVertexThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMap)).m_edgeDistanceThreshold as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMap),
            "::",
            stringify!(m_edgeDistanceThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMap)).m_maxEdgeAngleThreshold as *const _ as usize },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMap),
            "::",
            stringify!(m_maxEdgeAngleThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMap)).m_zeroAreaThreshold as *const _ as usize },
        176usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMap),
            "::",
            stringify!(m_zeroAreaThreshold)
        )
    );
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZN17btTriangleInfoMap11deSerializeER21btTriangleInfoMapData"]
    pub fn btTriangleInfoMap_deSerialize(
        this: *mut btTriangleInfoMap,
        data: *mut btTriangleInfoMapData,
    );
}
extern "C" {

    /// used to determine if a triangle is degenerate (length squared of cross product of 2 triangle edges < threshold)

    #[link_name = "\u{1}_ZN17btTriangleInfoMapC1Ev"]
    pub fn btTriangleInfoMap_btTriangleInfoMap(this: *mut btTriangleInfoMap);
}
impl btTriangleInfoMap {
    #[inline]
    pub unsafe fn deSerialize(&mut self, data: *mut btTriangleInfoMapData) {
        btTriangleInfoMap_deSerialize(self, data)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTriangleInfoMap_btTriangleInfoMap(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTriangleInfoMapD0Ev"]
    pub fn btTriangleInfoMap_btTriangleInfoMap_destructor(this: *mut btTriangleInfoMap);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btTriangleInfoMap28calculateSerializeBufferSizeEv"]
    pub fn btTriangleInfoMap_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK17btTriangleInfoMap9serializeEPvP12btSerializer"]
    pub fn btTriangleInfoMap_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// those fields have to be float and not btScalar for the serialization to work properly
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTriangleInfoData {
    pub m_flags: ::std::os::raw::c_int,
    pub m_edgeV0V1Angle: f32,
    pub m_edgeV1V2Angle: f32,
    pub m_edgeV2V0Angle: f32,
}
#[test]
fn bindgen_test_layout_btTriangleInfoData() {
    assert_eq!(
        ::std::mem::size_of::<btTriangleInfoData>(),
        16usize,
        concat!("Size of: ", stringify!(btTriangleInfoData))
    );
    assert_eq!(
        ::std::mem::align_of::<btTriangleInfoData>(),
        4usize,
        concat!("Alignment of ", stringify!(btTriangleInfoData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoData)).m_flags as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoData),
            "::",
            stringify!(m_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoData)).m_edgeV0V1Angle as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoData),
            "::",
            stringify!(m_edgeV0V1Angle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoData)).m_edgeV1V2Angle as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoData),
            "::",
            stringify!(m_edgeV1V2Angle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoData)).m_edgeV2V0Angle as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoData),
            "::",
            stringify!(m_edgeV2V0Angle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTriangleInfoMapData {
    pub m_hashTablePtr: *mut ::std::os::raw::c_int,
    pub m_nextPtr: *mut ::std::os::raw::c_int,
    pub m_valueArrayPtr: *mut btTriangleInfoData,
    pub m_keyArrayPtr: *mut ::std::os::raw::c_int,
    pub m_convexEpsilon: f32,
    pub m_planarEpsilon: f32,
    pub m_equalVertexThreshold: f32,
    pub m_edgeDistanceThreshold: f32,
    pub m_zeroAreaThreshold: f32,
    pub m_nextSize: ::std::os::raw::c_int,
    pub m_hashTableSize: ::std::os::raw::c_int,
    pub m_numValues: ::std::os::raw::c_int,
    pub m_numKeys: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btTriangleInfoMapData() {
    assert_eq!(
        ::std::mem::size_of::<btTriangleInfoMapData>(),
        72usize,
        concat!("Size of: ", stringify!(btTriangleInfoMapData))
    );
    assert_eq!(
        ::std::mem::align_of::<btTriangleInfoMapData>(),
        8usize,
        concat!("Alignment of ", stringify!(btTriangleInfoMapData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMapData)).m_hashTablePtr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMapData),
            "::",
            stringify!(m_hashTablePtr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMapData)).m_nextPtr as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMapData),
            "::",
            stringify!(m_nextPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMapData)).m_valueArrayPtr as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMapData),
            "::",
            stringify!(m_valueArrayPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMapData)).m_keyArrayPtr as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMapData),
            "::",
            stringify!(m_keyArrayPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMapData)).m_convexEpsilon as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMapData),
            "::",
            stringify!(m_convexEpsilon)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMapData)).m_planarEpsilon as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMapData),
            "::",
            stringify!(m_planarEpsilon)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTriangleInfoMapData)).m_equalVertexThreshold as *const _ as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMapData),
            "::",
            stringify!(m_equalVertexThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTriangleInfoMapData)).m_edgeDistanceThreshold as *const _ as usize
        },
        44usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMapData),
            "::",
            stringify!(m_edgeDistanceThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMapData)).m_zeroAreaThreshold as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMapData),
            "::",
            stringify!(m_zeroAreaThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMapData)).m_nextSize as *const _ as usize },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMapData),
            "::",
            stringify!(m_nextSize)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMapData)).m_hashTableSize as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMapData),
            "::",
            stringify!(m_hashTableSize)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMapData)).m_numValues as *const _ as usize },
        60usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMapData),
            "::",
            stringify!(m_numValues)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMapData)).m_numKeys as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMapData),
            "::",
            stringify!(m_numKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleInfoMapData)).m_padding as *const _ as usize },
        68usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleInfoMapData),
            "::",
            stringify!(m_padding)
        )
    );
}
/// The btBvhTriangleMeshShape is a static-triangle mesh shape, it can only be used for fixed/non-moving objects.
/// If you required moving concave triangle meshes, it is recommended to perform convex decomposition
/// using HACD, see Bullet/Demos/ConvexDecompositionDemo.
/// Alternatively, you can use btGimpactMeshShape for moving concave triangle meshes.
/// btBvhTriangleMeshShape has several optimizations, such as bounding volume hierarchy and
/// cache friendly traversal for PlayStation 3 Cell SPU.
/// It is recommended to enable useQuantizedAabbCompression for better memory usage.
/// It takes a triangle mesh as input, for example a btTriangleMesh or btTriangleIndexVertexArray. The btBvhTriangleMeshShape class allows for triangle mesh deformations by a refit or partialRefit method.
/// Instead of building the bounding volume hierarchy acceleration structure, it is also possible to serialize (save) and deserialize (load) the structure from disk.
/// See Demos\ConcaveDemo\ConcavePhysicsDemo.cpp for an example.
#[repr(C)]
#[derive(Debug)]
pub struct btBvhTriangleMeshShape {
    pub _base: btTriangleMeshShape,
    pub m_bvh: *mut btOptimizedBvh,
    pub m_triangleInfoMap: *mut btTriangleInfoMap,
    pub m_useQuantizedAabbCompression: bool,
    pub m_ownsBvh: bool,
    pub m_pad: [bool; 11usize],
}
#[test]
fn bindgen_test_layout_btBvhTriangleMeshShape() {
    assert_eq!(
        ::std::mem::size_of::<btBvhTriangleMeshShape>(),
        144usize,
        concat!("Size of: ", stringify!(btBvhTriangleMeshShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btBvhTriangleMeshShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btBvhTriangleMeshShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBvhTriangleMeshShape)).m_bvh as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBvhTriangleMeshShape),
            "::",
            stringify!(m_bvh)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBvhTriangleMeshShape)).m_triangleInfoMap as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBvhTriangleMeshShape),
            "::",
            stringify!(m_triangleInfoMap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btBvhTriangleMeshShape)).m_useQuantizedAabbCompression as *const _
                as usize
        },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBvhTriangleMeshShape),
            "::",
            stringify!(m_useQuantizedAabbCompression)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBvhTriangleMeshShape)).m_ownsBvh as *const _ as usize },
        129usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBvhTriangleMeshShape),
            "::",
            stringify!(m_ownsBvh)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBvhTriangleMeshShape)).m_pad as *const _ as usize },
        130usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBvhTriangleMeshShape),
            "::",
            stringify!(m_pad)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK22btBvhTriangleMeshShape10getOwnsBvhEv"]
    pub fn btBvhTriangleMeshShape_getOwnsBvh(this: *const btBvhTriangleMeshShape) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape14performRaycastEP18btTriangleCallbackRK9btVector3S4_"]
    pub fn btBvhTriangleMeshShape_performRaycast(
        this: *mut btBvhTriangleMeshShape,
        callback: *mut btTriangleCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape17performConvexcastEP18btTriangleCallbackRK9btVector3S4_S4_S4_"]
    pub fn btBvhTriangleMeshShape_performConvexcast(
        this: *mut btBvhTriangleMeshShape,
        callback: *mut btTriangleCallback,
        boxSource: *const btVector3,
        boxTarget: *const btVector3,
        boxMin: *const btVector3,
        boxMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape9refitTreeERK9btVector3S2_"]
    pub fn btBvhTriangleMeshShape_refitTree(
        this: *mut btBvhTriangleMeshShape,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {

    /// for a fast incremental refit of parts of the tree. Note: the entire AABB of the tree will become more conservative, it never shrinks

    #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape16partialRefitTreeERK9btVector3S2_"]
    pub fn btBvhTriangleMeshShape_partialRefitTree(
        this: *mut btBvhTriangleMeshShape,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape15getOptimizedBvhEv"]
    pub fn btBvhTriangleMeshShape_getOptimizedBvh(
        this: *mut btBvhTriangleMeshShape,
    ) -> *mut btOptimizedBvh;
}
extern "C" {
    #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape15setOptimizedBvhEP14btOptimizedBvhRK9btVector3"]
    pub fn btBvhTriangleMeshShape_setOptimizedBvh(
        this: *mut btBvhTriangleMeshShape,
        bvh: *mut btOptimizedBvh,
        localScaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape17buildOptimizedBvhEv"]
    pub fn btBvhTriangleMeshShape_buildOptimizedBvh(this: *mut btBvhTriangleMeshShape);
}
extern "C" {
    #[link_name = "\u{1}_ZNK22btBvhTriangleMeshShape28usesQuantizedAabbCompressionEv"]
    pub fn btBvhTriangleMeshShape_usesQuantizedAabbCompression(
        this: *const btBvhTriangleMeshShape,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape18setTriangleInfoMapEP17btTriangleInfoMap"]
    pub fn btBvhTriangleMeshShape_setTriangleInfoMap(
        this: *mut btBvhTriangleMeshShape,
        triangleInfoMap: *mut btTriangleInfoMap,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK22btBvhTriangleMeshShape18getTriangleInfoMapEv"]
    pub fn btBvhTriangleMeshShape_getTriangleInfoMap(
        this: *const btBvhTriangleMeshShape,
    ) -> *const btTriangleInfoMap;
}
extern "C" {
    #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape18getTriangleInfoMapEv"]
    pub fn btBvhTriangleMeshShape_getTriangleInfoMap1(
        this: *mut btBvhTriangleMeshShape,
    ) -> *mut btTriangleInfoMap;
}
extern "C" {
    #[link_name = "\u{1}_ZN22btBvhTriangleMeshShapeC1EP23btStridingMeshInterfacebb"]
    pub fn btBvhTriangleMeshShape_btBvhTriangleMeshShape(
        this: *mut btBvhTriangleMeshShape,
        meshInterface: *mut btStridingMeshInterface,
        useQuantizedAabbCompression: bool,
        buildBvh: bool,
    );
}
extern "C" {

    /// optionally pass in a larger bvh aabb, used for quantization. This allows for deformations within this aabb

    #[link_name = "\u{1}_ZN22btBvhTriangleMeshShapeC1EP23btStridingMeshInterfacebRK9btVector3S4_b"]
    pub fn btBvhTriangleMeshShape_btBvhTriangleMeshShape1(
        this: *mut btBvhTriangleMeshShape,
        meshInterface: *mut btStridingMeshInterface,
        useQuantizedAabbCompression: bool,
        bvhAabbMin: *const btVector3,
        bvhAabbMax: *const btVector3,
        buildBvh: bool,
    );
}
impl btBvhTriangleMeshShape {
    #[inline]
    pub unsafe fn getOwnsBvh(&self) -> bool {
        btBvhTriangleMeshShape_getOwnsBvh(self)
    }
    #[inline]
    pub unsafe fn performRaycast(
        &mut self,
        callback: *mut btTriangleCallback,
        raySource: *const btVector3,
        rayTarget: *const btVector3,
    ) {
        btBvhTriangleMeshShape_performRaycast(self, callback, raySource, rayTarget)
    }
    #[inline]
    pub unsafe fn performConvexcast(
        &mut self,
        callback: *mut btTriangleCallback,
        boxSource: *const btVector3,
        boxTarget: *const btVector3,
        boxMin: *const btVector3,
        boxMax: *const btVector3,
    ) {
        btBvhTriangleMeshShape_performConvexcast(
            self,
            callback,
            boxSource,
            boxTarget,
            boxMin,
            boxMax,
        )
    }
    #[inline]
    pub unsafe fn refitTree(&mut self, aabbMin: *const btVector3, aabbMax: *const btVector3) {
        btBvhTriangleMeshShape_refitTree(self, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn partialRefitTree(
        &mut self,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    ) {
        btBvhTriangleMeshShape_partialRefitTree(self, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn getOptimizedBvh(&mut self) -> *mut btOptimizedBvh {
        btBvhTriangleMeshShape_getOptimizedBvh(self)
    }
    #[inline]
    pub unsafe fn setOptimizedBvh(
        &mut self,
        bvh: *mut btOptimizedBvh,
        localScaling: *const btVector3,
    ) {
        btBvhTriangleMeshShape_setOptimizedBvh(self, bvh, localScaling)
    }
    #[inline]
    pub unsafe fn buildOptimizedBvh(&mut self) {
        btBvhTriangleMeshShape_buildOptimizedBvh(self)
    }
    #[inline]
    pub unsafe fn usesQuantizedAabbCompression(&self) -> bool {
        btBvhTriangleMeshShape_usesQuantizedAabbCompression(self)
    }
    #[inline]
    pub unsafe fn setTriangleInfoMap(&mut self, triangleInfoMap: *mut btTriangleInfoMap) {
        btBvhTriangleMeshShape_setTriangleInfoMap(self, triangleInfoMap)
    }
    #[inline]
    pub unsafe fn getTriangleInfoMap(&self) -> *const btTriangleInfoMap {
        btBvhTriangleMeshShape_getTriangleInfoMap(self)
    }
    #[inline]
    pub unsafe fn getTriangleInfoMap1(&mut self) -> *mut btTriangleInfoMap {
        btBvhTriangleMeshShape_getTriangleInfoMap1(self)
    }
    #[inline]
    pub unsafe fn new(
        meshInterface: *mut btStridingMeshInterface,
        useQuantizedAabbCompression: bool,
        buildBvh: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBvhTriangleMeshShape_btBvhTriangleMeshShape(
            &mut __bindgen_tmp,
            meshInterface,
            useQuantizedAabbCompression,
            buildBvh,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        meshInterface: *mut btStridingMeshInterface,
        useQuantizedAabbCompression: bool,
        bvhAabbMin: *const btVector3,
        bvhAabbMax: *const btVector3,
        buildBvh: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBvhTriangleMeshShape_btBvhTriangleMeshShape1(
            &mut __bindgen_tmp,
            meshInterface,
            useQuantizedAabbCompression,
            bvhAabbMin,
            bvhAabbMax,
            buildBvh,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN22btBvhTriangleMeshShapeD0Ev"]
    pub fn btBvhTriangleMeshShape_btBvhTriangleMeshShape_destructor(
        this: *mut btBvhTriangleMeshShape,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK22btBvhTriangleMeshShape19processAllTrianglesEP18btTriangleCallbackRK9btVector3S4_"]
    pub fn btBvhTriangleMeshShape_processAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK22btBvhTriangleMeshShape7getNameEv"]
    pub fn btBvhTriangleMeshShape_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN22btBvhTriangleMeshShape15setLocalScalingERK9btVector3"]
    pub fn btBvhTriangleMeshShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK22btBvhTriangleMeshShape28calculateSerializeBufferSizeEv"]
    pub fn btBvhTriangleMeshShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK22btBvhTriangleMeshShape9serializeEPvP12btSerializer"]
    pub fn btBvhTriangleMeshShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK22btBvhTriangleMeshShape18serializeSingleBvhEP12btSerializer"]
    pub fn btBvhTriangleMeshShape_serializeSingleBvh(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK22btBvhTriangleMeshShape30serializeSingleTriangleInfoMapEP12btSerializer"]
    pub fn btBvhTriangleMeshShape_serializeSingleTriangleInfoMap(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTriangleMeshShapeData {
    pub m_collisionShapeData: btCollisionShapeData,
    pub m_meshInterface: btStridingMeshInterfaceData,
    pub m_quantizedFloatBvh: *mut btQuantizedBvhFloatData,
    pub m_quantizedDoubleBvh: *mut btQuantizedBvhDoubleData,
    pub m_triangleInfoMap: *mut btTriangleInfoMapData,
    pub m_collisionMargin: f32,
    pub m_pad3: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btTriangleMeshShapeData() {
    assert_eq!(
        ::std::mem::size_of::<btTriangleMeshShapeData>(),
        80usize,
        concat!("Size of: ", stringify!(btTriangleMeshShapeData))
    );
    assert_eq!(
        ::std::mem::align_of::<btTriangleMeshShapeData>(),
        8usize,
        concat!("Alignment of ", stringify!(btTriangleMeshShapeData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTriangleMeshShapeData)).m_collisionShapeData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMeshShapeData),
            "::",
            stringify!(m_collisionShapeData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleMeshShapeData)).m_meshInterface as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMeshShapeData),
            "::",
            stringify!(m_meshInterface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTriangleMeshShapeData)).m_quantizedFloatBvh as *const _ as usize
        },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMeshShapeData),
            "::",
            stringify!(m_quantizedFloatBvh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTriangleMeshShapeData)).m_quantizedDoubleBvh as *const _ as usize
        },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMeshShapeData),
            "::",
            stringify!(m_quantizedDoubleBvh)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleMeshShapeData)).m_triangleInfoMap as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMeshShapeData),
            "::",
            stringify!(m_triangleInfoMap)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleMeshShapeData)).m_collisionMargin as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMeshShapeData),
            "::",
            stringify!(m_collisionMargin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTriangleMeshShapeData)).m_pad3 as *const _ as usize },
        76usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTriangleMeshShapeData),
            "::",
            stringify!(m_pad3)
        )
    );
}
/// The btScaledBvhTriangleMeshShape allows to instance a scaled version of an existing btBvhTriangleMeshShape.
/// Note that each btBvhTriangleMeshShape still can have its own local scaling, independent from this btScaledBvhTriangleMeshShape 'localScaling'
#[repr(C)]
#[derive(Debug)]
pub struct btScaledBvhTriangleMeshShape {
    pub _base: btConcaveShape,
    pub m_localScaling: btVector3,
    pub m_bvhTriMeshShape: *mut btBvhTriangleMeshShape,
}
#[test]
fn bindgen_test_layout_btScaledBvhTriangleMeshShape() {
    assert_eq!(
        ::std::mem::size_of::<btScaledBvhTriangleMeshShape>(),
        80usize,
        concat!("Size of: ", stringify!(btScaledBvhTriangleMeshShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btScaledBvhTriangleMeshShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btScaledBvhTriangleMeshShape))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btScaledBvhTriangleMeshShape)).m_localScaling as *const _ as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btScaledBvhTriangleMeshShape),
            "::",
            stringify!(m_localScaling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btScaledBvhTriangleMeshShape)).m_bvhTriMeshShape as *const _ as usize
        },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btScaledBvhTriangleMeshShape),
            "::",
            stringify!(m_bvhTriMeshShape)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28btScaledBvhTriangleMeshShape13getChildShapeEv"]
    pub fn btScaledBvhTriangleMeshShape_getChildShape(
        this: *mut btScaledBvhTriangleMeshShape,
    ) -> *mut btBvhTriangleMeshShape;
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btScaledBvhTriangleMeshShape13getChildShapeEv"]
    pub fn btScaledBvhTriangleMeshShape_getChildShape1(
        this: *const btScaledBvhTriangleMeshShape,
    ) -> *const btBvhTriangleMeshShape;
}
extern "C" {
    #[link_name = "\u{1}_ZN28btScaledBvhTriangleMeshShapeC1EP22btBvhTriangleMeshShapeRK9btVector3"]
    pub fn btScaledBvhTriangleMeshShape_btScaledBvhTriangleMeshShape(
        this: *mut btScaledBvhTriangleMeshShape,
        childShape: *mut btBvhTriangleMeshShape,
        localScaling: *const btVector3,
    );
}
impl btScaledBvhTriangleMeshShape {
    #[inline]
    pub unsafe fn getChildShape(&mut self) -> *mut btBvhTriangleMeshShape {
        btScaledBvhTriangleMeshShape_getChildShape(self)
    }
    #[inline]
    pub unsafe fn getChildShape1(&self) -> *const btBvhTriangleMeshShape {
        btScaledBvhTriangleMeshShape_getChildShape1(self)
    }
    #[inline]
    pub unsafe fn new(
        childShape: *mut btBvhTriangleMeshShape,
        localScaling: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btScaledBvhTriangleMeshShape_btScaledBvhTriangleMeshShape(
            &mut __bindgen_tmp,
            childShape,
            localScaling,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN28btScaledBvhTriangleMeshShapeD0Ev"]
    pub fn btScaledBvhTriangleMeshShape_btScaledBvhTriangleMeshShape_destructor(
        this: *mut btScaledBvhTriangleMeshShape,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btScaledBvhTriangleMeshShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btScaledBvhTriangleMeshShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN28btScaledBvhTriangleMeshShape15setLocalScalingERK9btVector3"]
    pub fn btScaledBvhTriangleMeshShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btScaledBvhTriangleMeshShape15getLocalScalingEv"]
    pub fn btScaledBvhTriangleMeshShape_getLocalScaling(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btScaledBvhTriangleMeshShape21calculateLocalInertiaEdR9btVector3"]
    pub fn btScaledBvhTriangleMeshShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btScaledBvhTriangleMeshShape19processAllTrianglesEP18btTriangleCallbackRK9btVector3S4_"]
    pub fn btScaledBvhTriangleMeshShape_processAllTriangles(
        this: *mut ::std::os::raw::c_void,
        callback: *mut btTriangleCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btScaledBvhTriangleMeshShape7getNameEv"]
    pub fn btScaledBvhTriangleMeshShape_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK28btScaledBvhTriangleMeshShape28calculateSerializeBufferSizeEv"]
    pub fn btScaledBvhTriangleMeshShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK28btScaledBvhTriangleMeshShape9serializeEPvP12btSerializer"]
    pub fn btScaledBvhTriangleMeshShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btScaledTriangleMeshShapeData {
    pub m_trimeshShapeData: btTriangleMeshShapeData,
    pub m_localScaling: btVector3FloatData,
}
#[test]
fn bindgen_test_layout_btScaledTriangleMeshShapeData() {
    assert_eq!(
        ::std::mem::size_of::<btScaledTriangleMeshShapeData>(),
        96usize,
        concat!("Size of: ", stringify!(btScaledTriangleMeshShapeData))
    );
    assert_eq!(
        ::std::mem::align_of::<btScaledTriangleMeshShapeData>(),
        8usize,
        concat!("Alignment of ", stringify!(btScaledTriangleMeshShapeData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btScaledTriangleMeshShapeData)).m_trimeshShapeData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btScaledTriangleMeshShapeData),
            "::",
            stringify!(m_trimeshShapeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btScaledTriangleMeshShapeData)).m_localScaling as *const _ as usize
        },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btScaledTriangleMeshShapeData),
            "::",
            stringify!(m_localScaling)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCompoundShapeChild {
    pub m_transform: btTransform,
    pub m_childShape: *mut btCollisionShape,
    pub m_childShapeType: ::std::os::raw::c_int,
    pub m_childMargin: btScalar,
    pub m_node: *mut btDbvtNode,
}
#[test]
fn bindgen_test_layout_btCompoundShapeChild() {
    assert_eq!(
        ::std::mem::size_of::<btCompoundShapeChild>(),
        160usize,
        concat!("Size of: ", stringify!(btCompoundShapeChild))
    );
    assert_eq!(
        ::std::mem::align_of::<btCompoundShapeChild>(),
        8usize,
        concat!("Alignment of ", stringify!(btCompoundShapeChild))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShapeChild)).m_transform as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShapeChild),
            "::",
            stringify!(m_transform)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShapeChild)).m_childShape as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShapeChild),
            "::",
            stringify!(m_childShape)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShapeChild)).m_childShapeType as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShapeChild),
            "::",
            stringify!(m_childShapeType)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShapeChild)).m_childMargin as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShapeChild),
            "::",
            stringify!(m_childMargin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShapeChild)).m_node as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShapeChild),
            "::",
            stringify!(m_node)
        )
    );
}
/// The btCompoundShape allows to store multiple other btCollisionShapes
/// This allows for moving concave collision objects. This is more general then the static concave btBvhTriangleMeshShape.
/// It has an (optional) dynamic aabb tree to accelerate early rejection tests.
/// @todo: This aabb tree can also be use to speed up ray tests on btCompoundShape, see http://code.google.com/p/bullet/issues/detail?id=25
/// Currently, removal of child shapes is only supported when disabling the aabb tree (pass 'false' in the constructor of btCompoundShape)
#[repr(C)]
#[derive(Debug)]
pub struct btCompoundShape {
    pub _base: btCollisionShape,
    pub m_children: btAlignedObjectArray<btCompoundShapeChild>,
    pub m_localAabbMin: btVector3,
    pub m_localAabbMax: btVector3,
    pub m_dynamicAabbTree: *mut btDbvt,
    /// increment m_updateRevision when adding/removing/replacing child shapes, so that some caches can be updated
    pub m_updateRevision: ::std::os::raw::c_int,
    pub m_collisionMargin: btScalar,
    pub m_localScaling: btVector3,
}
#[test]
fn bindgen_test_layout_btCompoundShape() {
    assert_eq!(
        ::std::mem::size_of::<btCompoundShape>(),
        184usize,
        concat!("Size of: ", stringify!(btCompoundShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btCompoundShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btCompoundShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShape)).m_children as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShape),
            "::",
            stringify!(m_children)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShape)).m_localAabbMin as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShape),
            "::",
            stringify!(m_localAabbMin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShape)).m_localAabbMax as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShape),
            "::",
            stringify!(m_localAabbMax)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShape)).m_dynamicAabbTree as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShape),
            "::",
            stringify!(m_dynamicAabbTree)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShape)).m_updateRevision as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShape),
            "::",
            stringify!(m_updateRevision)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShape)).m_collisionMargin as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShape),
            "::",
            stringify!(m_collisionMargin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShape)).m_localScaling as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShape),
            "::",
            stringify!(m_localScaling)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCompoundShape13addChildShapeERK11btTransformP16btCollisionShape"]
    pub fn btCompoundShape_addChildShape(
        this: *mut btCompoundShape,
        localTransform: *const btTransform,
        shape: *mut btCollisionShape,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCompoundShape23removeChildShapeByIndexEi"]
    pub fn btCompoundShape_removeChildShapeByIndex(
        this: *mut btCompoundShape,
        childShapeindex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCompoundShape17getNumChildShapesEv"]
    pub fn btCompoundShape_getNumChildShapes(this: *const btCompoundShape)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCompoundShape13getChildShapeEi"]
    pub fn btCompoundShape_getChildShape(
        this: *mut btCompoundShape,
        index: ::std::os::raw::c_int,
    ) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCompoundShape13getChildShapeEi"]
    pub fn btCompoundShape_getChildShape1(
        this: *const btCompoundShape,
        index: ::std::os::raw::c_int,
    ) -> *const btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCompoundShape17getChildTransformEi"]
    pub fn btCompoundShape_getChildTransform(
        this: *mut btCompoundShape,
        index: ::std::os::raw::c_int,
    ) -> *mut btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCompoundShape17getChildTransformEi"]
    pub fn btCompoundShape_getChildTransform1(
        this: *const btCompoundShape,
        index: ::std::os::raw::c_int,
    ) -> *const btTransform;
}
extern "C" {

    /// set a new transform for a child, and update internal data structures (local aabb and dynamic tree)

    #[link_name = "\u{1}_ZN15btCompoundShape20updateChildTransformEiRK11btTransformb"]
    pub fn btCompoundShape_updateChildTransform(
        this: *mut btCompoundShape,
        childIndex: ::std::os::raw::c_int,
        newChildTransform: *const btTransform,
        shouldRecalculateLocalAabb: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCompoundShape12getChildListEv"]
    pub fn btCompoundShape_getChildList(this: *mut btCompoundShape) -> *mut btCompoundShapeChild;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCompoundShape18getDynamicAabbTreeEv"]
    pub fn btCompoundShape_getDynamicAabbTree(this: *const btCompoundShape) -> *const btDbvt;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCompoundShape18getDynamicAabbTreeEv"]
    pub fn btCompoundShape_getDynamicAabbTree1(this: *mut btCompoundShape) -> *mut btDbvt;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCompoundShape26createAabbTreeFromChildrenEv"]
    pub fn btCompoundShape_createAabbTreeFromChildren(this: *mut btCompoundShape);
}
extern "C" {

    /// computes the exact moment of inertia and the transform from the coordinate system defined by the principal axes of the moment of inertia
    /// ///and the center of mass to the current coordinate system. "masses" points to an array of masses of the children. The resulting transform
    /// ///"principal" has to be applied inversely to all children transforms in order for the local coordinate system of the compound
    /// ///shape to be centered at the center of mass and to coincide with the principal axes. This also necessitates a correction of the world transform
    /// ///of the collision object by the principal transform.

    #[link_name = "\u{1}_ZNK15btCompoundShape31calculatePrincipalAxisTransformEPdR11btTransformR9btVector3"]
    pub fn btCompoundShape_calculatePrincipalAxisTransform(
        this: *const btCompoundShape,
        masses: *mut btScalar,
        principal: *mut btTransform,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCompoundShape17getUpdateRevisionEv"]
    pub fn btCompoundShape_getUpdateRevision(this: *const btCompoundShape)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCompoundShapeC1Ebi"]
    pub fn btCompoundShape_btCompoundShape(
        this: *mut btCompoundShape,
        enableDynamicAabbTree: bool,
        initialChildCapacity: ::std::os::raw::c_int,
    );
}
impl btCompoundShape {
    #[inline]
    pub unsafe fn addChildShape(
        &mut self,
        localTransform: *const btTransform,
        shape: *mut btCollisionShape,
    ) {
        btCompoundShape_addChildShape(self, localTransform, shape)
    }
    #[inline]
    pub unsafe fn removeChildShapeByIndex(&mut self, childShapeindex: ::std::os::raw::c_int) {
        btCompoundShape_removeChildShapeByIndex(self, childShapeindex)
    }
    #[inline]
    pub unsafe fn getNumChildShapes(&self) -> ::std::os::raw::c_int {
        btCompoundShape_getNumChildShapes(self)
    }
    #[inline]
    pub unsafe fn getChildShape(&mut self, index: ::std::os::raw::c_int) -> *mut btCollisionShape {
        btCompoundShape_getChildShape(self, index)
    }
    #[inline]
    pub unsafe fn getChildShape1(&self, index: ::std::os::raw::c_int) -> *const btCollisionShape {
        btCompoundShape_getChildShape1(self, index)
    }
    #[inline]
    pub unsafe fn getChildTransform(&mut self, index: ::std::os::raw::c_int) -> *mut btTransform {
        btCompoundShape_getChildTransform(self, index)
    }
    #[inline]
    pub unsafe fn getChildTransform1(&self, index: ::std::os::raw::c_int) -> *const btTransform {
        btCompoundShape_getChildTransform1(self, index)
    }
    #[inline]
    pub unsafe fn updateChildTransform(
        &mut self,
        childIndex: ::std::os::raw::c_int,
        newChildTransform: *const btTransform,
        shouldRecalculateLocalAabb: bool,
    ) {
        btCompoundShape_updateChildTransform(
            self,
            childIndex,
            newChildTransform,
            shouldRecalculateLocalAabb,
        )
    }
    #[inline]
    pub unsafe fn getChildList(&mut self) -> *mut btCompoundShapeChild {
        btCompoundShape_getChildList(self)
    }
    #[inline]
    pub unsafe fn getDynamicAabbTree(&self) -> *const btDbvt {
        btCompoundShape_getDynamicAabbTree(self)
    }
    #[inline]
    pub unsafe fn getDynamicAabbTree1(&mut self) -> *mut btDbvt {
        btCompoundShape_getDynamicAabbTree1(self)
    }
    #[inline]
    pub unsafe fn createAabbTreeFromChildren(&mut self) {
        btCompoundShape_createAabbTreeFromChildren(self)
    }
    #[inline]
    pub unsafe fn calculatePrincipalAxisTransform(
        &self,
        masses: *mut btScalar,
        principal: *mut btTransform,
        inertia: *mut btVector3,
    ) {
        btCompoundShape_calculatePrincipalAxisTransform(self, masses, principal, inertia)
    }
    #[inline]
    pub unsafe fn getUpdateRevision(&self) -> ::std::os::raw::c_int {
        btCompoundShape_getUpdateRevision(self)
    }
    #[inline]
    pub unsafe fn new(
        enableDynamicAabbTree: bool,
        initialChildCapacity: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCompoundShape_btCompoundShape(
            &mut __bindgen_tmp,
            enableDynamicAabbTree,
            initialChildCapacity,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCompoundShapeD0Ev"]
    pub fn btCompoundShape_btCompoundShape_destructor(this: *mut btCompoundShape);
}
extern "C" {

    /// Remove all children shapes that contain the specified shape

    #[link_name = "\u{1}_ZN15btCompoundShape16removeChildShapeEP16btCollisionShape"]
    pub fn btCompoundShape_removeChildShape(
        this: *mut ::std::os::raw::c_void,
        shape: *mut btCollisionShape,
    );
}
extern "C" {

    /// getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version

    #[link_name = "\u{1}_ZNK15btCompoundShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btCompoundShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {

    /// Re-calculate the local Aabb. Is called at the end of removeChildShapes.
    /// Use this yourself if you modify the children or their transforms.

    #[link_name = "\u{1}_ZN15btCompoundShape20recalculateLocalAabbEv"]
    pub fn btCompoundShape_recalculateLocalAabb(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCompoundShape15setLocalScalingERK9btVector3"]
    pub fn btCompoundShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCompoundShape15getLocalScalingEv"]
    pub fn btCompoundShape_getLocalScaling(this: *mut ::std::os::raw::c_void) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCompoundShape21calculateLocalInertiaEdR9btVector3"]
    pub fn btCompoundShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btCompoundShape9setMarginEd"]
    pub fn btCompoundShape_setMargin(this: *mut ::std::os::raw::c_void, margin: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCompoundShape9getMarginEv"]
    pub fn btCompoundShape_getMargin(this: *mut ::std::os::raw::c_void) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCompoundShape7getNameEv"]
    pub fn btCompoundShape_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btCompoundShape28calculateSerializeBufferSizeEv"]
    pub fn btCompoundShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK15btCompoundShape9serializeEPvP12btSerializer"]
    pub fn btCompoundShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCompoundShapeChildData {
    pub m_transform: btTransformFloatData,
    pub m_childShape: *mut btCollisionShapeData,
    pub m_childShapeType: ::std::os::raw::c_int,
    pub m_childMargin: f32,
}
#[test]
fn bindgen_test_layout_btCompoundShapeChildData() {
    assert_eq!(
        ::std::mem::size_of::<btCompoundShapeChildData>(),
        80usize,
        concat!("Size of: ", stringify!(btCompoundShapeChildData))
    );
    assert_eq!(
        ::std::mem::align_of::<btCompoundShapeChildData>(),
        8usize,
        concat!("Alignment of ", stringify!(btCompoundShapeChildData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShapeChildData)).m_transform as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShapeChildData),
            "::",
            stringify!(m_transform)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShapeChildData)).m_childShape as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShapeChildData),
            "::",
            stringify!(m_childShape)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShapeChildData)).m_childShapeType as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShapeChildData),
            "::",
            stringify!(m_childShapeType)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShapeChildData)).m_childMargin as *const _ as usize },
        76usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShapeChildData),
            "::",
            stringify!(m_childMargin)
        )
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCompoundShapeData {
    pub m_collisionShapeData: btCollisionShapeData,
    pub m_childShapePtr: *mut btCompoundShapeChildData,
    pub m_numChildShapes: ::std::os::raw::c_int,
    pub m_collisionMargin: f32,
}
#[test]
fn bindgen_test_layout_btCompoundShapeData() {
    assert_eq!(
        ::std::mem::size_of::<btCompoundShapeData>(),
        32usize,
        concat!("Size of: ", stringify!(btCompoundShapeData))
    );
    assert_eq!(
        ::std::mem::align_of::<btCompoundShapeData>(),
        8usize,
        concat!("Alignment of ", stringify!(btCompoundShapeData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShapeData)).m_collisionShapeData as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShapeData),
            "::",
            stringify!(m_collisionShapeData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShapeData)).m_childShapePtr as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShapeData),
            "::",
            stringify!(m_childShapePtr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShapeData)).m_numChildShapes as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShapeData),
            "::",
            stringify!(m_numChildShapes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCompoundShapeData)).m_collisionMargin as *const _ as usize },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCompoundShapeData),
            "::",
            stringify!(m_collisionMargin)
        )
    );
}
/// The btBU_Simplex1to4 implements tetrahedron, triangle, line, vertex collision shapes. In most cases it is better to use btConvexHullShape instead.
#[repr(C)]
#[derive(Debug)]
pub struct btBU_Simplex1to4 {
    pub _base: btPolyhedralConvexShape,
    pub m_localAabbMin: btVector3,
    pub m_localAabbMax: btVector3,
    pub m_isLocalAabbValid: bool,
    pub m_numVertices: ::std::os::raw::c_int,
    pub m_vertices: [btVector3; 4usize],
}
#[test]
fn bindgen_test_layout_btBU_Simplex1to4() {
    assert_eq!(
        ::std::mem::size_of::<btBU_Simplex1to4>(),
        320usize,
        concat!("Size of: ", stringify!(btBU_Simplex1to4))
    );
    assert_eq!(
        ::std::mem::align_of::<btBU_Simplex1to4>(),
        8usize,
        concat!("Alignment of ", stringify!(btBU_Simplex1to4))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBU_Simplex1to4)).m_numVertices as *const _ as usize },
        188usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBU_Simplex1to4),
            "::",
            stringify!(m_numVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btBU_Simplex1to4)).m_vertices as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btBU_Simplex1to4),
            "::",
            stringify!(m_vertices)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btBU_Simplex1to45resetEv"]
    pub fn btBU_Simplex1to4_reset(this: *mut btBU_Simplex1to4);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btBU_Simplex1to49addVertexERK9btVector3"]
    pub fn btBU_Simplex1to4_addVertex(this: *mut btBU_Simplex1to4, pt: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btBU_Simplex1to4C1Ev"]
    pub fn btBU_Simplex1to4_btBU_Simplex1to4(this: *mut btBU_Simplex1to4);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btBU_Simplex1to4C1ERK9btVector3"]
    pub fn btBU_Simplex1to4_btBU_Simplex1to41(this: *mut btBU_Simplex1to4, pt0: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btBU_Simplex1to4C1ERK9btVector3S2_"]
    pub fn btBU_Simplex1to4_btBU_Simplex1to42(
        this: *mut btBU_Simplex1to4,
        pt0: *const btVector3,
        pt1: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btBU_Simplex1to4C1ERK9btVector3S2_S2_"]
    pub fn btBU_Simplex1to4_btBU_Simplex1to43(
        this: *mut btBU_Simplex1to4,
        pt0: *const btVector3,
        pt1: *const btVector3,
        pt2: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btBU_Simplex1to4C1ERK9btVector3S2_S2_S2_"]
    pub fn btBU_Simplex1to4_btBU_Simplex1to44(
        this: *mut btBU_Simplex1to4,
        pt0: *const btVector3,
        pt1: *const btVector3,
        pt2: *const btVector3,
        pt3: *const btVector3,
    );
}
impl btBU_Simplex1to4 {
    #[inline]
    pub unsafe fn reset(&mut self) {
        btBU_Simplex1to4_reset(self)
    }
    #[inline]
    pub unsafe fn addVertex(&mut self, pt: *const btVector3) {
        btBU_Simplex1to4_addVertex(self, pt)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBU_Simplex1to4_btBU_Simplex1to4(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(pt0: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBU_Simplex1to4_btBU_Simplex1to41(&mut __bindgen_tmp, pt0);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(pt0: *const btVector3, pt1: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBU_Simplex1to4_btBU_Simplex1to42(&mut __bindgen_tmp, pt0, pt1);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(
        pt0: *const btVector3,
        pt1: *const btVector3,
        pt2: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBU_Simplex1to4_btBU_Simplex1to43(&mut __bindgen_tmp, pt0, pt1, pt2);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(
        pt0: *const btVector3,
        pt1: *const btVector3,
        pt2: *const btVector3,
        pt3: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btBU_Simplex1to4_btBU_Simplex1to44(&mut __bindgen_tmp, pt0, pt1, pt2, pt3);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btBU_Simplex1to47getAabbERK11btTransformR9btVector3S4_"]
    pub fn btBU_Simplex1to4_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btBU_Simplex1to414getNumVerticesEv"]
    pub fn btBU_Simplex1to4_getNumVertices(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btBU_Simplex1to411getNumEdgesEv"]
    pub fn btBU_Simplex1to4_getNumEdges(this: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btBU_Simplex1to47getEdgeEiR9btVector3S1_"]
    pub fn btBU_Simplex1to4_getEdge(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        pa: *mut btVector3,
        pb: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btBU_Simplex1to49getVertexEiR9btVector3"]
    pub fn btBU_Simplex1to4_getVertex(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        vtx: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btBU_Simplex1to412getNumPlanesEv"]
    pub fn btBU_Simplex1to4_getNumPlanes(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btBU_Simplex1to48getPlaneER9btVector3S1_i"]
    pub fn btBU_Simplex1to4_getPlane(
        this: *mut ::std::os::raw::c_void,
        planeNormal: *mut btVector3,
        planeSupport: *mut btVector3,
        i: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btBU_Simplex1to48getIndexEi"]
    pub fn btBU_Simplex1to4_getIndex(
        this: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btBU_Simplex1to48isInsideERK9btVector3d"]
    pub fn btBU_Simplex1to4_isInside(
        this: *mut ::std::os::raw::c_void,
        pt: *const btVector3,
        tolerance: btScalar,
    ) -> bool;
}
extern "C" {

    /// getName is for debugging

    #[link_name = "\u{1}_ZNK16btBU_Simplex1to47getNameEv"]
    pub fn btBU_Simplex1to4_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
/// The btEmptyShape is a collision shape without actual collision detection shape, so most users should ignore this class.
/// It can be replaced by another shape during runtime, but the inertia tensor should be recomputed.
#[repr(C)]
#[derive(Debug)]
pub struct btEmptyShape {
    pub _base: btConcaveShape,
    pub m_localScaling: btVector3,
}
#[test]
fn bindgen_test_layout_btEmptyShape() {
    assert_eq!(
        ::std::mem::size_of::<btEmptyShape>(),
        72usize,
        concat!("Size of: ", stringify!(btEmptyShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btEmptyShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btEmptyShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btEmptyShape)).m_localScaling as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btEmptyShape),
            "::",
            stringify!(m_localScaling)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btEmptyShapeC1Ev"]
    pub fn btEmptyShape_btEmptyShape(this: *mut btEmptyShape);
}
impl btEmptyShape {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btEmptyShape_btEmptyShape(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN12btEmptyShapeD0Ev"]
    pub fn btEmptyShape_btEmptyShape_destructor(this: *mut btEmptyShape);
}
extern "C" {

    /// getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version

    #[link_name = "\u{1}_ZNK12btEmptyShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btEmptyShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btEmptyShape15setLocalScalingERK9btVector3"]
    pub fn btEmptyShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btEmptyShape15getLocalScalingEv"]
    pub fn btEmptyShape_getLocalScaling(this: *mut ::std::os::raw::c_void) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btEmptyShape21calculateLocalInertiaEdR9btVector3"]
    pub fn btEmptyShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btEmptyShape7getNameEv"]
    pub fn btEmptyShape_getName(this: *mut ::std::os::raw::c_void)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btEmptyShape19processAllTrianglesEP18btTriangleCallbackRK9btVector3S4_"]
    pub fn btEmptyShape_processAllTriangles(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btTriangleCallback,
        arg2: *const btVector3,
        arg3: *const btVector3,
    );
}
/// The btMultiSphereShape represents the convex hull of a collection of spheres. You can create special capsules or other smooth volumes.
/// It is possible to animate the spheres for deformation, but call 'recalcLocalAabb' after changing any sphere position/radius
#[repr(C)]
#[derive(Debug)]
pub struct btMultiSphereShape {
    pub _base: btConvexInternalAabbCachingShape,
    pub m_localPositionArray: btAlignedObjectArray<btVector3>,
    pub m_radiArray: btAlignedObjectArray<btScalar>,
}
#[test]
fn bindgen_test_layout_btMultiSphereShape() {
    assert_eq!(
        ::std::mem::size_of::<btMultiSphereShape>(),
        248usize,
        concat!("Size of: ", stringify!(btMultiSphereShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btMultiSphereShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btMultiSphereShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btMultiSphereShape)).m_localPositionArray as *const _ as usize },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMultiSphereShape),
            "::",
            stringify!(m_localPositionArray)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btMultiSphereShape)).m_radiArray as *const _ as usize },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMultiSphereShape),
            "::",
            stringify!(m_radiArray)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btMultiSphereShape14getSphereCountEv"]
    pub fn btMultiSphereShape_getSphereCount(
        this: *const btMultiSphereShape,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btMultiSphereShape17getSpherePositionEi"]
    pub fn btMultiSphereShape_getSpherePosition(
        this: *const btMultiSphereShape,
        index: ::std::os::raw::c_int,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btMultiSphereShape15getSphereRadiusEi"]
    pub fn btMultiSphereShape_getSphereRadius(
        this: *const btMultiSphereShape,
        index: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btMultiSphereShapeC1EPK9btVector3PKdi"]
    pub fn btMultiSphereShape_btMultiSphereShape(
        this: *mut btMultiSphereShape,
        positions: *const btVector3,
        radi: *const btScalar,
        numSpheres: ::std::os::raw::c_int,
    );
}
impl btMultiSphereShape {
    #[inline]
    pub unsafe fn getSphereCount(&self) -> ::std::os::raw::c_int {
        btMultiSphereShape_getSphereCount(self)
    }
    #[inline]
    pub unsafe fn getSpherePosition(&self, index: ::std::os::raw::c_int) -> *const btVector3 {
        btMultiSphereShape_getSpherePosition(self, index)
    }
    #[inline]
    pub unsafe fn getSphereRadius(&self, index: ::std::os::raw::c_int) -> btScalar {
        btMultiSphereShape_getSphereRadius(self, index)
    }
    #[inline]
    pub unsafe fn new(
        positions: *const btVector3,
        radi: *const btScalar,
        numSpheres: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btMultiSphereShape_btMultiSphereShape(&mut __bindgen_tmp, positions, radi, numSpheres);
        __bindgen_tmp
    }
}
extern "C" {

    /// CollisionShape Interface

    #[link_name = "\u{1}_ZNK18btMultiSphereShape21calculateLocalInertiaEdR9btVector3"]
    pub fn btMultiSphereShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {

    /// btConvexShape Interface

    #[link_name = "\u{1}_ZNK18btMultiSphereShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
    pub fn btMultiSphereShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btMultiSphereShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
    pub fn btMultiSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btMultiSphereShape7getNameEv"]
    pub fn btMultiSphereShape_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btMultiSphereShape28calculateSerializeBufferSizeEv"]
    pub fn btMultiSphereShape_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK18btMultiSphereShape9serializeEPvP12btSerializer"]
    pub fn btMultiSphereShape_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPositionAndRadius {
    pub m_pos: btVector3FloatData,
    pub m_radius: f32,
}
#[test]
fn bindgen_test_layout_btPositionAndRadius() {
    assert_eq!(
        ::std::mem::size_of::<btPositionAndRadius>(),
        20usize,
        concat!("Size of: ", stringify!(btPositionAndRadius))
    );
    assert_eq!(
        ::std::mem::align_of::<btPositionAndRadius>(),
        4usize,
        concat!("Alignment of ", stringify!(btPositionAndRadius))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPositionAndRadius)).m_pos as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPositionAndRadius),
            "::",
            stringify!(m_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPositionAndRadius)).m_radius as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPositionAndRadius),
            "::",
            stringify!(m_radius)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btMultiSphereShapeData {
    pub m_convexInternalShapeData: btConvexInternalShapeData,
    pub m_localPositionArrayPtr: *mut btPositionAndRadius,
    pub m_localPositionArraySize: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btMultiSphereShapeData() {
    assert_eq!(
        ::std::mem::size_of::<btMultiSphereShapeData>(),
        72usize,
        concat!("Size of: ", stringify!(btMultiSphereShapeData))
    );
    assert_eq!(
        ::std::mem::align_of::<btMultiSphereShapeData>(),
        8usize,
        concat!("Alignment of ", stringify!(btMultiSphereShapeData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btMultiSphereShapeData)).m_convexInternalShapeData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMultiSphereShapeData),
            "::",
            stringify!(m_convexInternalShapeData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btMultiSphereShapeData)).m_localPositionArrayPtr as *const _ as usize
        },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMultiSphereShapeData),
            "::",
            stringify!(m_localPositionArrayPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btMultiSphereShapeData)).m_localPositionArraySize as *const _ as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMultiSphereShapeData),
            "::",
            stringify!(m_localPositionArraySize)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btMultiSphereShapeData)).m_padding as *const _ as usize },
        68usize,
        concat!(
            "Alignment of field: ",
            stringify!(btMultiSphereShapeData),
            "::",
            stringify!(m_padding)
        )
    );
}
/// The btUniformScalingShape allows to re-use uniform scaled instances of btConvexShape in a memory efficient way.
/// Istead of using btUniformScalingShape, it is better to use the non-uniform setLocalScaling method on convex shapes that implement it.
#[repr(C)]
#[derive(Debug)]
pub struct btUniformScalingShape {
    pub _base: btConvexShape,
    pub m_childConvexShape: *mut btConvexShape,
    pub m_uniformScalingFactor: btScalar,
}
#[test]
fn bindgen_test_layout_btUniformScalingShape() {
    assert_eq!(
        ::std::mem::size_of::<btUniformScalingShape>(),
        48usize,
        concat!("Size of: ", stringify!(btUniformScalingShape))
    );
    assert_eq!(
        ::std::mem::align_of::<btUniformScalingShape>(),
        8usize,
        concat!("Alignment of ", stringify!(btUniformScalingShape))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btUniformScalingShape)).m_childConvexShape as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btUniformScalingShape),
            "::",
            stringify!(m_childConvexShape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btUniformScalingShape)).m_uniformScalingFactor as *const _ as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btUniformScalingShape),
            "::",
            stringify!(m_uniformScalingFactor)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btUniformScalingShape23getUniformScalingFactorEv"]
    pub fn btUniformScalingShape_getUniformScalingFactor(
        this: *const btUniformScalingShape,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniformScalingShape13getChildShapeEv"]
    pub fn btUniformScalingShape_getChildShape(
        this: *mut btUniformScalingShape,
    ) -> *mut btConvexShape;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btUniformScalingShape13getChildShapeEv"]
    pub fn btUniformScalingShape_getChildShape1(
        this: *const btUniformScalingShape,
    ) -> *const btConvexShape;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniformScalingShapeC1EP13btConvexShaped"]
    pub fn btUniformScalingShape_btUniformScalingShape(
        this: *mut btUniformScalingShape,
        convexChildShape: *mut btConvexShape,
        uniformScalingFactor: btScalar,
    );
}
impl btUniformScalingShape {
    #[inline]
    pub unsafe fn getUniformScalingFactor(&self) -> btScalar {
        btUniformScalingShape_getUniformScalingFactor(self)
    }
    #[inline]
    pub unsafe fn getChildShape(&mut self) -> *mut btConvexShape {
        btUniformScalingShape_getChildShape(self)
    }
    #[inline]
    pub unsafe fn getChildShape1(&self) -> *const btConvexShape {
        btUniformScalingShape_getChildShape1(self)
    }
    #[inline]
    pub unsafe fn new(
        convexChildShape: *mut btConvexShape,
        uniformScalingFactor: btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btUniformScalingShape_btUniformScalingShape(
            &mut __bindgen_tmp,
            convexChildShape,
            uniformScalingFactor,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniformScalingShapeD0Ev"]
    pub fn btUniformScalingShape_btUniformScalingShape_destructor(this: *mut btUniformScalingShape);
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btUniformScalingShape37localGetSupportingVertexWithoutMarginERK9btVector3"]
    pub fn btUniformScalingShape_localGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btUniformScalingShape24localGetSupportingVertexERK9btVector3"]
    pub fn btUniformScalingShape_localGetSupportingVertex(
        this: *mut ::std::os::raw::c_void,
        vec: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btUniformScalingShape49batchedUnitVectorGetSupportingVertexWithoutMarginEPK9btVector3PS0_i"]
    pub fn btUniformScalingShape_batchedUnitVectorGetSupportingVertexWithoutMargin(
        this: *mut ::std::os::raw::c_void,
        vectors: *const btVector3,
        supportVerticesOut: *mut btVector3,
        numVectors: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btUniformScalingShape21calculateLocalInertiaEdR9btVector3"]
    pub fn btUniformScalingShape_calculateLocalInertia(
        this: *mut ::std::os::raw::c_void,
        mass: btScalar,
        inertia: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btUniformScalingShape7getNameEv"]
    pub fn btUniformScalingShape_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {

    /// getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version

    #[link_name = "\u{1}_ZNK21btUniformScalingShape7getAabbERK11btTransformR9btVector3S4_"]
    pub fn btUniformScalingShape_getAabb(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btUniformScalingShape11getAabbSlowERK11btTransformR9btVector3S4_"]
    pub fn btUniformScalingShape_getAabbSlow(
        this: *mut ::std::os::raw::c_void,
        t: *const btTransform,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniformScalingShape15setLocalScalingERK9btVector3"]
    pub fn btUniformScalingShape_setLocalScaling(
        this: *mut ::std::os::raw::c_void,
        scaling: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btUniformScalingShape15getLocalScalingEv"]
    pub fn btUniformScalingShape_getLocalScaling(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniformScalingShape9setMarginEd"]
    pub fn btUniformScalingShape_setMargin(this: *mut ::std::os::raw::c_void, margin: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btUniformScalingShape9getMarginEv"]
    pub fn btUniformScalingShape_getMargin(this: *mut ::std::os::raw::c_void) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btUniformScalingShape36getNumPreferredPenetrationDirectionsEv"]
    pub fn btUniformScalingShape_getNumPreferredPenetrationDirections(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btUniformScalingShape32getPreferredPenetrationDirectionEiR9btVector3"]
    pub fn btUniformScalingShape_getPreferredPenetrationDirection(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
        penetrationVector: *mut btVector3,
    );
}
pub type btManifoldArray = btAlignedObjectArray<*mut btPersistentManifold>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btCollisionAlgorithmConstructionInfo {
    pub m_dispatcher1: *mut btDispatcher,
    pub m_manifold: *mut btPersistentManifold,
}
#[test]
fn bindgen_test_layout_btCollisionAlgorithmConstructionInfo() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionAlgorithmConstructionInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(btCollisionAlgorithmConstructionInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionAlgorithmConstructionInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btCollisionAlgorithmConstructionInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionAlgorithmConstructionInfo)).m_dispatcher1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionAlgorithmConstructionInfo),
            "::",
            stringify!(m_dispatcher1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btCollisionAlgorithmConstructionInfo)).m_manifold as *const _ as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionAlgorithmConstructionInfo),
            "::",
            stringify!(m_manifold)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN36btCollisionAlgorithmConstructionInfoC1Ev"]
    pub fn btCollisionAlgorithmConstructionInfo_btCollisionAlgorithmConstructionInfo(
        this: *mut btCollisionAlgorithmConstructionInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN36btCollisionAlgorithmConstructionInfoC1EP12btDispatcheri"]
    pub fn btCollisionAlgorithmConstructionInfo_btCollisionAlgorithmConstructionInfo1(
        this: *mut btCollisionAlgorithmConstructionInfo,
        dispatcher: *mut btDispatcher,
        temp: ::std::os::raw::c_int,
    );
}
impl btCollisionAlgorithmConstructionInfo {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionAlgorithmConstructionInfo_btCollisionAlgorithmConstructionInfo(
            &mut __bindgen_tmp,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(dispatcher: *mut btDispatcher, temp: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionAlgorithmConstructionInfo_btCollisionAlgorithmConstructionInfo1(
            &mut __bindgen_tmp,
            dispatcher,
            temp,
        );
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct btCollisionAlgorithm__bindgen_vtable(::std::os::raw::c_void);
/// btCollisionAlgorithm is an collision interface that is compatible with the Broadphase and btDispatcher.
/// It is persistent over frames
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionAlgorithm {
    pub vtable_: *const btCollisionAlgorithm__bindgen_vtable,
    pub m_dispatcher: *mut btDispatcher,
}
#[test]
fn bindgen_test_layout_btCollisionAlgorithm() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionAlgorithm>(),
        16usize,
        concat!("Size of: ", stringify!(btCollisionAlgorithm))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionAlgorithm>(),
        8usize,
        concat!("Alignment of ", stringify!(btCollisionAlgorithm))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btCollisionAlgorithm)).m_dispatcher as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btCollisionAlgorithm),
            "::",
            stringify!(m_dispatcher)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN20btCollisionAlgorithmC2Ev"]
    pub fn btCollisionAlgorithm_btCollisionAlgorithm(this: *mut btCollisionAlgorithm);
}
extern "C" {
    #[link_name = "\u{1}_ZN20btCollisionAlgorithmC2ERK36btCollisionAlgorithmConstructionInfo"]
    pub fn btCollisionAlgorithm_btCollisionAlgorithm1(
        this: *mut btCollisionAlgorithm,
        ci: *const btCollisionAlgorithmConstructionInfo,
    );
}
impl btCollisionAlgorithm {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionAlgorithm_btCollisionAlgorithm(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(ci: *const btCollisionAlgorithmConstructionInfo) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btCollisionAlgorithm_btCollisionAlgorithm1(&mut __bindgen_tmp, ci);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN20btCollisionAlgorithmD0Ev"]
    pub fn btCollisionAlgorithm_btCollisionAlgorithm_destructor(this: *mut btCollisionAlgorithm);
}
extern "C" {
    #[link_name = "\u{1}_ZN20btCollisionAlgorithm16processCollisionEPK24btCollisionObjectWrapperS2_RK16btDispatcherInfoP16btManifoldResult"]
    pub fn btCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN20btCollisionAlgorithm21calculateTimeOfImpactEP17btCollisionObjectS1_RK16btDispatcherInfoP16btManifoldResult"]
    pub fn btCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN20btCollisionAlgorithm22getAllContactManifoldsER20btAlignedObjectArrayIP20btPersistentManifoldE"]
    pub fn btCollisionAlgorithm_getAllContactManifolds(
        this: *mut ::std::os::raw::c_void,
        manifoldArray: *mut btManifoldArray,
    );
}
/// This class is not enabled yet (work-in-progress) to more aggressively activate objects.
#[repr(C)]
#[derive(Debug)]
pub struct btActivatingCollisionAlgorithm {
    pub _base: btCollisionAlgorithm,
}
#[test]
fn bindgen_test_layout_btActivatingCollisionAlgorithm() {
    assert_eq!(
        ::std::mem::size_of::<btActivatingCollisionAlgorithm>(),
        16usize,
        concat!("Size of: ", stringify!(btActivatingCollisionAlgorithm))
    );
    assert_eq!(
        ::std::mem::align_of::<btActivatingCollisionAlgorithm>(),
        8usize,
        concat!("Alignment of ", stringify!(btActivatingCollisionAlgorithm))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btActivatingCollisionAlgorithmC2ERK36btCollisionAlgorithmConstructionInfo"]
    pub fn btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm(
        this: *mut btActivatingCollisionAlgorithm,
        ci: *const btCollisionAlgorithmConstructionInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btActivatingCollisionAlgorithmC2ERK36btCollisionAlgorithmConstructionInfoPK24btCollisionObjectWrapperS5_"]
    pub fn btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm1(
        this: *mut btActivatingCollisionAlgorithm,
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    );
}
impl btActivatingCollisionAlgorithm {
    #[inline]
    pub unsafe fn new(ci: *const btCollisionAlgorithmConstructionInfo) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm(&mut __bindgen_tmp, ci);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        ci: *const btCollisionAlgorithmConstructionInfo,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm1(
            &mut __bindgen_tmp,
            ci,
            body0Wrap,
            body1Wrap,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN30btActivatingCollisionAlgorithmD0Ev"]
    pub fn btActivatingCollisionAlgorithm_btActivatingCollisionAlgorithm_destructor(
        this: *mut btActivatingCollisionAlgorithm,
    );
}
/// btSphereSphereCollisionAlgorithm  provides sphere-sphere collision detection.
/// Other features are frame-coherency (persistent data) and collision response.
/// Also provides the most basic sample for custom/user btCollisionAlgorithm
#[repr(C)]
#[derive(Debug)]
pub struct btSphereSphereCollisionAlgorithm {
    pub _base: btActivatingCollisionAlgorithm,
    pub m_ownManifold: bool,
    pub m_manifoldPtr: *mut btPersistentManifold,
}
#[repr(C)]
#[derive(Debug)]
pub struct btSphereSphereCollisionAlgorithm_CreateFunc {
    pub _base: btCollisionAlgorithmCreateFunc,
}
#[test]
fn bindgen_test_layout_btSphereSphereCollisionAlgorithm_CreateFunc() {
    assert_eq!(
        ::std::mem::size_of::<btSphereSphereCollisionAlgorithm_CreateFunc>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(btSphereSphereCollisionAlgorithm_CreateFunc)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btSphereSphereCollisionAlgorithm_CreateFunc>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btSphereSphereCollisionAlgorithm_CreateFunc)
        )
    );
}
#[test]
fn bindgen_test_layout_btSphereSphereCollisionAlgorithm() {
    assert_eq!(
        ::std::mem::size_of::<btSphereSphereCollisionAlgorithm>(),
        32usize,
        concat!("Size of: ", stringify!(btSphereSphereCollisionAlgorithm))
    );
    assert_eq!(
        ::std::mem::align_of::<btSphereSphereCollisionAlgorithm>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btSphereSphereCollisionAlgorithm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSphereSphereCollisionAlgorithm)).m_ownManifold as *const _ as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSphereSphereCollisionAlgorithm),
            "::",
            stringify!(m_ownManifold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSphereSphereCollisionAlgorithm)).m_manifoldPtr as *const _ as usize
        },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSphereSphereCollisionAlgorithm),
            "::",
            stringify!(m_manifoldPtr)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN32btSphereSphereCollisionAlgorithmC1EP20btPersistentManifoldRK36btCollisionAlgorithmConstructionInfoPK24btCollisionObjectWrapperS7_"]
    pub fn btSphereSphereCollisionAlgorithm_btSphereSphereCollisionAlgorithm(
        this: *mut btSphereSphereCollisionAlgorithm,
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        col0Wrap: *const btCollisionObjectWrapper,
        col1Wrap: *const btCollisionObjectWrapper,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN32btSphereSphereCollisionAlgorithmC1ERK36btCollisionAlgorithmConstructionInfo"]
    pub fn btSphereSphereCollisionAlgorithm_btSphereSphereCollisionAlgorithm1(
        this: *mut btSphereSphereCollisionAlgorithm,
        ci: *const btCollisionAlgorithmConstructionInfo,
    );
}
impl btSphereSphereCollisionAlgorithm {
    #[inline]
    pub unsafe fn new(
        mf: *mut btPersistentManifold,
        ci: *const btCollisionAlgorithmConstructionInfo,
        col0Wrap: *const btCollisionObjectWrapper,
        col1Wrap: *const btCollisionObjectWrapper,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSphereSphereCollisionAlgorithm_btSphereSphereCollisionAlgorithm(
            &mut __bindgen_tmp,
            mf,
            ci,
            col0Wrap,
            col1Wrap,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(ci: *const btCollisionAlgorithmConstructionInfo) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSphereSphereCollisionAlgorithm_btSphereSphereCollisionAlgorithm1(&mut __bindgen_tmp, ci);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN32btSphereSphereCollisionAlgorithm16processCollisionEPK24btCollisionObjectWrapperS2_RK16btDispatcherInfoP16btManifoldResult"]
    pub fn btSphereSphereCollisionAlgorithm_processCollision(
        this: *mut ::std::os::raw::c_void,
        body0Wrap: *const btCollisionObjectWrapper,
        body1Wrap: *const btCollisionObjectWrapper,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN32btSphereSphereCollisionAlgorithm21calculateTimeOfImpactEP17btCollisionObjectS1_RK16btDispatcherInfoP16btManifoldResult"]
    pub fn btSphereSphereCollisionAlgorithm_calculateTimeOfImpact(
        this: *mut ::std::os::raw::c_void,
        body0: *mut btCollisionObject,
        body1: *mut btCollisionObject,
        dispatchInfo: *const btDispatcherInfo,
        resultOut: *mut btManifoldResult,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN32btSphereSphereCollisionAlgorithm22getAllContactManifoldsER20btAlignedObjectArrayIP20btPersistentManifoldE"]
    pub fn btSphereSphereCollisionAlgorithm_getAllContactManifolds(
        this: *mut ::std::os::raw::c_void,
        manifoldArray: *mut btManifoldArray,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN32btSphereSphereCollisionAlgorithmD0Ev"]
    pub fn btSphereSphereCollisionAlgorithm_btSphereSphereCollisionAlgorithm_destructor(
        this: *mut btSphereSphereCollisionAlgorithm,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN32btSphereSphereCollisionAlgorithm10CreateFunc24CreateCollisionAlgorithmER36btCollisionAlgorithmConstructionInfoPK24btCollisionObjectWrapperS5_"]
    pub fn btSphereSphereCollisionAlgorithm_CreateFunc_CreateCollisionAlgorithm(
        this: *mut ::std::os::raw::c_void,
        ci: *mut btCollisionAlgorithmConstructionInfo,
        col0Wrap: *const btCollisionObjectWrapper,
        col1Wrap: *const btCollisionObjectWrapper,
    ) -> *mut btCollisionAlgorithm;
}
#[repr(C)]
pub struct btCollisionConfiguration__bindgen_vtable(::std::os::raw::c_void);
/// btCollisionConfiguration allows to configure Bullet collision detection
/// stack allocator size, default collision algorithms and persistent manifold pool size
/// @todo: describe the meaning
#[repr(C)]
#[derive(Debug)]
pub struct btCollisionConfiguration {
    pub vtable_: *const btCollisionConfiguration__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btCollisionConfiguration() {
    assert_eq!(
        ::std::mem::size_of::<btCollisionConfiguration>(),
        8usize,
        concat!("Size of: ", stringify!(btCollisionConfiguration))
    );
    assert_eq!(
        ::std::mem::align_of::<btCollisionConfiguration>(),
        8usize,
        concat!("Alignment of ", stringify!(btCollisionConfiguration))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN24btCollisionConfigurationD0Ev"]
    pub fn btCollisionConfiguration_btCollisionConfiguration_destructor(
        this: *mut btCollisionConfiguration,
    );
}
extern "C" {

    /// memory pools

    #[link_name = "\u{1}_ZN24btCollisionConfiguration25getPersistentManifoldPoolEv"]
    pub fn btCollisionConfiguration_getPersistentManifoldPool(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btPoolAllocator;
}
extern "C" {
    #[link_name = "\u{1}_ZN24btCollisionConfiguration25getCollisionAlgorithmPoolEv"]
    pub fn btCollisionConfiguration_getCollisionAlgorithmPool(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btPoolAllocator;
}
extern "C" {
    #[link_name = "\u{1}_ZN24btCollisionConfiguration31getCollisionAlgorithmCreateFuncEii"]
    pub fn btCollisionConfiguration_getCollisionAlgorithmCreateFunc(
        this: *mut ::std::os::raw::c_void,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
    ) -> *mut btCollisionAlgorithmCreateFunc;
}
extern "C" {
    #[link_name = "\u{1}_ZN24btCollisionConfiguration35getClosestPointsAlgorithmCreateFuncEii"]
    pub fn btCollisionConfiguration_getClosestPointsAlgorithmCreateFunc(
        this: *mut ::std::os::raw::c_void,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
    ) -> *mut btCollisionAlgorithmCreateFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btVoronoiSimplexSolver {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConvexPenetrationDepthSolver {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDefaultCollisionConstructionInfo {
    pub m_persistentManifoldPool: *mut btPoolAllocator,
    pub m_collisionAlgorithmPool: *mut btPoolAllocator,
    pub m_defaultMaxPersistentManifoldPoolSize: ::std::os::raw::c_int,
    pub m_defaultMaxCollisionAlgorithmPoolSize: ::std::os::raw::c_int,
    pub m_customCollisionAlgorithmMaxElementSize: ::std::os::raw::c_int,
    pub m_useEpaPenetrationAlgorithm: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btDefaultCollisionConstructionInfo() {
    assert_eq!(
        ::std::mem::size_of::<btDefaultCollisionConstructionInfo>(),
        32usize,
        concat!("Size of: ", stringify!(btDefaultCollisionConstructionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<btDefaultCollisionConstructionInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btDefaultCollisionConstructionInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConstructionInfo)).m_persistentManifoldPool
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConstructionInfo),
            "::",
            stringify!(m_persistentManifoldPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConstructionInfo)).m_collisionAlgorithmPool
                as *const _ as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConstructionInfo),
            "::",
            stringify!(m_collisionAlgorithmPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConstructionInfo))
                .m_defaultMaxPersistentManifoldPoolSize as *const _ as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConstructionInfo),
            "::",
            stringify!(m_defaultMaxPersistentManifoldPoolSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConstructionInfo))
                .m_defaultMaxCollisionAlgorithmPoolSize as *const _ as usize
        },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConstructionInfo),
            "::",
            stringify!(m_defaultMaxCollisionAlgorithmPoolSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConstructionInfo))
                .m_customCollisionAlgorithmMaxElementSize as *const _ as usize
        },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConstructionInfo),
            "::",
            stringify!(m_customCollisionAlgorithmMaxElementSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConstructionInfo)).m_useEpaPenetrationAlgorithm
                as *const _ as usize
        },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConstructionInfo),
            "::",
            stringify!(m_useEpaPenetrationAlgorithm)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN34btDefaultCollisionConstructionInfoC1Ev"]
    pub fn btDefaultCollisionConstructionInfo_btDefaultCollisionConstructionInfo(
        this: *mut btDefaultCollisionConstructionInfo,
    );
}
impl btDefaultCollisionConstructionInfo {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDefaultCollisionConstructionInfo_btDefaultCollisionConstructionInfo(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
/// btCollisionConfiguration allows to configure Bullet collision detection
/// stack allocator, pool memory allocators
/// @todo: describe the meaning
#[repr(C)]
#[derive(Debug)]
pub struct btDefaultCollisionConfiguration {
    pub _base: btCollisionConfiguration,
    pub m_persistentManifoldPoolSize: ::std::os::raw::c_int,
    pub m_persistentManifoldPool: *mut btPoolAllocator,
    pub m_ownsPersistentManifoldPool: bool,
    pub m_collisionAlgorithmPool: *mut btPoolAllocator,
    pub m_ownsCollisionAlgorithmPool: bool,
    pub m_pdSolver: *mut btConvexPenetrationDepthSolver,
    pub m_convexConvexCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_convexConcaveCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_swappedConvexConcaveCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_compoundCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_compoundCompoundCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_swappedCompoundCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_emptyCreateFunc: *mut btCollisionAlgorithmCreateFunc,
    pub m_sphereSphereCF: *mut btCollisionAlgorithmCreateFunc,
    pub m_sphereBoxCF: *mut btCollisionAlgorithmCreateFunc,
    pub m_boxSphereCF: *mut btCollisionAlgorithmCreateFunc,
    pub m_boxBoxCF: *mut btCollisionAlgorithmCreateFunc,
    pub m_sphereTriangleCF: *mut btCollisionAlgorithmCreateFunc,
    pub m_triangleSphereCF: *mut btCollisionAlgorithmCreateFunc,
    pub m_planeConvexCF: *mut btCollisionAlgorithmCreateFunc,
    pub m_convexPlaneCF: *mut btCollisionAlgorithmCreateFunc,
}
#[test]
fn bindgen_test_layout_btDefaultCollisionConfiguration() {
    assert_eq!(
        ::std::mem::size_of::<btDefaultCollisionConfiguration>(),
        176usize,
        concat!("Size of: ", stringify!(btDefaultCollisionConfiguration))
    );
    assert_eq!(
        ::std::mem::align_of::<btDefaultCollisionConfiguration>(),
        8usize,
        concat!("Alignment of ", stringify!(btDefaultCollisionConfiguration))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_persistentManifoldPoolSize
                as *const _ as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_persistentManifoldPoolSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_persistentManifoldPool as *const _
                as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_persistentManifoldPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_ownsPersistentManifoldPool
                as *const _ as usize
        },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_ownsPersistentManifoldPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_collisionAlgorithmPool as *const _
                as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_collisionAlgorithmPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_ownsCollisionAlgorithmPool
                as *const _ as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_ownsCollisionAlgorithmPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_pdSolver as *const _ as usize
        },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_pdSolver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_convexConvexCreateFunc as *const _
                as usize
        },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_convexConvexCreateFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_convexConcaveCreateFunc as *const _
                as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_convexConcaveCreateFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_swappedConvexConcaveCreateFunc
                as *const _ as usize
        },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_swappedConvexConcaveCreateFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_compoundCreateFunc as *const _
                as usize
        },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_compoundCreateFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_compoundCompoundCreateFunc
                as *const _ as usize
        },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_compoundCompoundCreateFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_swappedCompoundCreateFunc
                as *const _ as usize
        },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_swappedCompoundCreateFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_emptyCreateFunc as *const _ as usize
        },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_emptyCreateFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_sphereSphereCF as *const _ as usize
        },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_sphereSphereCF)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_sphereBoxCF as *const _ as usize
        },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_sphereBoxCF)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_boxSphereCF as *const _ as usize
        },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_boxSphereCF)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_boxBoxCF as *const _ as usize
        },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_boxBoxCF)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_sphereTriangleCF as *const _
                as usize
        },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_sphereTriangleCF)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_triangleSphereCF as *const _
                as usize
        },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_triangleSphereCF)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_planeConvexCF as *const _ as usize
        },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_planeConvexCF)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDefaultCollisionConfiguration)).m_convexPlaneCF as *const _ as usize
        },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultCollisionConfiguration),
            "::",
            stringify!(m_convexPlaneCF)
        )
    );
}
extern "C" {

    /// Use this method to allow to generate multiple contact points between at once, between two objects using the generic convex-convex algorithm.
    /// ///By default, this feature is disabled for best performance.
    /// ///@param numPerturbationIterations controls the number of collision queries. Set it to zero to disable the feature.
    /// ///@param minimumPointsPerturbationThreshold is the minimum number of points in the contact cache, above which the feature is disabled
    /// ///3 is a good value for both params, if you want to enable the feature. This is because the default contact cache contains a maximum of 4 points, and one collision query at the unperturbed orientation is performed first.
    /// ///See Bullet/Demos/CollisionDemo for an example how this feature gathers multiple points.
    /// ///@todo we could add a per-object setting of those parameters, for level-of-detail collision detection.

    #[link_name = "\u{1}_ZN31btDefaultCollisionConfiguration35setConvexConvexMultipointIterationsEii"]
    pub fn btDefaultCollisionConfiguration_setConvexConvexMultipointIterations(
        this: *mut btDefaultCollisionConfiguration,
        numPerturbationIterations: ::std::os::raw::c_int,
        minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN31btDefaultCollisionConfiguration34setPlaneConvexMultipointIterationsEii"]
    pub fn btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations(
        this: *mut btDefaultCollisionConfiguration,
        numPerturbationIterations: ::std::os::raw::c_int,
        minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN31btDefaultCollisionConfigurationC1ERK34btDefaultCollisionConstructionInfo"]
    pub fn btDefaultCollisionConfiguration_btDefaultCollisionConfiguration(
        this: *mut btDefaultCollisionConfiguration,
        constructionInfo: *const btDefaultCollisionConstructionInfo,
    );
}
impl btDefaultCollisionConfiguration {
    #[inline]
    pub unsafe fn setConvexConvexMultipointIterations(
        &mut self,
        numPerturbationIterations: ::std::os::raw::c_int,
        minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
    ) {
        btDefaultCollisionConfiguration_setConvexConvexMultipointIterations(
            self,
            numPerturbationIterations,
            minimumPointsPerturbationThreshold,
        )
    }
    #[inline]
    pub unsafe fn setPlaneConvexMultipointIterations(
        &mut self,
        numPerturbationIterations: ::std::os::raw::c_int,
        minimumPointsPerturbationThreshold: ::std::os::raw::c_int,
    ) {
        btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations(
            self,
            numPerturbationIterations,
            minimumPointsPerturbationThreshold,
        )
    }
    #[inline]
    pub unsafe fn new(constructionInfo: *const btDefaultCollisionConstructionInfo) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDefaultCollisionConfiguration_btDefaultCollisionConfiguration(
            &mut __bindgen_tmp,
            constructionInfo,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN31btDefaultCollisionConfigurationD0Ev"]
    pub fn btDefaultCollisionConfiguration_btDefaultCollisionConfiguration_destructor(
        this: *mut btDefaultCollisionConfiguration,
    );
}
extern "C" {

    /// memory pools

    #[link_name = "\u{1}_ZN31btDefaultCollisionConfiguration25getPersistentManifoldPoolEv"]
    pub fn btDefaultCollisionConfiguration_getPersistentManifoldPool(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btPoolAllocator;
}
extern "C" {
    #[link_name = "\u{1}_ZN31btDefaultCollisionConfiguration25getCollisionAlgorithmPoolEv"]
    pub fn btDefaultCollisionConfiguration_getCollisionAlgorithmPool(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btPoolAllocator;
}
extern "C" {
    #[link_name = "\u{1}_ZN31btDefaultCollisionConfiguration31getCollisionAlgorithmCreateFuncEii"]
    pub fn btDefaultCollisionConfiguration_getCollisionAlgorithmCreateFunc(
        this: *mut ::std::os::raw::c_void,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
    ) -> *mut btCollisionAlgorithmCreateFunc;
}
extern "C" {
    #[link_name = "\u{1}_ZN31btDefaultCollisionConfiguration35getClosestPointsAlgorithmCreateFuncEii"]
    pub fn btDefaultCollisionConfiguration_getClosestPointsAlgorithmCreateFunc(
        this: *mut ::std::os::raw::c_void,
        proxyType0: ::std::os::raw::c_int,
        proxyType1: ::std::os::raw::c_int,
    ) -> *mut btCollisionAlgorithmCreateFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSimpleBroadphaseProxy {
    pub _base: btBroadphaseProxy,
    pub m_nextFree: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btSimpleBroadphaseProxy() {
    assert_eq!(
        ::std::mem::size_of::<btSimpleBroadphaseProxy>(),
        96usize,
        concat!("Size of: ", stringify!(btSimpleBroadphaseProxy))
    );
    assert_eq!(
        ::std::mem::align_of::<btSimpleBroadphaseProxy>(),
        8usize,
        concat!("Alignment of ", stringify!(btSimpleBroadphaseProxy))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSimpleBroadphaseProxy)).m_nextFree as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSimpleBroadphaseProxy),
            "::",
            stringify!(m_nextFree)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btSimpleBroadphaseProxy11SetNextFreeEi"]
    pub fn btSimpleBroadphaseProxy_SetNextFree(
        this: *mut btSimpleBroadphaseProxy,
        next: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btSimpleBroadphaseProxy11GetNextFreeEv"]
    pub fn btSimpleBroadphaseProxy_GetNextFree(
        this: *const btSimpleBroadphaseProxy,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btSimpleBroadphaseProxyC1Ev"]
    pub fn btSimpleBroadphaseProxy_btSimpleBroadphaseProxy(this: *mut btSimpleBroadphaseProxy);
}
extern "C" {
    #[link_name = "\u{1}_ZN23btSimpleBroadphaseProxyC1ERK9btVector3S2_iPvii"]
    pub fn btSimpleBroadphaseProxy_btSimpleBroadphaseProxy1(
        this: *mut btSimpleBroadphaseProxy,
        minpt: *const btVector3,
        maxpt: *const btVector3,
        shapeType: ::std::os::raw::c_int,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
impl btSimpleBroadphaseProxy {
    #[inline]
    pub unsafe fn SetNextFree(&mut self, next: ::std::os::raw::c_int) {
        btSimpleBroadphaseProxy_SetNextFree(self, next)
    }
    #[inline]
    pub unsafe fn GetNextFree(&self) -> ::std::os::raw::c_int {
        btSimpleBroadphaseProxy_GetNextFree(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSimpleBroadphaseProxy_btSimpleBroadphaseProxy(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        minpt: *const btVector3,
        maxpt: *const btVector3,
        shapeType: ::std::os::raw::c_int,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSimpleBroadphaseProxy_btSimpleBroadphaseProxy1(
            &mut __bindgen_tmp,
            minpt,
            maxpt,
            shapeType,
            userPtr,
            collisionFilterGroup,
            collisionFilterMask,
        );
        __bindgen_tmp
    }
}
/// The SimpleBroadphase is just a unit-test for btAxisSweep3, bt32BitAxisSweep3, or btDbvtBroadphase, so use those classes instead.
/// It is a brute force aabb culling broadphase based on O(n^2) aabb checks
#[repr(C)]
#[derive(Debug)]
pub struct btSimpleBroadphase {
    pub _base: btBroadphaseInterface,
    pub m_numHandles: ::std::os::raw::c_int,
    pub m_maxHandles: ::std::os::raw::c_int,
    pub m_LastHandleIndex: ::std::os::raw::c_int,
    pub m_pHandles: *mut btSimpleBroadphaseProxy,
    pub m_pHandlesRawPtr: *mut ::std::os::raw::c_void,
    pub m_firstFreeHandle: ::std::os::raw::c_int,
    pub m_pairCache: *mut btOverlappingPairCache,
    pub m_ownsPairCache: bool,
    pub m_invalidPair: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btSimpleBroadphase() {
    assert_eq!(
        ::std::mem::size_of::<btSimpleBroadphase>(),
        64usize,
        concat!("Size of: ", stringify!(btSimpleBroadphase))
    );
    assert_eq!(
        ::std::mem::align_of::<btSimpleBroadphase>(),
        8usize,
        concat!("Alignment of ", stringify!(btSimpleBroadphase))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSimpleBroadphase)).m_numHandles as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSimpleBroadphase),
            "::",
            stringify!(m_numHandles)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSimpleBroadphase)).m_maxHandles as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSimpleBroadphase),
            "::",
            stringify!(m_maxHandles)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSimpleBroadphase)).m_LastHandleIndex as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSimpleBroadphase),
            "::",
            stringify!(m_LastHandleIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSimpleBroadphase)).m_pHandles as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSimpleBroadphase),
            "::",
            stringify!(m_pHandles)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSimpleBroadphase)).m_pHandlesRawPtr as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSimpleBroadphase),
            "::",
            stringify!(m_pHandlesRawPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSimpleBroadphase)).m_firstFreeHandle as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSimpleBroadphase),
            "::",
            stringify!(m_firstFreeHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSimpleBroadphase)).m_pairCache as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSimpleBroadphase),
            "::",
            stringify!(m_pairCache)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSimpleBroadphase)).m_ownsPairCache as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSimpleBroadphase),
            "::",
            stringify!(m_ownsPairCache)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSimpleBroadphase)).m_invalidPair as *const _ as usize },
        60usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSimpleBroadphase),
            "::",
            stringify!(m_invalidPair)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphase11allocHandleEv"]
    pub fn btSimpleBroadphase_allocHandle(this: *mut btSimpleBroadphase) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphase10freeHandleEP23btSimpleBroadphaseProxy"]
    pub fn btSimpleBroadphase_freeHandle(
        this: *mut btSimpleBroadphase,
        proxy: *mut btSimpleBroadphaseProxy,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphase23getSimpleProxyFromProxyEP17btBroadphaseProxy"]
    pub fn btSimpleBroadphase_getSimpleProxyFromProxy(
        this: *mut btSimpleBroadphase,
        proxy: *mut btBroadphaseProxy,
    ) -> *mut btSimpleBroadphaseProxy;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btSimpleBroadphase23getSimpleProxyFromProxyEP17btBroadphaseProxy"]
    pub fn btSimpleBroadphase_getSimpleProxyFromProxy1(
        this: *const btSimpleBroadphase,
        proxy: *mut btBroadphaseProxy,
    ) -> *const btSimpleBroadphaseProxy;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphase8validateEv"]
    pub fn btSimpleBroadphase_validate(this: *mut btSimpleBroadphase);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphase11aabbOverlapEP23btSimpleBroadphaseProxyS1_"]
    pub fn btSimpleBroadphase_aabbOverlap(
        proxy0: *mut btSimpleBroadphaseProxy,
        proxy1: *mut btSimpleBroadphaseProxy,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphase15testAabbOverlapEP17btBroadphaseProxyS1_"]
    pub fn btSimpleBroadphase_testAabbOverlap(
        this: *mut btSimpleBroadphase,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphaseC1EiP22btOverlappingPairCache"]
    pub fn btSimpleBroadphase_btSimpleBroadphase(
        this: *mut btSimpleBroadphase,
        maxProxies: ::std::os::raw::c_int,
        overlappingPairCache: *mut btOverlappingPairCache,
    );
}
impl btSimpleBroadphase {
    #[inline]
    pub unsafe fn allocHandle(&mut self) -> ::std::os::raw::c_int {
        btSimpleBroadphase_allocHandle(self)
    }
    #[inline]
    pub unsafe fn freeHandle(&mut self, proxy: *mut btSimpleBroadphaseProxy) {
        btSimpleBroadphase_freeHandle(self, proxy)
    }
    #[inline]
    pub unsafe fn getSimpleProxyFromProxy(
        &mut self,
        proxy: *mut btBroadphaseProxy,
    ) -> *mut btSimpleBroadphaseProxy {
        btSimpleBroadphase_getSimpleProxyFromProxy(self, proxy)
    }
    #[inline]
    pub unsafe fn getSimpleProxyFromProxy1(
        &self,
        proxy: *mut btBroadphaseProxy,
    ) -> *const btSimpleBroadphaseProxy {
        btSimpleBroadphase_getSimpleProxyFromProxy1(self, proxy)
    }
    #[inline]
    pub unsafe fn validate(&mut self) {
        btSimpleBroadphase_validate(self)
    }
    #[inline]
    pub unsafe fn aabbOverlap(
        proxy0: *mut btSimpleBroadphaseProxy,
        proxy1: *mut btSimpleBroadphaseProxy,
    ) -> bool {
        btSimpleBroadphase_aabbOverlap(proxy0, proxy1)
    }
    #[inline]
    pub unsafe fn testAabbOverlap(
        &mut self,
        proxy0: *mut btBroadphaseProxy,
        proxy1: *mut btBroadphaseProxy,
    ) -> bool {
        btSimpleBroadphase_testAabbOverlap(self, proxy0, proxy1)
    }
    #[inline]
    pub unsafe fn new(
        maxProxies: ::std::os::raw::c_int,
        overlappingPairCache: *mut btOverlappingPairCache,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSimpleBroadphase_btSimpleBroadphase(&mut __bindgen_tmp, maxProxies, overlappingPairCache);
        __bindgen_tmp
    }
}
extern "C" {

    /// reset broadphase internal structures, to ensure determinism/reproducability

    #[link_name = "\u{1}_ZN18btSimpleBroadphase9resetPoolEP12btDispatcher"]
    pub fn btSimpleBroadphase_resetPool(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphaseD0Ev"]
    pub fn btSimpleBroadphase_btSimpleBroadphase_destructor(this: *mut btSimpleBroadphase);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphase11createProxyERK9btVector3S2_iPviiP12btDispatcher"]
    pub fn btSimpleBroadphase_createProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        shapeType: ::std::os::raw::c_int,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
        dispatcher: *mut btDispatcher,
    ) -> *mut btBroadphaseProxy;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphase25calculateOverlappingPairsEP12btDispatcher"]
    pub fn btSimpleBroadphase_calculateOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphase12destroyProxyEP17btBroadphaseProxyP12btDispatcher"]
    pub fn btSimpleBroadphase_destroyProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphase7setAabbEP17btBroadphaseProxyRK9btVector3S4_P12btDispatcher"]
    pub fn btSimpleBroadphase_setAabb(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btSimpleBroadphase7getAabbEP17btBroadphaseProxyR9btVector3S3_"]
    pub fn btSimpleBroadphase_getAabb(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphase7rayTestERK9btVector3S2_R23btBroadphaseRayCallbackS2_S2_"]
    pub fn btSimpleBroadphase_rayTest(
        this: *mut ::std::os::raw::c_void,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        rayCallback: *mut btBroadphaseRayCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphase8aabbTestERK9btVector3S2_R24btBroadphaseAabbCallback"]
    pub fn btSimpleBroadphase_aabbTest(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        callback: *mut btBroadphaseAabbCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphase23getOverlappingPairCacheEv"]
    pub fn btSimpleBroadphase_getOverlappingPairCache(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btOverlappingPairCache;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btSimpleBroadphase23getOverlappingPairCacheEv"]
    pub fn btSimpleBroadphase_getOverlappingPairCache1(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btOverlappingPairCache;
}
extern "C" {

    /// getAabb returns the axis aligned bounding box in the 'global' coordinate frame
    /// ///will add some transform later

    #[link_name = "\u{1}_ZNK18btSimpleBroadphase17getBroadphaseAabbER9btVector3S1_"]
    pub fn btSimpleBroadphase_getBroadphaseAabb(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSimpleBroadphase10printStatsEv"]
    pub fn btSimpleBroadphase_printStats(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDbvtAabbMm {
    pub mi: btVector3,
    pub mx: btVector3,
}
#[test]
fn bindgen_test_layout_btDbvtAabbMm() {
    assert_eq!(
        ::std::mem::size_of::<btDbvtAabbMm>(),
        64usize,
        concat!("Size of: ", stringify!(btDbvtAabbMm))
    );
    assert_eq!(
        ::std::mem::align_of::<btDbvtAabbMm>(),
        8usize,
        concat!("Alignment of ", stringify!(btDbvtAabbMm))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtAabbMm)).mi as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtAabbMm),
            "::",
            stringify!(mi)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtAabbMm)).mx as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtAabbMm),
            "::",
            stringify!(mx)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btDbvtAabbMm6CenterEv"]
    pub fn btDbvtAabbMm_Center(this: *const btDbvtAabbMm) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btDbvtAabbMm7LengthsEv"]
    pub fn btDbvtAabbMm_Lengths(this: *const btDbvtAabbMm) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btDbvtAabbMm7ExtentsEv"]
    pub fn btDbvtAabbMm_Extents(this: *const btDbvtAabbMm) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btDbvtAabbMm4MinsEv"]
    pub fn btDbvtAabbMm_Mins(this: *const btDbvtAabbMm) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btDbvtAabbMm4MaxsEv"]
    pub fn btDbvtAabbMm_Maxs(this: *const btDbvtAabbMm) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDbvtAabbMm6FromCEERK9btVector3S2_"]
    pub fn btDbvtAabbMm_FromCE(c: *const btVector3, e: *const btVector3) -> btDbvtAabbMm;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDbvtAabbMm6FromCRERK9btVector3d"]
    pub fn btDbvtAabbMm_FromCR(c: *const btVector3, r: btScalar) -> btDbvtAabbMm;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDbvtAabbMm6FromMMERK9btVector3S2_"]
    pub fn btDbvtAabbMm_FromMM(mi: *const btVector3, mx: *const btVector3) -> btDbvtAabbMm;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDbvtAabbMm10FromPointsEPK9btVector3i"]
    pub fn btDbvtAabbMm_FromPoints(pts: *const btVector3, n: ::std::os::raw::c_int)
        -> btDbvtAabbMm;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDbvtAabbMm10FromPointsEPPK9btVector3i"]
    pub fn btDbvtAabbMm_FromPoints1(
        ppts: *mut *const btVector3,
        n: ::std::os::raw::c_int,
    ) -> btDbvtAabbMm;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDbvtAabbMm6ExpandERK9btVector3"]
    pub fn btDbvtAabbMm_Expand(this: *mut btDbvtAabbMm, e: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDbvtAabbMm12SignedExpandERK9btVector3"]
    pub fn btDbvtAabbMm_SignedExpand(this: *mut btDbvtAabbMm, e: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btDbvtAabbMm7ContainERKS_"]
    pub fn btDbvtAabbMm_Contain(this: *const btDbvtAabbMm, a: *const btDbvtAabbMm) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btDbvtAabbMm8ClassifyERK9btVector3di"]
    pub fn btDbvtAabbMm_Classify(
        this: *const btDbvtAabbMm,
        n: *const btVector3,
        o: btScalar,
        s: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btDbvtAabbMm14ProjectMinimumERK9btVector3j"]
    pub fn btDbvtAabbMm_ProjectMinimum(
        this: *const btDbvtAabbMm,
        v: *const btVector3,
        signs: ::std::os::raw::c_uint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDbvtAabbMm5tMinsEv"]
    pub fn btDbvtAabbMm_tMins(this: *mut btDbvtAabbMm) -> *mut btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btDbvtAabbMm5tMaxsEv"]
    pub fn btDbvtAabbMm_tMaxs(this: *mut btDbvtAabbMm) -> *mut btVector3;
}
impl btDbvtAabbMm {
    #[inline]
    pub unsafe fn Center(&self) -> btVector3 {
        btDbvtAabbMm_Center(self)
    }
    #[inline]
    pub unsafe fn Lengths(&self) -> btVector3 {
        btDbvtAabbMm_Lengths(self)
    }
    #[inline]
    pub unsafe fn Extents(&self) -> btVector3 {
        btDbvtAabbMm_Extents(self)
    }
    #[inline]
    pub unsafe fn Mins(&self) -> *const btVector3 {
        btDbvtAabbMm_Mins(self)
    }
    #[inline]
    pub unsafe fn Maxs(&self) -> *const btVector3 {
        btDbvtAabbMm_Maxs(self)
    }
    #[inline]
    pub unsafe fn FromCE(c: *const btVector3, e: *const btVector3) -> btDbvtAabbMm {
        btDbvtAabbMm_FromCE(c, e)
    }
    #[inline]
    pub unsafe fn FromCR(c: *const btVector3, r: btScalar) -> btDbvtAabbMm {
        btDbvtAabbMm_FromCR(c, r)
    }
    #[inline]
    pub unsafe fn FromMM(mi: *const btVector3, mx: *const btVector3) -> btDbvtAabbMm {
        btDbvtAabbMm_FromMM(mi, mx)
    }
    #[inline]
    pub unsafe fn FromPoints(pts: *const btVector3, n: ::std::os::raw::c_int) -> btDbvtAabbMm {
        btDbvtAabbMm_FromPoints(pts, n)
    }
    #[inline]
    pub unsafe fn FromPoints1(
        ppts: *mut *const btVector3,
        n: ::std::os::raw::c_int,
    ) -> btDbvtAabbMm {
        btDbvtAabbMm_FromPoints1(ppts, n)
    }
    #[inline]
    pub unsafe fn Expand(&mut self, e: *const btVector3) {
        btDbvtAabbMm_Expand(self, e)
    }
    #[inline]
    pub unsafe fn SignedExpand(&mut self, e: *const btVector3) {
        btDbvtAabbMm_SignedExpand(self, e)
    }
    #[inline]
    pub unsafe fn Contain(&self, a: *const btDbvtAabbMm) -> bool {
        btDbvtAabbMm_Contain(self, a)
    }
    #[inline]
    pub unsafe fn Classify(
        &self,
        n: *const btVector3,
        o: btScalar,
        s: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btDbvtAabbMm_Classify(self, n, o, s)
    }
    #[inline]
    pub unsafe fn ProjectMinimum(
        &self,
        v: *const btVector3,
        signs: ::std::os::raw::c_uint,
    ) -> btScalar {
        btDbvtAabbMm_ProjectMinimum(self, v, signs)
    }
    #[inline]
    pub unsafe fn tMins(&mut self) -> *mut btVector3 {
        btDbvtAabbMm_tMins(self)
    }
    #[inline]
    pub unsafe fn tMaxs(&mut self) -> *mut btVector3 {
        btDbvtAabbMm_tMaxs(self)
    }
}
pub type btDbvtVolume = btDbvtAabbMm;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btDbvtNode {
    pub volume: btDbvtVolume,
    pub parent: *mut btDbvtNode,
    pub __bindgen_anon_1: btDbvtNode__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btDbvtNode__bindgen_ty_1 {
    pub childs: [*mut btDbvtNode; 2usize],
    pub data: *mut ::std::os::raw::c_void,
    pub dataAsInt: ::std::os::raw::c_int,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_btDbvtNode__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btDbvtNode__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(btDbvtNode__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<btDbvtNode__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(btDbvtNode__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtNode__bindgen_ty_1)).childs as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtNode__bindgen_ty_1),
            "::",
            stringify!(childs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtNode__bindgen_ty_1)).data as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtNode__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtNode__bindgen_ty_1)).dataAsInt as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtNode__bindgen_ty_1),
            "::",
            stringify!(dataAsInt)
        )
    );
}
#[test]
fn bindgen_test_layout_btDbvtNode() {
    assert_eq!(
        ::std::mem::size_of::<btDbvtNode>(),
        88usize,
        concat!("Size of: ", stringify!(btDbvtNode))
    );
    assert_eq!(
        ::std::mem::align_of::<btDbvtNode>(),
        8usize,
        concat!("Alignment of ", stringify!(btDbvtNode))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtNode)).volume as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtNode),
            "::",
            stringify!(volume)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtNode)).parent as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtNode),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btDbvtNode6isleafEv"]
    pub fn btDbvtNode_isleaf(this: *const btDbvtNode) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK10btDbvtNode10isinternalEv"]
    pub fn btDbvtNode_isinternal(this: *const btDbvtNode) -> bool;
}
impl btDbvtNode {
    #[inline]
    pub unsafe fn isleaf(&self) -> bool {
        btDbvtNode_isleaf(self)
    }
    #[inline]
    pub unsafe fn isinternal(&self) -> bool {
        btDbvtNode_isinternal(self)
    }
}
pub type btNodeStack = btAlignedObjectArray<*const btDbvtNode>;
/// The btDbvt class implements a fast dynamic bounding volume tree based on axis aligned bounding boxes (aabb tree).
/// This btDbvt is used for soft body collision detection and for the btDbvtBroadphase. It has a fast insert, remove and update of nodes.
/// Unlike the btQuantizedBvh, nodes can be dynamically moved around, which allows for change in topology of the underlying data structure.
#[repr(C)]
#[derive(Debug)]
pub struct btDbvt {
    pub m_root: *mut btDbvtNode,
    pub m_free: *mut btDbvtNode,
    pub m_lkhd: ::std::os::raw::c_int,
    pub m_leaves: ::std::os::raw::c_int,
    pub m_opath: ::std::os::raw::c_uint,
    pub m_stkStack: btAlignedObjectArray<btDbvt_sStkNN>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDbvt_sStkNN {
    pub a: *const btDbvtNode,
    pub b: *const btDbvtNode,
}
#[test]
fn bindgen_test_layout_btDbvt_sStkNN() {
    assert_eq!(
        ::std::mem::size_of::<btDbvt_sStkNN>(),
        16usize,
        concat!("Size of: ", stringify!(btDbvt_sStkNN))
    );
    assert_eq!(
        ::std::mem::align_of::<btDbvt_sStkNN>(),
        8usize,
        concat!("Alignment of ", stringify!(btDbvt_sStkNN))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt_sStkNN)).a as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt_sStkNN),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt_sStkNN)).b as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt_sStkNN),
            "::",
            stringify!(b)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt6sStkNNC1Ev"]
    pub fn btDbvt_sStkNN_sStkNN(this: *mut btDbvt_sStkNN);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt6sStkNNC1EPK10btDbvtNodeS3_"]
    pub fn btDbvt_sStkNN_sStkNN1(
        this: *mut btDbvt_sStkNN,
        na: *const btDbvtNode,
        nb: *const btDbvtNode,
    );
}
impl btDbvt_sStkNN {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDbvt_sStkNN_sStkNN(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(na: *const btDbvtNode, nb: *const btDbvtNode) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDbvt_sStkNN_sStkNN1(&mut __bindgen_tmp, na, nb);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDbvt_sStkNP {
    pub node: *const btDbvtNode,
    pub mask: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btDbvt_sStkNP() {
    assert_eq!(
        ::std::mem::size_of::<btDbvt_sStkNP>(),
        16usize,
        concat!("Size of: ", stringify!(btDbvt_sStkNP))
    );
    assert_eq!(
        ::std::mem::align_of::<btDbvt_sStkNP>(),
        8usize,
        concat!("Alignment of ", stringify!(btDbvt_sStkNP))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt_sStkNP)).node as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt_sStkNP),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt_sStkNP)).mask as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt_sStkNP),
            "::",
            stringify!(mask)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt6sStkNPC1EPK10btDbvtNodej"]
    pub fn btDbvt_sStkNP_sStkNP(
        this: *mut btDbvt_sStkNP,
        n: *const btDbvtNode,
        m: ::std::os::raw::c_uint,
    );
}
impl btDbvt_sStkNP {
    #[inline]
    pub unsafe fn new(n: *const btDbvtNode, m: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDbvt_sStkNP_sStkNP(&mut __bindgen_tmp, n, m);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDbvt_sStkNPS {
    pub node: *const btDbvtNode,
    pub mask: ::std::os::raw::c_int,
    pub value: btScalar,
}
#[test]
fn bindgen_test_layout_btDbvt_sStkNPS() {
    assert_eq!(
        ::std::mem::size_of::<btDbvt_sStkNPS>(),
        24usize,
        concat!("Size of: ", stringify!(btDbvt_sStkNPS))
    );
    assert_eq!(
        ::std::mem::align_of::<btDbvt_sStkNPS>(),
        8usize,
        concat!("Alignment of ", stringify!(btDbvt_sStkNPS))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt_sStkNPS)).node as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt_sStkNPS),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt_sStkNPS)).mask as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt_sStkNPS),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt_sStkNPS)).value as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt_sStkNPS),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt7sStkNPSC1Ev"]
    pub fn btDbvt_sStkNPS_sStkNPS(this: *mut btDbvt_sStkNPS);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt7sStkNPSC1EPK10btDbvtNodejd"]
    pub fn btDbvt_sStkNPS_sStkNPS1(
        this: *mut btDbvt_sStkNPS,
        n: *const btDbvtNode,
        m: ::std::os::raw::c_uint,
        v: btScalar,
    );
}
impl btDbvt_sStkNPS {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDbvt_sStkNPS_sStkNPS(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(n: *const btDbvtNode, m: ::std::os::raw::c_uint, v: btScalar) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDbvt_sStkNPS_sStkNPS1(&mut __bindgen_tmp, n, m, v);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDbvt_sStkCLN {
    pub node: *const btDbvtNode,
    pub parent: *mut btDbvtNode,
}
#[test]
fn bindgen_test_layout_btDbvt_sStkCLN() {
    assert_eq!(
        ::std::mem::size_of::<btDbvt_sStkCLN>(),
        16usize,
        concat!("Size of: ", stringify!(btDbvt_sStkCLN))
    );
    assert_eq!(
        ::std::mem::align_of::<btDbvt_sStkCLN>(),
        8usize,
        concat!("Alignment of ", stringify!(btDbvt_sStkCLN))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt_sStkCLN)).node as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt_sStkCLN),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt_sStkCLN)).parent as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt_sStkCLN),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt7sStkCLNC1EPK10btDbvtNodePS1_"]
    pub fn btDbvt_sStkCLN_sStkCLN(
        this: *mut btDbvt_sStkCLN,
        n: *const btDbvtNode,
        p: *mut btDbvtNode,
    );
}
impl btDbvt_sStkCLN {
    #[inline]
    pub unsafe fn new(n: *const btDbvtNode, p: *mut btDbvtNode) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDbvt_sStkCLN_sStkCLN(&mut __bindgen_tmp, n, p);
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct btDbvt_ICollide__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btDbvt_ICollide {
    pub vtable_: *const btDbvt_ICollide__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btDbvt_ICollide() {
    assert_eq!(
        ::std::mem::size_of::<btDbvt_ICollide>(),
        8usize,
        concat!("Size of: ", stringify!(btDbvt_ICollide))
    );
    assert_eq!(
        ::std::mem::align_of::<btDbvt_ICollide>(),
        8usize,
        concat!("Alignment of ", stringify!(btDbvt_ICollide))
    );
}
#[repr(C)]
pub struct btDbvt_IWriter__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btDbvt_IWriter {
    pub vtable_: *const btDbvt_IWriter__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btDbvt_IWriter() {
    assert_eq!(
        ::std::mem::size_of::<btDbvt_IWriter>(),
        8usize,
        concat!("Size of: ", stringify!(btDbvt_IWriter))
    );
    assert_eq!(
        ::std::mem::align_of::<btDbvt_IWriter>(),
        8usize,
        concat!("Alignment of ", stringify!(btDbvt_IWriter))
    );
}
#[repr(C)]
pub struct btDbvt_IClone__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btDbvt_IClone {
    pub vtable_: *const btDbvt_IClone__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btDbvt_IClone() {
    assert_eq!(
        ::std::mem::size_of::<btDbvt_IClone>(),
        8usize,
        concat!("Size of: ", stringify!(btDbvt_IClone))
    );
    assert_eq!(
        ::std::mem::align_of::<btDbvt_IClone>(),
        8usize,
        concat!("Alignment of ", stringify!(btDbvt_IClone))
    );
}
pub const btDbvt_SIMPLE_STACKSIZE: btDbvt__bindgen_ty_1 = 64;
pub const btDbvt_DOUBLE_STACKSIZE: btDbvt__bindgen_ty_1 = 128;
pub type btDbvt__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_btDbvt() {
    assert_eq!(
        ::std::mem::size_of::<btDbvt>(),
        64usize,
        concat!("Size of: ", stringify!(btDbvt))
    );
    assert_eq!(
        ::std::mem::align_of::<btDbvt>(),
        8usize,
        concat!("Alignment of ", stringify!(btDbvt))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt)).m_root as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt),
            "::",
            stringify!(m_root)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt)).m_free as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt),
            "::",
            stringify!(m_free)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt)).m_lkhd as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt),
            "::",
            stringify!(m_lkhd)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt)).m_leaves as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt),
            "::",
            stringify!(m_leaves)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt)).m_opath as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt),
            "::",
            stringify!(m_opath)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvt)).m_stkStack as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvt),
            "::",
            stringify!(m_stkStack)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt5clearEv"]
    pub fn btDbvt_clear(this: *mut btDbvt);
}
extern "C" {
    #[link_name = "\u{1}_ZNK6btDbvt5emptyEv"]
    pub fn btDbvt_empty(this: *const btDbvt) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt16optimizeBottomUpEv"]
    pub fn btDbvt_optimizeBottomUp(this: *mut btDbvt);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt15optimizeTopDownEi"]
    pub fn btDbvt_optimizeTopDown(this: *mut btDbvt, bu_treshold: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt19optimizeIncrementalEi"]
    pub fn btDbvt_optimizeIncremental(this: *mut btDbvt, passes: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt6insertERK12btDbvtAabbMmPv"]
    pub fn btDbvt_insert(
        this: *mut btDbvt,
        box_: *const btDbvtVolume,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut btDbvtNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt6updateEP10btDbvtNodei"]
    pub fn btDbvt_update(
        this: *mut btDbvt,
        leaf: *mut btDbvtNode,
        lookahead: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt6updateEP10btDbvtNodeR12btDbvtAabbMm"]
    pub fn btDbvt_update1(this: *mut btDbvt, leaf: *mut btDbvtNode, volume: *mut btDbvtVolume);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt6updateEP10btDbvtNodeR12btDbvtAabbMmRK9btVector3d"]
    pub fn btDbvt_update2(
        this: *mut btDbvt,
        leaf: *mut btDbvtNode,
        volume: *mut btDbvtVolume,
        velocity: *const btVector3,
        margin: btScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt6updateEP10btDbvtNodeR12btDbvtAabbMmRK9btVector3"]
    pub fn btDbvt_update3(
        this: *mut btDbvt,
        leaf: *mut btDbvtNode,
        volume: *mut btDbvtVolume,
        velocity: *const btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt6updateEP10btDbvtNodeR12btDbvtAabbMmd"]
    pub fn btDbvt_update4(
        this: *mut btDbvt,
        leaf: *mut btDbvtNode,
        volume: *mut btDbvtVolume,
        margin: btScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt6removeEP10btDbvtNode"]
    pub fn btDbvt_remove(this: *mut btDbvt, leaf: *mut btDbvtNode);
}
extern "C" {
    #[link_name = "\u{1}_ZNK6btDbvt5writeEPNS_7IWriterE"]
    pub fn btDbvt_write(this: *const btDbvt, iwriter: *mut btDbvt_IWriter);
}
extern "C" {
    #[link_name = "\u{1}_ZNK6btDbvt5cloneERS_PNS_6ICloneE"]
    pub fn btDbvt_clone(this: *const btDbvt, dest: *mut btDbvt, iclone: *mut btDbvt_IClone);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt8maxdepthEPK10btDbvtNode"]
    pub fn btDbvt_maxdepth(node: *const btDbvtNode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt11countLeavesEPK10btDbvtNode"]
    pub fn btDbvt_countLeaves(node: *const btDbvtNode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt13extractLeavesEPK10btDbvtNodeR20btAlignedObjectArrayIS2_E"]
    pub fn btDbvt_extractLeaves(
        node: *const btDbvtNode,
        leaves: *mut btAlignedObjectArray<*const btDbvtNode>,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt9benchmarkEv"]
    pub fn btDbvt_benchmark();
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt9enumNodesEPK10btDbvtNodeRNS_8ICollideE"]
    pub fn btDbvt_enumNodes(root: *const btDbvtNode, policy: *mut btDbvt_ICollide);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt10enumLeavesEPK10btDbvtNodeRNS_8ICollideE"]
    pub fn btDbvt_enumLeaves(root: *const btDbvtNode, policy: *mut btDbvt_ICollide);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt9collideTTEPK10btDbvtNodeS2_RNS_8ICollideE"]
    pub fn btDbvt_collideTT(
        this: *mut btDbvt,
        root0: *const btDbvtNode,
        root1: *const btDbvtNode,
        policy: *mut btDbvt_ICollide,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt24collideTTpersistentStackEPK10btDbvtNodeS2_RNS_8ICollideE"]
    pub fn btDbvt_collideTTpersistentStack(
        this: *mut btDbvt,
        root0: *const btDbvtNode,
        root1: *const btDbvtNode,
        policy: *mut btDbvt_ICollide,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK6btDbvt9collideTVEPK10btDbvtNodeRK12btDbvtAabbMmRNS_8ICollideE"]
    pub fn btDbvt_collideTV(
        this: *const btDbvt,
        root: *const btDbvtNode,
        volume: *const btDbvtVolume,
        policy: *mut btDbvt_ICollide,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK6btDbvt21collideTVNoStackAllocEPK10btDbvtNodeRK12btDbvtAabbMmR20btAlignedObjectArrayIS2_ERNS_8ICollideE"]
    pub fn btDbvt_collideTVNoStackAlloc(
        this: *const btDbvt,
        root: *const btDbvtNode,
        volume: *const btDbvtVolume,
        stack: *mut btNodeStack,
        policy: *mut btDbvt_ICollide,
    );
}
extern "C" {

    /// rayTest is a re-entrant ray test, and can be called in parallel as long as the btAlignedAlloc is thread-safe (uses locking etc)
    /// ///rayTest is slower than rayTestInternal, because it builds a local stack, using memory allocations, and it recomputes signs/rayDirectionInverses each time

    #[link_name = "\u{1}_ZN6btDbvt7rayTestEPK10btDbvtNodeRK9btVector3S5_RNS_8ICollideE"]
    pub fn btDbvt_rayTest(
        root: *const btDbvtNode,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        policy: *mut btDbvt_ICollide,
    );
}
extern "C" {

    /// rayTestInternal is faster than rayTest, because it uses a persistent stack (to reduce dynamic memory allocations to a minimum) and it uses precomputed signs/rayInverseDirections
    /// ///rayTestInternal is used by btDbvtBroadphase to accelerate world ray casts

    #[link_name = "\u{1}_ZNK6btDbvt15rayTestInternalEPK10btDbvtNodeRK9btVector3S5_S5_PjdS5_S5_R20btAlignedObjectArrayIS2_ERNS_8ICollideE"]
    pub fn btDbvt_rayTestInternal(
        this: *const btDbvt,
        root: *const btDbvtNode,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        rayDirectionInverse: *const btVector3,
        signs: *mut ::std::os::raw::c_uint,
        lambda_max: btScalar,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        stack: *mut btAlignedObjectArray<*const btDbvtNode>,
        policy: *mut btDbvt_ICollide,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt11collideKDOPEPK10btDbvtNodePK9btVector3PKdiRNS_8ICollideE"]
    pub fn btDbvt_collideKDOP(
        root: *const btDbvtNode,
        normals: *const btVector3,
        offsets: *const btScalar,
        count: ::std::os::raw::c_int,
        policy: *mut btDbvt_ICollide,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt10collideOCLEPK10btDbvtNodePK9btVector3PKdRS4_iRNS_8ICollideEb"]
    pub fn btDbvt_collideOCL(
        root: *const btDbvtNode,
        normals: *const btVector3,
        offsets: *const btScalar,
        sortaxis: *const btVector3,
        count: ::std::os::raw::c_int,
        policy: *mut btDbvt_ICollide,
        fullsort: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt9collideTUEPK10btDbvtNodeRNS_8ICollideE"]
    pub fn btDbvt_collideTU(root: *const btDbvtNode, policy: *mut btDbvt_ICollide);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt7nearestEPKiPKNS_7sStkNPSEdii"]
    pub fn btDbvt_nearest(
        i: *const ::std::os::raw::c_int,
        a: *const btDbvt_sStkNPS,
        v: btScalar,
        l: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt8allocateER20btAlignedObjectArrayIiERS0_INS_7sStkNPSEERKS3_"]
    pub fn btDbvt_allocate(
        ifree: *mut btAlignedObjectArray<::std::os::raw::c_int>,
        stock: *mut btAlignedObjectArray<btDbvt_sStkNPS>,
        value: *const btDbvt_sStkNPS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvtC1Ev"]
    pub fn btDbvt_btDbvt(this: *mut btDbvt);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvtD1Ev"]
    pub fn btDbvt_btDbvt_destructor(this: *mut btDbvt);
}
impl btDbvt {
    #[inline]
    pub unsafe fn clear(&mut self) {
        btDbvt_clear(self)
    }
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        btDbvt_empty(self)
    }
    #[inline]
    pub unsafe fn optimizeBottomUp(&mut self) {
        btDbvt_optimizeBottomUp(self)
    }
    #[inline]
    pub unsafe fn optimizeTopDown(&mut self, bu_treshold: ::std::os::raw::c_int) {
        btDbvt_optimizeTopDown(self, bu_treshold)
    }
    #[inline]
    pub unsafe fn optimizeIncremental(&mut self, passes: ::std::os::raw::c_int) {
        btDbvt_optimizeIncremental(self, passes)
    }
    #[inline]
    pub unsafe fn insert(
        &mut self,
        box_: *const btDbvtVolume,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut btDbvtNode {
        btDbvt_insert(self, box_, data)
    }
    #[inline]
    pub unsafe fn update(&mut self, leaf: *mut btDbvtNode, lookahead: ::std::os::raw::c_int) {
        btDbvt_update(self, leaf, lookahead)
    }
    #[inline]
    pub unsafe fn update1(&mut self, leaf: *mut btDbvtNode, volume: *mut btDbvtVolume) {
        btDbvt_update1(self, leaf, volume)
    }
    #[inline]
    pub unsafe fn update2(
        &mut self,
        leaf: *mut btDbvtNode,
        volume: *mut btDbvtVolume,
        velocity: *const btVector3,
        margin: btScalar,
    ) -> bool {
        btDbvt_update2(self, leaf, volume, velocity, margin)
    }
    #[inline]
    pub unsafe fn update3(
        &mut self,
        leaf: *mut btDbvtNode,
        volume: *mut btDbvtVolume,
        velocity: *const btVector3,
    ) -> bool {
        btDbvt_update3(self, leaf, volume, velocity)
    }
    #[inline]
    pub unsafe fn update4(
        &mut self,
        leaf: *mut btDbvtNode,
        volume: *mut btDbvtVolume,
        margin: btScalar,
    ) -> bool {
        btDbvt_update4(self, leaf, volume, margin)
    }
    #[inline]
    pub unsafe fn remove(&mut self, leaf: *mut btDbvtNode) {
        btDbvt_remove(self, leaf)
    }
    #[inline]
    pub unsafe fn write(&self, iwriter: *mut btDbvt_IWriter) {
        btDbvt_write(self, iwriter)
    }
    #[inline]
    pub unsafe fn clone(&self, dest: *mut btDbvt, iclone: *mut btDbvt_IClone) {
        btDbvt_clone(self, dest, iclone)
    }
    #[inline]
    pub unsafe fn maxdepth(node: *const btDbvtNode) -> ::std::os::raw::c_int {
        btDbvt_maxdepth(node)
    }
    #[inline]
    pub unsafe fn countLeaves(node: *const btDbvtNode) -> ::std::os::raw::c_int {
        btDbvt_countLeaves(node)
    }
    #[inline]
    pub unsafe fn extractLeaves(
        node: *const btDbvtNode,
        leaves: *mut btAlignedObjectArray<*const btDbvtNode>,
    ) {
        btDbvt_extractLeaves(node, leaves)
    }
    #[inline]
    pub unsafe fn benchmark() {
        btDbvt_benchmark()
    }
    #[inline]
    pub unsafe fn enumNodes(root: *const btDbvtNode, policy: *mut btDbvt_ICollide) {
        btDbvt_enumNodes(root, policy)
    }
    #[inline]
    pub unsafe fn enumLeaves(root: *const btDbvtNode, policy: *mut btDbvt_ICollide) {
        btDbvt_enumLeaves(root, policy)
    }
    #[inline]
    pub unsafe fn collideTT(
        &mut self,
        root0: *const btDbvtNode,
        root1: *const btDbvtNode,
        policy: *mut btDbvt_ICollide,
    ) {
        btDbvt_collideTT(self, root0, root1, policy)
    }
    #[inline]
    pub unsafe fn collideTTpersistentStack(
        &mut self,
        root0: *const btDbvtNode,
        root1: *const btDbvtNode,
        policy: *mut btDbvt_ICollide,
    ) {
        btDbvt_collideTTpersistentStack(self, root0, root1, policy)
    }
    #[inline]
    pub unsafe fn collideTV(
        &self,
        root: *const btDbvtNode,
        volume: *const btDbvtVolume,
        policy: *mut btDbvt_ICollide,
    ) {
        btDbvt_collideTV(self, root, volume, policy)
    }
    #[inline]
    pub unsafe fn collideTVNoStackAlloc(
        &self,
        root: *const btDbvtNode,
        volume: *const btDbvtVolume,
        stack: *mut btNodeStack,
        policy: *mut btDbvt_ICollide,
    ) {
        btDbvt_collideTVNoStackAlloc(self, root, volume, stack, policy)
    }
    #[inline]
    pub unsafe fn rayTest(
        root: *const btDbvtNode,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        policy: *mut btDbvt_ICollide,
    ) {
        btDbvt_rayTest(root, rayFrom, rayTo, policy)
    }
    #[inline]
    pub unsafe fn rayTestInternal(
        &self,
        root: *const btDbvtNode,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        rayDirectionInverse: *const btVector3,
        signs: *mut ::std::os::raw::c_uint,
        lambda_max: btScalar,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        stack: *mut btAlignedObjectArray<*const btDbvtNode>,
        policy: *mut btDbvt_ICollide,
    ) {
        btDbvt_rayTestInternal(
            self,
            root,
            rayFrom,
            rayTo,
            rayDirectionInverse,
            signs,
            lambda_max,
            aabbMin,
            aabbMax,
            stack,
            policy,
        )
    }
    #[inline]
    pub unsafe fn collideKDOP(
        root: *const btDbvtNode,
        normals: *const btVector3,
        offsets: *const btScalar,
        count: ::std::os::raw::c_int,
        policy: *mut btDbvt_ICollide,
    ) {
        btDbvt_collideKDOP(root, normals, offsets, count, policy)
    }
    #[inline]
    pub unsafe fn collideOCL(
        root: *const btDbvtNode,
        normals: *const btVector3,
        offsets: *const btScalar,
        sortaxis: *const btVector3,
        count: ::std::os::raw::c_int,
        policy: *mut btDbvt_ICollide,
        fullsort: bool,
    ) {
        btDbvt_collideOCL(root, normals, offsets, sortaxis, count, policy, fullsort)
    }
    #[inline]
    pub unsafe fn collideTU(root: *const btDbvtNode, policy: *mut btDbvt_ICollide) {
        btDbvt_collideTU(root, policy)
    }
    #[inline]
    pub unsafe fn nearest(
        i: *const ::std::os::raw::c_int,
        a: *const btDbvt_sStkNPS,
        v: btScalar,
        l: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btDbvt_nearest(i, a, v, l, h)
    }
    #[inline]
    pub unsafe fn allocate(
        ifree: *mut btAlignedObjectArray<::std::os::raw::c_int>,
        stock: *mut btAlignedObjectArray<btDbvt_sStkNPS>,
        value: *const btDbvt_sStkNPS,
    ) -> ::std::os::raw::c_int {
        btDbvt_allocate(ifree, stock, value)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDbvt_btDbvt(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        btDbvt_btDbvt_destructor(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt8ICollideD0Ev"]
    pub fn btDbvt_ICollide_ICollide_destructor(this: *mut btDbvt_ICollide);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt8ICollide7ProcessEPK10btDbvtNodeS3_"]
    pub fn btDbvt_ICollide_Process(
        this: *mut ::std::os::raw::c_void,
        arg1: *const btDbvtNode,
        arg2: *const btDbvtNode,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt8ICollide7ProcessEPK10btDbvtNode"]
    pub fn btDbvt_ICollide_Process1(this: *mut ::std::os::raw::c_void, arg1: *const btDbvtNode);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt8ICollide7ProcessEPK10btDbvtNoded"]
    pub fn btDbvt_ICollide_Process2(
        this: *mut ::std::os::raw::c_void,
        n: *const btDbvtNode,
        arg1: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt8ICollide7DescentEPK10btDbvtNode"]
    pub fn btDbvt_ICollide_Descent(
        this: *mut ::std::os::raw::c_void,
        arg1: *const btDbvtNode,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt8ICollide9AllLeavesEPK10btDbvtNode"]
    pub fn btDbvt_ICollide_AllLeaves(
        this: *mut ::std::os::raw::c_void,
        arg1: *const btDbvtNode,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt7IWriterD0Ev"]
    pub fn btDbvt_IWriter_IWriter_destructor(this: *mut btDbvt_IWriter);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt7IWriter7PrepareEPK10btDbvtNodei"]
    pub fn btDbvt_IWriter_Prepare(
        this: *mut ::std::os::raw::c_void,
        root: *const btDbvtNode,
        numnodes: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt7IWriter9WriteNodeEPK10btDbvtNodeiiii"]
    pub fn btDbvt_IWriter_WriteNode(
        this: *mut ::std::os::raw::c_void,
        arg1: *const btDbvtNode,
        index: ::std::os::raw::c_int,
        parent: ::std::os::raw::c_int,
        child0: ::std::os::raw::c_int,
        child1: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt7IWriter9WriteLeafEPK10btDbvtNodeii"]
    pub fn btDbvt_IWriter_WriteLeaf(
        this: *mut ::std::os::raw::c_void,
        arg1: *const btDbvtNode,
        index: ::std::os::raw::c_int,
        parent: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt6ICloneD0Ev"]
    pub fn btDbvt_IClone_IClone_destructor(this: *mut btDbvt_IClone);
}
extern "C" {
    #[link_name = "\u{1}_ZN6btDbvt6IClone9CloneLeafEP10btDbvtNode"]
    pub fn btDbvt_IClone_CloneLeaf(this: *mut ::std::os::raw::c_void, arg1: *mut btDbvtNode);
}
extern "C" {
    #[link_name = "\u{1}_Z9IntersectRK12btDbvtAabbMmS1_"]
    pub fn Intersect(a: *const btDbvtAabbMm, b: *const btDbvtAabbMm) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z9IntersectRK12btDbvtAabbMmRK9btVector3"]
    pub fn Intersect1(a: *const btDbvtAabbMm, b: *const btVector3) -> bool;
}
extern "C" {

    ///

    #[link_name = "\u{1}_Z9ProximityRK12btDbvtAabbMmS1_"]
    pub fn Proximity(a: *const btDbvtAabbMm, b: *const btDbvtAabbMm) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_Z6SelectRK12btDbvtAabbMmS1_S1_"]
    pub fn Select(
        o: *const btDbvtAabbMm,
        a: *const btDbvtAabbMm,
        b: *const btDbvtAabbMm,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Z5MergeRK12btDbvtAabbMmS1_RS_"]
    pub fn Merge(a: *const btDbvtAabbMm, b: *const btDbvtAabbMm, r: *mut btDbvtAabbMm);
}
extern "C" {
    #[link_name = "\u{1}_Z8NotEqualRK12btDbvtAabbMmS1_"]
    pub fn NotEqual(a: *const btDbvtAabbMm, b: *const btDbvtAabbMm) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDbvtProxy {
    pub _base: btBroadphaseProxy,
    pub leaf: *mut btDbvtNode,
    pub links: [*mut btDbvtProxy; 2usize],
    pub stage: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btDbvtProxy() {
    assert_eq!(
        ::std::mem::size_of::<btDbvtProxy>(),
        120usize,
        concat!("Size of: ", stringify!(btDbvtProxy))
    );
    assert_eq!(
        ::std::mem::align_of::<btDbvtProxy>(),
        8usize,
        concat!("Alignment of ", stringify!(btDbvtProxy))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtProxy)).leaf as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtProxy),
            "::",
            stringify!(leaf)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtProxy)).links as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtProxy),
            "::",
            stringify!(links)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtProxy)).stage as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtProxy),
            "::",
            stringify!(stage)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11btDbvtProxyC1ERK9btVector3S2_Pvii"]
    pub fn btDbvtProxy_btDbvtProxy(
        this: *mut btDbvtProxy,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
impl btDbvtProxy {
    #[inline]
    pub unsafe fn new(
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDbvtProxy_btDbvtProxy(
            &mut __bindgen_tmp,
            aabbMin,
            aabbMax,
            userPtr,
            collisionFilterGroup,
            collisionFilterMask,
        );
        __bindgen_tmp
    }
}
pub type btDbvtProxyArray = btAlignedObjectArray<*mut btDbvtProxy>;
/// The btDbvtBroadphase implements a broadphase using two dynamic AABB bounding volume hierarchies/trees (see btDbvt).
/// One tree is used for static/non-moving objects, and another tree is used for dynamic objects. Objects can move from one tree to the other.
/// This is a very fast broadphase, especially for very dynamic worlds where many objects are moving. Its insert/add and remove of objects is generally faster than the sweep and prune broadphases btAxisSweep3 and bt32BitAxisSweep3.
#[repr(C)]
#[derive(Debug)]
pub struct btDbvtBroadphase {
    pub _base: btBroadphaseInterface,
    pub m_sets: [btDbvt; 2usize],
    pub m_stageRoots: [*mut btDbvtProxy; 3usize],
    pub m_paircache: *mut btOverlappingPairCache,
    pub m_prediction: btScalar,
    pub m_stageCurrent: ::std::os::raw::c_int,
    pub m_fupdates: ::std::os::raw::c_int,
    pub m_dupdates: ::std::os::raw::c_int,
    pub m_cupdates: ::std::os::raw::c_int,
    pub m_newpairs: ::std::os::raw::c_int,
    pub m_fixedleft: ::std::os::raw::c_int,
    pub m_updates_call: ::std::os::raw::c_uint,
    pub m_updates_done: ::std::os::raw::c_uint,
    pub m_updates_ratio: btScalar,
    pub m_pid: ::std::os::raw::c_int,
    pub m_cid: ::std::os::raw::c_int,
    pub m_gid: ::std::os::raw::c_int,
    pub m_releasepaircache: bool,
    pub m_deferedcollide: bool,
    pub m_needcleanup: bool,
    pub m_rayTestStacks: btAlignedObjectArray<btAlignedObjectArray<*const btDbvtNode>>,
}
pub const btDbvtBroadphase_DYNAMIC_SET: btDbvtBroadphase__bindgen_ty_1 = 0;
pub const btDbvtBroadphase_FIXED_SET: btDbvtBroadphase__bindgen_ty_1 = 1;
pub const btDbvtBroadphase_STAGECOUNT: btDbvtBroadphase__bindgen_ty_1 = 2;
pub type btDbvtBroadphase__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_btDbvtBroadphase() {
    assert_eq!(
        ::std::mem::size_of::<btDbvtBroadphase>(),
        264usize,
        concat!("Size of: ", stringify!(btDbvtBroadphase))
    );
    assert_eq!(
        ::std::mem::align_of::<btDbvtBroadphase>(),
        8usize,
        concat!("Alignment of ", stringify!(btDbvtBroadphase))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_sets as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_sets)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_stageRoots as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_stageRoots)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_paircache as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_paircache)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_prediction as *const _ as usize },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_prediction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_stageCurrent as *const _ as usize },
        176usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_stageCurrent)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_fupdates as *const _ as usize },
        180usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_fupdates)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_dupdates as *const _ as usize },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_dupdates)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_cupdates as *const _ as usize },
        188usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_cupdates)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_newpairs as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_newpairs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_fixedleft as *const _ as usize },
        196usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_fixedleft)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_updates_call as *const _ as usize },
        200usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_updates_call)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_updates_done as *const _ as usize },
        204usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_updates_done)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_updates_ratio as *const _ as usize },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_updates_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_pid as *const _ as usize },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_cid as *const _ as usize },
        220usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_cid)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_gid as *const _ as usize },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_releasepaircache as *const _ as usize },
        228usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_releasepaircache)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_deferedcollide as *const _ as usize },
        229usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_deferedcollide)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_needcleanup as *const _ as usize },
        230usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_needcleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDbvtBroadphase)).m_rayTestStacks as *const _ as usize },
        232usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDbvtBroadphase),
            "::",
            stringify!(m_rayTestStacks)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphase7collideEP12btDispatcher"]
    pub fn btDbvtBroadphase_collide(this: *mut btDbvtBroadphase, dispatcher: *mut btDispatcher);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphase8optimizeEv"]
    pub fn btDbvtBroadphase_optimize(this: *mut btDbvtBroadphase);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphase22performDeferredRemovalEP12btDispatcher"]
    pub fn btDbvtBroadphase_performDeferredRemoval(
        this: *mut btDbvtBroadphase,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphase21setVelocityPredictionEd"]
    pub fn btDbvtBroadphase_setVelocityPrediction(
        this: *mut btDbvtBroadphase,
        prediction: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btDbvtBroadphase21getVelocityPredictionEv"]
    pub fn btDbvtBroadphase_getVelocityPrediction(this: *const btDbvtBroadphase) -> btScalar;
}
extern "C" {

    /// this setAabbForceUpdate is similar to setAabb but always forces the aabb update.
    /// ///it is not part of the btBroadphaseInterface but specific to btDbvtBroadphase.
    /// ///it bypasses certain optimizations that prevent aabb updates (when the aabb shrinks), see
    /// ///http://code.google.com/p/bullet/issues/detail?id=223

    #[link_name = "\u{1}_ZN16btDbvtBroadphase18setAabbForceUpdateEP17btBroadphaseProxyRK9btVector3S4_P12btDispatcher"]
    pub fn btDbvtBroadphase_setAabbForceUpdate(
        this: *mut btDbvtBroadphase,
        absproxy: *mut btBroadphaseProxy,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        arg1: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphase9benchmarkEP21btBroadphaseInterface"]
    pub fn btDbvtBroadphase_benchmark(arg1: *mut btBroadphaseInterface);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphaseC1EP22btOverlappingPairCache"]
    pub fn btDbvtBroadphase_btDbvtBroadphase(
        this: *mut btDbvtBroadphase,
        paircache: *mut btOverlappingPairCache,
    );
}
impl btDbvtBroadphase {
    #[inline]
    pub unsafe fn collide(&mut self, dispatcher: *mut btDispatcher) {
        btDbvtBroadphase_collide(self, dispatcher)
    }
    #[inline]
    pub unsafe fn optimize(&mut self) {
        btDbvtBroadphase_optimize(self)
    }
    #[inline]
    pub unsafe fn performDeferredRemoval(&mut self, dispatcher: *mut btDispatcher) {
        btDbvtBroadphase_performDeferredRemoval(self, dispatcher)
    }
    #[inline]
    pub unsafe fn setVelocityPrediction(&mut self, prediction: btScalar) {
        btDbvtBroadphase_setVelocityPrediction(self, prediction)
    }
    #[inline]
    pub unsafe fn getVelocityPrediction(&self) -> btScalar {
        btDbvtBroadphase_getVelocityPrediction(self)
    }
    #[inline]
    pub unsafe fn setAabbForceUpdate(
        &mut self,
        absproxy: *mut btBroadphaseProxy,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        arg1: *mut btDispatcher,
    ) {
        btDbvtBroadphase_setAabbForceUpdate(self, absproxy, aabbMin, aabbMax, arg1)
    }
    #[inline]
    pub unsafe fn benchmark(arg1: *mut btBroadphaseInterface) {
        btDbvtBroadphase_benchmark(arg1)
    }
    #[inline]
    pub unsafe fn new(paircache: *mut btOverlappingPairCache) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDbvtBroadphase_btDbvtBroadphase(&mut __bindgen_tmp, paircache);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphaseD1Ev"]
    pub fn btDbvtBroadphase_btDbvtBroadphase_destructor(this: *mut btDbvtBroadphase);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphase11createProxyERK9btVector3S2_iPviiP12btDispatcher"]
    pub fn btDbvtBroadphase_createProxy(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        shapeType: ::std::os::raw::c_int,
        userPtr: *mut ::std::os::raw::c_void,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
        dispatcher: *mut btDispatcher,
    ) -> *mut btBroadphaseProxy;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphase12destroyProxyEP17btBroadphaseProxyP12btDispatcher"]
    pub fn btDbvtBroadphase_destroyProxy(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphase7setAabbEP17btBroadphaseProxyRK9btVector3S4_P12btDispatcher"]
    pub fn btDbvtBroadphase_setAabb(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphase7rayTestERK9btVector3S2_R23btBroadphaseRayCallbackS2_S2_"]
    pub fn btDbvtBroadphase_rayTest(
        this: *mut ::std::os::raw::c_void,
        rayFrom: *const btVector3,
        rayTo: *const btVector3,
        rayCallback: *mut btBroadphaseRayCallback,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphase8aabbTestERK9btVector3S2_R24btBroadphaseAabbCallback"]
    pub fn btDbvtBroadphase_aabbTest(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *const btVector3,
        aabbMax: *const btVector3,
        callback: *mut btBroadphaseAabbCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btDbvtBroadphase7getAabbEP17btBroadphaseProxyR9btVector3S3_"]
    pub fn btDbvtBroadphase_getAabb(
        this: *mut ::std::os::raw::c_void,
        proxy: *mut btBroadphaseProxy,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphase25calculateOverlappingPairsEP12btDispatcher"]
    pub fn btDbvtBroadphase_calculateOverlappingPairs(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphase23getOverlappingPairCacheEv"]
    pub fn btDbvtBroadphase_getOverlappingPairCache(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btOverlappingPairCache;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btDbvtBroadphase23getOverlappingPairCacheEv"]
    pub fn btDbvtBroadphase_getOverlappingPairCache1(
        this: *mut ::std::os::raw::c_void,
    ) -> *const btOverlappingPairCache;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btDbvtBroadphase17getBroadphaseAabbER9btVector3S1_"]
    pub fn btDbvtBroadphase_getBroadphaseAabb(
        this: *mut ::std::os::raw::c_void,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btDbvtBroadphase10printStatsEv"]
    pub fn btDbvtBroadphase_printStats(this: *mut ::std::os::raw::c_void);
}
extern "C" {

    /// reset broadphase internal structures, to ensure determinism/reproducability

    #[link_name = "\u{1}_ZN16btDbvtBroadphase9resetPoolEP12btDispatcher"]
    pub fn btDbvtBroadphase_resetPool(
        this: *mut ::std::os::raw::c_void,
        dispatcher: *mut btDispatcher,
    );
}
/// The internal templace class btAxisSweep3Internal implements the sweep and prune broadphase.
/// It uses quantized integers to represent the begin and end points for each of the 3 axis.
/// Dont use this class directly, use btAxisSweep3 or bt32BitAxisSweep3 instead.
#[repr(C)]
#[derive(Debug)]
pub struct btAxisSweep3Internal<BP_FP_INT_TYPE> {
    pub _base: btBroadphaseInterface,
    pub m_bpHandleMask: BP_FP_INT_TYPE,
    pub m_handleSentinel: BP_FP_INT_TYPE,
    pub m_worldAabbMin: btVector3,
    pub m_worldAabbMax: btVector3,
    pub m_quantize: btVector3,
    pub m_numHandles: BP_FP_INT_TYPE,
    pub m_maxHandles: BP_FP_INT_TYPE,
    pub m_pHandles: *mut btAxisSweep3Internal_Handle<BP_FP_INT_TYPE>,
    pub m_firstFreeHandle: BP_FP_INT_TYPE,
    pub m_pEdges: [*mut btAxisSweep3Internal_Edge<BP_FP_INT_TYPE>; 3usize],
    pub m_pEdgesRawPtr: [*mut ::std::os::raw::c_void; 3usize],
    pub m_pairCache: *mut btOverlappingPairCache,
    /// btOverlappingPairCallback is an additional optional user callback for adding/removing overlapping pairs, similar interface to btOverlappingPairCache.
    pub m_userPairCallback: *mut btOverlappingPairCallback,
    pub m_ownsPairCache: bool,
    pub m_invalidPair: ::std::os::raw::c_int,
    /// additional dynamic aabb structure, used to accelerate ray cast queries.
    /// ///can be disabled using a optional argument in the constructor
    pub m_raycastAccelerator: *mut btDbvtBroadphase,
    pub m_nullPairCache: *mut btOverlappingPairCache,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BP_FP_INT_TYPE>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btAxisSweep3Internal_Edge<BP_FP_INT_TYPE> {
    pub m_pos: BP_FP_INT_TYPE,
    pub m_handle: BP_FP_INT_TYPE,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BP_FP_INT_TYPE>>,
}
#[repr(C)]
#[derive(Debug)]
pub struct btAxisSweep3Internal_Handle<BP_FP_INT_TYPE> {
    pub _base: btBroadphaseProxy,
    pub m_minEdges: [BP_FP_INT_TYPE; 3usize],
    pub m_maxEdges: [BP_FP_INT_TYPE; 3usize],
    pub m_dbvtProxy: *mut btBroadphaseProxy,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BP_FP_INT_TYPE>>,
}
extern "C" {
    #[link_name = "\u{1}gOverlappingPairs"]
    pub static mut gOverlappingPairs: ::std::os::raw::c_int;
}
/// The btAxisSweep3 is an efficient implementation of the 3d axis sweep and prune broadphase.
/// It uses arrays rather then lists for storage of the 3 axis. Also it operates using 16 bit integer coordinates instead of floats.
/// For large worlds and many objects, use bt32BitAxisSweep3 or btDbvtBroadphase instead. bt32BitAxisSweep3 has higher precision and allows more then 16384 objects at the cost of more memory and bit of performance.
#[repr(C)]
#[derive(Debug)]
pub struct btAxisSweep3 {
    pub _base: btAxisSweep3Internal<::std::os::raw::c_ushort>,
}
#[test]
fn bindgen_test_layout_btAxisSweep3() {
    assert_eq!(
        ::std::mem::size_of::<btAxisSweep3>(),
        224usize,
        concat!("Size of: ", stringify!(btAxisSweep3))
    );
    assert_eq!(
        ::std::mem::align_of::<btAxisSweep3>(),
        8usize,
        concat!("Alignment of ", stringify!(btAxisSweep3))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btAxisSweep3C1ERK9btVector3S2_tP22btOverlappingPairCacheb"]
    pub fn btAxisSweep3_btAxisSweep3(
        this: *mut btAxisSweep3,
        worldAabbMin: *const btVector3,
        worldAabbMax: *const btVector3,
        maxHandles: ::std::os::raw::c_ushort,
        pairCache: *mut btOverlappingPairCache,
        disableRaycastAccelerator: bool,
    );
}
impl btAxisSweep3 {
    #[inline]
    pub unsafe fn new(
        worldAabbMin: *const btVector3,
        worldAabbMax: *const btVector3,
        maxHandles: ::std::os::raw::c_ushort,
        pairCache: *mut btOverlappingPairCache,
        disableRaycastAccelerator: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btAxisSweep3_btAxisSweep3(
            &mut __bindgen_tmp,
            worldAabbMin,
            worldAabbMax,
            maxHandles,
            pairCache,
            disableRaycastAccelerator,
        );
        __bindgen_tmp
    }
}
/// The bt32BitAxisSweep3 allows higher precision quantization and more objects compared to the btAxisSweep3 sweep and prune.
/// This comes at the cost of more memory per handle, and a bit slower performance.
/// It uses arrays rather then lists for storage of the 3 axis.
#[repr(C)]
#[derive(Debug)]
pub struct bt32BitAxisSweep3 {
    pub _base: btAxisSweep3Internal<::std::os::raw::c_uint>,
}
#[test]
fn bindgen_test_layout_bt32BitAxisSweep3() {
    assert_eq!(
        ::std::mem::size_of::<bt32BitAxisSweep3>(),
        224usize,
        concat!("Size of: ", stringify!(bt32BitAxisSweep3))
    );
    assert_eq!(
        ::std::mem::align_of::<bt32BitAxisSweep3>(),
        8usize,
        concat!("Alignment of ", stringify!(bt32BitAxisSweep3))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17bt32BitAxisSweep3C1ERK9btVector3S2_jP22btOverlappingPairCacheb"]
    pub fn bt32BitAxisSweep3_bt32BitAxisSweep3(
        this: *mut bt32BitAxisSweep3,
        worldAabbMin: *const btVector3,
        worldAabbMax: *const btVector3,
        maxHandles: ::std::os::raw::c_uint,
        pairCache: *mut btOverlappingPairCache,
        disableRaycastAccelerator: bool,
    );
}
impl bt32BitAxisSweep3 {
    #[inline]
    pub unsafe fn new(
        worldAabbMin: *const btVector3,
        worldAabbMax: *const btVector3,
        maxHandles: ::std::os::raw::c_uint,
        pairCache: *mut btOverlappingPairCache,
        disableRaycastAccelerator: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        bt32BitAxisSweep3_bt32BitAxisSweep3(
            &mut __bindgen_tmp,
            worldAabbMin,
            worldAabbMax,
            maxHandles,
            pairCache,
            disableRaycastAccelerator,
        );
        __bindgen_tmp
    }
}
/// The btDefaultMotionState provides a common implementation to synchronize world transforms with offsets.
#[repr(C)]
#[derive(Debug)]
pub struct btDefaultMotionState {
    pub _base: btMotionState,
    pub m_graphicsWorldTrans: btTransform,
    pub m_centerOfMassOffset: btTransform,
    pub m_startWorldTrans: btTransform,
    pub m_userPointer: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_btDefaultMotionState() {
    assert_eq!(
        ::std::mem::size_of::<btDefaultMotionState>(),
        400usize,
        concat!("Size of: ", stringify!(btDefaultMotionState))
    );
    assert_eq!(
        ::std::mem::align_of::<btDefaultMotionState>(),
        8usize,
        concat!("Alignment of ", stringify!(btDefaultMotionState))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultMotionState)).m_graphicsWorldTrans as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultMotionState),
            "::",
            stringify!(m_graphicsWorldTrans)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultMotionState)).m_centerOfMassOffset as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultMotionState),
            "::",
            stringify!(m_centerOfMassOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultMotionState)).m_startWorldTrans as *const _ as usize },
        264usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultMotionState),
            "::",
            stringify!(m_startWorldTrans)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultMotionState)).m_userPointer as *const _ as usize },
        392usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultMotionState),
            "::",
            stringify!(m_userPointer)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN20btDefaultMotionStateC1ERK11btTransformS2_"]
    pub fn btDefaultMotionState_btDefaultMotionState(
        this: *mut btDefaultMotionState,
        startTrans: *const btTransform,
        centerOfMassOffset: *const btTransform,
    );
}
impl btDefaultMotionState {
    #[inline]
    pub unsafe fn new(
        startTrans: *const btTransform,
        centerOfMassOffset: *const btTransform,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDefaultMotionState_btDefaultMotionState(
            &mut __bindgen_tmp,
            startTrans,
            centerOfMassOffset,
        );
        __bindgen_tmp
    }
}
extern "C" {

    /// synchronizes world transform from user to physics

    #[link_name = "\u{1}_ZNK20btDefaultMotionState17getWorldTransformER11btTransform"]
    pub fn btDefaultMotionState_getWorldTransform(
        this: *mut ::std::os::raw::c_void,
        centerOfMassWorldTrans: *mut btTransform,
    );
}
extern "C" {

    /// synchronizes world transform from physics to user
    /// ///Bullet only calls the update of worldtransform for active objects

    #[link_name = "\u{1}_ZN20btDefaultMotionState17setWorldTransformERK11btTransform"]
    pub fn btDefaultMotionState_setWorldTransform(
        this: *mut ::std::os::raw::c_void,
        centerOfMassWorldTrans: *const btTransform,
    );
}
/// The btClock is a portable basic clock that measures accurate time in seconds, use for profiling.
#[repr(C)]
#[derive(Debug)]
pub struct btClock {
    pub m_data: *mut btClockData,
}
#[test]
fn bindgen_test_layout_btClock() {
    assert_eq!(
        ::std::mem::size_of::<btClock>(),
        8usize,
        concat!("Size of: ", stringify!(btClock))
    );
    assert_eq!(
        ::std::mem::align_of::<btClock>(),
        8usize,
        concat!("Alignment of ", stringify!(btClock))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btClock)).m_data as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btClock),
            "::",
            stringify!(m_data)
        )
    );
}
extern "C" {

    /// Resets the initial reference time.

    #[link_name = "\u{1}_ZN7btClock5resetEv"]
    pub fn btClock_reset(this: *mut btClock);
}
extern "C" {

    /// Returns the time in ms since the last call to reset or since
    /// /// the btClock was created.

    #[link_name = "\u{1}_ZN7btClock19getTimeMillisecondsEv"]
    pub fn btClock_getTimeMilliseconds(this: *mut btClock) -> ::std::os::raw::c_ulonglong;
}
extern "C" {

    /// Returns the time in us since the last call to reset or since
    /// /// the Clock was created.

    #[link_name = "\u{1}_ZN7btClock19getTimeMicrosecondsEv"]
    pub fn btClock_getTimeMicroseconds(this: *mut btClock) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}_ZN7btClock18getTimeNanosecondsEv"]
    pub fn btClock_getTimeNanoseconds(this: *mut btClock) -> ::std::os::raw::c_ulonglong;
}
extern "C" {

    /// Returns the time in s since the last call to reset or since
    /// /// the Clock was created.

    #[link_name = "\u{1}_ZN7btClock14getTimeSecondsEv"]
    pub fn btClock_getTimeSeconds(this: *mut btClock) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN7btClockC1Ev"]
    pub fn btClock_btClock(this: *mut btClock);
}
extern "C" {
    #[link_name = "\u{1}_ZN7btClockC1ERKS_"]
    pub fn btClock_btClock1(this: *mut btClock, other: *const btClock);
}
extern "C" {
    #[link_name = "\u{1}_ZN7btClockD1Ev"]
    pub fn btClock_btClock_destructor(this: *mut btClock);
}
impl btClock {
    #[inline]
    pub unsafe fn reset(&mut self) {
        btClock_reset(self)
    }
    #[inline]
    pub unsafe fn getTimeMilliseconds(&mut self) -> ::std::os::raw::c_ulonglong {
        btClock_getTimeMilliseconds(self)
    }
    #[inline]
    pub unsafe fn getTimeMicroseconds(&mut self) -> ::std::os::raw::c_ulonglong {
        btClock_getTimeMicroseconds(self)
    }
    #[inline]
    pub unsafe fn getTimeNanoseconds(&mut self) -> ::std::os::raw::c_ulonglong {
        btClock_getTimeNanoseconds(self)
    }
    #[inline]
    pub unsafe fn getTimeSeconds(&mut self) -> btScalar {
        btClock_getTimeSeconds(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btClock_btClock(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(other: *const btClock) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btClock_btClock1(&mut __bindgen_tmp, other);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        btClock_btClock_destructor(self)
    }
}
pub type btEnterProfileZoneFunc = ::std::option::Option<
    unsafe extern "C" fn(msg: *const ::std::os::raw::c_char),
>;
pub type btLeaveProfileZoneFunc = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}_Z32btGetCurrentEnterProfileZoneFuncv"]
    pub fn btGetCurrentEnterProfileZoneFunc() -> btEnterProfileZoneFunc;
}
extern "C" {
    #[link_name = "\u{1}_Z32btGetCurrentLeaveProfileZoneFuncv"]
    pub fn btGetCurrentLeaveProfileZoneFunc() -> btLeaveProfileZoneFunc;
}
extern "C" {
    #[link_name = "\u{1}_Z31btSetCustomEnterProfileZoneFuncPFvPKcE"]
    pub fn btSetCustomEnterProfileZoneFunc(enterFunc: btEnterProfileZoneFunc);
}
extern "C" {
    #[link_name = "\u{1}_Z31btSetCustomLeaveProfileZoneFuncPFvvE"]
    pub fn btSetCustomLeaveProfileZoneFunc(leaveFunc: btLeaveProfileZoneFunc);
}
extern "C" {
    #[link_name = "\u{1}_Z33btQuickprofGetCurrentThreadIndex2v"]
    pub fn btQuickprofGetCurrentThreadIndex2() -> ::std::os::raw::c_uint;
}
pub const BT_QUICKPROF_MAX_THREAD_COUNT: ::std::os::raw::c_uint = 64;
/// A node in the Profile Hierarchy Tree
#[repr(C)]
#[derive(Debug)]
pub struct CProfileNode {
    pub Name: *const ::std::os::raw::c_char,
    pub TotalCalls: ::std::os::raw::c_int,
    pub TotalTime: f32,
    pub StartTime: ::std::os::raw::c_ulong,
    pub RecursionCounter: ::std::os::raw::c_int,
    pub Parent: *mut CProfileNode,
    pub Child: *mut CProfileNode,
    pub Sibling: *mut CProfileNode,
    pub m_userPtr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CProfileNode() {
    assert_eq!(
        ::std::mem::size_of::<CProfileNode>(),
        64usize,
        concat!("Size of: ", stringify!(CProfileNode))
    );
    assert_eq!(
        ::std::mem::align_of::<CProfileNode>(),
        8usize,
        concat!("Alignment of ", stringify!(CProfileNode))
    );
    assert_eq!(
        unsafe { &(*(0 as *const CProfileNode)).Name as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(CProfileNode),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const CProfileNode)).TotalCalls as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(CProfileNode),
            "::",
            stringify!(TotalCalls)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const CProfileNode)).TotalTime as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(CProfileNode),
            "::",
            stringify!(TotalTime)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const CProfileNode)).StartTime as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(CProfileNode),
            "::",
            stringify!(StartTime)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const CProfileNode)).RecursionCounter as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(CProfileNode),
            "::",
            stringify!(RecursionCounter)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const CProfileNode)).Parent as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(CProfileNode),
            "::",
            stringify!(Parent)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const CProfileNode)).Child as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(CProfileNode),
            "::",
            stringify!(Child)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const CProfileNode)).Sibling as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(CProfileNode),
            "::",
            stringify!(Sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const CProfileNode)).m_userPtr as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(CProfileNode),
            "::",
            stringify!(m_userPtr)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12CProfileNode12Get_Sub_NodeEPKc"]
    pub fn CProfileNode_Get_Sub_Node(
        this: *mut CProfileNode,
        name: *const ::std::os::raw::c_char,
    ) -> *mut CProfileNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN12CProfileNode10Get_ParentEv"]
    pub fn CProfileNode_Get_Parent(this: *mut CProfileNode) -> *mut CProfileNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN12CProfileNode11Get_SiblingEv"]
    pub fn CProfileNode_Get_Sibling(this: *mut CProfileNode) -> *mut CProfileNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN12CProfileNode9Get_ChildEv"]
    pub fn CProfileNode_Get_Child(this: *mut CProfileNode) -> *mut CProfileNode;
}
extern "C" {
    #[link_name = "\u{1}_ZN12CProfileNode13CleanupMemoryEv"]
    pub fn CProfileNode_CleanupMemory(this: *mut CProfileNode);
}
extern "C" {
    #[link_name = "\u{1}_ZN12CProfileNode5ResetEv"]
    pub fn CProfileNode_Reset(this: *mut CProfileNode);
}
extern "C" {
    #[link_name = "\u{1}_ZN12CProfileNode4CallEv"]
    pub fn CProfileNode_Call(this: *mut CProfileNode);
}
extern "C" {
    #[link_name = "\u{1}_ZN12CProfileNode6ReturnEv"]
    pub fn CProfileNode_Return(this: *mut CProfileNode) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12CProfileNode8Get_NameEv"]
    pub fn CProfileNode_Get_Name(this: *mut CProfileNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN12CProfileNode15Get_Total_CallsEv"]
    pub fn CProfileNode_Get_Total_Calls(this: *mut CProfileNode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN12CProfileNode14Get_Total_TimeEv"]
    pub fn CProfileNode_Get_Total_Time(this: *mut CProfileNode) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12CProfileNode14GetUserPointerEv"]
    pub fn CProfileNode_GetUserPointer(this: *const CProfileNode) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN12CProfileNode14SetUserPointerEPv"]
    pub fn CProfileNode_SetUserPointer(this: *mut CProfileNode, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN12CProfileNodeC1EPKcPS_"]
    pub fn CProfileNode_CProfileNode(
        this: *mut CProfileNode,
        name: *const ::std::os::raw::c_char,
        parent: *mut CProfileNode,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12CProfileNodeD1Ev"]
    pub fn CProfileNode_CProfileNode_destructor(this: *mut CProfileNode);
}
impl CProfileNode {
    #[inline]
    pub unsafe fn Get_Sub_Node(
        &mut self,
        name: *const ::std::os::raw::c_char,
    ) -> *mut CProfileNode {
        CProfileNode_Get_Sub_Node(self, name)
    }
    #[inline]
    pub unsafe fn Get_Parent(&mut self) -> *mut CProfileNode {
        CProfileNode_Get_Parent(self)
    }
    #[inline]
    pub unsafe fn Get_Sibling(&mut self) -> *mut CProfileNode {
        CProfileNode_Get_Sibling(self)
    }
    #[inline]
    pub unsafe fn Get_Child(&mut self) -> *mut CProfileNode {
        CProfileNode_Get_Child(self)
    }
    #[inline]
    pub unsafe fn CleanupMemory(&mut self) {
        CProfileNode_CleanupMemory(self)
    }
    #[inline]
    pub unsafe fn Reset(&mut self) {
        CProfileNode_Reset(self)
    }
    #[inline]
    pub unsafe fn Call(&mut self) {
        CProfileNode_Call(self)
    }
    #[inline]
    pub unsafe fn Return(&mut self) -> bool {
        CProfileNode_Return(self)
    }
    #[inline]
    pub unsafe fn Get_Name(&mut self) -> *const ::std::os::raw::c_char {
        CProfileNode_Get_Name(self)
    }
    #[inline]
    pub unsafe fn Get_Total_Calls(&mut self) -> ::std::os::raw::c_int {
        CProfileNode_Get_Total_Calls(self)
    }
    #[inline]
    pub unsafe fn Get_Total_Time(&mut self) -> f32 {
        CProfileNode_Get_Total_Time(self)
    }
    #[inline]
    pub unsafe fn GetUserPointer(&self) -> *mut ::std::os::raw::c_void {
        CProfileNode_GetUserPointer(self)
    }
    #[inline]
    pub unsafe fn SetUserPointer(&mut self, ptr: *mut ::std::os::raw::c_void) {
        CProfileNode_SetUserPointer(self, ptr)
    }
    #[inline]
    pub unsafe fn new(name: *const ::std::os::raw::c_char, parent: *mut CProfileNode) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        CProfileNode_CProfileNode(&mut __bindgen_tmp, name, parent);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        CProfileNode_CProfileNode_destructor(self)
    }
}
/// An iterator to navigate through the tree
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CProfileIterator {
    pub CurrentParent: *mut CProfileNode,
    pub CurrentChild: *mut CProfileNode,
}
#[test]
fn bindgen_test_layout_CProfileIterator() {
    assert_eq!(
        ::std::mem::size_of::<CProfileIterator>(),
        16usize,
        concat!("Size of: ", stringify!(CProfileIterator))
    );
    assert_eq!(
        ::std::mem::align_of::<CProfileIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(CProfileIterator))
    );
    assert_eq!(
        unsafe { &(*(0 as *const CProfileIterator)).CurrentParent as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(CProfileIterator),
            "::",
            stringify!(CurrentParent)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const CProfileIterator)).CurrentChild as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(CProfileIterator),
            "::",
            stringify!(CurrentChild)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator5FirstEv"]
    pub fn CProfileIterator_First(this: *mut CProfileIterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator4NextEv"]
    pub fn CProfileIterator_Next(this: *mut CProfileIterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator7Is_DoneEv"]
    pub fn CProfileIterator_Is_Done(this: *mut CProfileIterator) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator7Is_RootEv"]
    pub fn CProfileIterator_Is_Root(this: *mut CProfileIterator) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator11Enter_ChildEi"]
    pub fn CProfileIterator_Enter_Child(this: *mut CProfileIterator, index: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator19Enter_Largest_ChildEv"]
    pub fn CProfileIterator_Enter_Largest_Child(this: *mut CProfileIterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator12Enter_ParentEv"]
    pub fn CProfileIterator_Enter_Parent(this: *mut CProfileIterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator16Get_Current_NameEv"]
    pub fn CProfileIterator_Get_Current_Name(
        this: *mut CProfileIterator,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator23Get_Current_Total_CallsEv"]
    pub fn CProfileIterator_Get_Current_Total_Calls(
        this: *mut CProfileIterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator22Get_Current_Total_TimeEv"]
    pub fn CProfileIterator_Get_Current_Total_Time(this: *mut CProfileIterator) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator23Get_Current_UserPointerEv"]
    pub fn CProfileIterator_Get_Current_UserPointer(
        this: *mut CProfileIterator,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator23Set_Current_UserPointerEPv"]
    pub fn CProfileIterator_Set_Current_UserPointer(
        this: *mut CProfileIterator,
        ptr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator23Get_Current_Parent_NameEv"]
    pub fn CProfileIterator_Get_Current_Parent_Name(
        this: *mut CProfileIterator,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator30Get_Current_Parent_Total_CallsEv"]
    pub fn CProfileIterator_Get_Current_Parent_Total_Calls(
        this: *mut CProfileIterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIterator29Get_Current_Parent_Total_TimeEv"]
    pub fn CProfileIterator_Get_Current_Parent_Total_Time(this: *mut CProfileIterator) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN16CProfileIteratorC1EP12CProfileNode"]
    pub fn CProfileIterator_CProfileIterator(this: *mut CProfileIterator, start: *mut CProfileNode);
}
impl CProfileIterator {
    #[inline]
    pub unsafe fn First(&mut self) {
        CProfileIterator_First(self)
    }
    #[inline]
    pub unsafe fn Next(&mut self) {
        CProfileIterator_Next(self)
    }
    #[inline]
    pub unsafe fn Is_Done(&mut self) -> bool {
        CProfileIterator_Is_Done(self)
    }
    #[inline]
    pub unsafe fn Is_Root(&mut self) -> bool {
        CProfileIterator_Is_Root(self)
    }
    #[inline]
    pub unsafe fn Enter_Child(&mut self, index: ::std::os::raw::c_int) {
        CProfileIterator_Enter_Child(self, index)
    }
    #[inline]
    pub unsafe fn Enter_Largest_Child(&mut self) {
        CProfileIterator_Enter_Largest_Child(self)
    }
    #[inline]
    pub unsafe fn Enter_Parent(&mut self) {
        CProfileIterator_Enter_Parent(self)
    }
    #[inline]
    pub unsafe fn Get_Current_Name(&mut self) -> *const ::std::os::raw::c_char {
        CProfileIterator_Get_Current_Name(self)
    }
    #[inline]
    pub unsafe fn Get_Current_Total_Calls(&mut self) -> ::std::os::raw::c_int {
        CProfileIterator_Get_Current_Total_Calls(self)
    }
    #[inline]
    pub unsafe fn Get_Current_Total_Time(&mut self) -> f32 {
        CProfileIterator_Get_Current_Total_Time(self)
    }
    #[inline]
    pub unsafe fn Get_Current_UserPointer(&mut self) -> *mut ::std::os::raw::c_void {
        CProfileIterator_Get_Current_UserPointer(self)
    }
    #[inline]
    pub unsafe fn Set_Current_UserPointer(&mut self, ptr: *mut ::std::os::raw::c_void) {
        CProfileIterator_Set_Current_UserPointer(self, ptr)
    }
    #[inline]
    pub unsafe fn Get_Current_Parent_Name(&mut self) -> *const ::std::os::raw::c_char {
        CProfileIterator_Get_Current_Parent_Name(self)
    }
    #[inline]
    pub unsafe fn Get_Current_Parent_Total_Calls(&mut self) -> ::std::os::raw::c_int {
        CProfileIterator_Get_Current_Parent_Total_Calls(self)
    }
    #[inline]
    pub unsafe fn Get_Current_Parent_Total_Time(&mut self) -> f32 {
        CProfileIterator_Get_Current_Parent_Total_Time(self)
    }
    #[inline]
    pub unsafe fn new(start: *mut CProfileNode) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        CProfileIterator_CProfileIterator(&mut __bindgen_tmp, start);
        __bindgen_tmp
    }
}
/// The Manager for the Profile system
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CProfileManager {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN15CProfileManager12FrameCounterE"]
    pub static mut CProfileManager_FrameCounter: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN15CProfileManager9ResetTimeE"]
    pub static mut CProfileManager_ResetTime: ::std::os::raw::c_ulong;
}
#[test]
fn bindgen_test_layout_CProfileManager() {
    assert_eq!(
        ::std::mem::size_of::<CProfileManager>(),
        1usize,
        concat!("Size of: ", stringify!(CProfileManager))
    );
    assert_eq!(
        ::std::mem::align_of::<CProfileManager>(),
        1usize,
        concat!("Alignment of ", stringify!(CProfileManager))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15CProfileManager13Start_ProfileEPKc"]
    pub fn CProfileManager_Start_Profile(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN15CProfileManager12Stop_ProfileEv"]
    pub fn CProfileManager_Stop_Profile();
}
extern "C" {
    #[link_name = "\u{1}_ZN15CProfileManager13CleanupMemoryEv"]
    pub fn CProfileManager_CleanupMemory();
}
extern "C" {
    #[link_name = "\u{1}_ZN15CProfileManager5ResetEv"]
    pub fn CProfileManager_Reset();
}
extern "C" {
    #[link_name = "\u{1}_ZN15CProfileManager23Increment_Frame_CounterEv"]
    pub fn CProfileManager_Increment_Frame_Counter();
}
extern "C" {
    #[link_name = "\u{1}_ZN15CProfileManager27Get_Frame_Count_Since_ResetEv"]
    pub fn CProfileManager_Get_Frame_Count_Since_Reset() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN15CProfileManager20Get_Time_Since_ResetEv"]
    pub fn CProfileManager_Get_Time_Since_Reset() -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN15CProfileManager12Get_IteratorEv"]
    pub fn CProfileManager_Get_Iterator() -> *mut CProfileIterator;
}
extern "C" {
    #[link_name = "\u{1}_ZN15CProfileManager16Release_IteratorEP16CProfileIterator"]
    pub fn CProfileManager_Release_Iterator(iterator: *mut CProfileIterator);
}
extern "C" {
    #[link_name = "\u{1}_ZN15CProfileManager13dumpRecursiveEP16CProfileIteratori"]
    pub fn CProfileManager_dumpRecursive(
        profileIterator: *mut CProfileIterator,
        spacing: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15CProfileManager7dumpAllEv"]
    pub fn CProfileManager_dumpAll();
}
impl CProfileManager {
    #[inline]
    pub unsafe fn Start_Profile(name: *const ::std::os::raw::c_char) {
        CProfileManager_Start_Profile(name)
    }
    #[inline]
    pub unsafe fn Stop_Profile() {
        CProfileManager_Stop_Profile()
    }
    #[inline]
    pub unsafe fn CleanupMemory() {
        CProfileManager_CleanupMemory()
    }
    #[inline]
    pub unsafe fn Reset() {
        CProfileManager_Reset()
    }
    #[inline]
    pub unsafe fn Increment_Frame_Counter() {
        CProfileManager_Increment_Frame_Counter()
    }
    #[inline]
    pub unsafe fn Get_Frame_Count_Since_Reset() -> ::std::os::raw::c_int {
        CProfileManager_Get_Frame_Count_Since_Reset()
    }
    #[inline]
    pub unsafe fn Get_Time_Since_Reset() -> f32 {
        CProfileManager_Get_Time_Since_Reset()
    }
    #[inline]
    pub unsafe fn Get_Iterator() -> *mut CProfileIterator {
        CProfileManager_Get_Iterator()
    }
    #[inline]
    pub unsafe fn Release_Iterator(iterator: *mut CProfileIterator) {
        CProfileManager_Release_Iterator(iterator)
    }
    #[inline]
    pub unsafe fn dumpRecursive(
        profileIterator: *mut CProfileIterator,
        spacing: ::std::os::raw::c_int,
    ) {
        CProfileManager_dumpRecursive(profileIterator, spacing)
    }
    #[inline]
    pub unsafe fn dumpAll() {
        CProfileManager_dumpAll()
    }
}
/// ProfileSampleClass is a simple way to profile a function's scope
/// Use the BT_PROFILE macro at the start of scope to time
#[repr(C)]
#[derive(Debug)]
pub struct CProfileSample {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_CProfileSample() {
    assert_eq!(
        ::std::mem::size_of::<CProfileSample>(),
        1usize,
        concat!("Size of: ", stringify!(CProfileSample))
    );
    assert_eq!(
        ::std::mem::align_of::<CProfileSample>(),
        1usize,
        concat!("Alignment of ", stringify!(CProfileSample))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14CProfileSampleC1EPKc"]
    pub fn CProfileSample_CProfileSample(
        this: *mut CProfileSample,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14CProfileSampleD1Ev"]
    pub fn CProfileSample_CProfileSample_destructor(this: *mut CProfileSample);
}
impl CProfileSample {
    #[inline]
    pub unsafe fn new(name: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        CProfileSample_CProfileSample(&mut __bindgen_tmp, name);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        CProfileSample_CProfileSample_destructor(self)
    }
}
#[repr(C)]
pub struct btIDebugDraw__bindgen_vtable(::std::os::raw::c_void);
/// The btIDebugDraw interface class allows hooking up a debug renderer to visually debug simulations.
/// Typical use case: create a debug drawer object, and assign it to a btCollisionWorld or btDynamicsWorld using setDebugDrawer and call debugDrawWorld.
/// A class that implements the btIDebugDraw interface has to implement the drawLine method at a minimum.
/// For color arguments the X,Y,Z components refer to Red, Green and Blue each in the range [0..1]
#[repr(C)]
#[derive(Debug)]
pub struct btIDebugDraw {
    pub vtable_: *const btIDebugDraw__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btIDebugDraw_DefaultColors {
    pub m_activeObject: btVector3,
    pub m_deactivatedObject: btVector3,
    pub m_wantsDeactivationObject: btVector3,
    pub m_disabledDeactivationObject: btVector3,
    pub m_disabledSimulationObject: btVector3,
    pub m_aabb: btVector3,
    pub m_contactPoint: btVector3,
}
#[test]
fn bindgen_test_layout_btIDebugDraw_DefaultColors() {
    assert_eq!(
        ::std::mem::size_of::<btIDebugDraw_DefaultColors>(),
        224usize,
        concat!("Size of: ", stringify!(btIDebugDraw_DefaultColors))
    );
    assert_eq!(
        ::std::mem::align_of::<btIDebugDraw_DefaultColors>(),
        8usize,
        concat!("Alignment of ", stringify!(btIDebugDraw_DefaultColors))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btIDebugDraw_DefaultColors)).m_activeObject as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIDebugDraw_DefaultColors),
            "::",
            stringify!(m_activeObject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btIDebugDraw_DefaultColors)).m_deactivatedObject as *const _ as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIDebugDraw_DefaultColors),
            "::",
            stringify!(m_deactivatedObject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btIDebugDraw_DefaultColors)).m_wantsDeactivationObject as *const _
                as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIDebugDraw_DefaultColors),
            "::",
            stringify!(m_wantsDeactivationObject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btIDebugDraw_DefaultColors)).m_disabledDeactivationObject as *const _
                as usize
        },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIDebugDraw_DefaultColors),
            "::",
            stringify!(m_disabledDeactivationObject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btIDebugDraw_DefaultColors)).m_disabledSimulationObject as *const _
                as usize
        },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIDebugDraw_DefaultColors),
            "::",
            stringify!(m_disabledSimulationObject)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btIDebugDraw_DefaultColors)).m_aabb as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIDebugDraw_DefaultColors),
            "::",
            stringify!(m_aabb)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btIDebugDraw_DefaultColors)).m_contactPoint as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btIDebugDraw_DefaultColors),
            "::",
            stringify!(m_contactPoint)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw13DefaultColorsC1Ev"]
    pub fn btIDebugDraw_DefaultColors_DefaultColors(this: *mut btIDebugDraw_DefaultColors);
}
impl btIDebugDraw_DefaultColors {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btIDebugDraw_DefaultColors_DefaultColors(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
pub const btIDebugDraw_DebugDrawModes_DBG_NoDebug: btIDebugDraw_DebugDrawModes = 0;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawWireframe: btIDebugDraw_DebugDrawModes = 1;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawAabb: btIDebugDraw_DebugDrawModes = 2;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawFeaturesText: btIDebugDraw_DebugDrawModes = 4;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawContactPoints: btIDebugDraw_DebugDrawModes = 8;
pub const btIDebugDraw_DebugDrawModes_DBG_NoDeactivation: btIDebugDraw_DebugDrawModes = 16;
pub const btIDebugDraw_DebugDrawModes_DBG_NoHelpText: btIDebugDraw_DebugDrawModes = 32;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawText: btIDebugDraw_DebugDrawModes = 64;
pub const btIDebugDraw_DebugDrawModes_DBG_ProfileTimings: btIDebugDraw_DebugDrawModes = 128;
pub const btIDebugDraw_DebugDrawModes_DBG_EnableSatComparison: btIDebugDraw_DebugDrawModes = 256;
pub const btIDebugDraw_DebugDrawModes_DBG_DisableBulletLCP: btIDebugDraw_DebugDrawModes = 512;
pub const btIDebugDraw_DebugDrawModes_DBG_EnableCCD: btIDebugDraw_DebugDrawModes = 1024;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawConstraints: btIDebugDraw_DebugDrawModes = 2048;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawConstraintLimits: btIDebugDraw_DebugDrawModes = 4096;
pub const btIDebugDraw_DebugDrawModes_DBG_FastWireframe: btIDebugDraw_DebugDrawModes = 8192;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawNormals: btIDebugDraw_DebugDrawModes = 16384;
pub const btIDebugDraw_DebugDrawModes_DBG_DrawFrames: btIDebugDraw_DebugDrawModes = 32768;
pub const btIDebugDraw_DebugDrawModes_DBG_MAX_DEBUG_DRAW_MODE: btIDebugDraw_DebugDrawModes = 32769;
pub type btIDebugDraw_DebugDrawModes = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_btIDebugDraw() {
    assert_eq!(
        ::std::mem::size_of::<btIDebugDraw>(),
        8usize,
        concat!("Size of: ", stringify!(btIDebugDraw))
    );
    assert_eq!(
        ::std::mem::align_of::<btIDebugDraw>(),
        8usize,
        concat!("Alignment of ", stringify!(btIDebugDraw))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDrawD0Ev"]
    pub fn btIDebugDraw_btIDebugDraw_destructor(this: *mut btIDebugDraw);
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btIDebugDraw16getDefaultColorsEv"]
    pub fn btIDebugDraw_getDefaultColors(
        this: *mut ::std::os::raw::c_void,
    ) -> btIDebugDraw_DefaultColors;
}
extern "C" {

    /// the default implementation for setDefaultColors has no effect. A derived class can implement it and store the colors.

    #[link_name = "\u{1}_ZN12btIDebugDraw16setDefaultColorsERKNS_13DefaultColorsE"]
    pub fn btIDebugDraw_setDefaultColors(
        this: *mut ::std::os::raw::c_void,
        arg1: *const btIDebugDraw_DefaultColors,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw8drawLineERK9btVector3S2_S2_"]
    pub fn btIDebugDraw_drawLine(
        this: *mut ::std::os::raw::c_void,
        from: *const btVector3,
        to: *const btVector3,
        color: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw8drawLineERK9btVector3S2_S2_S2_"]
    pub fn btIDebugDraw_drawLine1(
        this: *mut ::std::os::raw::c_void,
        from: *const btVector3,
        to: *const btVector3,
        fromColor: *const btVector3,
        toColor: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw10drawSphereEdRK11btTransformRK9btVector3"]
    pub fn btIDebugDraw_drawSphere(
        this: *mut ::std::os::raw::c_void,
        radius: btScalar,
        transform: *const btTransform,
        color: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw10drawSphereERK9btVector3dS2_"]
    pub fn btIDebugDraw_drawSphere1(
        this: *mut ::std::os::raw::c_void,
        p: *const btVector3,
        radius: btScalar,
        color: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw12drawTriangleERK9btVector3S2_S2_S2_S2_S2_S2_d"]
    pub fn btIDebugDraw_drawTriangle(
        this: *mut ::std::os::raw::c_void,
        v0: *const btVector3,
        v1: *const btVector3,
        v2: *const btVector3,
        arg1: *const btVector3,
        arg2: *const btVector3,
        arg3: *const btVector3,
        color: *const btVector3,
        alpha: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw12drawTriangleERK9btVector3S2_S2_S2_d"]
    pub fn btIDebugDraw_drawTriangle1(
        this: *mut ::std::os::raw::c_void,
        v0: *const btVector3,
        v1: *const btVector3,
        v2: *const btVector3,
        color: *const btVector3,
        arg1: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw16drawContactPointERK9btVector3S2_diS2_"]
    pub fn btIDebugDraw_drawContactPoint(
        this: *mut ::std::os::raw::c_void,
        PointOnB: *const btVector3,
        normalOnB: *const btVector3,
        distance: btScalar,
        lifeTime: ::std::os::raw::c_int,
        color: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw18reportErrorWarningEPKc"]
    pub fn btIDebugDraw_reportErrorWarning(
        this: *mut ::std::os::raw::c_void,
        warningString: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw10draw3dTextERK9btVector3PKc"]
    pub fn btIDebugDraw_draw3dText(
        this: *mut ::std::os::raw::c_void,
        location: *const btVector3,
        textString: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw12setDebugModeEi"]
    pub fn btIDebugDraw_setDebugMode(
        this: *mut ::std::os::raw::c_void,
        debugMode: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btIDebugDraw12getDebugModeEv"]
    pub fn btIDebugDraw_getDebugMode(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw8drawAabbERK9btVector3S2_S2_"]
    pub fn btIDebugDraw_drawAabb(
        this: *mut ::std::os::raw::c_void,
        from: *const btVector3,
        to: *const btVector3,
        color: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw13drawTransformERK11btTransformd"]
    pub fn btIDebugDraw_drawTransform(
        this: *mut ::std::os::raw::c_void,
        transform: *const btTransform,
        orthoLen: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw7drawArcERK9btVector3S2_S2_ddddS2_bd"]
    pub fn btIDebugDraw_drawArc(
        this: *mut ::std::os::raw::c_void,
        center: *const btVector3,
        normal: *const btVector3,
        axis: *const btVector3,
        radiusA: btScalar,
        radiusB: btScalar,
        minAngle: btScalar,
        maxAngle: btScalar,
        color: *const btVector3,
        drawSect: bool,
        stepDegrees: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw15drawSpherePatchERK9btVector3S2_S2_dddddS2_db"]
    pub fn btIDebugDraw_drawSpherePatch(
        this: *mut ::std::os::raw::c_void,
        center: *const btVector3,
        up: *const btVector3,
        axis: *const btVector3,
        radius: btScalar,
        minTh: btScalar,
        maxTh: btScalar,
        minPs: btScalar,
        maxPs: btScalar,
        color: *const btVector3,
        stepDegrees: btScalar,
        drawCenter: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw7drawBoxERK9btVector3S2_S2_"]
    pub fn btIDebugDraw_drawBox(
        this: *mut ::std::os::raw::c_void,
        bbMin: *const btVector3,
        bbMax: *const btVector3,
        color: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw7drawBoxERK9btVector3S2_RK11btTransformS2_"]
    pub fn btIDebugDraw_drawBox1(
        this: *mut ::std::os::raw::c_void,
        bbMin: *const btVector3,
        bbMax: *const btVector3,
        trans: *const btTransform,
        color: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw11drawCapsuleEddiRK11btTransformRK9btVector3"]
    pub fn btIDebugDraw_drawCapsule(
        this: *mut ::std::os::raw::c_void,
        radius: btScalar,
        halfHeight: btScalar,
        upAxis: ::std::os::raw::c_int,
        transform: *const btTransform,
        color: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw12drawCylinderEddiRK11btTransformRK9btVector3"]
    pub fn btIDebugDraw_drawCylinder(
        this: *mut ::std::os::raw::c_void,
        radius: btScalar,
        halfHeight: btScalar,
        upAxis: ::std::os::raw::c_int,
        transform: *const btTransform,
        color: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw8drawConeEddiRK11btTransformRK9btVector3"]
    pub fn btIDebugDraw_drawCone(
        this: *mut ::std::os::raw::c_void,
        radius: btScalar,
        height: btScalar,
        upAxis: ::std::os::raw::c_int,
        transform: *const btTransform,
        color: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw9drawPlaneERK9btVector3dRK11btTransformS2_"]
    pub fn btIDebugDraw_drawPlane(
        this: *mut ::std::os::raw::c_void,
        planeNormal: *const btVector3,
        planeConst: btScalar,
        transform: *const btTransform,
        color: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw10clearLinesEv"]
    pub fn btIDebugDraw_clearLines(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN12btIDebugDraw10flushLinesEv"]
    pub fn btIDebugDraw_flushLines(this: *mut ::std::os::raw::c_void);
}
pub const btSolverMode_SOLVER_RANDMIZE_ORDER: btSolverMode = 1;
pub const btSolverMode_SOLVER_FRICTION_SEPARATE: btSolverMode = 2;
pub const btSolverMode_SOLVER_USE_WARMSTARTING: btSolverMode = 4;
pub const btSolverMode_SOLVER_USE_2_FRICTION_DIRECTIONS: btSolverMode = 16;
pub const btSolverMode_SOLVER_ENABLE_FRICTION_DIRECTION_CACHING: btSolverMode = 32;
pub const btSolverMode_SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION: btSolverMode = 64;
pub const btSolverMode_SOLVER_CACHE_FRIENDLY: btSolverMode = 128;
pub const btSolverMode_SOLVER_SIMD: btSolverMode = 256;
pub const btSolverMode_SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS: btSolverMode = 512;
pub const btSolverMode_SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS: btSolverMode = 1024;
pub type btSolverMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btContactSolverInfoData {
    pub m_tau: btScalar,
    pub m_damping: btScalar,
    pub m_friction: btScalar,
    pub m_timeStep: btScalar,
    pub m_restitution: btScalar,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_maxErrorReduction: btScalar,
    pub m_sor: btScalar,
    pub m_erp: btScalar,
    pub m_erp2: btScalar,
    pub m_globalCfm: btScalar,
    pub m_frictionERP: btScalar,
    pub m_frictionCFM: btScalar,
    pub m_splitImpulse: ::std::os::raw::c_int,
    pub m_splitImpulsePenetrationThreshold: btScalar,
    pub m_splitImpulseTurnErp: btScalar,
    pub m_linearSlop: btScalar,
    pub m_warmstartingFactor: btScalar,
    pub m_solverMode: ::std::os::raw::c_int,
    pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
    pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
    pub m_maxGyroscopicForce: btScalar,
    pub m_singleAxisRollingFrictionThreshold: btScalar,
    pub m_leastSquaresResidualThreshold: btScalar,
    pub m_restitutionVelocityThreshold: btScalar,
}
#[test]
fn bindgen_test_layout_btContactSolverInfoData() {
    assert_eq!(
        ::std::mem::size_of::<btContactSolverInfoData>(),
        192usize,
        concat!("Size of: ", stringify!(btContactSolverInfoData))
    );
    assert_eq!(
        ::std::mem::align_of::<btContactSolverInfoData>(),
        8usize,
        concat!("Alignment of ", stringify!(btContactSolverInfoData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_tau as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_tau)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_damping as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_damping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_friction as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_friction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_timeStep as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_timeStep)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_restitution as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_restitution)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_numIterations as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_numIterations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoData)).m_maxErrorReduction as *const _ as usize
        },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_maxErrorReduction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_sor as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_sor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_erp as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_erp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_erp2 as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_erp2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_globalCfm as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_globalCfm)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_frictionERP as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_frictionERP)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_frictionCFM as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_frictionCFM)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_splitImpulse as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_splitImpulse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoData)).m_splitImpulsePenetrationThreshold as *const _
                as usize
        },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_splitImpulsePenetrationThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoData)).m_splitImpulseTurnErp as *const _ as usize
        },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_splitImpulseTurnErp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_linearSlop as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_linearSlop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoData)).m_warmstartingFactor as *const _ as usize
        },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_warmstartingFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoData)).m_solverMode as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_solverMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoData)).m_restingContactRestitutionThreshold
                as *const _ as usize
        },
        148usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_restingContactRestitutionThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoData)).m_minimumSolverBatchSize as *const _ as usize
        },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_minimumSolverBatchSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoData)).m_maxGyroscopicForce as *const _ as usize
        },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_maxGyroscopicForce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoData)).m_singleAxisRollingFrictionThreshold
                as *const _ as usize
        },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_singleAxisRollingFrictionThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoData)).m_leastSquaresResidualThreshold as *const _
                as usize
        },
        176usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_leastSquaresResidualThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoData)).m_restitutionVelocityThreshold as *const _
                as usize
        },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoData),
            "::",
            stringify!(m_restitutionVelocityThreshold)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btContactSolverInfo {
    pub _base: btContactSolverInfoData,
}
#[test]
fn bindgen_test_layout_btContactSolverInfo() {
    assert_eq!(
        ::std::mem::size_of::<btContactSolverInfo>(),
        192usize,
        concat!("Size of: ", stringify!(btContactSolverInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<btContactSolverInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(btContactSolverInfo))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19btContactSolverInfoC1Ev"]
    pub fn btContactSolverInfo_btContactSolverInfo(this: *mut btContactSolverInfo);
}
impl btContactSolverInfo {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btContactSolverInfo_btContactSolverInfo(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btContactSolverInfoDoubleData {
    pub m_tau: f64,
    pub m_damping: f64,
    pub m_friction: f64,
    pub m_timeStep: f64,
    pub m_restitution: f64,
    pub m_maxErrorReduction: f64,
    pub m_sor: f64,
    pub m_erp: f64,
    pub m_erp2: f64,
    pub m_globalCfm: f64,
    pub m_splitImpulsePenetrationThreshold: f64,
    pub m_splitImpulseTurnErp: f64,
    pub m_linearSlop: f64,
    pub m_warmstartingFactor: f64,
    pub m_maxGyroscopicForce: f64,
    /// it is only used for 'explicit' version of gyroscopic force
    pub m_singleAxisRollingFrictionThreshold: f64,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_solverMode: ::std::os::raw::c_int,
    pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
    pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
    pub m_splitImpulse: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btContactSolverInfoDoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btContactSolverInfoDoubleData>(),
        152usize,
        concat!("Size of: ", stringify!(btContactSolverInfoDoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btContactSolverInfoDoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btContactSolverInfoDoubleData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoDoubleData)).m_tau as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_tau)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoDoubleData)).m_damping as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_damping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoDoubleData)).m_friction as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_friction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoDoubleData)).m_timeStep as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_timeStep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoDoubleData)).m_restitution as *const _ as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_restitution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoDoubleData)).m_maxErrorReduction as *const _ as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_maxErrorReduction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoDoubleData)).m_sor as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_sor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoDoubleData)).m_erp as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_erp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoDoubleData)).m_erp2 as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_erp2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoDoubleData)).m_globalCfm as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_globalCfm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoDoubleData)).m_splitImpulsePenetrationThreshold
                as *const _ as usize
        },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_splitImpulsePenetrationThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoDoubleData)).m_splitImpulseTurnErp as *const _
                as usize
        },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_splitImpulseTurnErp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoDoubleData)).m_linearSlop as *const _ as usize
        },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_linearSlop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoDoubleData)).m_warmstartingFactor as *const _
                as usize
        },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_warmstartingFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoDoubleData)).m_maxGyroscopicForce as *const _
                as usize
        },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_maxGyroscopicForce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoDoubleData)).m_singleAxisRollingFrictionThreshold
                as *const _ as usize
        },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_singleAxisRollingFrictionThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoDoubleData)).m_numIterations as *const _ as usize
        },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_numIterations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoDoubleData)).m_solverMode as *const _ as usize
        },
        132usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_solverMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoDoubleData)).m_restingContactRestitutionThreshold
                as *const _ as usize
        },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_restingContactRestitutionThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoDoubleData)).m_minimumSolverBatchSize as *const _
                as usize
        },
        140usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_minimumSolverBatchSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoDoubleData)).m_splitImpulse as *const _ as usize
        },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_splitImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoDoubleData)).m_padding as *const _ as usize },
        148usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoDoubleData),
            "::",
            stringify!(m_padding)
        )
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btContactSolverInfoFloatData {
    pub m_tau: f32,
    pub m_damping: f32,
    pub m_friction: f32,
    pub m_timeStep: f32,
    pub m_restitution: f32,
    pub m_maxErrorReduction: f32,
    pub m_sor: f32,
    pub m_erp: f32,
    pub m_erp2: f32,
    pub m_globalCfm: f32,
    pub m_splitImpulsePenetrationThreshold: f32,
    pub m_splitImpulseTurnErp: f32,
    pub m_linearSlop: f32,
    pub m_warmstartingFactor: f32,
    pub m_maxGyroscopicForce: f32,
    pub m_singleAxisRollingFrictionThreshold: f32,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_solverMode: ::std::os::raw::c_int,
    pub m_restingContactRestitutionThreshold: ::std::os::raw::c_int,
    pub m_minimumSolverBatchSize: ::std::os::raw::c_int,
    pub m_splitImpulse: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btContactSolverInfoFloatData() {
    assert_eq!(
        ::std::mem::size_of::<btContactSolverInfoFloatData>(),
        88usize,
        concat!("Size of: ", stringify!(btContactSolverInfoFloatData))
    );
    assert_eq!(
        ::std::mem::align_of::<btContactSolverInfoFloatData>(),
        4usize,
        concat!("Alignment of ", stringify!(btContactSolverInfoFloatData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoFloatData)).m_tau as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_tau)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoFloatData)).m_damping as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_damping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoFloatData)).m_friction as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_friction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoFloatData)).m_timeStep as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_timeStep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoFloatData)).m_restitution as *const _ as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_restitution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoFloatData)).m_maxErrorReduction as *const _ as usize
        },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_maxErrorReduction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoFloatData)).m_sor as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_sor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoFloatData)).m_erp as *const _ as usize },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_erp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoFloatData)).m_erp2 as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_erp2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoFloatData)).m_globalCfm as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_globalCfm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoFloatData)).m_splitImpulsePenetrationThreshold
                as *const _ as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_splitImpulsePenetrationThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoFloatData)).m_splitImpulseTurnErp as *const _
                as usize
        },
        44usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_splitImpulseTurnErp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoFloatData)).m_linearSlop as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_linearSlop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoFloatData)).m_warmstartingFactor as *const _ as usize
        },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_warmstartingFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoFloatData)).m_maxGyroscopicForce as *const _ as usize
        },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_maxGyroscopicForce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoFloatData)).m_singleAxisRollingFrictionThreshold
                as *const _ as usize
        },
        60usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_singleAxisRollingFrictionThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoFloatData)).m_numIterations as *const _ as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_numIterations)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoFloatData)).m_solverMode as *const _ as usize },
        68usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_solverMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoFloatData)).m_restingContactRestitutionThreshold
                as *const _ as usize
        },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_restingContactRestitutionThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoFloatData)).m_minimumSolverBatchSize as *const _
                as usize
        },
        76usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_minimumSolverBatchSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btContactSolverInfoFloatData)).m_splitImpulse as *const _ as usize
        },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_splitImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btContactSolverInfoFloatData)).m_padding as *const _ as usize },
        84usize,
        concat!(
            "Alignment of field: ",
            stringify!(btContactSolverInfoFloatData),
            "::",
            stringify!(m_padding)
        )
    );
}
/// Type for the callback for each tick
pub type btInternalTickCallback = ::std::option::Option<
    unsafe extern "C" fn(world: *mut btDynamicsWorld, timeStep: btScalar),
>;
pub const btDynamicsWorldType_BT_SIMPLE_DYNAMICS_WORLD: btDynamicsWorldType = 1;
pub const btDynamicsWorldType_BT_DISCRETE_DYNAMICS_WORLD: btDynamicsWorldType = 2;
pub const btDynamicsWorldType_BT_CONTINUOUS_DYNAMICS_WORLD: btDynamicsWorldType = 3;
pub const btDynamicsWorldType_BT_SOFT_RIGID_DYNAMICS_WORLD: btDynamicsWorldType = 4;
pub const btDynamicsWorldType_BT_GPU_DYNAMICS_WORLD: btDynamicsWorldType = 5;
pub const btDynamicsWorldType_BT_SOFT_MULTIBODY_DYNAMICS_WORLD: btDynamicsWorldType = 6;
pub type btDynamicsWorldType = ::std::os::raw::c_uint;
/// The btDynamicsWorld is the interface class for several dynamics implementation, basic, discrete, parallel, and continuous etc.
#[repr(C)]
#[derive(Debug)]
pub struct btDynamicsWorld {
    pub _base: btCollisionWorld,
    pub m_internalTickCallback: btInternalTickCallback,
    pub m_internalPreTickCallback: btInternalTickCallback,
    pub m_worldUserInfo: *mut ::std::os::raw::c_void,
    pub m_solverInfo: btContactSolverInfo,
}
#[test]
fn bindgen_test_layout_btDynamicsWorld() {
    assert_eq!(
        ::std::mem::size_of::<btDynamicsWorld>(),
        360usize,
        concat!("Size of: ", stringify!(btDynamicsWorld))
    );
    assert_eq!(
        ::std::mem::align_of::<btDynamicsWorld>(),
        8usize,
        concat!("Alignment of ", stringify!(btDynamicsWorld))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDynamicsWorld)).m_internalTickCallback as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDynamicsWorld),
            "::",
            stringify!(m_internalTickCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDynamicsWorld)).m_internalPreTickCallback as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDynamicsWorld),
            "::",
            stringify!(m_internalPreTickCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDynamicsWorld)).m_worldUserInfo as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDynamicsWorld),
            "::",
            stringify!(m_worldUserInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDynamicsWorld)).m_solverInfo as *const _ as usize },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDynamicsWorld),
            "::",
            stringify!(m_solverInfo)
        )
    );
}
extern "C" {

    /// Set the callback for when an internal tick (simulation substep) happens, optional user info

    #[link_name = "\u{1}_ZN15btDynamicsWorld23setInternalTickCallbackEPFvPS_dEPvb"]
    pub fn btDynamicsWorld_setInternalTickCallback(
        this: *mut btDynamicsWorld,
        cb: btInternalTickCallback,
        worldUserInfo: *mut ::std::os::raw::c_void,
        isPreTick: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld16setWorldUserInfoEPv"]
    pub fn btDynamicsWorld_setWorldUserInfo(
        this: *mut btDynamicsWorld,
        worldUserInfo: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btDynamicsWorld16getWorldUserInfoEv"]
    pub fn btDynamicsWorld_getWorldUserInfo(
        this: *const btDynamicsWorld,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld13getSolverInfoEv"]
    pub fn btDynamicsWorld_getSolverInfo(this: *mut btDynamicsWorld) -> *mut btContactSolverInfo;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btDynamicsWorld13getSolverInfoEv"]
    pub fn btDynamicsWorld_getSolverInfo1(
        this: *const btDynamicsWorld,
    ) -> *const btContactSolverInfo;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorldC2EP12btDispatcherP21btBroadphaseInterfaceP24btCollisionConfiguration"]
    pub fn btDynamicsWorld_btDynamicsWorld(
        this: *mut btDynamicsWorld,
        dispatcher: *mut btDispatcher,
        broadphase: *mut btBroadphaseInterface,
        collisionConfiguration: *mut btCollisionConfiguration,
    );
}
impl btDynamicsWorld {
    #[inline]
    pub unsafe fn setInternalTickCallback(
        &mut self,
        cb: btInternalTickCallback,
        worldUserInfo: *mut ::std::os::raw::c_void,
        isPreTick: bool,
    ) {
        btDynamicsWorld_setInternalTickCallback(self, cb, worldUserInfo, isPreTick)
    }
    #[inline]
    pub unsafe fn setWorldUserInfo(&mut self, worldUserInfo: *mut ::std::os::raw::c_void) {
        btDynamicsWorld_setWorldUserInfo(self, worldUserInfo)
    }
    #[inline]
    pub unsafe fn getWorldUserInfo(&self) -> *mut ::std::os::raw::c_void {
        btDynamicsWorld_getWorldUserInfo(self)
    }
    #[inline]
    pub unsafe fn getSolverInfo(&mut self) -> *mut btContactSolverInfo {
        btDynamicsWorld_getSolverInfo(self)
    }
    #[inline]
    pub unsafe fn getSolverInfo1(&self) -> *const btContactSolverInfo {
        btDynamicsWorld_getSolverInfo1(self)
    }
    #[inline]
    pub unsafe fn new(
        dispatcher: *mut btDispatcher,
        broadphase: *mut btBroadphaseInterface,
        collisionConfiguration: *mut btCollisionConfiguration,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDynamicsWorld_btDynamicsWorld(
            &mut __bindgen_tmp,
            dispatcher,
            broadphase,
            collisionConfiguration,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorldD0Ev"]
    pub fn btDynamicsWorld_btDynamicsWorld_destructor(this: *mut btDynamicsWorld);
}
extern "C" {

    /// stepSimulation proceeds the simulation over 'timeStep', units in preferably in seconds.
    /// ///By default, Bullet will subdivide the timestep in constant substeps of each 'fixedTimeStep'.
    /// ///in order to keep the simulation real-time, the maximum number of substeps can be clamped to 'maxSubSteps'.
    /// ///You can disable subdividing the timestep/substepping by passing maxSubSteps=0 as second argument to stepSimulation, but in that case you have to keep the timeStep constant.

    #[link_name = "\u{1}_ZN15btDynamicsWorld14stepSimulationEdid"]
    pub fn btDynamicsWorld_stepSimulation(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
        maxSubSteps: ::std::os::raw::c_int,
        fixedTimeStep: btScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld14debugDrawWorldEv"]
    pub fn btDynamicsWorld_debugDrawWorld(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld13addConstraintEP17btTypedConstraintb"]
    pub fn btDynamicsWorld_addConstraint(
        this: *mut ::std::os::raw::c_void,
        constraint: *mut btTypedConstraint,
        disableCollisionsBetweenLinkedBodies: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld16removeConstraintEP17btTypedConstraint"]
    pub fn btDynamicsWorld_removeConstraint(
        this: *mut ::std::os::raw::c_void,
        constraint: *mut btTypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld9addActionEP17btActionInterface"]
    pub fn btDynamicsWorld_addAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut btActionInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld12removeActionEP17btActionInterface"]
    pub fn btDynamicsWorld_removeAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut btActionInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld10setGravityERK9btVector3"]
    pub fn btDynamicsWorld_setGravity(this: *mut ::std::os::raw::c_void, gravity: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btDynamicsWorld10getGravityEv"]
    pub fn btDynamicsWorld_getGravity(this: *mut ::std::os::raw::c_void) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld23synchronizeMotionStatesEv"]
    pub fn btDynamicsWorld_synchronizeMotionStates(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld12addRigidBodyEP11btRigidBody"]
    pub fn btDynamicsWorld_addRigidBody(this: *mut ::std::os::raw::c_void, body: *mut btRigidBody);
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld12addRigidBodyEP11btRigidBodyii"]
    pub fn btDynamicsWorld_addRigidBody1(
        this: *mut ::std::os::raw::c_void,
        body: *mut btRigidBody,
        group: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld15removeRigidBodyEP11btRigidBody"]
    pub fn btDynamicsWorld_removeRigidBody(
        this: *mut ::std::os::raw::c_void,
        body: *mut btRigidBody,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld19setConstraintSolverEP18btConstraintSolver"]
    pub fn btDynamicsWorld_setConstraintSolver(
        this: *mut ::std::os::raw::c_void,
        solver: *mut btConstraintSolver,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld19getConstraintSolverEv"]
    pub fn btDynamicsWorld_getConstraintSolver(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btConstraintSolver;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btDynamicsWorld17getNumConstraintsEv"]
    pub fn btDynamicsWorld_getNumConstraints(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld13getConstraintEi"]
    pub fn btDynamicsWorld_getConstraint(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
    ) -> *mut btTypedConstraint;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btDynamicsWorld13getConstraintEi"]
    pub fn btDynamicsWorld_getConstraint1(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
    ) -> *const btTypedConstraint;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btDynamicsWorld12getWorldTypeEv"]
    pub fn btDynamicsWorld_getWorldType(this: *mut ::std::os::raw::c_void) -> btDynamicsWorldType;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btDynamicsWorld11clearForcesEv"]
    pub fn btDynamicsWorld_clearForces(this: *mut ::std::os::raw::c_void);
}
extern "C" {

    /// obsolete, use addAction instead.

    #[link_name = "\u{1}_ZN15btDynamicsWorld10addVehicleEP17btActionInterface"]
    pub fn btDynamicsWorld_addVehicle(
        this: *mut ::std::os::raw::c_void,
        vehicle: *mut btActionInterface,
    );
}
extern "C" {

    /// obsolete, use removeAction instead

    #[link_name = "\u{1}_ZN15btDynamicsWorld13removeVehicleEP17btActionInterface"]
    pub fn btDynamicsWorld_removeVehicle(
        this: *mut ::std::os::raw::c_void,
        vehicle: *mut btActionInterface,
    );
}
extern "C" {

    /// obsolete, use addAction instead.

    #[link_name = "\u{1}_ZN15btDynamicsWorld12addCharacterEP17btActionInterface"]
    pub fn btDynamicsWorld_addCharacter(
        this: *mut ::std::os::raw::c_void,
        character: *mut btActionInterface,
    );
}
extern "C" {

    /// obsolete, use removeAction instead

    #[link_name = "\u{1}_ZN15btDynamicsWorld15removeCharacterEP17btActionInterface"]
    pub fn btDynamicsWorld_removeCharacter(
        this: *mut ::std::os::raw::c_void,
        character: *mut btActionInterface,
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDynamicsWorldDoubleData {
    pub m_solverInfo: btContactSolverInfoDoubleData,
    pub m_gravity: btVector3DoubleData,
}
#[test]
fn bindgen_test_layout_btDynamicsWorldDoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btDynamicsWorldDoubleData>(),
        184usize,
        concat!("Size of: ", stringify!(btDynamicsWorldDoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btDynamicsWorldDoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btDynamicsWorldDoubleData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDynamicsWorldDoubleData)).m_solverInfo as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDynamicsWorldDoubleData),
            "::",
            stringify!(m_solverInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDynamicsWorldDoubleData)).m_gravity as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDynamicsWorldDoubleData),
            "::",
            stringify!(m_gravity)
        )
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btDynamicsWorldFloatData {
    pub m_solverInfo: btContactSolverInfoFloatData,
    pub m_gravity: btVector3FloatData,
}
#[test]
fn bindgen_test_layout_btDynamicsWorldFloatData() {
    assert_eq!(
        ::std::mem::size_of::<btDynamicsWorldFloatData>(),
        104usize,
        concat!("Size of: ", stringify!(btDynamicsWorldFloatData))
    );
    assert_eq!(
        ::std::mem::align_of::<btDynamicsWorldFloatData>(),
        4usize,
        concat!("Alignment of ", stringify!(btDynamicsWorldFloatData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDynamicsWorldFloatData)).m_solverInfo as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDynamicsWorldFloatData),
            "::",
            stringify!(m_solverInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDynamicsWorldFloatData)).m_gravity as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDynamicsWorldFloatData),
            "::",
            stringify!(m_gravity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSimulationIslandManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InplaceSolverIslandCallback {
    _unused: [u8; 0],
}
pub const BT_MAX_THREAD_COUNT: ::std::os::raw::c_uint = 64;
extern "C" {
    #[link_name = "\u{1}_Z14btIsMainThreadv"]
    pub fn btIsMainThread() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z19btThreadsAreRunningv"]
    pub fn btThreadsAreRunning() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z23btGetCurrentThreadIndexv"]
    pub fn btGetCurrentThreadIndex() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_Z25btResetThreadIndexCounterv"]
    pub fn btResetThreadIndexCounter();
}
///
/// btSpinMutex -- lightweight spin-mutex implemented with atomic ops, never puts
/// a thread to sleep because it is designed to be used with a task scheduler
/// which has one thread per core and the threads don't sleep until they
/// run out of tasks. Not good for general purpose use.
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSpinMutex {
    pub mLock: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btSpinMutex() {
    assert_eq!(
        ::std::mem::size_of::<btSpinMutex>(),
        4usize,
        concat!("Size of: ", stringify!(btSpinMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<btSpinMutex>(),
        4usize,
        concat!("Alignment of ", stringify!(btSpinMutex))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSpinMutex)).mLock as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSpinMutex),
            "::",
            stringify!(mLock)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11btSpinMutex4lockEv"]
    pub fn btSpinMutex_lock(this: *mut btSpinMutex);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btSpinMutex6unlockEv"]
    pub fn btSpinMutex_unlock(this: *mut btSpinMutex);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btSpinMutex7tryLockEv"]
    pub fn btSpinMutex_tryLock(this: *mut btSpinMutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btSpinMutexC1Ev"]
    pub fn btSpinMutex_btSpinMutex(this: *mut btSpinMutex);
}
impl btSpinMutex {
    #[inline]
    pub unsafe fn lock(&mut self) {
        btSpinMutex_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        btSpinMutex_unlock(self)
    }
    #[inline]
    pub unsafe fn tryLock(&mut self) -> bool {
        btSpinMutex_tryLock(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSpinMutex_btSpinMutex(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_Z11btMutexLockP11btSpinMutex"]
    pub fn btMutexLock(mutex: *mut btSpinMutex);
}
extern "C" {
    #[link_name = "\u{1}_Z13btMutexUnlockP11btSpinMutex"]
    pub fn btMutexUnlock(mutex: *mut btSpinMutex);
}
extern "C" {
    #[link_name = "\u{1}_Z14btMutexTryLockP11btSpinMutex"]
    pub fn btMutexTryLock(mutex: *mut btSpinMutex) -> bool;
}
#[repr(C)]
pub struct btIParallelForBody__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btIParallelForBody {
    pub vtable_: *const btIParallelForBody__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btIParallelForBody() {
    assert_eq!(
        ::std::mem::size_of::<btIParallelForBody>(),
        8usize,
        concat!("Size of: ", stringify!(btIParallelForBody))
    );
    assert_eq!(
        ::std::mem::align_of::<btIParallelForBody>(),
        8usize,
        concat!("Alignment of ", stringify!(btIParallelForBody))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btIParallelForBodyD0Ev"]
    pub fn btIParallelForBody_btIParallelForBody_destructor(this: *mut btIParallelForBody);
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btIParallelForBody7forLoopEii"]
    pub fn btIParallelForBody_forLoop(
        this: *mut ::std::os::raw::c_void,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
    );
}
#[repr(C)]
pub struct btITaskScheduler__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btITaskScheduler {
    pub vtable_: *const btITaskScheduler__bindgen_vtable,
    pub m_name: *const ::std::os::raw::c_char,
    pub m_savedThreadCounter: ::std::os::raw::c_uint,
    pub m_isActive: bool,
}
#[test]
fn bindgen_test_layout_btITaskScheduler() {
    assert_eq!(
        ::std::mem::size_of::<btITaskScheduler>(),
        24usize,
        concat!("Size of: ", stringify!(btITaskScheduler))
    );
    assert_eq!(
        ::std::mem::align_of::<btITaskScheduler>(),
        8usize,
        concat!("Alignment of ", stringify!(btITaskScheduler))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btITaskScheduler)).m_name as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btITaskScheduler),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btITaskScheduler)).m_savedThreadCounter as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btITaskScheduler),
            "::",
            stringify!(m_savedThreadCounter)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btITaskScheduler)).m_isActive as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(btITaskScheduler),
            "::",
            stringify!(m_isActive)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btITaskScheduler7getNameEv"]
    pub fn btITaskScheduler_getName(this: *const btITaskScheduler)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btITaskSchedulerC2EPKc"]
    pub fn btITaskScheduler_btITaskScheduler(
        this: *mut btITaskScheduler,
        name: *const ::std::os::raw::c_char,
    );
}
impl btITaskScheduler {
    #[inline]
    pub unsafe fn getName(&self) -> *const ::std::os::raw::c_char {
        btITaskScheduler_getName(self)
    }
    #[inline]
    pub unsafe fn new(name: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btITaskScheduler_btITaskScheduler(&mut __bindgen_tmp, name);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN16btITaskSchedulerD0Ev"]
    pub fn btITaskScheduler_btITaskScheduler_destructor(this: *mut btITaskScheduler);
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btITaskScheduler16getMaxNumThreadsEv"]
    pub fn btITaskScheduler_getMaxNumThreads(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btITaskScheduler13getNumThreadsEv"]
    pub fn btITaskScheduler_getNumThreads(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btITaskScheduler13setNumThreadsEi"]
    pub fn btITaskScheduler_setNumThreads(
        this: *mut ::std::os::raw::c_void,
        numThreads: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btITaskScheduler11parallelForEiiiRK18btIParallelForBody"]
    pub fn btITaskScheduler_parallelFor(
        this: *mut ::std::os::raw::c_void,
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        grainSize: ::std::os::raw::c_int,
        body: *const btIParallelForBody,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btITaskScheduler8activateEv"]
    pub fn btITaskScheduler_activate(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btITaskScheduler10deactivateEv"]
    pub fn btITaskScheduler_deactivate(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_Z18btSetTaskSchedulerP16btITaskScheduler"]
    pub fn btSetTaskScheduler(ts: *mut btITaskScheduler);
}
extern "C" {
    #[link_name = "\u{1}_Z18btGetTaskSchedulerv"]
    pub fn btGetTaskScheduler() -> *mut btITaskScheduler;
}
extern "C" {
    #[link_name = "\u{1}_Z28btGetSequentialTaskSchedulerv"]
    pub fn btGetSequentialTaskScheduler() -> *mut btITaskScheduler;
}
extern "C" {
    #[link_name = "\u{1}_Z24btGetOpenMPTaskSchedulerv"]
    pub fn btGetOpenMPTaskScheduler() -> *mut btITaskScheduler;
}
extern "C" {
    #[link_name = "\u{1}_Z21btGetTBBTaskSchedulerv"]
    pub fn btGetTBBTaskScheduler() -> *mut btITaskScheduler;
}
extern "C" {
    #[link_name = "\u{1}_Z21btGetPPLTaskSchedulerv"]
    pub fn btGetPPLTaskScheduler() -> *mut btITaskScheduler;
}
extern "C" {
    #[link_name = "\u{1}_Z13btParallelForiiiRK18btIParallelForBody"]
    pub fn btParallelFor(
        iBegin: ::std::os::raw::c_int,
        iEnd: ::std::os::raw::c_int,
        grainSize: ::std::os::raw::c_int,
        body: *const btIParallelForBody,
    );
}
/// btDiscreteDynamicsWorld provides discrete rigid body simulation
/// those classes replace the obsolete CcdPhysicsEnvironment/CcdPhysicsController
#[repr(C)]
#[derive(Debug)]
pub struct btDiscreteDynamicsWorld {
    pub _base: btDynamicsWorld,
    pub m_sortedConstraints: btAlignedObjectArray<*mut btTypedConstraint>,
    pub m_solverIslandCallback: *mut InplaceSolverIslandCallback,
    pub m_constraintSolver: *mut btConstraintSolver,
    pub m_islandManager: *mut btSimulationIslandManager,
    pub m_constraints: btAlignedObjectArray<*mut btTypedConstraint>,
    pub m_nonStaticRigidBodies: btAlignedObjectArray<*mut btRigidBody>,
    pub m_gravity: btVector3,
    pub m_localTime: btScalar,
    pub m_fixedTimeStep: btScalar,
    pub m_ownsIslandManager: bool,
    pub m_ownsConstraintSolver: bool,
    pub m_synchronizeAllMotionStates: bool,
    pub m_applySpeculativeContactRestitution: bool,
    pub m_actions: btAlignedObjectArray<*mut btActionInterface>,
    pub m_profileTimings: ::std::os::raw::c_int,
    pub m_latencyMotionStateInterpolation: bool,
    pub m_predictiveManifolds: btAlignedObjectArray<*mut btPersistentManifold>,
    pub m_predictiveManifoldsMutex: btSpinMutex,
}
#[test]
fn bindgen_test_layout_btDiscreteDynamicsWorld() {
    assert_eq!(
        ::std::mem::size_of::<btDiscreteDynamicsWorld>(),
        616usize,
        concat!("Size of: ", stringify!(btDiscreteDynamicsWorld))
    );
    assert_eq!(
        ::std::mem::align_of::<btDiscreteDynamicsWorld>(),
        8usize,
        concat!("Alignment of ", stringify!(btDiscreteDynamicsWorld))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDiscreteDynamicsWorld)).m_sortedConstraints as *const _ as usize
        },
        360usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_sortedConstraints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDiscreteDynamicsWorld)).m_solverIslandCallback as *const _ as usize
        },
        392usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_solverIslandCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDiscreteDynamicsWorld)).m_constraintSolver as *const _ as usize
        },
        400usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_constraintSolver)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDiscreteDynamicsWorld)).m_islandManager as *const _ as usize },
        408usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_islandManager)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDiscreteDynamicsWorld)).m_constraints as *const _ as usize },
        416usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_constraints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDiscreteDynamicsWorld)).m_nonStaticRigidBodies as *const _ as usize
        },
        448usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_nonStaticRigidBodies)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDiscreteDynamicsWorld)).m_gravity as *const _ as usize },
        480usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_gravity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDiscreteDynamicsWorld)).m_localTime as *const _ as usize },
        512usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_localTime)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDiscreteDynamicsWorld)).m_fixedTimeStep as *const _ as usize },
        520usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_fixedTimeStep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDiscreteDynamicsWorld)).m_ownsIslandManager as *const _ as usize
        },
        528usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_ownsIslandManager)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDiscreteDynamicsWorld)).m_ownsConstraintSolver as *const _ as usize
        },
        529usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_ownsConstraintSolver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDiscreteDynamicsWorld)).m_synchronizeAllMotionStates as *const _
                as usize
        },
        530usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_synchronizeAllMotionStates)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDiscreteDynamicsWorld)).m_applySpeculativeContactRestitution
                as *const _ as usize
        },
        531usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_applySpeculativeContactRestitution)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDiscreteDynamicsWorld)).m_actions as *const _ as usize },
        536usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_actions)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDiscreteDynamicsWorld)).m_profileTimings as *const _ as usize },
        568usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_profileTimings)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDiscreteDynamicsWorld)).m_latencyMotionStateInterpolation as *const _
                as usize
        },
        572usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_latencyMotionStateInterpolation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDiscreteDynamicsWorld)).m_predictiveManifolds as *const _ as usize
        },
        576usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_predictiveManifolds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btDiscreteDynamicsWorld)).m_predictiveManifoldsMutex as *const _
                as usize
        },
        608usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDiscreteDynamicsWorld),
            "::",
            stringify!(m_predictiveManifoldsMutex)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld27integrateTransformsInternalEPP11btRigidBodyid"]
    pub fn btDiscreteDynamicsWorld_integrateTransformsInternal(
        this: *mut btDiscreteDynamicsWorld,
        bodies: *mut *mut btRigidBody,
        numBodies: ::std::os::raw::c_int,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld13updateActionsEd"]
    pub fn btDiscreteDynamicsWorld_updateActions(
        this: *mut btDiscreteDynamicsWorld,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld14startProfilingEd"]
    pub fn btDiscreteDynamicsWorld_startProfiling(
        this: *mut btDiscreteDynamicsWorld,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld25releasePredictiveContactsEv"]
    pub fn btDiscreteDynamicsWorld_releasePredictiveContacts(this: *mut btDiscreteDynamicsWorld);
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld32createPredictiveContactsInternalEPP11btRigidBodyid"]
    pub fn btDiscreteDynamicsWorld_createPredictiveContactsInternal(
        this: *mut btDiscreteDynamicsWorld,
        bodies: *mut *mut btRigidBody,
        numBodies: ::std::os::raw::c_int,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld20serializeRigidBodiesEP12btSerializer"]
    pub fn btDiscreteDynamicsWorld_serializeRigidBodies(
        this: *mut btDiscreteDynamicsWorld,
        serializer: *mut btSerializer,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld26serializeDynamicsWorldInfoEP12btSerializer"]
    pub fn btDiscreteDynamicsWorld_serializeDynamicsWorldInfo(
        this: *mut btDiscreteDynamicsWorld,
        serializer: *mut btSerializer,
    );
}
extern "C" {

    /// this can be useful to synchronize a single rigid body -> graphics object

    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld28synchronizeSingleMotionStateEP11btRigidBody"]
    pub fn btDiscreteDynamicsWorld_synchronizeSingleMotionState(
        this: *mut btDiscreteDynamicsWorld,
        body: *mut btRigidBody,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld26getSimulationIslandManagerEv"]
    pub fn btDiscreteDynamicsWorld_getSimulationIslandManager(
        this: *mut btDiscreteDynamicsWorld,
    ) -> *mut btSimulationIslandManager;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btDiscreteDynamicsWorld26getSimulationIslandManagerEv"]
    pub fn btDiscreteDynamicsWorld_getSimulationIslandManager1(
        this: *const btDiscreteDynamicsWorld,
    ) -> *const btSimulationIslandManager;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld17getCollisionWorldEv"]
    pub fn btDiscreteDynamicsWorld_getCollisionWorld(
        this: *mut btDiscreteDynamicsWorld,
    ) -> *mut btCollisionWorld;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld29setSynchronizeAllMotionStatesEb"]
    pub fn btDiscreteDynamicsWorld_setSynchronizeAllMotionStates(
        this: *mut btDiscreteDynamicsWorld,
        synchronizeAll: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btDiscreteDynamicsWorld29getSynchronizeAllMotionStatesEv"]
    pub fn btDiscreteDynamicsWorld_getSynchronizeAllMotionStates(
        this: *const btDiscreteDynamicsWorld,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld37setApplySpeculativeContactRestitutionEb"]
    pub fn btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution(
        this: *mut btDiscreteDynamicsWorld,
        enable: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btDiscreteDynamicsWorld37getApplySpeculativeContactRestitutionEv"]
    pub fn btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution(
        this: *const btDiscreteDynamicsWorld,
    ) -> bool;
}
extern "C" {

    /// Interpolate motion state between previous and current transform, instead of current and next transform.
    /// ///This can relieve discontinuities in the rendering, due to penetrations

    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld34setLatencyMotionStateInterpolationEb"]
    pub fn btDiscreteDynamicsWorld_setLatencyMotionStateInterpolation(
        this: *mut btDiscreteDynamicsWorld,
        latencyInterpolation: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btDiscreteDynamicsWorld34getLatencyMotionStateInterpolationEv"]
    pub fn btDiscreteDynamicsWorld_getLatencyMotionStateInterpolation(
        this: *const btDiscreteDynamicsWorld,
    ) -> bool;
}
extern "C" {

    /// this btDiscreteDynamicsWorld constructor gets created objects from the user, and will not delete those

    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorldC1EP12btDispatcherP21btBroadphaseInterfaceP18btConstraintSolverP24btCollisionConfiguration"]
    pub fn btDiscreteDynamicsWorld_btDiscreteDynamicsWorld(
        this: *mut btDiscreteDynamicsWorld,
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
    );
}
impl btDiscreteDynamicsWorld {
    #[inline]
    pub unsafe fn integrateTransformsInternal(
        &mut self,
        bodies: *mut *mut btRigidBody,
        numBodies: ::std::os::raw::c_int,
        timeStep: btScalar,
    ) {
        btDiscreteDynamicsWorld_integrateTransformsInternal(self, bodies, numBodies, timeStep)
    }
    #[inline]
    pub unsafe fn updateActions(&mut self, timeStep: btScalar) {
        btDiscreteDynamicsWorld_updateActions(self, timeStep)
    }
    #[inline]
    pub unsafe fn startProfiling(&mut self, timeStep: btScalar) {
        btDiscreteDynamicsWorld_startProfiling(self, timeStep)
    }
    #[inline]
    pub unsafe fn releasePredictiveContacts(&mut self) {
        btDiscreteDynamicsWorld_releasePredictiveContacts(self)
    }
    #[inline]
    pub unsafe fn createPredictiveContactsInternal(
        &mut self,
        bodies: *mut *mut btRigidBody,
        numBodies: ::std::os::raw::c_int,
        timeStep: btScalar,
    ) {
        btDiscreteDynamicsWorld_createPredictiveContactsInternal(self, bodies, numBodies, timeStep)
    }
    #[inline]
    pub unsafe fn serializeRigidBodies(&mut self, serializer: *mut btSerializer) {
        btDiscreteDynamicsWorld_serializeRigidBodies(self, serializer)
    }
    #[inline]
    pub unsafe fn serializeDynamicsWorldInfo(&mut self, serializer: *mut btSerializer) {
        btDiscreteDynamicsWorld_serializeDynamicsWorldInfo(self, serializer)
    }
    #[inline]
    pub unsafe fn synchronizeSingleMotionState(&mut self, body: *mut btRigidBody) {
        btDiscreteDynamicsWorld_synchronizeSingleMotionState(self, body)
    }
    #[inline]
    pub unsafe fn getSimulationIslandManager(&mut self) -> *mut btSimulationIslandManager {
        btDiscreteDynamicsWorld_getSimulationIslandManager(self)
    }
    #[inline]
    pub unsafe fn getSimulationIslandManager1(&self) -> *const btSimulationIslandManager {
        btDiscreteDynamicsWorld_getSimulationIslandManager1(self)
    }
    #[inline]
    pub unsafe fn getCollisionWorld(&mut self) -> *mut btCollisionWorld {
        btDiscreteDynamicsWorld_getCollisionWorld(self)
    }
    #[inline]
    pub unsafe fn setSynchronizeAllMotionStates(&mut self, synchronizeAll: bool) {
        btDiscreteDynamicsWorld_setSynchronizeAllMotionStates(self, synchronizeAll)
    }
    #[inline]
    pub unsafe fn getSynchronizeAllMotionStates(&self) -> bool {
        btDiscreteDynamicsWorld_getSynchronizeAllMotionStates(self)
    }
    #[inline]
    pub unsafe fn setApplySpeculativeContactRestitution(&mut self, enable: bool) {
        btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution(self, enable)
    }
    #[inline]
    pub unsafe fn getApplySpeculativeContactRestitution(&self) -> bool {
        btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution(self)
    }
    #[inline]
    pub unsafe fn setLatencyMotionStateInterpolation(&mut self, latencyInterpolation: bool) {
        btDiscreteDynamicsWorld_setLatencyMotionStateInterpolation(self, latencyInterpolation)
    }
    #[inline]
    pub unsafe fn getLatencyMotionStateInterpolation(&self) -> bool {
        btDiscreteDynamicsWorld_getLatencyMotionStateInterpolation(self)
    }
    #[inline]
    pub unsafe fn new(
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDiscreteDynamicsWorld_btDiscreteDynamicsWorld(
            &mut __bindgen_tmp,
            dispatcher,
            pairCache,
            constraintSolver,
            collisionConfiguration,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld25predictUnconstraintMotionEd"]
    pub fn btDiscreteDynamicsWorld_predictUnconstraintMotion(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld19integrateTransformsEd"]
    pub fn btDiscreteDynamicsWorld_integrateTransforms(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld26calculateSimulationIslandsEv"]
    pub fn btDiscreteDynamicsWorld_calculateSimulationIslands(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld16solveConstraintsER19btContactSolverInfo"]
    pub fn btDiscreteDynamicsWorld_solveConstraints(
        this: *mut ::std::os::raw::c_void,
        solverInfo: *mut btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld21updateActivationStateEd"]
    pub fn btDiscreteDynamicsWorld_updateActivationState(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld28internalSingleStepSimulationEd"]
    pub fn btDiscreteDynamicsWorld_internalSingleStepSimulation(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld24createPredictiveContactsEd"]
    pub fn btDiscreteDynamicsWorld_createPredictiveContacts(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld18saveKinematicStateEd"]
    pub fn btDiscreteDynamicsWorld_saveKinematicState(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorldD0Ev"]
    pub fn btDiscreteDynamicsWorld_btDiscreteDynamicsWorld_destructor(
        this: *mut btDiscreteDynamicsWorld,
    );
}
extern "C" {

    /// if maxSubSteps > 0, it will interpolate motion between fixedTimeStep's

    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld14stepSimulationEdid"]
    pub fn btDiscreteDynamicsWorld_stepSimulation(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
        maxSubSteps: ::std::os::raw::c_int,
        fixedTimeStep: btScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld23synchronizeMotionStatesEv"]
    pub fn btDiscreteDynamicsWorld_synchronizeMotionStates(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld13addConstraintEP17btTypedConstraintb"]
    pub fn btDiscreteDynamicsWorld_addConstraint(
        this: *mut ::std::os::raw::c_void,
        constraint: *mut btTypedConstraint,
        disableCollisionsBetweenLinkedBodies: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld16removeConstraintEP17btTypedConstraint"]
    pub fn btDiscreteDynamicsWorld_removeConstraint(
        this: *mut ::std::os::raw::c_void,
        constraint: *mut btTypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld9addActionEP17btActionInterface"]
    pub fn btDiscreteDynamicsWorld_addAction(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btActionInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld12removeActionEP17btActionInterface"]
    pub fn btDiscreteDynamicsWorld_removeAction(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btActionInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld10setGravityERK9btVector3"]
    pub fn btDiscreteDynamicsWorld_setGravity(
        this: *mut ::std::os::raw::c_void,
        gravity: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btDiscreteDynamicsWorld10getGravityEv"]
    pub fn btDiscreteDynamicsWorld_getGravity(this: *mut ::std::os::raw::c_void) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld18addCollisionObjectEP17btCollisionObjectii"]
    pub fn btDiscreteDynamicsWorld_addCollisionObject(
        this: *mut ::std::os::raw::c_void,
        collisionObject: *mut btCollisionObject,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld12addRigidBodyEP11btRigidBody"]
    pub fn btDiscreteDynamicsWorld_addRigidBody(
        this: *mut ::std::os::raw::c_void,
        body: *mut btRigidBody,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld12addRigidBodyEP11btRigidBodyii"]
    pub fn btDiscreteDynamicsWorld_addRigidBody1(
        this: *mut ::std::os::raw::c_void,
        body: *mut btRigidBody,
        group: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld15removeRigidBodyEP11btRigidBody"]
    pub fn btDiscreteDynamicsWorld_removeRigidBody(
        this: *mut ::std::os::raw::c_void,
        body: *mut btRigidBody,
    );
}
extern "C" {

    /// removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btCollisionWorld::removeCollisionObject

    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld21removeCollisionObjectEP17btCollisionObject"]
    pub fn btDiscreteDynamicsWorld_removeCollisionObject(
        this: *mut ::std::os::raw::c_void,
        collisionObject: *mut btCollisionObject,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld19debugDrawConstraintEP17btTypedConstraint"]
    pub fn btDiscreteDynamicsWorld_debugDrawConstraint(
        this: *mut ::std::os::raw::c_void,
        constraint: *mut btTypedConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld14debugDrawWorldEv"]
    pub fn btDiscreteDynamicsWorld_debugDrawWorld(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld19setConstraintSolverEP18btConstraintSolver"]
    pub fn btDiscreteDynamicsWorld_setConstraintSolver(
        this: *mut ::std::os::raw::c_void,
        solver: *mut btConstraintSolver,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld19getConstraintSolverEv"]
    pub fn btDiscreteDynamicsWorld_getConstraintSolver(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btConstraintSolver;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btDiscreteDynamicsWorld17getNumConstraintsEv"]
    pub fn btDiscreteDynamicsWorld_getNumConstraints(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld13getConstraintEi"]
    pub fn btDiscreteDynamicsWorld_getConstraint(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
    ) -> *mut btTypedConstraint;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btDiscreteDynamicsWorld13getConstraintEi"]
    pub fn btDiscreteDynamicsWorld_getConstraint1(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
    ) -> *const btTypedConstraint;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btDiscreteDynamicsWorld12getWorldTypeEv"]
    pub fn btDiscreteDynamicsWorld_getWorldType(
        this: *mut ::std::os::raw::c_void,
    ) -> btDynamicsWorldType;
}
extern "C" {

    /// the forces on each rigidbody is accumulating together with gravity. clear this after each timestep.

    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld11clearForcesEv"]
    pub fn btDiscreteDynamicsWorld_clearForces(this: *mut ::std::os::raw::c_void);
}
extern "C" {

    /// apply gravity, call this once per timestep

    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld12applyGravityEv"]
    pub fn btDiscreteDynamicsWorld_applyGravity(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld11setNumTasksEi"]
    pub fn btDiscreteDynamicsWorld_setNumTasks(
        this: *mut ::std::os::raw::c_void,
        numTasks: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// obsolete, use updateActions instead

    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld14updateVehiclesEd"]
    pub fn btDiscreteDynamicsWorld_updateVehicles(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
    );
}
extern "C" {

    /// obsolete, use addAction instead

    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld10addVehicleEP17btActionInterface"]
    pub fn btDiscreteDynamicsWorld_addVehicle(
        this: *mut ::std::os::raw::c_void,
        vehicle: *mut btActionInterface,
    );
}
extern "C" {

    /// obsolete, use removeAction instead

    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld13removeVehicleEP17btActionInterface"]
    pub fn btDiscreteDynamicsWorld_removeVehicle(
        this: *mut ::std::os::raw::c_void,
        vehicle: *mut btActionInterface,
    );
}
extern "C" {

    /// obsolete, use addAction instead

    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld12addCharacterEP17btActionInterface"]
    pub fn btDiscreteDynamicsWorld_addCharacter(
        this: *mut ::std::os::raw::c_void,
        character: *mut btActionInterface,
    );
}
extern "C" {

    /// obsolete, use removeAction instead

    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld15removeCharacterEP17btActionInterface"]
    pub fn btDiscreteDynamicsWorld_removeCharacter(
        this: *mut ::std::os::raw::c_void,
        character: *mut btActionInterface,
    );
}
extern "C" {

    /// Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (see Bullet/Demos/SerializeDemo)

    #[link_name = "\u{1}_ZN23btDiscreteDynamicsWorld9serializeEP12btSerializer"]
    pub fn btDiscreteDynamicsWorld_serialize(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
/// The btSimpleDynamicsWorld serves as unit-test and to verify more complicated and optimized dynamics worlds.
/// Please use btDiscreteDynamicsWorld instead
#[repr(C)]
#[derive(Debug)]
pub struct btSimpleDynamicsWorld {
    pub _base: btDynamicsWorld,
    pub m_constraintSolver: *mut btConstraintSolver,
    pub m_ownsConstraintSolver: bool,
    pub m_gravity: btVector3,
}
#[test]
fn bindgen_test_layout_btSimpleDynamicsWorld() {
    assert_eq!(
        ::std::mem::size_of::<btSimpleDynamicsWorld>(),
        408usize,
        concat!("Size of: ", stringify!(btSimpleDynamicsWorld))
    );
    assert_eq!(
        ::std::mem::align_of::<btSimpleDynamicsWorld>(),
        8usize,
        concat!("Alignment of ", stringify!(btSimpleDynamicsWorld))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSimpleDynamicsWorld)).m_constraintSolver as *const _ as usize },
        360usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSimpleDynamicsWorld),
            "::",
            stringify!(m_constraintSolver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSimpleDynamicsWorld)).m_ownsConstraintSolver as *const _ as usize
        },
        368usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSimpleDynamicsWorld),
            "::",
            stringify!(m_ownsConstraintSolver)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSimpleDynamicsWorld)).m_gravity as *const _ as usize },
        376usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSimpleDynamicsWorld),
            "::",
            stringify!(m_gravity)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld25predictUnconstraintMotionEd"]
    pub fn btSimpleDynamicsWorld_predictUnconstraintMotion(
        this: *mut btSimpleDynamicsWorld,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld19integrateTransformsEd"]
    pub fn btSimpleDynamicsWorld_integrateTransforms(
        this: *mut btSimpleDynamicsWorld,
        timeStep: btScalar,
    );
}
extern "C" {

    /// this btSimpleDynamicsWorld constructor creates dispatcher, broadphase pairCache and constraintSolver

    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorldC1EP12btDispatcherP21btBroadphaseInterfaceP18btConstraintSolverP24btCollisionConfiguration"]
    pub fn btSimpleDynamicsWorld_btSimpleDynamicsWorld(
        this: *mut btSimpleDynamicsWorld,
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
    );
}
impl btSimpleDynamicsWorld {
    #[inline]
    pub unsafe fn predictUnconstraintMotion(&mut self, timeStep: btScalar) {
        btSimpleDynamicsWorld_predictUnconstraintMotion(self, timeStep)
    }
    #[inline]
    pub unsafe fn integrateTransforms(&mut self, timeStep: btScalar) {
        btSimpleDynamicsWorld_integrateTransforms(self, timeStep)
    }
    #[inline]
    pub unsafe fn new(
        dispatcher: *mut btDispatcher,
        pairCache: *mut btBroadphaseInterface,
        constraintSolver: *mut btConstraintSolver,
        collisionConfiguration: *mut btCollisionConfiguration,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSimpleDynamicsWorld_btSimpleDynamicsWorld(
            &mut __bindgen_tmp,
            dispatcher,
            pairCache,
            constraintSolver,
            collisionConfiguration,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorldD0Ev"]
    pub fn btSimpleDynamicsWorld_btSimpleDynamicsWorld_destructor(this: *mut btSimpleDynamicsWorld);
}
extern "C" {

    /// maxSubSteps/fixedTimeStep for interpolation is currently ignored for btSimpleDynamicsWorld, use btDiscreteDynamicsWorld instead

    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld14stepSimulationEdid"]
    pub fn btSimpleDynamicsWorld_stepSimulation(
        this: *mut ::std::os::raw::c_void,
        timeStep: btScalar,
        maxSubSteps: ::std::os::raw::c_int,
        fixedTimeStep: btScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld10setGravityERK9btVector3"]
    pub fn btSimpleDynamicsWorld_setGravity(
        this: *mut ::std::os::raw::c_void,
        gravity: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btSimpleDynamicsWorld10getGravityEv"]
    pub fn btSimpleDynamicsWorld_getGravity(this: *mut ::std::os::raw::c_void) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld12addRigidBodyEP11btRigidBody"]
    pub fn btSimpleDynamicsWorld_addRigidBody(
        this: *mut ::std::os::raw::c_void,
        body: *mut btRigidBody,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld12addRigidBodyEP11btRigidBodyii"]
    pub fn btSimpleDynamicsWorld_addRigidBody1(
        this: *mut ::std::os::raw::c_void,
        body: *mut btRigidBody,
        group: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld15removeRigidBodyEP11btRigidBody"]
    pub fn btSimpleDynamicsWorld_removeRigidBody(
        this: *mut ::std::os::raw::c_void,
        body: *mut btRigidBody,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld14debugDrawWorldEv"]
    pub fn btSimpleDynamicsWorld_debugDrawWorld(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld9addActionEP17btActionInterface"]
    pub fn btSimpleDynamicsWorld_addAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut btActionInterface,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld12removeActionEP17btActionInterface"]
    pub fn btSimpleDynamicsWorld_removeAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut btActionInterface,
    );
}
extern "C" {

    /// removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btCollisionWorld::removeCollisionObject

    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld21removeCollisionObjectEP17btCollisionObject"]
    pub fn btSimpleDynamicsWorld_removeCollisionObject(
        this: *mut ::std::os::raw::c_void,
        collisionObject: *mut btCollisionObject,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld11updateAabbsEv"]
    pub fn btSimpleDynamicsWorld_updateAabbs(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld23synchronizeMotionStatesEv"]
    pub fn btSimpleDynamicsWorld_synchronizeMotionStates(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld19setConstraintSolverEP18btConstraintSolver"]
    pub fn btSimpleDynamicsWorld_setConstraintSolver(
        this: *mut ::std::os::raw::c_void,
        solver: *mut btConstraintSolver,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld19getConstraintSolverEv"]
    pub fn btSimpleDynamicsWorld_getConstraintSolver(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut btConstraintSolver;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btSimpleDynamicsWorld12getWorldTypeEv"]
    pub fn btSimpleDynamicsWorld_getWorldType(
        this: *mut ::std::os::raw::c_void,
    ) -> btDynamicsWorldType;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btSimpleDynamicsWorld11clearForcesEv"]
    pub fn btSimpleDynamicsWorld_clearForces(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}gDeactivationTime"]
    pub static mut gDeactivationTime: btScalar;
}
extern "C" {
    #[link_name = "\u{1}gDisableDeactivation"]
    pub static mut gDisableDeactivation: bool;
}
pub const btRigidBodyFlags_BT_DISABLE_WORLD_GRAVITY: btRigidBodyFlags = 1;
pub const btRigidBodyFlags_BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT: btRigidBodyFlags = 2;
pub const btRigidBodyFlags_BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD: btRigidBodyFlags = 4;
pub const btRigidBodyFlags_BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY: btRigidBodyFlags = 8;
pub const btRigidBodyFlags_BT_ENABLE_GYROPSCOPIC_FORCE: btRigidBodyFlags = 8;
pub type btRigidBodyFlags = ::std::os::raw::c_uint;
/// The btRigidBody is the main class for rigid body objects. It is derived from btCollisionObject, so it keeps a pointer to a btCollisionShape.
/// It is recommended for performance and memory use to share btCollisionShape objects whenever possible.
/// There are 3 types of rigid bodies:
/// - A) Dynamic rigid bodies, with positive mass. Motion is controlled by rigid body dynamics.
/// - B) Fixed objects with zero mass. They are not moving (basically collision objects)
/// - C) Kinematic objects, which are objects without mass, but the user can move them. There is on-way interaction, and Bullet calculates a velocity based on the timestep and previous and current world transform.
/// Bullet automatically deactivates dynamic rigid bodies, when the velocity is below a threshold for a given time.
/// Deactivated (sleeping) rigid bodies don't take any processing time, except a minor broadphase collision detection impact (to allow active objects to activate/wake up sleeping objects)
#[repr(C)]
#[derive(Debug)]
pub struct btRigidBody {
    pub _base: btCollisionObject,
    pub m_invInertiaTensorWorld: btMatrix3x3,
    pub m_linearVelocity: btVector3,
    pub m_angularVelocity: btVector3,
    pub m_inverseMass: btScalar,
    pub m_linearFactor: btVector3,
    pub m_gravity: btVector3,
    pub m_gravity_acceleration: btVector3,
    pub m_invInertiaLocal: btVector3,
    pub m_totalForce: btVector3,
    pub m_totalTorque: btVector3,
    pub m_linearDamping: btScalar,
    pub m_angularDamping: btScalar,
    pub m_additionalDamping: bool,
    pub m_additionalDampingFactor: btScalar,
    pub m_additionalLinearDampingThresholdSqr: btScalar,
    pub m_additionalAngularDampingThresholdSqr: btScalar,
    pub m_additionalAngularDampingFactor: btScalar,
    pub m_linearSleepingThreshold: btScalar,
    pub m_angularSleepingThreshold: btScalar,
    pub m_optionalMotionState: *mut btMotionState,
    pub m_constraintRefs: btAlignedObjectArray<*mut btTypedConstraint>,
    pub m_rigidbodyFlags: ::std::os::raw::c_int,
    pub m_debugBodyId: ::std::os::raw::c_int,
    pub m_deltaLinearVelocity: btVector3,
    pub m_deltaAngularVelocity: btVector3,
    pub m_angularFactor: btVector3,
    pub m_invMass: btVector3,
    pub m_pushVelocity: btVector3,
    pub m_turnVelocity: btVector3,
    pub m_contactSolverType: ::std::os::raw::c_int,
    pub m_frictionSolverType: ::std::os::raw::c_int,
}
/// The btRigidBodyConstructionInfo structure provides information to create a rigid body. Setting mass to zero creates a fixed (non-dynamic) rigid body.
/// ///For dynamic objects, you can use the collision shape to approximate the local inertia tensor, otherwise use the zero vector (default argument)
/// ///You can use the motion state to synchronize the world transform between physics and graphics objects.
/// ///And if the motion state is provided, the rigid body will initialize its initial world transform from the motion state,
/// ///m_startWorldTransform is only used when you don't provide a motion state.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btRigidBody_btRigidBodyConstructionInfo {
    pub m_mass: btScalar,
    /// When a motionState is provided, the rigid body will initialize its world transform from the motion state
    /// ///In this case, m_startWorldTransform is ignored.
    pub m_motionState: *mut btMotionState,
    pub m_startWorldTransform: btTransform,
    pub m_collisionShape: *mut btCollisionShape,
    pub m_localInertia: btVector3,
    pub m_linearDamping: btScalar,
    pub m_angularDamping: btScalar,
    /// best simulation results when friction is non-zero
    pub m_friction: btScalar,
    /// the m_rollingFriction prevents rounded shapes, such as spheres, cylinders and capsules from rolling forever.
    /// ///See Bullet/Demos/RollingFrictionDemo for usage
    pub m_rollingFriction: btScalar,
    pub m_spinningFriction: btScalar,
    /// best simulation results using zero restitution.
    pub m_restitution: btScalar,
    pub m_linearSleepingThreshold: btScalar,
    pub m_angularSleepingThreshold: btScalar,
    pub m_additionalDamping: bool,
    pub m_additionalDampingFactor: btScalar,
    pub m_additionalLinearDampingThresholdSqr: btScalar,
    pub m_additionalAngularDampingThresholdSqr: btScalar,
    pub m_additionalAngularDampingFactor: btScalar,
}
#[test]
fn bindgen_test_layout_btRigidBody_btRigidBodyConstructionInfo() {
    assert_eq!(
        ::std::mem::size_of::<btRigidBody_btRigidBodyConstructionInfo>(),
        288usize,
        concat!(
            "Size of: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btRigidBody_btRigidBodyConstructionInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_mass as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_mass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_motionState as *const _
                as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_motionState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_startWorldTransform
                as *const _ as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_startWorldTransform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_collisionShape as *const _
                as usize
        },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_collisionShape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_localInertia as *const _
                as usize
        },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_localInertia)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_linearDamping as *const _
                as usize
        },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_linearDamping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_angularDamping as *const _
                as usize
        },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_angularDamping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_friction as *const _
                as usize
        },
        200usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_friction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_rollingFriction as *const _
                as usize
        },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_rollingFriction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_spinningFriction as *const _
                as usize
        },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_spinningFriction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_restitution as *const _
                as usize
        },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_restitution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_linearSleepingThreshold
                as *const _ as usize
        },
        232usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_linearSleepingThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_angularSleepingThreshold
                as *const _ as usize
        },
        240usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_angularSleepingThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_additionalDamping
                as *const _ as usize
        },
        248usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_additionalDamping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo)).m_additionalDampingFactor
                as *const _ as usize
        },
        256usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_additionalDampingFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo))
                .m_additionalLinearDampingThresholdSqr as *const _ as usize
        },
        264usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_additionalLinearDampingThresholdSqr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo))
                .m_additionalAngularDampingThresholdSqr as *const _ as usize
        },
        272usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_additionalAngularDampingThresholdSqr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody_btRigidBodyConstructionInfo))
                .m_additionalAngularDampingFactor as *const _ as usize
        },
        280usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody_btRigidBodyConstructionInfo),
            "::",
            stringify!(m_additionalAngularDampingFactor)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody27btRigidBodyConstructionInfoC1EdP13btMotionStateP16btCollisionShapeRK9btVector3"]
    pub fn btRigidBody_btRigidBodyConstructionInfo_btRigidBodyConstructionInfo(
        this: *mut btRigidBody_btRigidBodyConstructionInfo,
        mass: btScalar,
        motionState: *mut btMotionState,
        collisionShape: *mut btCollisionShape,
        localInertia: *const btVector3,
    );
}
impl btRigidBody_btRigidBodyConstructionInfo {
    #[inline]
    pub unsafe fn new(
        mass: btScalar,
        motionState: *mut btMotionState,
        collisionShape: *mut btCollisionShape,
        localInertia: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btRigidBody_btRigidBodyConstructionInfo_btRigidBodyConstructionInfo(
            &mut __bindgen_tmp,
            mass,
            motionState,
            collisionShape,
            localInertia,
        );
        __bindgen_tmp
    }
}
#[test]
fn bindgen_test_layout_btRigidBody() {
    assert_eq!(
        ::std::mem::size_of::<btRigidBody>(),
        1296usize,
        concat!("Size of: ", stringify!(btRigidBody))
    );
    assert_eq!(
        ::std::mem::align_of::<btRigidBody>(),
        8usize,
        concat!("Alignment of ", stringify!(btRigidBody))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_invInertiaTensorWorld as *const _ as usize },
        616usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_invInertiaTensorWorld)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_linearVelocity as *const _ as usize },
        712usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_linearVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_angularVelocity as *const _ as usize },
        744usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_angularVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_inverseMass as *const _ as usize },
        776usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_inverseMass)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_linearFactor as *const _ as usize },
        784usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_linearFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_gravity as *const _ as usize },
        816usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_gravity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_gravity_acceleration as *const _ as usize },
        848usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_gravity_acceleration)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_invInertiaLocal as *const _ as usize },
        880usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_invInertiaLocal)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_totalForce as *const _ as usize },
        912usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_totalForce)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_totalTorque as *const _ as usize },
        944usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_totalTorque)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_linearDamping as *const _ as usize },
        976usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_linearDamping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_angularDamping as *const _ as usize },
        984usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_angularDamping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_additionalDamping as *const _ as usize },
        992usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_additionalDamping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_additionalDampingFactor as *const _ as usize },
        1000usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_additionalDampingFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody)).m_additionalLinearDampingThresholdSqr as *const _ as usize
        },
        1008usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_additionalLinearDampingThresholdSqr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody)).m_additionalAngularDampingThresholdSqr as *const _
                as usize
        },
        1016usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_additionalAngularDampingThresholdSqr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBody)).m_additionalAngularDampingFactor as *const _ as usize
        },
        1024usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_additionalAngularDampingFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_linearSleepingThreshold as *const _ as usize },
        1032usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_linearSleepingThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_angularSleepingThreshold as *const _ as usize },
        1040usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_angularSleepingThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_optionalMotionState as *const _ as usize },
        1048usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_optionalMotionState)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_constraintRefs as *const _ as usize },
        1056usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_constraintRefs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_rigidbodyFlags as *const _ as usize },
        1088usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_rigidbodyFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_debugBodyId as *const _ as usize },
        1092usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_debugBodyId)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_deltaLinearVelocity as *const _ as usize },
        1096usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_deltaLinearVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_deltaAngularVelocity as *const _ as usize },
        1128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_deltaAngularVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_angularFactor as *const _ as usize },
        1160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_angularFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_invMass as *const _ as usize },
        1192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_invMass)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_pushVelocity as *const _ as usize },
        1224usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_pushVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_turnVelocity as *const _ as usize },
        1256usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_turnVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_contactSolverType as *const _ as usize },
        1288usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_contactSolverType)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBody)).m_frictionSolverType as *const _ as usize },
        1292usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBody),
            "::",
            stringify!(m_frictionSolverType)
        )
    );
}
extern "C" {

    /// setupRigidBody is only used internally by the constructor

    #[link_name = "\u{1}_ZN11btRigidBody14setupRigidBodyERKNS_27btRigidBodyConstructionInfoE"]
    pub fn btRigidBody_setupRigidBody(
        this: *mut btRigidBody,
        constructionInfo: *const btRigidBody_btRigidBodyConstructionInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody18proceedToTransformERK11btTransform"]
    pub fn btRigidBody_proceedToTransform(this: *mut btRigidBody, newTrans: *const btTransform);
}
extern "C" {

    /// to keep collision detection and dynamics separate we don't store a rigidbody pointer
    /// ///but a rigidbody is derived from btCollisionObject, so we can safely perform an upcast

    #[link_name = "\u{1}_ZN11btRigidBody6upcastEPK17btCollisionObject"]
    pub fn btRigidBody_upcast(colObj: *const btCollisionObject) -> *const btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody6upcastEP17btCollisionObject"]
    pub fn btRigidBody_upcast1(colObj: *mut btCollisionObject) -> *mut btRigidBody;
}
extern "C" {

    /// continuous collision detection needs prediction

    #[link_name = "\u{1}_ZN11btRigidBody26predictIntegratedTransformEdR11btTransform"]
    pub fn btRigidBody_predictIntegratedTransform(
        this: *mut btRigidBody,
        step: btScalar,
        predictedTransform: *mut btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody18saveKinematicStateEd"]
    pub fn btRigidBody_saveKinematicState(this: *mut btRigidBody, step: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody12applyGravityEv"]
    pub fn btRigidBody_applyGravity(this: *mut btRigidBody);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody10setGravityERK9btVector3"]
    pub fn btRigidBody_setGravity(this: *mut btRigidBody, acceleration: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody10getGravityEv"]
    pub fn btRigidBody_getGravity(this: *const btRigidBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody10setDampingEdd"]
    pub fn btRigidBody_setDamping(
        this: *mut btRigidBody,
        lin_damping: btScalar,
        ang_damping: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody16getLinearDampingEv"]
    pub fn btRigidBody_getLinearDamping(this: *const btRigidBody) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody17getAngularDampingEv"]
    pub fn btRigidBody_getAngularDamping(this: *const btRigidBody) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody26getLinearSleepingThresholdEv"]
    pub fn btRigidBody_getLinearSleepingThreshold(this: *const btRigidBody) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody27getAngularSleepingThresholdEv"]
    pub fn btRigidBody_getAngularSleepingThreshold(this: *const btRigidBody) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody12applyDampingEd"]
    pub fn btRigidBody_applyDamping(this: *mut btRigidBody, timeStep: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody17getCollisionShapeEv"]
    pub fn btRigidBody_getCollisionShape(this: *const btRigidBody) -> *const btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody17getCollisionShapeEv"]
    pub fn btRigidBody_getCollisionShape1(this: *mut btRigidBody) -> *mut btCollisionShape;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody12setMassPropsEdRK9btVector3"]
    pub fn btRigidBody_setMassProps(
        this: *mut btRigidBody,
        mass: btScalar,
        inertia: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody15getLinearFactorEv"]
    pub fn btRigidBody_getLinearFactor(this: *const btRigidBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody15setLinearFactorERK9btVector3"]
    pub fn btRigidBody_setLinearFactor(this: *mut btRigidBody, linearFactor: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody10getInvMassEv"]
    pub fn btRigidBody_getInvMass(this: *const btRigidBody) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody24getInvInertiaTensorWorldEv"]
    pub fn btRigidBody_getInvInertiaTensorWorld(this: *const btRigidBody) -> *const btMatrix3x3;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody19integrateVelocitiesEd"]
    pub fn btRigidBody_integrateVelocities(this: *mut btRigidBody, step: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody24setCenterOfMassTransformERK11btTransform"]
    pub fn btRigidBody_setCenterOfMassTransform(this: *mut btRigidBody, xform: *const btTransform);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody17applyCentralForceERK9btVector3"]
    pub fn btRigidBody_applyCentralForce(this: *mut btRigidBody, force: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody13getTotalForceEv"]
    pub fn btRigidBody_getTotalForce(this: *const btRigidBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody14getTotalTorqueEv"]
    pub fn btRigidBody_getTotalTorque(this: *const btRigidBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody22getInvInertiaDiagLocalEv"]
    pub fn btRigidBody_getInvInertiaDiagLocal(this: *const btRigidBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody22setInvInertiaDiagLocalERK9btVector3"]
    pub fn btRigidBody_setInvInertiaDiagLocal(
        this: *mut btRigidBody,
        diagInvInertia: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody21setSleepingThresholdsEdd"]
    pub fn btRigidBody_setSleepingThresholds(
        this: *mut btRigidBody,
        linear: btScalar,
        angular: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody11applyTorqueERK9btVector3"]
    pub fn btRigidBody_applyTorque(this: *mut btRigidBody, torque: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody10applyForceERK9btVector3S2_"]
    pub fn btRigidBody_applyForce(
        this: *mut btRigidBody,
        force: *const btVector3,
        rel_pos: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody19applyCentralImpulseERK9btVector3"]
    pub fn btRigidBody_applyCentralImpulse(this: *mut btRigidBody, impulse: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody18applyTorqueImpulseERK9btVector3"]
    pub fn btRigidBody_applyTorqueImpulse(this: *mut btRigidBody, torque: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody12applyImpulseERK9btVector3S2_"]
    pub fn btRigidBody_applyImpulse(
        this: *mut btRigidBody,
        impulse: *const btVector3,
        rel_pos: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody11clearForcesEv"]
    pub fn btRigidBody_clearForces(this: *mut btRigidBody);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody19updateInertiaTensorEv"]
    pub fn btRigidBody_updateInertiaTensor(this: *mut btRigidBody);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody23getCenterOfMassPositionEv"]
    pub fn btRigidBody_getCenterOfMassPosition(this: *const btRigidBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody14getOrientationEv"]
    pub fn btRigidBody_getOrientation(this: *const btRigidBody) -> btQuaternion;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody24getCenterOfMassTransformEv"]
    pub fn btRigidBody_getCenterOfMassTransform(this: *const btRigidBody) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody17getLinearVelocityEv"]
    pub fn btRigidBody_getLinearVelocity(this: *const btRigidBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody18getAngularVelocityEv"]
    pub fn btRigidBody_getAngularVelocity(this: *const btRigidBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody17setLinearVelocityERK9btVector3"]
    pub fn btRigidBody_setLinearVelocity(this: *mut btRigidBody, lin_vel: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody18setAngularVelocityERK9btVector3"]
    pub fn btRigidBody_setAngularVelocity(this: *mut btRigidBody, ang_vel: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody23getVelocityInLocalPointERK9btVector3"]
    pub fn btRigidBody_getVelocityInLocalPoint(
        this: *const btRigidBody,
        rel_pos: *const btVector3,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody9translateERK9btVector3"]
    pub fn btRigidBody_translate(this: *mut btRigidBody, v: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody7getAabbER9btVector3S1_"]
    pub fn btRigidBody_getAabb(
        this: *const btRigidBody,
        aabbMin: *mut btVector3,
        aabbMax: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody25computeImpulseDenominatorERK9btVector3S2_"]
    pub fn btRigidBody_computeImpulseDenominator(
        this: *const btRigidBody,
        pos: *const btVector3,
        normal: *const btVector3,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody32computeAngularImpulseDenominatorERK9btVector3"]
    pub fn btRigidBody_computeAngularImpulseDenominator(
        this: *const btRigidBody,
        axis: *const btVector3,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody18updateDeactivationEd"]
    pub fn btRigidBody_updateDeactivation(this: *mut btRigidBody, timeStep: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody13wantsSleepingEv"]
    pub fn btRigidBody_wantsSleeping(this: *mut btRigidBody) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody18getBroadphaseProxyEv"]
    pub fn btRigidBody_getBroadphaseProxy(this: *const btRigidBody) -> *const btBroadphaseProxy;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody18getBroadphaseProxyEv"]
    pub fn btRigidBody_getBroadphaseProxy1(this: *mut btRigidBody) -> *mut btBroadphaseProxy;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody21setNewBroadphaseProxyEP17btBroadphaseProxy"]
    pub fn btRigidBody_setNewBroadphaseProxy(
        this: *mut btRigidBody,
        broadphaseProxy: *mut btBroadphaseProxy,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody14getMotionStateEv"]
    pub fn btRigidBody_getMotionState(this: *mut btRigidBody) -> *mut btMotionState;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody14getMotionStateEv"]
    pub fn btRigidBody_getMotionState1(this: *const btRigidBody) -> *const btMotionState;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody14setMotionStateEP13btMotionState"]
    pub fn btRigidBody_setMotionState(this: *mut btRigidBody, motionState: *mut btMotionState);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody16setAngularFactorERK9btVector3"]
    pub fn btRigidBody_setAngularFactor(this: *mut btRigidBody, angFac: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody16setAngularFactorEd"]
    pub fn btRigidBody_setAngularFactor1(this: *mut btRigidBody, angFac: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody16getAngularFactorEv"]
    pub fn btRigidBody_getAngularFactor(this: *const btRigidBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody9isInWorldEv"]
    pub fn btRigidBody_isInWorld(this: *const btRigidBody) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody16addConstraintRefEP17btTypedConstraint"]
    pub fn btRigidBody_addConstraintRef(this: *mut btRigidBody, c: *mut btTypedConstraint);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody19removeConstraintRefEP17btTypedConstraint"]
    pub fn btRigidBody_removeConstraintRef(this: *mut btRigidBody, c: *mut btTypedConstraint);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody16getConstraintRefEi"]
    pub fn btRigidBody_getConstraintRef(
        this: *mut btRigidBody,
        index: ::std::os::raw::c_int,
    ) -> *mut btTypedConstraint;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody20getNumConstraintRefsEv"]
    pub fn btRigidBody_getNumConstraintRefs(this: *const btRigidBody) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBody8setFlagsEi"]
    pub fn btRigidBody_setFlags(this: *mut btRigidBody, flags: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody8getFlagsEv"]
    pub fn btRigidBody_getFlags(this: *const btRigidBody) -> ::std::os::raw::c_int;
}
extern "C" {

    /// perform implicit force computation in world space

    #[link_name = "\u{1}_ZNK11btRigidBody38computeGyroscopicImpulseImplicit_WorldEd"]
    pub fn btRigidBody_computeGyroscopicImpulseImplicit_World(
        this: *const btRigidBody,
        dt: btScalar,
    ) -> btVector3;
}
extern "C" {

    /// perform implicit force computation in body space (inertial frame)

    #[link_name = "\u{1}_ZNK11btRigidBody37computeGyroscopicImpulseImplicit_BodyEd"]
    pub fn btRigidBody_computeGyroscopicImpulseImplicit_Body(
        this: *const btRigidBody,
        step: btScalar,
    ) -> btVector3;
}
extern "C" {

    /// explicit version is best avoided, it gains energy

    #[link_name = "\u{1}_ZNK11btRigidBody30computeGyroscopicForceExplicitEd"]
    pub fn btRigidBody_computeGyroscopicForceExplicit(
        this: *const btRigidBody,
        maxGyroscopicForce: btScalar,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody15getLocalInertiaEv"]
    pub fn btRigidBody_getLocalInertia(this: *const btRigidBody) -> btVector3;
}
extern "C" {

    /// btRigidBody constructor using construction info

    #[link_name = "\u{1}_ZN11btRigidBodyC1ERKNS_27btRigidBodyConstructionInfoE"]
    pub fn btRigidBody_btRigidBody(
        this: *mut btRigidBody,
        constructionInfo: *const btRigidBody_btRigidBodyConstructionInfo,
    );
}
extern "C" {

    /// btRigidBody constructor for backwards compatibility.
    /// ///To specify friction (etc) during rigid body construction, please use the other constructor (using btRigidBodyConstructionInfo)

    #[link_name = "\u{1}_ZN11btRigidBodyC1EdP13btMotionStateP16btCollisionShapeRK9btVector3"]
    pub fn btRigidBody_btRigidBody1(
        this: *mut btRigidBody,
        mass: btScalar,
        motionState: *mut btMotionState,
        collisionShape: *mut btCollisionShape,
        localInertia: *const btVector3,
    );
}
impl btRigidBody {
    #[inline]
    pub unsafe fn setupRigidBody(
        &mut self,
        constructionInfo: *const btRigidBody_btRigidBodyConstructionInfo,
    ) {
        btRigidBody_setupRigidBody(self, constructionInfo)
    }
    #[inline]
    pub unsafe fn proceedToTransform(&mut self, newTrans: *const btTransform) {
        btRigidBody_proceedToTransform(self, newTrans)
    }
    #[inline]
    pub unsafe fn upcast(colObj: *const btCollisionObject) -> *const btRigidBody {
        btRigidBody_upcast(colObj)
    }
    #[inline]
    pub unsafe fn upcast1(colObj: *mut btCollisionObject) -> *mut btRigidBody {
        btRigidBody_upcast1(colObj)
    }
    #[inline]
    pub unsafe fn predictIntegratedTransform(
        &mut self,
        step: btScalar,
        predictedTransform: *mut btTransform,
    ) {
        btRigidBody_predictIntegratedTransform(self, step, predictedTransform)
    }
    #[inline]
    pub unsafe fn saveKinematicState(&mut self, step: btScalar) {
        btRigidBody_saveKinematicState(self, step)
    }
    #[inline]
    pub unsafe fn applyGravity(&mut self) {
        btRigidBody_applyGravity(self)
    }
    #[inline]
    pub unsafe fn setGravity(&mut self, acceleration: *const btVector3) {
        btRigidBody_setGravity(self, acceleration)
    }
    #[inline]
    pub unsafe fn getGravity(&self) -> *const btVector3 {
        btRigidBody_getGravity(self)
    }
    #[inline]
    pub unsafe fn setDamping(&mut self, lin_damping: btScalar, ang_damping: btScalar) {
        btRigidBody_setDamping(self, lin_damping, ang_damping)
    }
    #[inline]
    pub unsafe fn getLinearDamping(&self) -> btScalar {
        btRigidBody_getLinearDamping(self)
    }
    #[inline]
    pub unsafe fn getAngularDamping(&self) -> btScalar {
        btRigidBody_getAngularDamping(self)
    }
    #[inline]
    pub unsafe fn getLinearSleepingThreshold(&self) -> btScalar {
        btRigidBody_getLinearSleepingThreshold(self)
    }
    #[inline]
    pub unsafe fn getAngularSleepingThreshold(&self) -> btScalar {
        btRigidBody_getAngularSleepingThreshold(self)
    }
    #[inline]
    pub unsafe fn applyDamping(&mut self, timeStep: btScalar) {
        btRigidBody_applyDamping(self, timeStep)
    }
    #[inline]
    pub unsafe fn getCollisionShape(&self) -> *const btCollisionShape {
        btRigidBody_getCollisionShape(self)
    }
    #[inline]
    pub unsafe fn getCollisionShape1(&mut self) -> *mut btCollisionShape {
        btRigidBody_getCollisionShape1(self)
    }
    #[inline]
    pub unsafe fn setMassProps(&mut self, mass: btScalar, inertia: *const btVector3) {
        btRigidBody_setMassProps(self, mass, inertia)
    }
    #[inline]
    pub unsafe fn getLinearFactor(&self) -> *const btVector3 {
        btRigidBody_getLinearFactor(self)
    }
    #[inline]
    pub unsafe fn setLinearFactor(&mut self, linearFactor: *const btVector3) {
        btRigidBody_setLinearFactor(self, linearFactor)
    }
    #[inline]
    pub unsafe fn getInvMass(&self) -> btScalar {
        btRigidBody_getInvMass(self)
    }
    #[inline]
    pub unsafe fn getInvInertiaTensorWorld(&self) -> *const btMatrix3x3 {
        btRigidBody_getInvInertiaTensorWorld(self)
    }
    #[inline]
    pub unsafe fn integrateVelocities(&mut self, step: btScalar) {
        btRigidBody_integrateVelocities(self, step)
    }
    #[inline]
    pub unsafe fn setCenterOfMassTransform(&mut self, xform: *const btTransform) {
        btRigidBody_setCenterOfMassTransform(self, xform)
    }
    #[inline]
    pub unsafe fn applyCentralForce(&mut self, force: *const btVector3) {
        btRigidBody_applyCentralForce(self, force)
    }
    #[inline]
    pub unsafe fn getTotalForce(&self) -> *const btVector3 {
        btRigidBody_getTotalForce(self)
    }
    #[inline]
    pub unsafe fn getTotalTorque(&self) -> *const btVector3 {
        btRigidBody_getTotalTorque(self)
    }
    #[inline]
    pub unsafe fn getInvInertiaDiagLocal(&self) -> *const btVector3 {
        btRigidBody_getInvInertiaDiagLocal(self)
    }
    #[inline]
    pub unsafe fn setInvInertiaDiagLocal(&mut self, diagInvInertia: *const btVector3) {
        btRigidBody_setInvInertiaDiagLocal(self, diagInvInertia)
    }
    #[inline]
    pub unsafe fn setSleepingThresholds(&mut self, linear: btScalar, angular: btScalar) {
        btRigidBody_setSleepingThresholds(self, linear, angular)
    }
    #[inline]
    pub unsafe fn applyTorque(&mut self, torque: *const btVector3) {
        btRigidBody_applyTorque(self, torque)
    }
    #[inline]
    pub unsafe fn applyForce(&mut self, force: *const btVector3, rel_pos: *const btVector3) {
        btRigidBody_applyForce(self, force, rel_pos)
    }
    #[inline]
    pub unsafe fn applyCentralImpulse(&mut self, impulse: *const btVector3) {
        btRigidBody_applyCentralImpulse(self, impulse)
    }
    #[inline]
    pub unsafe fn applyTorqueImpulse(&mut self, torque: *const btVector3) {
        btRigidBody_applyTorqueImpulse(self, torque)
    }
    #[inline]
    pub unsafe fn applyImpulse(&mut self, impulse: *const btVector3, rel_pos: *const btVector3) {
        btRigidBody_applyImpulse(self, impulse, rel_pos)
    }
    #[inline]
    pub unsafe fn clearForces(&mut self) {
        btRigidBody_clearForces(self)
    }
    #[inline]
    pub unsafe fn updateInertiaTensor(&mut self) {
        btRigidBody_updateInertiaTensor(self)
    }
    #[inline]
    pub unsafe fn getCenterOfMassPosition(&self) -> *const btVector3 {
        btRigidBody_getCenterOfMassPosition(self)
    }
    #[inline]
    pub unsafe fn getOrientation(&self) -> btQuaternion {
        btRigidBody_getOrientation(self)
    }
    #[inline]
    pub unsafe fn getCenterOfMassTransform(&self) -> *const btTransform {
        btRigidBody_getCenterOfMassTransform(self)
    }
    #[inline]
    pub unsafe fn getLinearVelocity(&self) -> *const btVector3 {
        btRigidBody_getLinearVelocity(self)
    }
    #[inline]
    pub unsafe fn getAngularVelocity(&self) -> *const btVector3 {
        btRigidBody_getAngularVelocity(self)
    }
    #[inline]
    pub unsafe fn setLinearVelocity(&mut self, lin_vel: *const btVector3) {
        btRigidBody_setLinearVelocity(self, lin_vel)
    }
    #[inline]
    pub unsafe fn setAngularVelocity(&mut self, ang_vel: *const btVector3) {
        btRigidBody_setAngularVelocity(self, ang_vel)
    }
    #[inline]
    pub unsafe fn getVelocityInLocalPoint(&self, rel_pos: *const btVector3) -> btVector3 {
        btRigidBody_getVelocityInLocalPoint(self, rel_pos)
    }
    #[inline]
    pub unsafe fn translate(&mut self, v: *const btVector3) {
        btRigidBody_translate(self, v)
    }
    #[inline]
    pub unsafe fn getAabb(&self, aabbMin: *mut btVector3, aabbMax: *mut btVector3) {
        btRigidBody_getAabb(self, aabbMin, aabbMax)
    }
    #[inline]
    pub unsafe fn computeImpulseDenominator(
        &self,
        pos: *const btVector3,
        normal: *const btVector3,
    ) -> btScalar {
        btRigidBody_computeImpulseDenominator(self, pos, normal)
    }
    #[inline]
    pub unsafe fn computeAngularImpulseDenominator(&self, axis: *const btVector3) -> btScalar {
        btRigidBody_computeAngularImpulseDenominator(self, axis)
    }
    #[inline]
    pub unsafe fn updateDeactivation(&mut self, timeStep: btScalar) {
        btRigidBody_updateDeactivation(self, timeStep)
    }
    #[inline]
    pub unsafe fn wantsSleeping(&mut self) -> bool {
        btRigidBody_wantsSleeping(self)
    }
    #[inline]
    pub unsafe fn getBroadphaseProxy(&self) -> *const btBroadphaseProxy {
        btRigidBody_getBroadphaseProxy(self)
    }
    #[inline]
    pub unsafe fn getBroadphaseProxy1(&mut self) -> *mut btBroadphaseProxy {
        btRigidBody_getBroadphaseProxy1(self)
    }
    #[inline]
    pub unsafe fn setNewBroadphaseProxy(&mut self, broadphaseProxy: *mut btBroadphaseProxy) {
        btRigidBody_setNewBroadphaseProxy(self, broadphaseProxy)
    }
    #[inline]
    pub unsafe fn getMotionState(&mut self) -> *mut btMotionState {
        btRigidBody_getMotionState(self)
    }
    #[inline]
    pub unsafe fn getMotionState1(&self) -> *const btMotionState {
        btRigidBody_getMotionState1(self)
    }
    #[inline]
    pub unsafe fn setMotionState(&mut self, motionState: *mut btMotionState) {
        btRigidBody_setMotionState(self, motionState)
    }
    #[inline]
    pub unsafe fn setAngularFactor(&mut self, angFac: *const btVector3) {
        btRigidBody_setAngularFactor(self, angFac)
    }
    #[inline]
    pub unsafe fn setAngularFactor1(&mut self, angFac: btScalar) {
        btRigidBody_setAngularFactor1(self, angFac)
    }
    #[inline]
    pub unsafe fn getAngularFactor(&self) -> *const btVector3 {
        btRigidBody_getAngularFactor(self)
    }
    #[inline]
    pub unsafe fn isInWorld(&self) -> bool {
        btRigidBody_isInWorld(self)
    }
    #[inline]
    pub unsafe fn addConstraintRef(&mut self, c: *mut btTypedConstraint) {
        btRigidBody_addConstraintRef(self, c)
    }
    #[inline]
    pub unsafe fn removeConstraintRef(&mut self, c: *mut btTypedConstraint) {
        btRigidBody_removeConstraintRef(self, c)
    }
    #[inline]
    pub unsafe fn getConstraintRef(
        &mut self,
        index: ::std::os::raw::c_int,
    ) -> *mut btTypedConstraint {
        btRigidBody_getConstraintRef(self, index)
    }
    #[inline]
    pub unsafe fn getNumConstraintRefs(&self) -> ::std::os::raw::c_int {
        btRigidBody_getNumConstraintRefs(self)
    }
    #[inline]
    pub unsafe fn setFlags(&mut self, flags: ::std::os::raw::c_int) {
        btRigidBody_setFlags(self, flags)
    }
    #[inline]
    pub unsafe fn getFlags(&self) -> ::std::os::raw::c_int {
        btRigidBody_getFlags(self)
    }
    #[inline]
    pub unsafe fn computeGyroscopicImpulseImplicit_World(&self, dt: btScalar) -> btVector3 {
        btRigidBody_computeGyroscopicImpulseImplicit_World(self, dt)
    }
    #[inline]
    pub unsafe fn computeGyroscopicImpulseImplicit_Body(&self, step: btScalar) -> btVector3 {
        btRigidBody_computeGyroscopicImpulseImplicit_Body(self, step)
    }
    #[inline]
    pub unsafe fn computeGyroscopicForceExplicit(&self, maxGyroscopicForce: btScalar) -> btVector3 {
        btRigidBody_computeGyroscopicForceExplicit(self, maxGyroscopicForce)
    }
    #[inline]
    pub unsafe fn getLocalInertia(&self) -> btVector3 {
        btRigidBody_getLocalInertia(self)
    }
    #[inline]
    pub unsafe fn new(constructionInfo: *const btRigidBody_btRigidBodyConstructionInfo) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btRigidBody_btRigidBody(&mut __bindgen_tmp, constructionInfo);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        mass: btScalar,
        motionState: *mut btMotionState,
        collisionShape: *mut btCollisionShape,
        localInertia: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btRigidBody_btRigidBody1(
            &mut __bindgen_tmp,
            mass,
            motionState,
            collisionShape,
            localInertia,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN11btRigidBodyD1Ev"]
    pub fn btRigidBody_btRigidBody_destructor(this: *mut btRigidBody);
}
extern "C" {

    ///

    #[link_name = "\u{1}_ZNK11btRigidBody28calculateSerializeBufferSizeEv"]
    pub fn btRigidBody_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK11btRigidBody9serializeEPvP12btSerializer"]
    pub fn btRigidBody_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btRigidBody21serializeSingleObjectEP12btSerializer"]
    pub fn btRigidBody_serializeSingleObject(
        this: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btRigidBodyFloatData {
    pub m_collisionObjectData: btCollisionObjectFloatData,
    pub m_invInertiaTensorWorld: btMatrix3x3FloatData,
    pub m_linearVelocity: btVector3FloatData,
    pub m_angularVelocity: btVector3FloatData,
    pub m_angularFactor: btVector3FloatData,
    pub m_linearFactor: btVector3FloatData,
    pub m_gravity: btVector3FloatData,
    pub m_gravity_acceleration: btVector3FloatData,
    pub m_invInertiaLocal: btVector3FloatData,
    pub m_totalForce: btVector3FloatData,
    pub m_totalTorque: btVector3FloatData,
    pub m_inverseMass: f32,
    pub m_linearDamping: f32,
    pub m_angularDamping: f32,
    pub m_additionalDampingFactor: f32,
    pub m_additionalLinearDampingThresholdSqr: f32,
    pub m_additionalAngularDampingThresholdSqr: f32,
    pub m_additionalAngularDampingFactor: f32,
    pub m_linearSleepingThreshold: f32,
    pub m_angularSleepingThreshold: f32,
    pub m_additionalDamping: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btRigidBodyFloatData() {
    assert_eq!(
        ::std::mem::size_of::<btRigidBodyFloatData>(),
        512usize,
        concat!("Size of: ", stringify!(btRigidBodyFloatData))
    );
    assert_eq!(
        ::std::mem::align_of::<btRigidBodyFloatData>(),
        8usize,
        concat!("Alignment of ", stringify!(btRigidBodyFloatData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyFloatData)).m_collisionObjectData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_collisionObjectData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyFloatData)).m_invInertiaTensorWorld as *const _ as usize
        },
        280usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_invInertiaTensorWorld)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyFloatData)).m_linearVelocity as *const _ as usize },
        328usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_linearVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyFloatData)).m_angularVelocity as *const _ as usize },
        344usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_angularVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyFloatData)).m_angularFactor as *const _ as usize },
        360usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_angularFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyFloatData)).m_linearFactor as *const _ as usize },
        376usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_linearFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyFloatData)).m_gravity as *const _ as usize },
        392usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyFloatData)).m_gravity_acceleration as *const _ as usize
        },
        408usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_gravity_acceleration)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyFloatData)).m_invInertiaLocal as *const _ as usize },
        424usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_invInertiaLocal)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyFloatData)).m_totalForce as *const _ as usize },
        440usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_totalForce)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyFloatData)).m_totalTorque as *const _ as usize },
        456usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_totalTorque)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyFloatData)).m_inverseMass as *const _ as usize },
        472usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_inverseMass)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyFloatData)).m_linearDamping as *const _ as usize },
        476usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_linearDamping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyFloatData)).m_angularDamping as *const _ as usize },
        480usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_angularDamping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyFloatData)).m_additionalDampingFactor as *const _ as usize
        },
        484usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_additionalDampingFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyFloatData)).m_additionalLinearDampingThresholdSqr as *const _
                as usize
        },
        488usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_additionalLinearDampingThresholdSqr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyFloatData)).m_additionalAngularDampingThresholdSqr
                as *const _ as usize
        },
        492usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_additionalAngularDampingThresholdSqr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyFloatData)).m_additionalAngularDampingFactor as *const _
                as usize
        },
        496usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_additionalAngularDampingFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyFloatData)).m_linearSleepingThreshold as *const _ as usize
        },
        500usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_linearSleepingThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyFloatData)).m_angularSleepingThreshold as *const _ as usize
        },
        504usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_angularSleepingThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyFloatData)).m_additionalDamping as *const _ as usize },
        508usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyFloatData),
            "::",
            stringify!(m_additionalDamping)
        )
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btRigidBodyDoubleData {
    pub m_collisionObjectData: btCollisionObjectDoubleData,
    pub m_invInertiaTensorWorld: btMatrix3x3DoubleData,
    pub m_linearVelocity: btVector3DoubleData,
    pub m_angularVelocity: btVector3DoubleData,
    pub m_angularFactor: btVector3DoubleData,
    pub m_linearFactor: btVector3DoubleData,
    pub m_gravity: btVector3DoubleData,
    pub m_gravity_acceleration: btVector3DoubleData,
    pub m_invInertiaLocal: btVector3DoubleData,
    pub m_totalForce: btVector3DoubleData,
    pub m_totalTorque: btVector3DoubleData,
    pub m_inverseMass: f64,
    pub m_linearDamping: f64,
    pub m_angularDamping: f64,
    pub m_additionalDampingFactor: f64,
    pub m_additionalLinearDampingThresholdSqr: f64,
    pub m_additionalAngularDampingThresholdSqr: f64,
    pub m_additionalAngularDampingFactor: f64,
    pub m_linearSleepingThreshold: f64,
    pub m_angularSleepingThreshold: f64,
    pub m_additionalDamping: ::std::os::raw::c_int,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btRigidBodyDoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btRigidBodyDoubleData>(),
        960usize,
        concat!("Size of: ", stringify!(btRigidBodyDoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btRigidBodyDoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btRigidBodyDoubleData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyDoubleData)).m_collisionObjectData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_collisionObjectData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyDoubleData)).m_invInertiaTensorWorld as *const _ as usize
        },
        496usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_invInertiaTensorWorld)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyDoubleData)).m_linearVelocity as *const _ as usize },
        592usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_linearVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyDoubleData)).m_angularVelocity as *const _ as usize },
        624usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_angularVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyDoubleData)).m_angularFactor as *const _ as usize },
        656usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_angularFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyDoubleData)).m_linearFactor as *const _ as usize },
        688usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_linearFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyDoubleData)).m_gravity as *const _ as usize },
        720usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyDoubleData)).m_gravity_acceleration as *const _ as usize
        },
        752usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_gravity_acceleration)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyDoubleData)).m_invInertiaLocal as *const _ as usize },
        784usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_invInertiaLocal)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyDoubleData)).m_totalForce as *const _ as usize },
        816usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_totalForce)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyDoubleData)).m_totalTorque as *const _ as usize },
        848usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_totalTorque)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyDoubleData)).m_inverseMass as *const _ as usize },
        880usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_inverseMass)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyDoubleData)).m_linearDamping as *const _ as usize },
        888usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_linearDamping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyDoubleData)).m_angularDamping as *const _ as usize },
        896usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_angularDamping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyDoubleData)).m_additionalDampingFactor as *const _ as usize
        },
        904usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_additionalDampingFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyDoubleData)).m_additionalLinearDampingThresholdSqr
                as *const _ as usize
        },
        912usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_additionalLinearDampingThresholdSqr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyDoubleData)).m_additionalAngularDampingThresholdSqr
                as *const _ as usize
        },
        920usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_additionalAngularDampingThresholdSqr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyDoubleData)).m_additionalAngularDampingFactor as *const _
                as usize
        },
        928usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_additionalAngularDampingFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyDoubleData)).m_linearSleepingThreshold as *const _ as usize
        },
        936usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_linearSleepingThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRigidBodyDoubleData)).m_angularSleepingThreshold as *const _ as usize
        },
        944usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_angularSleepingThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyDoubleData)).m_additionalDamping as *const _ as usize },
        952usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_additionalDamping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRigidBodyDoubleData)).m_padding as *const _ as usize },
        956usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRigidBodyDoubleData),
            "::",
            stringify!(m_padding)
        )
    );
}
/// Jacobian entry is an abstraction that allows to describe constraints
/// it can be used in combination with a constraint solver
/// Can be used to relate the effect of an impulse to the constraint error
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btJacobianEntry {
    pub m_linearJointAxis: btVector3,
    pub m_aJ: btVector3,
    pub m_bJ: btVector3,
    pub m_0MinvJt: btVector3,
    pub m_1MinvJt: btVector3,
    pub m_Adiag: btScalar,
}
#[test]
fn bindgen_test_layout_btJacobianEntry() {
    assert_eq!(
        ::std::mem::size_of::<btJacobianEntry>(),
        168usize,
        concat!("Size of: ", stringify!(btJacobianEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<btJacobianEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(btJacobianEntry))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btJacobianEntry)).m_linearJointAxis as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btJacobianEntry),
            "::",
            stringify!(m_linearJointAxis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btJacobianEntry)).m_aJ as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btJacobianEntry),
            "::",
            stringify!(m_aJ)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btJacobianEntry)).m_bJ as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btJacobianEntry),
            "::",
            stringify!(m_bJ)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btJacobianEntry)).m_0MinvJt as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btJacobianEntry),
            "::",
            stringify!(m_0MinvJt)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btJacobianEntry)).m_1MinvJt as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btJacobianEntry),
            "::",
            stringify!(m_1MinvJt)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btJacobianEntry)).m_Adiag as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btJacobianEntry),
            "::",
            stringify!(m_Adiag)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btJacobianEntry11getDiagonalEv"]
    pub fn btJacobianEntry_getDiagonal(this: *const btJacobianEntry) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btJacobianEntry14getNonDiagonalERKS_d"]
    pub fn btJacobianEntry_getNonDiagonal(
        this: *const btJacobianEntry,
        jacB: *const btJacobianEntry,
        massInvA: btScalar,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK15btJacobianEntry14getNonDiagonalERKS_dd"]
    pub fn btJacobianEntry_getNonDiagonal1(
        this: *const btJacobianEntry,
        jacB: *const btJacobianEntry,
        massInvA: btScalar,
        massInvB: btScalar,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btJacobianEntry19getRelativeVelocityERK9btVector3S2_S2_S2_"]
    pub fn btJacobianEntry_getRelativeVelocity(
        this: *mut btJacobianEntry,
        linvelA: *const btVector3,
        angvelA: *const btVector3,
        linvelB: *const btVector3,
        angvelB: *const btVector3,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN15btJacobianEntryC1Ev"]
    pub fn btJacobianEntry_btJacobianEntry(this: *mut btJacobianEntry);
}
extern "C" {
    #[link_name = "\u{1}_ZN15btJacobianEntryC1ERK11btMatrix3x3S2_RK9btVector3S5_S5_S5_dS5_d"]
    pub fn btJacobianEntry_btJacobianEntry1(
        this: *mut btJacobianEntry,
        world2A: *const btMatrix3x3,
        world2B: *const btMatrix3x3,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        jointAxis: *const btVector3,
        inertiaInvA: *const btVector3,
        massInvA: btScalar,
        inertiaInvB: *const btVector3,
        massInvB: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btJacobianEntryC1ERK9btVector3RK11btMatrix3x3S5_S2_S2_"]
    pub fn btJacobianEntry_btJacobianEntry2(
        this: *mut btJacobianEntry,
        jointAxis: *const btVector3,
        world2A: *const btMatrix3x3,
        world2B: *const btMatrix3x3,
        inertiaInvA: *const btVector3,
        inertiaInvB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btJacobianEntryC1ERK9btVector3S2_S2_S2_"]
    pub fn btJacobianEntry_btJacobianEntry3(
        this: *mut btJacobianEntry,
        axisInA: *const btVector3,
        axisInB: *const btVector3,
        inertiaInvA: *const btVector3,
        inertiaInvB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN15btJacobianEntryC1ERK11btMatrix3x3RK9btVector3S5_S5_S5_d"]
    pub fn btJacobianEntry_btJacobianEntry4(
        this: *mut btJacobianEntry,
        world2A: *const btMatrix3x3,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        jointAxis: *const btVector3,
        inertiaInvA: *const btVector3,
        massInvA: btScalar,
    );
}
impl btJacobianEntry {
    #[inline]
    pub unsafe fn getDiagonal(&self) -> btScalar {
        btJacobianEntry_getDiagonal(self)
    }
    #[inline]
    pub unsafe fn getNonDiagonal(
        &self,
        jacB: *const btJacobianEntry,
        massInvA: btScalar,
    ) -> btScalar {
        btJacobianEntry_getNonDiagonal(self, jacB, massInvA)
    }
    #[inline]
    pub unsafe fn getNonDiagonal1(
        &self,
        jacB: *const btJacobianEntry,
        massInvA: btScalar,
        massInvB: btScalar,
    ) -> btScalar {
        btJacobianEntry_getNonDiagonal1(self, jacB, massInvA, massInvB)
    }
    #[inline]
    pub unsafe fn getRelativeVelocity(
        &mut self,
        linvelA: *const btVector3,
        angvelA: *const btVector3,
        linvelB: *const btVector3,
        angvelB: *const btVector3,
    ) -> btScalar {
        btJacobianEntry_getRelativeVelocity(self, linvelA, angvelA, linvelB, angvelB)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btJacobianEntry_btJacobianEntry(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        world2A: *const btMatrix3x3,
        world2B: *const btMatrix3x3,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        jointAxis: *const btVector3,
        inertiaInvA: *const btVector3,
        massInvA: btScalar,
        inertiaInvB: *const btVector3,
        massInvB: btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btJacobianEntry_btJacobianEntry1(
            &mut __bindgen_tmp,
            world2A,
            world2B,
            rel_pos1,
            rel_pos2,
            jointAxis,
            inertiaInvA,
            massInvA,
            inertiaInvB,
            massInvB,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(
        jointAxis: *const btVector3,
        world2A: *const btMatrix3x3,
        world2B: *const btMatrix3x3,
        inertiaInvA: *const btVector3,
        inertiaInvB: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btJacobianEntry_btJacobianEntry2(
            &mut __bindgen_tmp,
            jointAxis,
            world2A,
            world2B,
            inertiaInvA,
            inertiaInvB,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(
        axisInA: *const btVector3,
        axisInB: *const btVector3,
        inertiaInvA: *const btVector3,
        inertiaInvB: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btJacobianEntry_btJacobianEntry3(
            &mut __bindgen_tmp,
            axisInA,
            axisInB,
            inertiaInvA,
            inertiaInvB,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new4(
        world2A: *const btMatrix3x3,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        jointAxis: *const btVector3,
        inertiaInvA: *const btVector3,
        massInvA: btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btJacobianEntry_btJacobianEntry4(
            &mut __bindgen_tmp,
            world2A,
            rel_pos1,
            rel_pos2,
            jointAxis,
            inertiaInvA,
            massInvA,
        );
        __bindgen_tmp
    }
}
/// The btSolverBody is an internal datastructure for the constraint solver. Only necessary data is packed to increase cache coherence/performance.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSolverBody {
    pub m_worldTransform: btTransform,
    pub m_deltaLinearVelocity: btVector3,
    pub m_deltaAngularVelocity: btVector3,
    pub m_angularFactor: btVector3,
    pub m_linearFactor: btVector3,
    pub m_invMass: btVector3,
    pub m_pushVelocity: btVector3,
    pub m_turnVelocity: btVector3,
    pub m_linearVelocity: btVector3,
    pub m_angularVelocity: btVector3,
    pub m_externalForceImpulse: btVector3,
    pub m_externalTorqueImpulse: btVector3,
    pub m_originalBody: *mut btRigidBody,
}
#[test]
fn bindgen_test_layout_btSolverBody() {
    assert_eq!(
        ::std::mem::size_of::<btSolverBody>(),
        488usize,
        concat!("Size of: ", stringify!(btSolverBody))
    );
    assert_eq!(
        ::std::mem::align_of::<btSolverBody>(),
        8usize,
        concat!("Alignment of ", stringify!(btSolverBody))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverBody)).m_worldTransform as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverBody),
            "::",
            stringify!(m_worldTransform)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverBody)).m_deltaLinearVelocity as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverBody),
            "::",
            stringify!(m_deltaLinearVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverBody)).m_deltaAngularVelocity as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverBody),
            "::",
            stringify!(m_deltaAngularVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverBody)).m_angularFactor as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverBody),
            "::",
            stringify!(m_angularFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverBody)).m_linearFactor as *const _ as usize },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverBody),
            "::",
            stringify!(m_linearFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverBody)).m_invMass as *const _ as usize },
        256usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverBody),
            "::",
            stringify!(m_invMass)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverBody)).m_pushVelocity as *const _ as usize },
        288usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverBody),
            "::",
            stringify!(m_pushVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverBody)).m_turnVelocity as *const _ as usize },
        320usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverBody),
            "::",
            stringify!(m_turnVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverBody)).m_linearVelocity as *const _ as usize },
        352usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverBody),
            "::",
            stringify!(m_linearVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverBody)).m_angularVelocity as *const _ as usize },
        384usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverBody),
            "::",
            stringify!(m_angularVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverBody)).m_externalForceImpulse as *const _ as usize },
        416usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverBody),
            "::",
            stringify!(m_externalForceImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverBody)).m_externalTorqueImpulse as *const _ as usize },
        448usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverBody),
            "::",
            stringify!(m_externalTorqueImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverBody)).m_originalBody as *const _ as usize },
        480usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverBody),
            "::",
            stringify!(m_originalBody)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSolverBody17setWorldTransformERK11btTransform"]
    pub fn btSolverBody_setWorldTransform(
        this: *mut btSolverBody,
        worldTransform: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSolverBody17getWorldTransformEv"]
    pub fn btSolverBody_getWorldTransform(this: *const btSolverBody) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSolverBody30getVelocityInLocalPointNoDeltaERK9btVector3RS0_"]
    pub fn btSolverBody_getVelocityInLocalPointNoDelta(
        this: *const btSolverBody,
        rel_pos: *const btVector3,
        velocity: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSolverBody31getVelocityInLocalPointObsoleteERK9btVector3RS0_"]
    pub fn btSolverBody_getVelocityInLocalPointObsolete(
        this: *const btSolverBody,
        rel_pos: *const btVector3,
        velocity: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSolverBody18getAngularVelocityER9btVector3"]
    pub fn btSolverBody_getAngularVelocity(this: *const btSolverBody, angVel: *mut btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSolverBody12applyImpulseERK9btVector3S2_d"]
    pub fn btSolverBody_applyImpulse(
        this: *mut btSolverBody,
        linearComponent: *const btVector3,
        angularComponent: *const btVector3,
        impulseMagnitude: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSolverBody24internalApplyPushImpulseERK9btVector3S2_d"]
    pub fn btSolverBody_internalApplyPushImpulse(
        this: *mut btSolverBody,
        linearComponent: *const btVector3,
        angularComponent: *const btVector3,
        impulseMagnitude: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSolverBody22getDeltaLinearVelocityEv"]
    pub fn btSolverBody_getDeltaLinearVelocity(this: *const btSolverBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSolverBody23getDeltaAngularVelocityEv"]
    pub fn btSolverBody_getDeltaAngularVelocity(this: *const btSolverBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSolverBody15getPushVelocityEv"]
    pub fn btSolverBody_getPushVelocity(this: *const btSolverBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSolverBody15getTurnVelocityEv"]
    pub fn btSolverBody_getTurnVelocity(this: *const btSolverBody) -> *const btVector3;
}
extern "C" {

    ///
    /// ///some internal methods, don't use them

    #[link_name = "\u{1}_ZN12btSolverBody30internalGetDeltaLinearVelocityEv"]
    pub fn btSolverBody_internalGetDeltaLinearVelocity(this: *mut btSolverBody) -> *mut btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSolverBody31internalGetDeltaAngularVelocityEv"]
    pub fn btSolverBody_internalGetDeltaAngularVelocity(this: *mut btSolverBody) -> *mut btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSolverBody24internalGetAngularFactorEv"]
    pub fn btSolverBody_internalGetAngularFactor(this: *const btSolverBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSolverBody18internalGetInvMassEv"]
    pub fn btSolverBody_internalGetInvMass(this: *const btSolverBody) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSolverBody18internalSetInvMassERK9btVector3"]
    pub fn btSolverBody_internalSetInvMass(this: *mut btSolverBody, invMass: *const btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSolverBody23internalGetPushVelocityEv"]
    pub fn btSolverBody_internalGetPushVelocity(this: *mut btSolverBody) -> *mut btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSolverBody23internalGetTurnVelocityEv"]
    pub fn btSolverBody_internalGetTurnVelocity(this: *mut btSolverBody) -> *mut btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSolverBody39internalGetVelocityInLocalPointObsoleteERK9btVector3RS0_"]
    pub fn btSolverBody_internalGetVelocityInLocalPointObsolete(
        this: *const btSolverBody,
        rel_pos: *const btVector3,
        velocity: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK12btSolverBody26internalGetAngularVelocityER9btVector3"]
    pub fn btSolverBody_internalGetAngularVelocity(
        this: *const btSolverBody,
        angVel: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSolverBody20internalApplyImpulseERK9btVector3S2_d"]
    pub fn btSolverBody_internalApplyImpulse(
        this: *mut btSolverBody,
        linearComponent: *const btVector3,
        angularComponent: *const btVector3,
        impulseMagnitude: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSolverBody17writebackVelocityEv"]
    pub fn btSolverBody_writebackVelocity(this: *mut btSolverBody);
}
extern "C" {
    #[link_name = "\u{1}_ZN12btSolverBody29writebackVelocityAndTransformEdd"]
    pub fn btSolverBody_writebackVelocityAndTransform(
        this: *mut btSolverBody,
        timeStep: btScalar,
        splitImpulseTurnErp: btScalar,
    );
}
impl btSolverBody {
    #[inline]
    pub unsafe fn setWorldTransform(&mut self, worldTransform: *const btTransform) {
        btSolverBody_setWorldTransform(self, worldTransform)
    }
    #[inline]
    pub unsafe fn getWorldTransform(&self) -> *const btTransform {
        btSolverBody_getWorldTransform(self)
    }
    #[inline]
    pub unsafe fn getVelocityInLocalPointNoDelta(
        &self,
        rel_pos: *const btVector3,
        velocity: *mut btVector3,
    ) {
        btSolverBody_getVelocityInLocalPointNoDelta(self, rel_pos, velocity)
    }
    #[inline]
    pub unsafe fn getVelocityInLocalPointObsolete(
        &self,
        rel_pos: *const btVector3,
        velocity: *mut btVector3,
    ) {
        btSolverBody_getVelocityInLocalPointObsolete(self, rel_pos, velocity)
    }
    #[inline]
    pub unsafe fn getAngularVelocity(&self, angVel: *mut btVector3) {
        btSolverBody_getAngularVelocity(self, angVel)
    }
    #[inline]
    pub unsafe fn applyImpulse(
        &mut self,
        linearComponent: *const btVector3,
        angularComponent: *const btVector3,
        impulseMagnitude: btScalar,
    ) {
        btSolverBody_applyImpulse(self, linearComponent, angularComponent, impulseMagnitude)
    }
    #[inline]
    pub unsafe fn internalApplyPushImpulse(
        &mut self,
        linearComponent: *const btVector3,
        angularComponent: *const btVector3,
        impulseMagnitude: btScalar,
    ) {
        btSolverBody_internalApplyPushImpulse(
            self,
            linearComponent,
            angularComponent,
            impulseMagnitude,
        )
    }
    #[inline]
    pub unsafe fn getDeltaLinearVelocity(&self) -> *const btVector3 {
        btSolverBody_getDeltaLinearVelocity(self)
    }
    #[inline]
    pub unsafe fn getDeltaAngularVelocity(&self) -> *const btVector3 {
        btSolverBody_getDeltaAngularVelocity(self)
    }
    #[inline]
    pub unsafe fn getPushVelocity(&self) -> *const btVector3 {
        btSolverBody_getPushVelocity(self)
    }
    #[inline]
    pub unsafe fn getTurnVelocity(&self) -> *const btVector3 {
        btSolverBody_getTurnVelocity(self)
    }
    #[inline]
    pub unsafe fn internalGetDeltaLinearVelocity(&mut self) -> *mut btVector3 {
        btSolverBody_internalGetDeltaLinearVelocity(self)
    }
    #[inline]
    pub unsafe fn internalGetDeltaAngularVelocity(&mut self) -> *mut btVector3 {
        btSolverBody_internalGetDeltaAngularVelocity(self)
    }
    #[inline]
    pub unsafe fn internalGetAngularFactor(&self) -> *const btVector3 {
        btSolverBody_internalGetAngularFactor(self)
    }
    #[inline]
    pub unsafe fn internalGetInvMass(&self) -> *const btVector3 {
        btSolverBody_internalGetInvMass(self)
    }
    #[inline]
    pub unsafe fn internalSetInvMass(&mut self, invMass: *const btVector3) {
        btSolverBody_internalSetInvMass(self, invMass)
    }
    #[inline]
    pub unsafe fn internalGetPushVelocity(&mut self) -> *mut btVector3 {
        btSolverBody_internalGetPushVelocity(self)
    }
    #[inline]
    pub unsafe fn internalGetTurnVelocity(&mut self) -> *mut btVector3 {
        btSolverBody_internalGetTurnVelocity(self)
    }
    #[inline]
    pub unsafe fn internalGetVelocityInLocalPointObsolete(
        &self,
        rel_pos: *const btVector3,
        velocity: *mut btVector3,
    ) {
        btSolverBody_internalGetVelocityInLocalPointObsolete(self, rel_pos, velocity)
    }
    #[inline]
    pub unsafe fn internalGetAngularVelocity(&self, angVel: *mut btVector3) {
        btSolverBody_internalGetAngularVelocity(self, angVel)
    }
    #[inline]
    pub unsafe fn internalApplyImpulse(
        &mut self,
        linearComponent: *const btVector3,
        angularComponent: *const btVector3,
        impulseMagnitude: btScalar,
    ) {
        btSolverBody_internalApplyImpulse(self, linearComponent, angularComponent, impulseMagnitude)
    }
    #[inline]
    pub unsafe fn writebackVelocity(&mut self) {
        btSolverBody_writebackVelocity(self)
    }
    #[inline]
    pub unsafe fn writebackVelocityAndTransform(
        &mut self,
        timeStep: btScalar,
        splitImpulseTurnErp: btScalar,
    ) {
        btSolverBody_writebackVelocityAndTransform(self, timeStep, splitImpulseTurnErp)
    }
}
/// 1D constraint along a normal axis between bodyA and bodyB. It can be combined to solve contact and friction constraints.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btSolverConstraint {
    pub m_relpos1CrossNormal: btVector3,
    pub m_contactNormal1: btVector3,
    pub m_relpos2CrossNormal: btVector3,
    pub m_contactNormal2: btVector3,
    pub m_angularComponentA: btVector3,
    pub m_angularComponentB: btVector3,
    pub m_appliedPushImpulse: btScalar,
    pub m_appliedImpulse: btScalar,
    pub m_friction: btScalar,
    pub m_jacDiagABInv: btScalar,
    pub m_rhs: btScalar,
    pub m_cfm: btScalar,
    pub m_lowerLimit: btScalar,
    pub m_upperLimit: btScalar,
    pub m_rhsPenetration: btScalar,
    pub __bindgen_anon_1: btSolverConstraint__bindgen_ty_1,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_frictionIndex: ::std::os::raw::c_int,
    pub m_solverBodyIdA: ::std::os::raw::c_int,
    pub m_solverBodyIdB: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btSolverConstraint__bindgen_ty_1 {
    pub m_originalContactPoint: *mut ::std::os::raw::c_void,
    pub m_unusedPadding4: btScalar,
    pub m_numRowsForNonContactConstraint: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_btSolverConstraint__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btSolverConstraint__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(btSolverConstraint__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<btSolverConstraint__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btSolverConstraint__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSolverConstraint__bindgen_ty_1)).m_originalContactPoint as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint__bindgen_ty_1),
            "::",
            stringify!(m_originalContactPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSolverConstraint__bindgen_ty_1)).m_unusedPadding4 as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint__bindgen_ty_1),
            "::",
            stringify!(m_unusedPadding4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSolverConstraint__bindgen_ty_1)).m_numRowsForNonContactConstraint
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint__bindgen_ty_1),
            "::",
            stringify!(m_numRowsForNonContactConstraint)
        )
    );
}
pub const btSolverConstraint_btSolverConstraintType_BT_SOLVER_CONTACT_1D : btSolverConstraint_btSolverConstraintType = 0 ;
pub const btSolverConstraint_btSolverConstraintType_BT_SOLVER_FRICTION_1D : btSolverConstraint_btSolverConstraintType = 1 ;
pub type btSolverConstraint_btSolverConstraintType = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_btSolverConstraint() {
    assert_eq!(
        ::std::mem::size_of::<btSolverConstraint>(),
        288usize,
        concat!("Size of: ", stringify!(btSolverConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<btSolverConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(btSolverConstraint))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_relpos1CrossNormal as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_relpos1CrossNormal)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_contactNormal1 as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_contactNormal1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_relpos2CrossNormal as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_relpos2CrossNormal)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_contactNormal2 as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_contactNormal2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_angularComponentA as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_angularComponentA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_angularComponentB as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_angularComponentB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_appliedPushImpulse as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_appliedPushImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_appliedImpulse as *const _ as usize },
        200usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_appliedImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_friction as *const _ as usize },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_friction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_jacDiagABInv as *const _ as usize },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_jacDiagABInv)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_rhs as *const _ as usize },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_rhs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_cfm as *const _ as usize },
        232usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_cfm)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_lowerLimit as *const _ as usize },
        240usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_lowerLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_upperLimit as *const _ as usize },
        248usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_upperLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_rhsPenetration as *const _ as usize },
        256usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_rhsPenetration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSolverConstraint)).m_overrideNumSolverIterations as *const _ as usize
        },
        272usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_overrideNumSolverIterations)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_frictionIndex as *const _ as usize },
        276usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_frictionIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_solverBodyIdA as *const _ as usize },
        280usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_solverBodyIdA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSolverConstraint)).m_solverBodyIdB as *const _ as usize },
        284usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSolverConstraint),
            "::",
            stringify!(m_solverBodyIdB)
        )
    );
}
pub type btConstraintArray = btAlignedObjectArray<btSolverConstraint>;
pub const btTypedConstraintType_POINT2POINT_CONSTRAINT_TYPE: btTypedConstraintType = 3;
pub const btTypedConstraintType_HINGE_CONSTRAINT_TYPE: btTypedConstraintType = 4;
pub const btTypedConstraintType_CONETWIST_CONSTRAINT_TYPE: btTypedConstraintType = 5;
pub const btTypedConstraintType_D6_CONSTRAINT_TYPE: btTypedConstraintType = 6;
pub const btTypedConstraintType_SLIDER_CONSTRAINT_TYPE: btTypedConstraintType = 7;
pub const btTypedConstraintType_CONTACT_CONSTRAINT_TYPE: btTypedConstraintType = 8;
pub const btTypedConstraintType_D6_SPRING_CONSTRAINT_TYPE: btTypedConstraintType = 9;
pub const btTypedConstraintType_GEAR_CONSTRAINT_TYPE: btTypedConstraintType = 10;
pub const btTypedConstraintType_FIXED_CONSTRAINT_TYPE: btTypedConstraintType = 11;
pub const btTypedConstraintType_D6_SPRING_2_CONSTRAINT_TYPE: btTypedConstraintType = 12;
pub const btTypedConstraintType_MAX_CONSTRAINT_TYPE: btTypedConstraintType = 13;
pub type btTypedConstraintType = ::std::os::raw::c_uint;
pub const btConstraintParams_BT_CONSTRAINT_ERP: btConstraintParams = 1;
pub const btConstraintParams_BT_CONSTRAINT_STOP_ERP: btConstraintParams = 2;
pub const btConstraintParams_BT_CONSTRAINT_CFM: btConstraintParams = 3;
pub const btConstraintParams_BT_CONSTRAINT_STOP_CFM: btConstraintParams = 4;
pub type btConstraintParams = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btJointFeedback {
    pub m_appliedForceBodyA: btVector3,
    pub m_appliedTorqueBodyA: btVector3,
    pub m_appliedForceBodyB: btVector3,
    pub m_appliedTorqueBodyB: btVector3,
}
#[test]
fn bindgen_test_layout_btJointFeedback() {
    assert_eq!(
        ::std::mem::size_of::<btJointFeedback>(),
        128usize,
        concat!("Size of: ", stringify!(btJointFeedback))
    );
    assert_eq!(
        ::std::mem::align_of::<btJointFeedback>(),
        8usize,
        concat!("Alignment of ", stringify!(btJointFeedback))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btJointFeedback)).m_appliedForceBodyA as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btJointFeedback),
            "::",
            stringify!(m_appliedForceBodyA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btJointFeedback)).m_appliedTorqueBodyA as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btJointFeedback),
            "::",
            stringify!(m_appliedTorqueBodyA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btJointFeedback)).m_appliedForceBodyB as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btJointFeedback),
            "::",
            stringify!(m_appliedForceBodyB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btJointFeedback)).m_appliedTorqueBodyB as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btJointFeedback),
            "::",
            stringify!(m_appliedTorqueBodyB)
        )
    );
}
#[repr(C)]
pub struct btTypedConstraint__bindgen_vtable(::std::os::raw::c_void);
/// TypedConstraint is the baseclass for Bullet constraints and vehicles
#[repr(C)]
pub struct btTypedConstraint {
    pub vtable_: *const btTypedConstraint__bindgen_vtable,
    pub _base: btTypedObject,
    pub m_userConstraintType: ::std::os::raw::c_int,
    pub __bindgen_anon_1: btTypedConstraint__bindgen_ty_1,
    pub m_breakingImpulseThreshold: btScalar,
    pub m_isEnabled: bool,
    pub m_needsFeedback: bool,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_rbA: *mut btRigidBody,
    pub m_rbB: *mut btRigidBody,
    pub m_appliedImpulse: btScalar,
    pub m_dbgDrawSize: btScalar,
    pub m_jointFeedback: *mut btJointFeedback,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btTypedConstraint__bindgen_ty_1 {
    pub m_userConstraintId: ::std::os::raw::c_int,
    pub m_userConstraintPtr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_btTypedConstraint__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<btTypedConstraint__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(btTypedConstraint__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<btTypedConstraint__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(btTypedConstraint__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint__bindgen_ty_1)).m_userConstraintId as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint__bindgen_ty_1),
            "::",
            stringify!(m_userConstraintId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint__bindgen_ty_1)).m_userConstraintPtr as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint__bindgen_ty_1),
            "::",
            stringify!(m_userConstraintPtr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTypedConstraint_btConstraintInfo1 {
    pub m_numConstraintRows: ::std::os::raw::c_int,
    pub nub: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btTypedConstraint_btConstraintInfo1() {
    assert_eq!(
        ::std::mem::size_of::<btTypedConstraint_btConstraintInfo1>(),
        8usize,
        concat!("Size of: ", stringify!(btTypedConstraint_btConstraintInfo1))
    );
    assert_eq!(
        ::std::mem::align_of::<btTypedConstraint_btConstraintInfo1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(btTypedConstraint_btConstraintInfo1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint_btConstraintInfo1)).m_numConstraintRows as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo1),
            "::",
            stringify!(m_numConstraintRows)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraint_btConstraintInfo1)).nub as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo1),
            "::",
            stringify!(nub)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTypedConstraint_btConstraintInfo2 {
    pub fps: btScalar,
    pub erp: btScalar,
    pub m_J1linearAxis: *mut btScalar,
    pub m_J1angularAxis: *mut btScalar,
    pub m_J2linearAxis: *mut btScalar,
    pub m_J2angularAxis: *mut btScalar,
    pub rowskip: ::std::os::raw::c_int,
    pub m_constraintError: *mut btScalar,
    pub cfm: *mut btScalar,
    pub m_lowerLimit: *mut btScalar,
    pub m_upperLimit: *mut btScalar,
    pub m_numIterations: ::std::os::raw::c_int,
    pub m_damping: btScalar,
}
#[test]
fn bindgen_test_layout_btTypedConstraint_btConstraintInfo2() {
    assert_eq!(
        ::std::mem::size_of::<btTypedConstraint_btConstraintInfo2>(),
        104usize,
        concat!("Size of: ", stringify!(btTypedConstraint_btConstraintInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<btTypedConstraint_btConstraintInfo2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btTypedConstraint_btConstraintInfo2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraint_btConstraintInfo2)).fps as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo2),
            "::",
            stringify!(fps)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraint_btConstraintInfo2)).erp as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo2),
            "::",
            stringify!(erp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint_btConstraintInfo2)).m_J1linearAxis as *const _
                as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo2),
            "::",
            stringify!(m_J1linearAxis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint_btConstraintInfo2)).m_J1angularAxis as *const _
                as usize
        },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo2),
            "::",
            stringify!(m_J1angularAxis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint_btConstraintInfo2)).m_J2linearAxis as *const _
                as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo2),
            "::",
            stringify!(m_J2linearAxis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint_btConstraintInfo2)).m_J2angularAxis as *const _
                as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo2),
            "::",
            stringify!(m_J2angularAxis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint_btConstraintInfo2)).rowskip as *const _ as usize
        },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo2),
            "::",
            stringify!(rowskip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint_btConstraintInfo2)).m_constraintError as *const _
                as usize
        },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo2),
            "::",
            stringify!(m_constraintError)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraint_btConstraintInfo2)).cfm as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo2),
            "::",
            stringify!(cfm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint_btConstraintInfo2)).m_lowerLimit as *const _ as usize
        },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo2),
            "::",
            stringify!(m_lowerLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint_btConstraintInfo2)).m_upperLimit as *const _ as usize
        },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo2),
            "::",
            stringify!(m_upperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint_btConstraintInfo2)).m_numIterations as *const _
                as usize
        },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo2),
            "::",
            stringify!(m_numIterations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint_btConstraintInfo2)).m_damping as *const _ as usize
        },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint_btConstraintInfo2),
            "::",
            stringify!(m_damping)
        )
    );
}
#[test]
fn bindgen_test_layout_btTypedConstraint() {
    assert_eq!(
        ::std::mem::size_of::<btTypedConstraint>(),
        80usize,
        concat!("Size of: ", stringify!(btTypedConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<btTypedConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(btTypedConstraint))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraint)).m_userConstraintType as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint),
            "::",
            stringify!(m_userConstraintType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint)).m_breakingImpulseThreshold as *const _ as usize
        },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint),
            "::",
            stringify!(m_breakingImpulseThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraint)).m_isEnabled as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint),
            "::",
            stringify!(m_isEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraint)).m_needsFeedback as *const _ as usize },
        33usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint),
            "::",
            stringify!(m_needsFeedback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraint)).m_overrideNumSolverIterations as *const _ as usize
        },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint),
            "::",
            stringify!(m_overrideNumSolverIterations)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraint)).m_rbA as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint),
            "::",
            stringify!(m_rbA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraint)).m_rbB as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint),
            "::",
            stringify!(m_rbB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraint)).m_appliedImpulse as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint),
            "::",
            stringify!(m_appliedImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraint)).m_dbgDrawSize as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint),
            "::",
            stringify!(m_dbgDrawSize)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraint)).m_jointFeedback as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraint),
            "::",
            stringify!(m_jointFeedback)
        )
    );
}
extern "C" {

    /// internal method used by the constraint solver, don't use them directly

    #[link_name = "\u{1}_ZN17btTypedConstraint14getMotorFactorEddddd"]
    pub fn btTypedConstraint_getMotorFactor(
        this: *mut btTypedConstraint,
        pos: btScalar,
        lowLim: btScalar,
        uppLim: btScalar,
        vel: btScalar,
        timeFact: btScalar,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraint12getFixedBodyEv"]
    pub fn btTypedConstraint_getFixedBody() -> *mut btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btTypedConstraint30getOverrideNumSolverIterationsEv"]
    pub fn btTypedConstraint_getOverrideNumSolverIterations(
        this: *const btTypedConstraint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// override the number of constraint solver iterations used to solve this constraint
    /// ///-1 will use the default number of iterations, as specified in SolverInfo.m_numIterations

    #[link_name = "\u{1}_ZN17btTypedConstraint30setOverrideNumSolverIterationsEi"]
    pub fn btTypedConstraint_setOverrideNumSolverIterations(
        this: *mut btTypedConstraint,
        overideNumIterations: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// internal method used by the constraint solver, don't use them directly

    #[link_name = "\u{1}_ZN17btTypedConstraint25internalSetAppliedImpulseEd"]
    pub fn btTypedConstraint_internalSetAppliedImpulse(
        this: *mut btTypedConstraint,
        appliedImpulse: btScalar,
    );
}
extern "C" {

    /// internal method used by the constraint solver, don't use them directly

    #[link_name = "\u{1}_ZN17btTypedConstraint25internalGetAppliedImpulseEv"]
    pub fn btTypedConstraint_internalGetAppliedImpulse(this: *mut btTypedConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btTypedConstraint27getBreakingImpulseThresholdEv"]
    pub fn btTypedConstraint_getBreakingImpulseThreshold(
        this: *const btTypedConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraint27setBreakingImpulseThresholdEd"]
    pub fn btTypedConstraint_setBreakingImpulseThreshold(
        this: *mut btTypedConstraint,
        threshold: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btTypedConstraint9isEnabledEv"]
    pub fn btTypedConstraint_isEnabled(this: *const btTypedConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraint10setEnabledEb"]
    pub fn btTypedConstraint_setEnabled(this: *mut btTypedConstraint, enabled: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btTypedConstraint13getRigidBodyAEv"]
    pub fn btTypedConstraint_getRigidBodyA(this: *const btTypedConstraint) -> *const btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btTypedConstraint13getRigidBodyBEv"]
    pub fn btTypedConstraint_getRigidBodyB(this: *const btTypedConstraint) -> *const btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraint13getRigidBodyAEv"]
    pub fn btTypedConstraint_getRigidBodyA1(this: *mut btTypedConstraint) -> *mut btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraint13getRigidBodyBEv"]
    pub fn btTypedConstraint_getRigidBodyB1(this: *mut btTypedConstraint) -> *mut btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btTypedConstraint21getUserConstraintTypeEv"]
    pub fn btTypedConstraint_getUserConstraintType(
        this: *const btTypedConstraint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraint21setUserConstraintTypeEi"]
    pub fn btTypedConstraint_setUserConstraintType(
        this: *mut btTypedConstraint,
        userConstraintType: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraint19setUserConstraintIdEi"]
    pub fn btTypedConstraint_setUserConstraintId(
        this: *mut btTypedConstraint,
        uid: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btTypedConstraint19getUserConstraintIdEv"]
    pub fn btTypedConstraint_getUserConstraintId(
        this: *const btTypedConstraint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraint20setUserConstraintPtrEPv"]
    pub fn btTypedConstraint_setUserConstraintPtr(
        this: *mut btTypedConstraint,
        ptr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraint20getUserConstraintPtrEv"]
    pub fn btTypedConstraint_getUserConstraintPtr(
        this: *mut btTypedConstraint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraint16setJointFeedbackEP15btJointFeedback"]
    pub fn btTypedConstraint_setJointFeedback(
        this: *mut btTypedConstraint,
        jointFeedback: *mut btJointFeedback,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btTypedConstraint16getJointFeedbackEv"]
    pub fn btTypedConstraint_getJointFeedback(
        this: *const btTypedConstraint,
    ) -> *const btJointFeedback;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraint16getJointFeedbackEv"]
    pub fn btTypedConstraint_getJointFeedback1(
        this: *mut btTypedConstraint,
    ) -> *mut btJointFeedback;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btTypedConstraint6getUidEv"]
    pub fn btTypedConstraint_getUid(this: *const btTypedConstraint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btTypedConstraint13needsFeedbackEv"]
    pub fn btTypedConstraint_needsFeedback(this: *const btTypedConstraint) -> bool;
}
extern "C" {

    /// enableFeedback will allow to read the applied linear and angular impulse
    /// ///use getAppliedImpulse, getAppliedLinearImpulse and getAppliedAngularImpulse to read feedback information

    #[link_name = "\u{1}_ZN17btTypedConstraint14enableFeedbackEb"]
    pub fn btTypedConstraint_enableFeedback(this: *mut btTypedConstraint, needsFeedback: bool);
}
extern "C" {

    /// getAppliedImpulse is an estimated total applied impulse.
    /// ///This feedback could be used to determine breaking constraints or playing sounds.

    #[link_name = "\u{1}_ZNK17btTypedConstraint17getAppliedImpulseEv"]
    pub fn btTypedConstraint_getAppliedImpulse(this: *const btTypedConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btTypedConstraint17getConstraintTypeEv"]
    pub fn btTypedConstraint_getConstraintType(
        this: *const btTypedConstraint,
    ) -> btTypedConstraintType;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraint14setDbgDrawSizeEd"]
    pub fn btTypedConstraint_setDbgDrawSize(this: *mut btTypedConstraint, dbgDrawSize: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraint14getDbgDrawSizeEv"]
    pub fn btTypedConstraint_getDbgDrawSize(this: *mut btTypedConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraintC2E21btTypedConstraintTypeR11btRigidBody"]
    pub fn btTypedConstraint_btTypedConstraint(
        this: *mut btTypedConstraint,
        type_: btTypedConstraintType,
        rbA: *mut btRigidBody,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraintC2E21btTypedConstraintTypeR11btRigidBodyS2_"]
    pub fn btTypedConstraint_btTypedConstraint1(
        this: *mut btTypedConstraint,
        type_: btTypedConstraintType,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
    );
}
impl btTypedConstraint {
    #[inline]
    pub unsafe fn getMotorFactor(
        &mut self,
        pos: btScalar,
        lowLim: btScalar,
        uppLim: btScalar,
        vel: btScalar,
        timeFact: btScalar,
    ) -> btScalar {
        btTypedConstraint_getMotorFactor(self, pos, lowLim, uppLim, vel, timeFact)
    }
    #[inline]
    pub unsafe fn getFixedBody() -> *mut btRigidBody {
        btTypedConstraint_getFixedBody()
    }
    #[inline]
    pub unsafe fn getOverrideNumSolverIterations(&self) -> ::std::os::raw::c_int {
        btTypedConstraint_getOverrideNumSolverIterations(self)
    }
    #[inline]
    pub unsafe fn setOverrideNumSolverIterations(
        &mut self,
        overideNumIterations: ::std::os::raw::c_int,
    ) {
        btTypedConstraint_setOverrideNumSolverIterations(self, overideNumIterations)
    }
    #[inline]
    pub unsafe fn internalSetAppliedImpulse(&mut self, appliedImpulse: btScalar) {
        btTypedConstraint_internalSetAppliedImpulse(self, appliedImpulse)
    }
    #[inline]
    pub unsafe fn internalGetAppliedImpulse(&mut self) -> btScalar {
        btTypedConstraint_internalGetAppliedImpulse(self)
    }
    #[inline]
    pub unsafe fn getBreakingImpulseThreshold(&self) -> btScalar {
        btTypedConstraint_getBreakingImpulseThreshold(self)
    }
    #[inline]
    pub unsafe fn setBreakingImpulseThreshold(&mut self, threshold: btScalar) {
        btTypedConstraint_setBreakingImpulseThreshold(self, threshold)
    }
    #[inline]
    pub unsafe fn isEnabled(&self) -> bool {
        btTypedConstraint_isEnabled(self)
    }
    #[inline]
    pub unsafe fn setEnabled(&mut self, enabled: bool) {
        btTypedConstraint_setEnabled(self, enabled)
    }
    #[inline]
    pub unsafe fn getRigidBodyA(&self) -> *const btRigidBody {
        btTypedConstraint_getRigidBodyA(self)
    }
    #[inline]
    pub unsafe fn getRigidBodyB(&self) -> *const btRigidBody {
        btTypedConstraint_getRigidBodyB(self)
    }
    #[inline]
    pub unsafe fn getRigidBodyA1(&mut self) -> *mut btRigidBody {
        btTypedConstraint_getRigidBodyA1(self)
    }
    #[inline]
    pub unsafe fn getRigidBodyB1(&mut self) -> *mut btRigidBody {
        btTypedConstraint_getRigidBodyB1(self)
    }
    #[inline]
    pub unsafe fn getUserConstraintType(&self) -> ::std::os::raw::c_int {
        btTypedConstraint_getUserConstraintType(self)
    }
    #[inline]
    pub unsafe fn setUserConstraintType(&mut self, userConstraintType: ::std::os::raw::c_int) {
        btTypedConstraint_setUserConstraintType(self, userConstraintType)
    }
    #[inline]
    pub unsafe fn setUserConstraintId(&mut self, uid: ::std::os::raw::c_int) {
        btTypedConstraint_setUserConstraintId(self, uid)
    }
    #[inline]
    pub unsafe fn getUserConstraintId(&self) -> ::std::os::raw::c_int {
        btTypedConstraint_getUserConstraintId(self)
    }
    #[inline]
    pub unsafe fn setUserConstraintPtr(&mut self, ptr: *mut ::std::os::raw::c_void) {
        btTypedConstraint_setUserConstraintPtr(self, ptr)
    }
    #[inline]
    pub unsafe fn getUserConstraintPtr(&mut self) -> *mut ::std::os::raw::c_void {
        btTypedConstraint_getUserConstraintPtr(self)
    }
    #[inline]
    pub unsafe fn setJointFeedback(&mut self, jointFeedback: *mut btJointFeedback) {
        btTypedConstraint_setJointFeedback(self, jointFeedback)
    }
    #[inline]
    pub unsafe fn getJointFeedback(&self) -> *const btJointFeedback {
        btTypedConstraint_getJointFeedback(self)
    }
    #[inline]
    pub unsafe fn getJointFeedback1(&mut self) -> *mut btJointFeedback {
        btTypedConstraint_getJointFeedback1(self)
    }
    #[inline]
    pub unsafe fn getUid(&self) -> ::std::os::raw::c_int {
        btTypedConstraint_getUid(self)
    }
    #[inline]
    pub unsafe fn needsFeedback(&self) -> bool {
        btTypedConstraint_needsFeedback(self)
    }
    #[inline]
    pub unsafe fn enableFeedback(&mut self, needsFeedback: bool) {
        btTypedConstraint_enableFeedback(self, needsFeedback)
    }
    #[inline]
    pub unsafe fn getAppliedImpulse(&self) -> btScalar {
        btTypedConstraint_getAppliedImpulse(self)
    }
    #[inline]
    pub unsafe fn getConstraintType(&self) -> btTypedConstraintType {
        btTypedConstraint_getConstraintType(self)
    }
    #[inline]
    pub unsafe fn setDbgDrawSize(&mut self, dbgDrawSize: btScalar) {
        btTypedConstraint_setDbgDrawSize(self, dbgDrawSize)
    }
    #[inline]
    pub unsafe fn getDbgDrawSize(&mut self) -> btScalar {
        btTypedConstraint_getDbgDrawSize(self)
    }
    #[inline]
    pub unsafe fn new(type_: btTypedConstraintType, rbA: *mut btRigidBody) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTypedConstraint_btTypedConstraint(&mut __bindgen_tmp, type_, rbA);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        type_: btTypedConstraintType,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTypedConstraint_btTypedConstraint1(&mut __bindgen_tmp, type_, rbA, rbB);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN17btTypedConstraintD0Ev"]
    pub fn btTypedConstraint_btTypedConstraint_destructor(this: *mut btTypedConstraint);
}
extern "C" {

    /// internal method used by the constraint solver, don't use them directly

    #[link_name = "\u{1}_ZN17btTypedConstraint13buildJacobianEv"]
    pub fn btTypedConstraint_buildJacobian(this: *mut ::std::os::raw::c_void);
}
extern "C" {

    /// internal method used by the constraint solver, don't use them directly

    #[link_name = "\u{1}_ZN17btTypedConstraint21setupSolverConstraintER20btAlignedObjectArrayI18btSolverConstraintEiid"]
    pub fn btTypedConstraint_setupSolverConstraint(
        this: *mut ::std::os::raw::c_void,
        ca: *mut btConstraintArray,
        solverBodyA: ::std::os::raw::c_int,
        solverBodyB: ::std::os::raw::c_int,
        timeStep: btScalar,
    );
}
extern "C" {

    /// internal method used by the constraint solver, don't use them directly

    #[link_name = "\u{1}_ZN17btTypedConstraint8getInfo1EPNS_17btConstraintInfo1E"]
    pub fn btTypedConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {

    /// internal method used by the constraint solver, don't use them directly

    #[link_name = "\u{1}_ZN17btTypedConstraint8getInfo2EPNS_17btConstraintInfo2E"]
    pub fn btTypedConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {

    /// internal method used by the constraint solver, don't use them directly

    #[link_name = "\u{1}_ZN17btTypedConstraint23solveConstraintObsoleteER12btSolverBodyS1_d"]
    pub fn btTypedConstraint_solveConstraintObsolete(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut btSolverBody,
        arg2: *mut btSolverBody,
        arg3: btScalar,
    );
}
extern "C" {

    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.

    #[link_name = "\u{1}_ZN17btTypedConstraint8setParamEidi"]
    pub fn btTypedConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: btScalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// return the local value of parameter

    #[link_name = "\u{1}_ZNK17btTypedConstraint8getParamEii"]
    pub fn btTypedConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btTypedConstraint28calculateSerializeBufferSizeEv"]
    pub fn btTypedConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK17btTypedConstraint9serializeEPvP12btSerializer"]
    pub fn btTypedConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_Z21btAdjustAngleToLimitsddd"]
    pub fn btAdjustAngleToLimits(
        angleInRadians: btScalar,
        angleLowerLimitInRadians: btScalar,
        angleUpperLimitInRadians: btScalar,
    ) -> btScalar;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTypedConstraintFloatData {
    pub m_rbA: *mut btRigidBodyFloatData,
    pub m_rbB: *mut btRigidBodyFloatData,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_objectType: ::std::os::raw::c_int,
    pub m_userConstraintType: ::std::os::raw::c_int,
    pub m_userConstraintId: ::std::os::raw::c_int,
    pub m_needsFeedback: ::std::os::raw::c_int,
    pub m_appliedImpulse: f32,
    pub m_dbgDrawSize: f32,
    pub m_disableCollisionsBetweenLinkedBodies: ::std::os::raw::c_int,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_breakingImpulseThreshold: f32,
    pub m_isEnabled: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btTypedConstraintFloatData() {
    assert_eq!(
        ::std::mem::size_of::<btTypedConstraintFloatData>(),
        64usize,
        concat!("Size of: ", stringify!(btTypedConstraintFloatData))
    );
    assert_eq!(
        ::std::mem::align_of::<btTypedConstraintFloatData>(),
        8usize,
        concat!("Alignment of ", stringify!(btTypedConstraintFloatData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintFloatData)).m_rbA as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintFloatData),
            "::",
            stringify!(m_rbA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintFloatData)).m_rbB as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintFloatData),
            "::",
            stringify!(m_rbB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintFloatData)).m_name as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintFloatData),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintFloatData)).m_objectType as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintFloatData),
            "::",
            stringify!(m_objectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintFloatData)).m_userConstraintType as *const _ as usize
        },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintFloatData),
            "::",
            stringify!(m_userConstraintType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintFloatData)).m_userConstraintId as *const _ as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintFloatData),
            "::",
            stringify!(m_userConstraintId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintFloatData)).m_needsFeedback as *const _ as usize
        },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintFloatData),
            "::",
            stringify!(m_needsFeedback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintFloatData)).m_appliedImpulse as *const _ as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintFloatData),
            "::",
            stringify!(m_appliedImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintFloatData)).m_dbgDrawSize as *const _ as usize },
        44usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintFloatData),
            "::",
            stringify!(m_dbgDrawSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintFloatData)).m_disableCollisionsBetweenLinkedBodies
                as *const _ as usize
        },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintFloatData),
            "::",
            stringify!(m_disableCollisionsBetweenLinkedBodies)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintFloatData)).m_overrideNumSolverIterations as *const _
                as usize
        },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintFloatData),
            "::",
            stringify!(m_overrideNumSolverIterations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintFloatData)).m_breakingImpulseThreshold as *const _
                as usize
        },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintFloatData),
            "::",
            stringify!(m_breakingImpulseThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintFloatData)).m_isEnabled as *const _ as usize },
        60usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintFloatData),
            "::",
            stringify!(m_isEnabled)
        )
    );
}
/// this structure is not used, except for loading pre-2.82 .bullet files
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTypedConstraintData {
    pub m_rbA: *mut btRigidBodyDoubleData,
    pub m_rbB: *mut btRigidBodyDoubleData,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_objectType: ::std::os::raw::c_int,
    pub m_userConstraintType: ::std::os::raw::c_int,
    pub m_userConstraintId: ::std::os::raw::c_int,
    pub m_needsFeedback: ::std::os::raw::c_int,
    pub m_appliedImpulse: f32,
    pub m_dbgDrawSize: f32,
    pub m_disableCollisionsBetweenLinkedBodies: ::std::os::raw::c_int,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_breakingImpulseThreshold: f32,
    pub m_isEnabled: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btTypedConstraintData() {
    assert_eq!(
        ::std::mem::size_of::<btTypedConstraintData>(),
        64usize,
        concat!("Size of: ", stringify!(btTypedConstraintData))
    );
    assert_eq!(
        ::std::mem::align_of::<btTypedConstraintData>(),
        8usize,
        concat!("Alignment of ", stringify!(btTypedConstraintData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintData)).m_rbA as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintData),
            "::",
            stringify!(m_rbA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintData)).m_rbB as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintData),
            "::",
            stringify!(m_rbB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintData)).m_name as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintData),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintData)).m_objectType as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintData),
            "::",
            stringify!(m_objectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintData)).m_userConstraintType as *const _ as usize
        },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintData),
            "::",
            stringify!(m_userConstraintType)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintData)).m_userConstraintId as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintData),
            "::",
            stringify!(m_userConstraintId)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintData)).m_needsFeedback as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintData),
            "::",
            stringify!(m_needsFeedback)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintData)).m_appliedImpulse as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintData),
            "::",
            stringify!(m_appliedImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintData)).m_dbgDrawSize as *const _ as usize },
        44usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintData),
            "::",
            stringify!(m_dbgDrawSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintData)).m_disableCollisionsBetweenLinkedBodies
                as *const _ as usize
        },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintData),
            "::",
            stringify!(m_disableCollisionsBetweenLinkedBodies)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintData)).m_overrideNumSolverIterations as *const _
                as usize
        },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintData),
            "::",
            stringify!(m_overrideNumSolverIterations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintData)).m_breakingImpulseThreshold as *const _ as usize
        },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintData),
            "::",
            stringify!(m_breakingImpulseThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintData)).m_isEnabled as *const _ as usize },
        60usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintData),
            "::",
            stringify!(m_isEnabled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTypedConstraintDoubleData {
    pub m_rbA: *mut btRigidBodyDoubleData,
    pub m_rbB: *mut btRigidBodyDoubleData,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_objectType: ::std::os::raw::c_int,
    pub m_userConstraintType: ::std::os::raw::c_int,
    pub m_userConstraintId: ::std::os::raw::c_int,
    pub m_needsFeedback: ::std::os::raw::c_int,
    pub m_appliedImpulse: f64,
    pub m_dbgDrawSize: f64,
    pub m_disableCollisionsBetweenLinkedBodies: ::std::os::raw::c_int,
    pub m_overrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_breakingImpulseThreshold: f64,
    pub m_isEnabled: ::std::os::raw::c_int,
    pub padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btTypedConstraintDoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btTypedConstraintDoubleData>(),
        80usize,
        concat!("Size of: ", stringify!(btTypedConstraintDoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btTypedConstraintDoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btTypedConstraintDoubleData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintDoubleData)).m_rbA as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintDoubleData),
            "::",
            stringify!(m_rbA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintDoubleData)).m_rbB as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintDoubleData),
            "::",
            stringify!(m_rbB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintDoubleData)).m_name as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintDoubleData),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintDoubleData)).m_objectType as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintDoubleData),
            "::",
            stringify!(m_objectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintDoubleData)).m_userConstraintType as *const _ as usize
        },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintDoubleData),
            "::",
            stringify!(m_userConstraintType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintDoubleData)).m_userConstraintId as *const _ as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintDoubleData),
            "::",
            stringify!(m_userConstraintId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintDoubleData)).m_needsFeedback as *const _ as usize
        },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintDoubleData),
            "::",
            stringify!(m_needsFeedback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintDoubleData)).m_appliedImpulse as *const _ as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintDoubleData),
            "::",
            stringify!(m_appliedImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintDoubleData)).m_dbgDrawSize as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintDoubleData),
            "::",
            stringify!(m_dbgDrawSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintDoubleData)).m_disableCollisionsBetweenLinkedBodies
                as *const _ as usize
        },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintDoubleData),
            "::",
            stringify!(m_disableCollisionsBetweenLinkedBodies)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintDoubleData)).m_overrideNumSolverIterations as *const _
                as usize
        },
        60usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintDoubleData),
            "::",
            stringify!(m_overrideNumSolverIterations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTypedConstraintDoubleData)).m_breakingImpulseThreshold as *const _
                as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintDoubleData),
            "::",
            stringify!(m_breakingImpulseThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintDoubleData)).m_isEnabled as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintDoubleData),
            "::",
            stringify!(m_isEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTypedConstraintDoubleData)).padding as *const _ as usize },
        76usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTypedConstraintDoubleData),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btAngularLimit {
    pub m_center: btScalar,
    pub m_halfRange: btScalar,
    pub m_softness: btScalar,
    pub m_biasFactor: btScalar,
    pub m_relaxationFactor: btScalar,
    pub m_correction: btScalar,
    pub m_sign: btScalar,
    pub m_solveLimit: bool,
}
#[test]
fn bindgen_test_layout_btAngularLimit() {
    assert_eq!(
        ::std::mem::size_of::<btAngularLimit>(),
        64usize,
        concat!("Size of: ", stringify!(btAngularLimit))
    );
    assert_eq!(
        ::std::mem::align_of::<btAngularLimit>(),
        8usize,
        concat!("Alignment of ", stringify!(btAngularLimit))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btAngularLimit)).m_center as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btAngularLimit),
            "::",
            stringify!(m_center)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btAngularLimit)).m_halfRange as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btAngularLimit),
            "::",
            stringify!(m_halfRange)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btAngularLimit)).m_softness as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btAngularLimit),
            "::",
            stringify!(m_softness)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btAngularLimit)).m_biasFactor as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btAngularLimit),
            "::",
            stringify!(m_biasFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btAngularLimit)).m_relaxationFactor as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btAngularLimit),
            "::",
            stringify!(m_relaxationFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btAngularLimit)).m_correction as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btAngularLimit),
            "::",
            stringify!(m_correction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btAngularLimit)).m_sign as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btAngularLimit),
            "::",
            stringify!(m_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btAngularLimit)).m_solveLimit as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btAngularLimit),
            "::",
            stringify!(m_solveLimit)
        )
    );
}
extern "C" {

    /// Sets all limit's parameters.
    /// /// When low > high limit becomes inactive.
    /// /// When high - low > 2PI limit is ineffective too becouse no angle can exceed the limit

    #[link_name = "\u{1}_ZN14btAngularLimit3setEddddd"]
    pub fn btAngularLimit_set(
        this: *mut btAngularLimit,
        low: btScalar,
        high: btScalar,
        _softness: btScalar,
        _biasFactor: btScalar,
        _relaxationFactor: btScalar,
    );
}
extern "C" {

    /// Checks conastaint angle against limit. If limit is active and the angle violates the limit
    /// /// correction is calculated.

    #[link_name = "\u{1}_ZN14btAngularLimit4testEd"]
    pub fn btAngularLimit_test(this: *mut btAngularLimit, angle: btScalar);
}
extern "C" {

    /// Returns limit's softness

    #[link_name = "\u{1}_ZNK14btAngularLimit11getSoftnessEv"]
    pub fn btAngularLimit_getSoftness(this: *const btAngularLimit) -> btScalar;
}
extern "C" {

    /// Returns limit's bias factor

    #[link_name = "\u{1}_ZNK14btAngularLimit13getBiasFactorEv"]
    pub fn btAngularLimit_getBiasFactor(this: *const btAngularLimit) -> btScalar;
}
extern "C" {

    /// Returns limit's relaxation factor

    #[link_name = "\u{1}_ZNK14btAngularLimit19getRelaxationFactorEv"]
    pub fn btAngularLimit_getRelaxationFactor(this: *const btAngularLimit) -> btScalar;
}
extern "C" {

    /// Returns correction value evaluated when test() was invoked

    #[link_name = "\u{1}_ZNK14btAngularLimit13getCorrectionEv"]
    pub fn btAngularLimit_getCorrection(this: *const btAngularLimit) -> btScalar;
}
extern "C" {

    /// Returns sign value evaluated when test() was invoked

    #[link_name = "\u{1}_ZNK14btAngularLimit7getSignEv"]
    pub fn btAngularLimit_getSign(this: *const btAngularLimit) -> btScalar;
}
extern "C" {

    /// Gives half of the distance between min and max limit angle

    #[link_name = "\u{1}_ZNK14btAngularLimit12getHalfRangeEv"]
    pub fn btAngularLimit_getHalfRange(this: *const btAngularLimit) -> btScalar;
}
extern "C" {

    /// Returns true when the last test() invocation recognized limit violation

    #[link_name = "\u{1}_ZNK14btAngularLimit7isLimitEv"]
    pub fn btAngularLimit_isLimit(this: *const btAngularLimit) -> bool;
}
extern "C" {

    /// Checks given angle against limit. If limit is active and angle doesn't fit it, the angle
    /// /// returned is modified so it equals to the limit closest to given angle.

    #[link_name = "\u{1}_ZNK14btAngularLimit3fitERd"]
    pub fn btAngularLimit_fit(this: *const btAngularLimit, angle: *mut btScalar);
}
extern "C" {

    /// Returns correction value multiplied by sign value

    #[link_name = "\u{1}_ZNK14btAngularLimit8getErrorEv"]
    pub fn btAngularLimit_getError(this: *const btAngularLimit) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btAngularLimit6getLowEv"]
    pub fn btAngularLimit_getLow(this: *const btAngularLimit) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK14btAngularLimit7getHighEv"]
    pub fn btAngularLimit_getHigh(this: *const btAngularLimit) -> btScalar;
}
extern "C" {

    /// Default constructor initializes limit as inactive, allowing free constraint movement

    #[link_name = "\u{1}_ZN14btAngularLimitC1Ev"]
    pub fn btAngularLimit_btAngularLimit(this: *mut btAngularLimit);
}
impl btAngularLimit {
    #[inline]
    pub unsafe fn set(
        &mut self,
        low: btScalar,
        high: btScalar,
        _softness: btScalar,
        _biasFactor: btScalar,
        _relaxationFactor: btScalar,
    ) {
        btAngularLimit_set(self, low, high, _softness, _biasFactor, _relaxationFactor)
    }
    #[inline]
    pub unsafe fn test(&mut self, angle: btScalar) {
        btAngularLimit_test(self, angle)
    }
    #[inline]
    pub unsafe fn getSoftness(&self) -> btScalar {
        btAngularLimit_getSoftness(self)
    }
    #[inline]
    pub unsafe fn getBiasFactor(&self) -> btScalar {
        btAngularLimit_getBiasFactor(self)
    }
    #[inline]
    pub unsafe fn getRelaxationFactor(&self) -> btScalar {
        btAngularLimit_getRelaxationFactor(self)
    }
    #[inline]
    pub unsafe fn getCorrection(&self) -> btScalar {
        btAngularLimit_getCorrection(self)
    }
    #[inline]
    pub unsafe fn getSign(&self) -> btScalar {
        btAngularLimit_getSign(self)
    }
    #[inline]
    pub unsafe fn getHalfRange(&self) -> btScalar {
        btAngularLimit_getHalfRange(self)
    }
    #[inline]
    pub unsafe fn isLimit(&self) -> bool {
        btAngularLimit_isLimit(self)
    }
    #[inline]
    pub unsafe fn fit(&self, angle: *mut btScalar) {
        btAngularLimit_fit(self, angle)
    }
    #[inline]
    pub unsafe fn getError(&self) -> btScalar {
        btAngularLimit_getError(self)
    }
    #[inline]
    pub unsafe fn getLow(&self) -> btScalar {
        btAngularLimit_getLow(self)
    }
    #[inline]
    pub unsafe fn getHigh(&self) -> btScalar {
        btAngularLimit_getHigh(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btAngularLimit_btAngularLimit(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConstraintSetting {
    pub m_tau: btScalar,
    pub m_damping: btScalar,
    pub m_impulseClamp: btScalar,
}
#[test]
fn bindgen_test_layout_btConstraintSetting() {
    assert_eq!(
        ::std::mem::size_of::<btConstraintSetting>(),
        24usize,
        concat!("Size of: ", stringify!(btConstraintSetting))
    );
    assert_eq!(
        ::std::mem::align_of::<btConstraintSetting>(),
        8usize,
        concat!("Alignment of ", stringify!(btConstraintSetting))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConstraintSetting)).m_tau as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConstraintSetting),
            "::",
            stringify!(m_tau)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConstraintSetting)).m_damping as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConstraintSetting),
            "::",
            stringify!(m_damping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConstraintSetting)).m_impulseClamp as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConstraintSetting),
            "::",
            stringify!(m_impulseClamp)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19btConstraintSettingC1Ev"]
    pub fn btConstraintSetting_btConstraintSetting(this: *mut btConstraintSetting);
}
impl btConstraintSetting {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConstraintSetting_btConstraintSetting(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
pub const btPoint2PointFlags_BT_P2P_FLAGS_ERP: btPoint2PointFlags = 1;
pub const btPoint2PointFlags_BT_P2P_FLAGS_CFM: btPoint2PointFlags = 2;
pub type btPoint2PointFlags = ::std::os::raw::c_uint;
/// point to point constraint between two rigidbodies each with a pivotpoint that descibes the 'ballsocket' location in local space
#[repr(C)]
pub struct btPoint2PointConstraint {
    pub _base: btTypedConstraint,
    pub m_jac: [btJacobianEntry; 3usize],
    pub m_pivotInA: btVector3,
    pub m_pivotInB: btVector3,
    pub m_flags: ::std::os::raw::c_int,
    pub m_erp: btScalar,
    pub m_cfm: btScalar,
    /// for backwards compatibility during the transition to 'getInfo/getInfo2'
    pub m_useSolveConstraintObsolete: bool,
    pub m_setting: btConstraintSetting,
}
#[test]
fn bindgen_test_layout_btPoint2PointConstraint() {
    assert_eq!(
        ::std::mem::size_of::<btPoint2PointConstraint>(),
        704usize,
        concat!("Size of: ", stringify!(btPoint2PointConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<btPoint2PointConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(btPoint2PointConstraint))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPoint2PointConstraint)).m_jac as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraint),
            "::",
            stringify!(m_jac)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPoint2PointConstraint)).m_pivotInA as *const _ as usize },
        584usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraint),
            "::",
            stringify!(m_pivotInA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPoint2PointConstraint)).m_pivotInB as *const _ as usize },
        616usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraint),
            "::",
            stringify!(m_pivotInB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPoint2PointConstraint)).m_flags as *const _ as usize },
        648usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraint),
            "::",
            stringify!(m_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPoint2PointConstraint)).m_erp as *const _ as usize },
        656usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraint),
            "::",
            stringify!(m_erp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPoint2PointConstraint)).m_cfm as *const _ as usize },
        664usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraint),
            "::",
            stringify!(m_cfm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPoint2PointConstraint)).m_useSolveConstraintObsolete as *const _
                as usize
        },
        672usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraint),
            "::",
            stringify!(m_useSolveConstraintObsolete)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btPoint2PointConstraint)).m_setting as *const _ as usize },
        680usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraint),
            "::",
            stringify!(m_setting)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btPoint2PointConstraint18getInfo1NonVirtualEPN17btTypedConstraint17btConstraintInfo1E"]
    pub fn btPoint2PointConstraint_getInfo1NonVirtual(
        this: *mut btPoint2PointConstraint,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btPoint2PointConstraint18getInfo2NonVirtualEPN17btTypedConstraint17btConstraintInfo2ERK11btTransformS5_"]
    pub fn btPoint2PointConstraint_getInfo2NonVirtual(
        this: *mut btPoint2PointConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        body0_trans: *const btTransform,
        body1_trans: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btPoint2PointConstraint9updateRHSEd"]
    pub fn btPoint2PointConstraint_updateRHS(
        this: *mut btPoint2PointConstraint,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btPoint2PointConstraint9setPivotAERK9btVector3"]
    pub fn btPoint2PointConstraint_setPivotA(
        this: *mut btPoint2PointConstraint,
        pivotA: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btPoint2PointConstraint9setPivotBERK9btVector3"]
    pub fn btPoint2PointConstraint_setPivotB(
        this: *mut btPoint2PointConstraint,
        pivotB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPoint2PointConstraint11getPivotInAEv"]
    pub fn btPoint2PointConstraint_getPivotInA(
        this: *const btPoint2PointConstraint,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPoint2PointConstraint11getPivotInBEv"]
    pub fn btPoint2PointConstraint_getPivotInB(
        this: *const btPoint2PointConstraint,
    ) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btPoint2PointConstraintC1ER11btRigidBodyS1_RK9btVector3S4_"]
    pub fn btPoint2PointConstraint_btPoint2PointConstraint(
        this: *mut btPoint2PointConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btPoint2PointConstraintC1ER11btRigidBodyRK9btVector3"]
    pub fn btPoint2PointConstraint_btPoint2PointConstraint1(
        this: *mut btPoint2PointConstraint,
        rbA: *mut btRigidBody,
        pivotInA: *const btVector3,
    );
}
impl btPoint2PointConstraint {
    #[inline]
    pub unsafe fn getInfo1NonVirtual(&mut self, info: *mut btTypedConstraint_btConstraintInfo1) {
        btPoint2PointConstraint_getInfo1NonVirtual(self, info)
    }
    #[inline]
    pub unsafe fn getInfo2NonVirtual(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        body0_trans: *const btTransform,
        body1_trans: *const btTransform,
    ) {
        btPoint2PointConstraint_getInfo2NonVirtual(self, info, body0_trans, body1_trans)
    }
    #[inline]
    pub unsafe fn updateRHS(&mut self, timeStep: btScalar) {
        btPoint2PointConstraint_updateRHS(self, timeStep)
    }
    #[inline]
    pub unsafe fn setPivotA(&mut self, pivotA: *const btVector3) {
        btPoint2PointConstraint_setPivotA(self, pivotA)
    }
    #[inline]
    pub unsafe fn setPivotB(&mut self, pivotB: *const btVector3) {
        btPoint2PointConstraint_setPivotB(self, pivotB)
    }
    #[inline]
    pub unsafe fn getPivotInA(&self) -> *const btVector3 {
        btPoint2PointConstraint_getPivotInA(self)
    }
    #[inline]
    pub unsafe fn getPivotInB(&self) -> *const btVector3 {
        btPoint2PointConstraint_getPivotInB(self)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btPoint2PointConstraint_btPoint2PointConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            pivotInA,
            pivotInB,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(rbA: *mut btRigidBody, pivotInA: *const btVector3) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btPoint2PointConstraint_btPoint2PointConstraint1(&mut __bindgen_tmp, rbA, pivotInA);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN23btPoint2PointConstraint13buildJacobianEv"]
    pub fn btPoint2PointConstraint_buildJacobian(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN23btPoint2PointConstraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
    pub fn btPoint2PointConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btPoint2PointConstraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
    pub fn btPoint2PointConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {

    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.

    #[link_name = "\u{1}_ZN23btPoint2PointConstraint8setParamEidi"]
    pub fn btPoint2PointConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: btScalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// return the local value of parameter

    #[link_name = "\u{1}_ZNK23btPoint2PointConstraint8getParamEii"]
    pub fn btPoint2PointConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPoint2PointConstraint8getFlagsEv"]
    pub fn btPoint2PointConstraint_getFlags(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btPoint2PointConstraint28calculateSerializeBufferSizeEv"]
    pub fn btPoint2PointConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK23btPoint2PointConstraint9serializeEPvP12btSerializer"]
    pub fn btPoint2PointConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPoint2PointConstraintFloatData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_pivotInA: btVector3FloatData,
    pub m_pivotInB: btVector3FloatData,
}
#[test]
fn bindgen_test_layout_btPoint2PointConstraintFloatData() {
    assert_eq!(
        ::std::mem::size_of::<btPoint2PointConstraintFloatData>(),
        96usize,
        concat!("Size of: ", stringify!(btPoint2PointConstraintFloatData))
    );
    assert_eq!(
        ::std::mem::align_of::<btPoint2PointConstraintFloatData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btPoint2PointConstraintFloatData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPoint2PointConstraintFloatData)).m_typeConstraintData as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraintFloatData),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPoint2PointConstraintFloatData)).m_pivotInA as *const _ as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraintFloatData),
            "::",
            stringify!(m_pivotInA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPoint2PointConstraintFloatData)).m_pivotInB as *const _ as usize
        },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraintFloatData),
            "::",
            stringify!(m_pivotInB)
        )
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPoint2PointConstraintDoubleData2 {
    pub m_typeConstraintData: btTypedConstraintDoubleData,
    pub m_pivotInA: btVector3DoubleData,
    pub m_pivotInB: btVector3DoubleData,
}
#[test]
fn bindgen_test_layout_btPoint2PointConstraintDoubleData2() {
    assert_eq!(
        ::std::mem::size_of::<btPoint2PointConstraintDoubleData2>(),
        144usize,
        concat!("Size of: ", stringify!(btPoint2PointConstraintDoubleData2))
    );
    assert_eq!(
        ::std::mem::align_of::<btPoint2PointConstraintDoubleData2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btPoint2PointConstraintDoubleData2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPoint2PointConstraintDoubleData2)).m_typeConstraintData as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraintDoubleData2),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPoint2PointConstraintDoubleData2)).m_pivotInA as *const _ as usize
        },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraintDoubleData2),
            "::",
            stringify!(m_pivotInA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPoint2PointConstraintDoubleData2)).m_pivotInB as *const _ as usize
        },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraintDoubleData2),
            "::",
            stringify!(m_pivotInB)
        )
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
/// this structure is not used, except for loading pre-2.82 .bullet files
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btPoint2PointConstraintDoubleData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_pivotInA: btVector3DoubleData,
    pub m_pivotInB: btVector3DoubleData,
}
#[test]
fn bindgen_test_layout_btPoint2PointConstraintDoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btPoint2PointConstraintDoubleData>(),
        128usize,
        concat!("Size of: ", stringify!(btPoint2PointConstraintDoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btPoint2PointConstraintDoubleData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btPoint2PointConstraintDoubleData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPoint2PointConstraintDoubleData)).m_typeConstraintData as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraintDoubleData),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPoint2PointConstraintDoubleData)).m_pivotInA as *const _ as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraintDoubleData),
            "::",
            stringify!(m_pivotInA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btPoint2PointConstraintDoubleData)).m_pivotInB as *const _ as usize
        },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btPoint2PointConstraintDoubleData),
            "::",
            stringify!(m_pivotInB)
        )
    );
}
pub const btHingeFlags_BT_HINGE_FLAGS_CFM_STOP: btHingeFlags = 1;
pub const btHingeFlags_BT_HINGE_FLAGS_ERP_STOP: btHingeFlags = 2;
pub const btHingeFlags_BT_HINGE_FLAGS_CFM_NORM: btHingeFlags = 4;
pub const btHingeFlags_BT_HINGE_FLAGS_ERP_NORM: btHingeFlags = 8;
pub type btHingeFlags = ::std::os::raw::c_uint;
/// hinge constraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
/// axis defines the orientation of the hinge axis
#[repr(C)]
pub struct btHingeConstraint {
    pub _base: btTypedConstraint,
    pub m_jac: [btJacobianEntry; 3usize],
    pub m_jacAng: [btJacobianEntry; 3usize],
    pub m_rbAFrame: btTransform,
    pub m_rbBFrame: btTransform,
    pub m_motorTargetVelocity: btScalar,
    pub m_maxMotorImpulse: btScalar,
    pub m_limit: btAngularLimit,
    pub m_kHinge: btScalar,
    pub m_accLimitImpulse: btScalar,
    pub m_hingeAngle: btScalar,
    pub m_referenceSign: btScalar,
    pub m_angularOnly: bool,
    pub m_enableAngularMotor: bool,
    pub m_useSolveConstraintObsolete: bool,
    pub m_useOffsetForConstraintFrame: bool,
    pub m_useReferenceFrameA: bool,
    pub m_accMotorImpulse: btScalar,
    pub m_flags: ::std::os::raw::c_int,
    pub m_normalCFM: btScalar,
    pub m_normalERP: btScalar,
    pub m_stopCFM: btScalar,
    pub m_stopERP: btScalar,
}
#[test]
fn bindgen_test_layout_btHingeConstraint() {
    assert_eq!(
        ::std::mem::size_of::<btHingeConstraint>(),
        1512usize,
        concat!("Size of: ", stringify!(btHingeConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<btHingeConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(btHingeConstraint))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_jac as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_jac)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_jacAng as *const _ as usize },
        584usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_jacAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_rbAFrame as *const _ as usize },
        1088usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_rbAFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_rbBFrame as *const _ as usize },
        1216usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_rbBFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_motorTargetVelocity as *const _ as usize },
        1344usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_motorTargetVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_maxMotorImpulse as *const _ as usize },
        1352usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_maxMotorImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_limit as *const _ as usize },
        1360usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_kHinge as *const _ as usize },
        1424usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_kHinge)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_accLimitImpulse as *const _ as usize },
        1432usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_accLimitImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_hingeAngle as *const _ as usize },
        1440usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_hingeAngle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_referenceSign as *const _ as usize },
        1448usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_referenceSign)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_angularOnly as *const _ as usize },
        1456usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_angularOnly)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_enableAngularMotor as *const _ as usize },
        1457usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_enableAngularMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraint)).m_useSolveConstraintObsolete as *const _ as usize
        },
        1458usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_useSolveConstraintObsolete)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraint)).m_useOffsetForConstraintFrame as *const _ as usize
        },
        1459usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_useOffsetForConstraintFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_useReferenceFrameA as *const _ as usize },
        1460usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_useReferenceFrameA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_accMotorImpulse as *const _ as usize },
        1464usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_accMotorImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_flags as *const _ as usize },
        1472usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_normalCFM as *const _ as usize },
        1480usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_normalCFM)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_normalERP as *const _ as usize },
        1488usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_normalERP)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_stopCFM as *const _ as usize },
        1496usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_stopCFM)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraint)).m_stopERP as *const _ as usize },
        1504usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraint),
            "::",
            stringify!(m_stopERP)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint18getInfo1NonVirtualEPN17btTypedConstraint17btConstraintInfo1E"]
    pub fn btHingeConstraint_getInfo1NonVirtual(
        this: *mut btHingeConstraint,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint18getInfo2NonVirtualEPN17btTypedConstraint17btConstraintInfo2ERK11btTransformS5_RK9btVector3S8_"]
    pub fn btHingeConstraint_getInfo2NonVirtual(
        this: *mut btHingeConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint16getInfo2InternalEPN17btTypedConstraint17btConstraintInfo2ERK11btTransformS5_RK9btVector3S8_"]
    pub fn btHingeConstraint_getInfo2Internal(
        this: *mut btHingeConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint32getInfo2InternalUsingFrameOffsetEPN17btTypedConstraint17btConstraintInfo2ERK11btTransformS5_RK9btVector3S8_"]
    pub fn btHingeConstraint_getInfo2InternalUsingFrameOffset(
        this: *mut btHingeConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint9updateRHSEd"]
    pub fn btHingeConstraint_updateRHS(this: *mut btHingeConstraint, timeStep: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btHingeConstraint13getRigidBodyAEv"]
    pub fn btHingeConstraint_getRigidBodyA(this: *const btHingeConstraint) -> *const btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btHingeConstraint13getRigidBodyBEv"]
    pub fn btHingeConstraint_getRigidBodyB(this: *const btHingeConstraint) -> *const btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint13getRigidBodyAEv"]
    pub fn btHingeConstraint_getRigidBodyA1(this: *mut btHingeConstraint) -> *mut btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint13getRigidBodyBEv"]
    pub fn btHingeConstraint_getRigidBodyB1(this: *mut btHingeConstraint) -> *mut btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint15getFrameOffsetAEv"]
    pub fn btHingeConstraint_getFrameOffsetA(this: *mut btHingeConstraint) -> *mut btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint15getFrameOffsetBEv"]
    pub fn btHingeConstraint_getFrameOffsetB(this: *mut btHingeConstraint) -> *mut btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint9setFramesERK11btTransformS2_"]
    pub fn btHingeConstraint_setFrames(
        this: *mut btHingeConstraint,
        frameA: *const btTransform,
        frameB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint14setAngularOnlyEb"]
    pub fn btHingeConstraint_setAngularOnly(this: *mut btHingeConstraint, angularOnly: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint18enableAngularMotorEbdd"]
    pub fn btHingeConstraint_enableAngularMotor(
        this: *mut btHingeConstraint,
        enableMotor: bool,
        targetVelocity: btScalar,
        maxMotorImpulse: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint11enableMotorEb"]
    pub fn btHingeConstraint_enableMotor(this: *mut btHingeConstraint, enableMotor: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint18setMaxMotorImpulseEd"]
    pub fn btHingeConstraint_setMaxMotorImpulse(
        this: *mut btHingeConstraint,
        maxMotorImpulse: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint22setMotorTargetVelocityEd"]
    pub fn btHingeConstraint_setMotorTargetVelocity(
        this: *mut btHingeConstraint,
        motorTargetVelocity: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint14setMotorTargetERK12btQuaterniond"]
    pub fn btHingeConstraint_setMotorTarget(
        this: *mut btHingeConstraint,
        qAinB: *const btQuaternion,
        dt: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint14setMotorTargetEdd"]
    pub fn btHingeConstraint_setMotorTarget1(
        this: *mut btHingeConstraint,
        targetAngle: btScalar,
        dt: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint8setLimitEddddd"]
    pub fn btHingeConstraint_setLimit(
        this: *mut btHingeConstraint,
        low: btScalar,
        high: btScalar,
        _softness: btScalar,
        _biasFactor: btScalar,
        _relaxationFactor: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btHingeConstraint16getLimitSoftnessEv"]
    pub fn btHingeConstraint_getLimitSoftness(this: *const btHingeConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btHingeConstraint18getLimitBiasFactorEv"]
    pub fn btHingeConstraint_getLimitBiasFactor(this: *const btHingeConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btHingeConstraint24getLimitRelaxationFactorEv"]
    pub fn btHingeConstraint_getLimitRelaxationFactor(this: *const btHingeConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint7setAxisER9btVector3"]
    pub fn btHingeConstraint_setAxis(this: *mut btHingeConstraint, axisInA: *mut btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btHingeConstraint8hasLimitEv"]
    pub fn btHingeConstraint_hasLimit(this: *const btHingeConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btHingeConstraint13getLowerLimitEv"]
    pub fn btHingeConstraint_getLowerLimit(this: *const btHingeConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btHingeConstraint13getUpperLimitEv"]
    pub fn btHingeConstraint_getUpperLimit(this: *const btHingeConstraint) -> btScalar;
}
extern "C" {

    /// The getHingeAngle gives the hinge angle in range [-PI,PI]

    #[link_name = "\u{1}_ZN17btHingeConstraint13getHingeAngleEv"]
    pub fn btHingeConstraint_getHingeAngle(this: *mut btHingeConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint13getHingeAngleERK11btTransformS2_"]
    pub fn btHingeConstraint_getHingeAngle1(
        this: *mut btHingeConstraint,
        transA: *const btTransform,
        transB: *const btTransform,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint9testLimitERK11btTransformS2_"]
    pub fn btHingeConstraint_testLimit(
        this: *mut btHingeConstraint,
        transA: *const btTransform,
        transB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btHingeConstraint9getAFrameEv"]
    pub fn btHingeConstraint_getAFrame(this: *const btHingeConstraint) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btHingeConstraint9getBFrameEv"]
    pub fn btHingeConstraint_getBFrame(this: *const btHingeConstraint) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint9getAFrameEv"]
    pub fn btHingeConstraint_getAFrame1(this: *mut btHingeConstraint) -> *mut btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint9getBFrameEv"]
    pub fn btHingeConstraint_getBFrame1(this: *mut btHingeConstraint) -> *mut btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint13getSolveLimitEv"]
    pub fn btHingeConstraint_getSolveLimit(this: *mut btHingeConstraint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint12getLimitSignEv"]
    pub fn btHingeConstraint_getLimitSign(this: *mut btHingeConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint14getAngularOnlyEv"]
    pub fn btHingeConstraint_getAngularOnly(this: *mut btHingeConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint21getEnableAngularMotorEv"]
    pub fn btHingeConstraint_getEnableAngularMotor(this: *mut btHingeConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint22getMotorTargetVelocityEv"]
    pub fn btHingeConstraint_getMotorTargetVelocity(this: *mut btHingeConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint18getMaxMotorImpulseEv"]
    pub fn btHingeConstraint_getMaxMotorImpulse(this: *mut btHingeConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint17getUseFrameOffsetEv"]
    pub fn btHingeConstraint_getUseFrameOffset(this: *mut btHingeConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint17setUseFrameOffsetEb"]
    pub fn btHingeConstraint_setUseFrameOffset(
        this: *mut btHingeConstraint,
        frameOffsetOnOff: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btHingeConstraint21getUseReferenceFrameAEv"]
    pub fn btHingeConstraint_getUseReferenceFrameA(this: *const btHingeConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint21setUseReferenceFrameAEb"]
    pub fn btHingeConstraint_setUseReferenceFrameA(
        this: *mut btHingeConstraint,
        useReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraintC1ER11btRigidBodyS1_RK9btVector3S4_S4_S4_b"]
    pub fn btHingeConstraint_btHingeConstraint(
        this: *mut btHingeConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        axisInA: *const btVector3,
        axisInB: *const btVector3,
        useReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraintC1ER11btRigidBodyRK9btVector3S4_b"]
    pub fn btHingeConstraint_btHingeConstraint1(
        this: *mut btHingeConstraint,
        rbA: *mut btRigidBody,
        pivotInA: *const btVector3,
        axisInA: *const btVector3,
        useReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b"]
    pub fn btHingeConstraint_btHingeConstraint2(
        this: *mut btHingeConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        rbAFrame: *const btTransform,
        rbBFrame: *const btTransform,
        useReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraintC1ER11btRigidBodyRK11btTransformb"]
    pub fn btHingeConstraint_btHingeConstraint3(
        this: *mut btHingeConstraint,
        rbA: *mut btRigidBody,
        rbAFrame: *const btTransform,
        useReferenceFrameA: bool,
    );
}
impl btHingeConstraint {
    #[inline]
    pub unsafe fn getInfo1NonVirtual(&mut self, info: *mut btTypedConstraint_btConstraintInfo1) {
        btHingeConstraint_getInfo1NonVirtual(self, info)
    }
    #[inline]
    pub unsafe fn getInfo2NonVirtual(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) {
        btHingeConstraint_getInfo2NonVirtual(self, info, transA, transB, angVelA, angVelB)
    }
    #[inline]
    pub unsafe fn getInfo2Internal(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) {
        btHingeConstraint_getInfo2Internal(self, info, transA, transB, angVelA, angVelB)
    }
    #[inline]
    pub unsafe fn getInfo2InternalUsingFrameOffset(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) {
        btHingeConstraint_getInfo2InternalUsingFrameOffset(
            self,
            info,
            transA,
            transB,
            angVelA,
            angVelB,
        )
    }
    #[inline]
    pub unsafe fn updateRHS(&mut self, timeStep: btScalar) {
        btHingeConstraint_updateRHS(self, timeStep)
    }
    #[inline]
    pub unsafe fn getRigidBodyA(&self) -> *const btRigidBody {
        btHingeConstraint_getRigidBodyA(self)
    }
    #[inline]
    pub unsafe fn getRigidBodyB(&self) -> *const btRigidBody {
        btHingeConstraint_getRigidBodyB(self)
    }
    #[inline]
    pub unsafe fn getRigidBodyA1(&mut self) -> *mut btRigidBody {
        btHingeConstraint_getRigidBodyA1(self)
    }
    #[inline]
    pub unsafe fn getRigidBodyB1(&mut self) -> *mut btRigidBody {
        btHingeConstraint_getRigidBodyB1(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetA(&mut self) -> *mut btTransform {
        btHingeConstraint_getFrameOffsetA(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetB(&mut self) -> *mut btTransform {
        btHingeConstraint_getFrameOffsetB(self)
    }
    #[inline]
    pub unsafe fn setFrames(&mut self, frameA: *const btTransform, frameB: *const btTransform) {
        btHingeConstraint_setFrames(self, frameA, frameB)
    }
    #[inline]
    pub unsafe fn setAngularOnly(&mut self, angularOnly: bool) {
        btHingeConstraint_setAngularOnly(self, angularOnly)
    }
    #[inline]
    pub unsafe fn enableAngularMotor(
        &mut self,
        enableMotor: bool,
        targetVelocity: btScalar,
        maxMotorImpulse: btScalar,
    ) {
        btHingeConstraint_enableAngularMotor(self, enableMotor, targetVelocity, maxMotorImpulse)
    }
    #[inline]
    pub unsafe fn enableMotor(&mut self, enableMotor: bool) {
        btHingeConstraint_enableMotor(self, enableMotor)
    }
    #[inline]
    pub unsafe fn setMaxMotorImpulse(&mut self, maxMotorImpulse: btScalar) {
        btHingeConstraint_setMaxMotorImpulse(self, maxMotorImpulse)
    }
    #[inline]
    pub unsafe fn setMotorTargetVelocity(&mut self, motorTargetVelocity: btScalar) {
        btHingeConstraint_setMotorTargetVelocity(self, motorTargetVelocity)
    }
    #[inline]
    pub unsafe fn setMotorTarget(&mut self, qAinB: *const btQuaternion, dt: btScalar) {
        btHingeConstraint_setMotorTarget(self, qAinB, dt)
    }
    #[inline]
    pub unsafe fn setMotorTarget1(&mut self, targetAngle: btScalar, dt: btScalar) {
        btHingeConstraint_setMotorTarget1(self, targetAngle, dt)
    }
    #[inline]
    pub unsafe fn setLimit(
        &mut self,
        low: btScalar,
        high: btScalar,
        _softness: btScalar,
        _biasFactor: btScalar,
        _relaxationFactor: btScalar,
    ) {
        btHingeConstraint_setLimit(self, low, high, _softness, _biasFactor, _relaxationFactor)
    }
    #[inline]
    pub unsafe fn getLimitSoftness(&self) -> btScalar {
        btHingeConstraint_getLimitSoftness(self)
    }
    #[inline]
    pub unsafe fn getLimitBiasFactor(&self) -> btScalar {
        btHingeConstraint_getLimitBiasFactor(self)
    }
    #[inline]
    pub unsafe fn getLimitRelaxationFactor(&self) -> btScalar {
        btHingeConstraint_getLimitRelaxationFactor(self)
    }
    #[inline]
    pub unsafe fn setAxis(&mut self, axisInA: *mut btVector3) {
        btHingeConstraint_setAxis(self, axisInA)
    }
    #[inline]
    pub unsafe fn hasLimit(&self) -> bool {
        btHingeConstraint_hasLimit(self)
    }
    #[inline]
    pub unsafe fn getLowerLimit(&self) -> btScalar {
        btHingeConstraint_getLowerLimit(self)
    }
    #[inline]
    pub unsafe fn getUpperLimit(&self) -> btScalar {
        btHingeConstraint_getUpperLimit(self)
    }
    #[inline]
    pub unsafe fn getHingeAngle(&mut self) -> btScalar {
        btHingeConstraint_getHingeAngle(self)
    }
    #[inline]
    pub unsafe fn getHingeAngle1(
        &mut self,
        transA: *const btTransform,
        transB: *const btTransform,
    ) -> btScalar {
        btHingeConstraint_getHingeAngle1(self, transA, transB)
    }
    #[inline]
    pub unsafe fn testLimit(&mut self, transA: *const btTransform, transB: *const btTransform) {
        btHingeConstraint_testLimit(self, transA, transB)
    }
    #[inline]
    pub unsafe fn getAFrame(&self) -> *const btTransform {
        btHingeConstraint_getAFrame(self)
    }
    #[inline]
    pub unsafe fn getBFrame(&self) -> *const btTransform {
        btHingeConstraint_getBFrame(self)
    }
    #[inline]
    pub unsafe fn getAFrame1(&mut self) -> *mut btTransform {
        btHingeConstraint_getAFrame1(self)
    }
    #[inline]
    pub unsafe fn getBFrame1(&mut self) -> *mut btTransform {
        btHingeConstraint_getBFrame1(self)
    }
    #[inline]
    pub unsafe fn getSolveLimit(&mut self) -> ::std::os::raw::c_int {
        btHingeConstraint_getSolveLimit(self)
    }
    #[inline]
    pub unsafe fn getLimitSign(&mut self) -> btScalar {
        btHingeConstraint_getLimitSign(self)
    }
    #[inline]
    pub unsafe fn getAngularOnly(&mut self) -> bool {
        btHingeConstraint_getAngularOnly(self)
    }
    #[inline]
    pub unsafe fn getEnableAngularMotor(&mut self) -> bool {
        btHingeConstraint_getEnableAngularMotor(self)
    }
    #[inline]
    pub unsafe fn getMotorTargetVelocity(&mut self) -> btScalar {
        btHingeConstraint_getMotorTargetVelocity(self)
    }
    #[inline]
    pub unsafe fn getMaxMotorImpulse(&mut self) -> btScalar {
        btHingeConstraint_getMaxMotorImpulse(self)
    }
    #[inline]
    pub unsafe fn getUseFrameOffset(&mut self) -> bool {
        btHingeConstraint_getUseFrameOffset(self)
    }
    #[inline]
    pub unsafe fn setUseFrameOffset(&mut self, frameOffsetOnOff: bool) {
        btHingeConstraint_setUseFrameOffset(self, frameOffsetOnOff)
    }
    #[inline]
    pub unsafe fn getUseReferenceFrameA(&self) -> bool {
        btHingeConstraint_getUseReferenceFrameA(self)
    }
    #[inline]
    pub unsafe fn setUseReferenceFrameA(&mut self, useReferenceFrameA: bool) {
        btHingeConstraint_setUseReferenceFrameA(self, useReferenceFrameA)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        axisInA: *const btVector3,
        axisInB: *const btVector3,
        useReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHingeConstraint_btHingeConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            pivotInA,
            pivotInB,
            axisInA,
            axisInB,
            useReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        rbA: *mut btRigidBody,
        pivotInA: *const btVector3,
        axisInA: *const btVector3,
        useReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHingeConstraint_btHingeConstraint1(
            &mut __bindgen_tmp,
            rbA,
            pivotInA,
            axisInA,
            useReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        rbAFrame: *const btTransform,
        rbBFrame: *const btTransform,
        useReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHingeConstraint_btHingeConstraint2(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            rbAFrame,
            rbBFrame,
            useReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(
        rbA: *mut btRigidBody,
        rbAFrame: *const btTransform,
        useReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHingeConstraint_btHingeConstraint3(&mut __bindgen_tmp, rbA, rbAFrame, useReferenceFrameA);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint13buildJacobianEv"]
    pub fn btHingeConstraint_buildJacobian(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
    pub fn btHingeConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btHingeConstraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
    pub fn btHingeConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {

    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.

    #[link_name = "\u{1}_ZN17btHingeConstraint8setParamEidi"]
    pub fn btHingeConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: btScalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// return the local value of parameter

    #[link_name = "\u{1}_ZNK17btHingeConstraint8getParamEii"]
    pub fn btHingeConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btHingeConstraint8getFlagsEv"]
    pub fn btHingeConstraint_getFlags(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK17btHingeConstraint28calculateSerializeBufferSizeEv"]
    pub fn btHingeConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK17btHingeConstraint9serializeEPvP12btSerializer"]
    pub fn btHingeConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// this structure is not used, except for loading pre-2.82 .bullet files
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHingeConstraintDoubleData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_rbAFrame: btTransformDoubleData,
    pub m_rbBFrame: btTransformDoubleData,
    pub m_useReferenceFrameA: ::std::os::raw::c_int,
    pub m_angularOnly: ::std::os::raw::c_int,
    pub m_enableAngularMotor: ::std::os::raw::c_int,
    pub m_motorTargetVelocity: f32,
    pub m_maxMotorImpulse: f32,
    pub m_lowerLimit: f32,
    pub m_upperLimit: f32,
    pub m_limitSoftness: f32,
    pub m_biasFactor: f32,
    pub m_relaxationFactor: f32,
}
#[test]
fn bindgen_test_layout_btHingeConstraintDoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btHingeConstraintDoubleData>(),
        360usize,
        concat!("Size of: ", stringify!(btHingeConstraintDoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btHingeConstraintDoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btHingeConstraintDoubleData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData)).m_typeConstraintData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintDoubleData)).m_rbAFrame as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData),
            "::",
            stringify!(m_rbAFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintDoubleData)).m_rbBFrame as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData),
            "::",
            stringify!(m_rbBFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData)).m_useReferenceFrameA as *const _ as usize
        },
        320usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData),
            "::",
            stringify!(m_useReferenceFrameA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintDoubleData)).m_angularOnly as *const _ as usize },
        324usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData),
            "::",
            stringify!(m_angularOnly)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData)).m_enableAngularMotor as *const _ as usize
        },
        328usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData),
            "::",
            stringify!(m_enableAngularMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData)).m_motorTargetVelocity as *const _ as usize
        },
        332usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData),
            "::",
            stringify!(m_motorTargetVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData)).m_maxMotorImpulse as *const _ as usize
        },
        336usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData),
            "::",
            stringify!(m_maxMotorImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintDoubleData)).m_lowerLimit as *const _ as usize },
        340usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData),
            "::",
            stringify!(m_lowerLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintDoubleData)).m_upperLimit as *const _ as usize },
        344usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData),
            "::",
            stringify!(m_upperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData)).m_limitSoftness as *const _ as usize
        },
        348usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData),
            "::",
            stringify!(m_limitSoftness)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintDoubleData)).m_biasFactor as *const _ as usize },
        352usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData),
            "::",
            stringify!(m_biasFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData)).m_relaxationFactor as *const _ as usize
        },
        356usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData),
            "::",
            stringify!(m_relaxationFactor)
        )
    );
}
/// The getAccumulatedHingeAngle returns the accumulated hinge angle, taking rotation across the -PI/PI boundary into account
#[repr(C)]
pub struct btHingeAccumulatedAngleConstraint {
    pub _base: btHingeConstraint,
    pub m_accumulatedAngle: btScalar,
}
#[test]
fn bindgen_test_layout_btHingeAccumulatedAngleConstraint() {
    assert_eq!(
        ::std::mem::size_of::<btHingeAccumulatedAngleConstraint>(),
        1520usize,
        concat!("Size of: ", stringify!(btHingeAccumulatedAngleConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<btHingeAccumulatedAngleConstraint>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btHingeAccumulatedAngleConstraint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeAccumulatedAngleConstraint)).m_accumulatedAngle as *const _
                as usize
        },
        1512usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeAccumulatedAngleConstraint),
            "::",
            stringify!(m_accumulatedAngle)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN33btHingeAccumulatedAngleConstraint24getAccumulatedHingeAngleEv"]
    pub fn btHingeAccumulatedAngleConstraint_getAccumulatedHingeAngle(
        this: *mut btHingeAccumulatedAngleConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN33btHingeAccumulatedAngleConstraint24setAccumulatedHingeAngleEd"]
    pub fn btHingeAccumulatedAngleConstraint_setAccumulatedHingeAngle(
        this: *mut btHingeAccumulatedAngleConstraint,
        accAngle: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN33btHingeAccumulatedAngleConstraintC1ER11btRigidBodyS1_RK9btVector3S4_S4_S4_b"]
    pub fn btHingeAccumulatedAngleConstraint_btHingeAccumulatedAngleConstraint(
        this: *mut btHingeAccumulatedAngleConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        axisInA: *const btVector3,
        axisInB: *const btVector3,
        useReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN33btHingeAccumulatedAngleConstraintC1ER11btRigidBodyRK9btVector3S4_b"]
    pub fn btHingeAccumulatedAngleConstraint_btHingeAccumulatedAngleConstraint1(
        this: *mut btHingeAccumulatedAngleConstraint,
        rbA: *mut btRigidBody,
        pivotInA: *const btVector3,
        axisInA: *const btVector3,
        useReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN33btHingeAccumulatedAngleConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b"]
    pub fn btHingeAccumulatedAngleConstraint_btHingeAccumulatedAngleConstraint2(
        this: *mut btHingeAccumulatedAngleConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        rbAFrame: *const btTransform,
        rbBFrame: *const btTransform,
        useReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN33btHingeAccumulatedAngleConstraintC1ER11btRigidBodyRK11btTransformb"]
    pub fn btHingeAccumulatedAngleConstraint_btHingeAccumulatedAngleConstraint3(
        this: *mut btHingeAccumulatedAngleConstraint,
        rbA: *mut btRigidBody,
        rbAFrame: *const btTransform,
        useReferenceFrameA: bool,
    );
}
impl btHingeAccumulatedAngleConstraint {
    #[inline]
    pub unsafe fn getAccumulatedHingeAngle(&mut self) -> btScalar {
        btHingeAccumulatedAngleConstraint_getAccumulatedHingeAngle(self)
    }
    #[inline]
    pub unsafe fn setAccumulatedHingeAngle(&mut self, accAngle: btScalar) {
        btHingeAccumulatedAngleConstraint_setAccumulatedHingeAngle(self, accAngle)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        pivotInA: *const btVector3,
        pivotInB: *const btVector3,
        axisInA: *const btVector3,
        axisInB: *const btVector3,
        useReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHingeAccumulatedAngleConstraint_btHingeAccumulatedAngleConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            pivotInA,
            pivotInB,
            axisInA,
            axisInB,
            useReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        rbA: *mut btRigidBody,
        pivotInA: *const btVector3,
        axisInA: *const btVector3,
        useReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHingeAccumulatedAngleConstraint_btHingeAccumulatedAngleConstraint1(
            &mut __bindgen_tmp,
            rbA,
            pivotInA,
            axisInA,
            useReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        rbAFrame: *const btTransform,
        rbBFrame: *const btTransform,
        useReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHingeAccumulatedAngleConstraint_btHingeAccumulatedAngleConstraint2(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            rbAFrame,
            rbBFrame,
            useReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new3(
        rbA: *mut btRigidBody,
        rbAFrame: *const btTransform,
        useReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHingeAccumulatedAngleConstraint_btHingeAccumulatedAngleConstraint3(
            &mut __bindgen_tmp,
            rbA,
            rbAFrame,
            useReferenceFrameA,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN33btHingeAccumulatedAngleConstraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
    pub fn btHingeAccumulatedAngleConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHingeConstraintFloatData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_rbAFrame: btTransformFloatData,
    pub m_rbBFrame: btTransformFloatData,
    pub m_useReferenceFrameA: ::std::os::raw::c_int,
    pub m_angularOnly: ::std::os::raw::c_int,
    pub m_enableAngularMotor: ::std::os::raw::c_int,
    pub m_motorTargetVelocity: f32,
    pub m_maxMotorImpulse: f32,
    pub m_lowerLimit: f32,
    pub m_upperLimit: f32,
    pub m_limitSoftness: f32,
    pub m_biasFactor: f32,
    pub m_relaxationFactor: f32,
}
#[test]
fn bindgen_test_layout_btHingeConstraintFloatData() {
    assert_eq!(
        ::std::mem::size_of::<btHingeConstraintFloatData>(),
        232usize,
        concat!("Size of: ", stringify!(btHingeConstraintFloatData))
    );
    assert_eq!(
        ::std::mem::align_of::<btHingeConstraintFloatData>(),
        8usize,
        concat!("Alignment of ", stringify!(btHingeConstraintFloatData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintFloatData)).m_typeConstraintData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintFloatData),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintFloatData)).m_rbAFrame as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintFloatData),
            "::",
            stringify!(m_rbAFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintFloatData)).m_rbBFrame as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintFloatData),
            "::",
            stringify!(m_rbBFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintFloatData)).m_useReferenceFrameA as *const _ as usize
        },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintFloatData),
            "::",
            stringify!(m_useReferenceFrameA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintFloatData)).m_angularOnly as *const _ as usize },
        196usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintFloatData),
            "::",
            stringify!(m_angularOnly)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintFloatData)).m_enableAngularMotor as *const _ as usize
        },
        200usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintFloatData),
            "::",
            stringify!(m_enableAngularMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintFloatData)).m_motorTargetVelocity as *const _ as usize
        },
        204usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintFloatData),
            "::",
            stringify!(m_motorTargetVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintFloatData)).m_maxMotorImpulse as *const _ as usize
        },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintFloatData),
            "::",
            stringify!(m_maxMotorImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintFloatData)).m_lowerLimit as *const _ as usize },
        212usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintFloatData),
            "::",
            stringify!(m_lowerLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintFloatData)).m_upperLimit as *const _ as usize },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintFloatData),
            "::",
            stringify!(m_upperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintFloatData)).m_limitSoftness as *const _ as usize
        },
        220usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintFloatData),
            "::",
            stringify!(m_limitSoftness)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintFloatData)).m_biasFactor as *const _ as usize },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintFloatData),
            "::",
            stringify!(m_biasFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintFloatData)).m_relaxationFactor as *const _ as usize
        },
        228usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintFloatData),
            "::",
            stringify!(m_relaxationFactor)
        )
    );
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btHingeConstraintDoubleData2 {
    pub m_typeConstraintData: btTypedConstraintDoubleData,
    pub m_rbAFrame: btTransformDoubleData,
    pub m_rbBFrame: btTransformDoubleData,
    pub m_useReferenceFrameA: ::std::os::raw::c_int,
    pub m_angularOnly: ::std::os::raw::c_int,
    pub m_enableAngularMotor: ::std::os::raw::c_int,
    pub m_motorTargetVelocity: f64,
    pub m_maxMotorImpulse: f64,
    pub m_lowerLimit: f64,
    pub m_upperLimit: f64,
    pub m_limitSoftness: f64,
    pub m_biasFactor: f64,
    pub m_relaxationFactor: f64,
    pub m_padding1: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btHingeConstraintDoubleData2() {
    assert_eq!(
        ::std::mem::size_of::<btHingeConstraintDoubleData2>(),
        416usize,
        concat!("Size of: ", stringify!(btHingeConstraintDoubleData2))
    );
    assert_eq!(
        ::std::mem::align_of::<btHingeConstraintDoubleData2>(),
        8usize,
        concat!("Alignment of ", stringify!(btHingeConstraintDoubleData2))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData2)).m_typeConstraintData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData2),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintDoubleData2)).m_rbAFrame as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData2),
            "::",
            stringify!(m_rbAFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintDoubleData2)).m_rbBFrame as *const _ as usize },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData2),
            "::",
            stringify!(m_rbBFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData2)).m_useReferenceFrameA as *const _ as usize
        },
        336usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData2),
            "::",
            stringify!(m_useReferenceFrameA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData2)).m_angularOnly as *const _ as usize
        },
        340usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData2),
            "::",
            stringify!(m_angularOnly)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData2)).m_enableAngularMotor as *const _ as usize
        },
        344usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData2),
            "::",
            stringify!(m_enableAngularMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData2)).m_motorTargetVelocity as *const _
                as usize
        },
        352usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData2),
            "::",
            stringify!(m_motorTargetVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData2)).m_maxMotorImpulse as *const _ as usize
        },
        360usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData2),
            "::",
            stringify!(m_maxMotorImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintDoubleData2)).m_lowerLimit as *const _ as usize },
        368usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData2),
            "::",
            stringify!(m_lowerLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintDoubleData2)).m_upperLimit as *const _ as usize },
        376usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData2),
            "::",
            stringify!(m_upperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData2)).m_limitSoftness as *const _ as usize
        },
        384usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData2),
            "::",
            stringify!(m_limitSoftness)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintDoubleData2)).m_biasFactor as *const _ as usize },
        392usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData2),
            "::",
            stringify!(m_biasFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btHingeConstraintDoubleData2)).m_relaxationFactor as *const _ as usize
        },
        400usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData2),
            "::",
            stringify!(m_relaxationFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHingeConstraintDoubleData2)).m_padding1 as *const _ as usize },
        408usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHingeConstraintDoubleData2),
            "::",
            stringify!(m_padding1)
        )
    );
}
pub const btConeTwistFlags_BT_CONETWIST_FLAGS_LIN_CFM: btConeTwistFlags = 1;
pub const btConeTwistFlags_BT_CONETWIST_FLAGS_LIN_ERP: btConeTwistFlags = 2;
pub const btConeTwistFlags_BT_CONETWIST_FLAGS_ANG_CFM: btConeTwistFlags = 4;
pub type btConeTwistFlags = ::std::os::raw::c_uint;
/// btConeTwistConstraint can be used to simulate ragdoll joints (upper arm, leg etc)
#[repr(C)]
pub struct btConeTwistConstraint {
    pub _base: btTypedConstraint,
    pub m_jac: [btJacobianEntry; 3usize],
    pub m_rbAFrame: btTransform,
    pub m_rbBFrame: btTransform,
    pub m_limitSoftness: btScalar,
    pub m_biasFactor: btScalar,
    pub m_relaxationFactor: btScalar,
    pub m_damping: btScalar,
    pub m_swingSpan1: btScalar,
    pub m_swingSpan2: btScalar,
    pub m_twistSpan: btScalar,
    pub m_fixThresh: btScalar,
    pub m_swingAxis: btVector3,
    pub m_twistAxis: btVector3,
    pub m_kSwing: btScalar,
    pub m_kTwist: btScalar,
    pub m_twistLimitSign: btScalar,
    pub m_swingCorrection: btScalar,
    pub m_twistCorrection: btScalar,
    pub m_twistAngle: btScalar,
    pub m_accSwingLimitImpulse: btScalar,
    pub m_accTwistLimitImpulse: btScalar,
    pub m_angularOnly: bool,
    pub m_solveTwistLimit: bool,
    pub m_solveSwingLimit: bool,
    pub m_useSolveConstraintObsolete: bool,
    pub m_swingLimitRatio: btScalar,
    pub m_twistLimitRatio: btScalar,
    pub m_twistAxisA: btVector3,
    pub m_bMotorEnabled: bool,
    pub m_bNormalizedMotorStrength: bool,
    pub m_qTarget: btQuaternion,
    pub m_maxMotorImpulse: btScalar,
    pub m_accMotorImpulse: btVector3,
    pub m_flags: ::std::os::raw::c_int,
    pub m_linCFM: btScalar,
    pub m_linERP: btScalar,
    pub m_angCFM: btScalar,
}
#[test]
fn bindgen_test_layout_btConeTwistConstraint() {
    assert_eq!(
        ::std::mem::size_of::<btConeTwistConstraint>(),
        1200usize,
        concat!("Size of: ", stringify!(btConeTwistConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<btConeTwistConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(btConeTwistConstraint))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_jac as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_jac)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_rbAFrame as *const _ as usize },
        584usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_rbAFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_rbBFrame as *const _ as usize },
        712usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_rbBFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_limitSoftness as *const _ as usize },
        840usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_limitSoftness)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_biasFactor as *const _ as usize },
        848usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_biasFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_relaxationFactor as *const _ as usize },
        856usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_relaxationFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_damping as *const _ as usize },
        864usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_damping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_swingSpan1 as *const _ as usize },
        872usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_swingSpan1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_swingSpan2 as *const _ as usize },
        880usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_swingSpan2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_twistSpan as *const _ as usize },
        888usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_twistSpan)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_fixThresh as *const _ as usize },
        896usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_fixThresh)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_swingAxis as *const _ as usize },
        904usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_swingAxis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_twistAxis as *const _ as usize },
        936usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_twistAxis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_kSwing as *const _ as usize },
        968usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_kSwing)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_kTwist as *const _ as usize },
        976usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_kTwist)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_twistLimitSign as *const _ as usize },
        984usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_twistLimitSign)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_swingCorrection as *const _ as usize },
        992usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_swingCorrection)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_twistCorrection as *const _ as usize },
        1000usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_twistCorrection)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_twistAngle as *const _ as usize },
        1008usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_twistAngle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraint)).m_accSwingLimitImpulse as *const _ as usize
        },
        1016usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_accSwingLimitImpulse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraint)).m_accTwistLimitImpulse as *const _ as usize
        },
        1024usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_accTwistLimitImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_angularOnly as *const _ as usize },
        1032usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_angularOnly)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_solveTwistLimit as *const _ as usize },
        1033usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_solveTwistLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_solveSwingLimit as *const _ as usize },
        1034usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_solveSwingLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraint)).m_useSolveConstraintObsolete as *const _
                as usize
        },
        1035usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_useSolveConstraintObsolete)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_swingLimitRatio as *const _ as usize },
        1040usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_swingLimitRatio)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_twistLimitRatio as *const _ as usize },
        1048usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_twistLimitRatio)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_twistAxisA as *const _ as usize },
        1056usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_twistAxisA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_bMotorEnabled as *const _ as usize },
        1088usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_bMotorEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraint)).m_bNormalizedMotorStrength as *const _ as usize
        },
        1089usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_bNormalizedMotorStrength)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_qTarget as *const _ as usize },
        1096usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_qTarget)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_maxMotorImpulse as *const _ as usize },
        1128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_maxMotorImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_accMotorImpulse as *const _ as usize },
        1136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_accMotorImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_flags as *const _ as usize },
        1168usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_linCFM as *const _ as usize },
        1176usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_linCFM)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_linERP as *const _ as usize },
        1184usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_linERP)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraint)).m_angCFM as *const _ as usize },
        1192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraint),
            "::",
            stringify!(m_angCFM)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint4initEv"]
    pub fn btConeTwistConstraint_init(this: *mut btConeTwistConstraint);
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint20computeConeLimitInfoERK12btQuaternionRdR9btVector3S3_"]
    pub fn btConeTwistConstraint_computeConeLimitInfo(
        this: *mut btConeTwistConstraint,
        qCone: *const btQuaternion,
        swingAngle: *mut btScalar,
        vSwingAxis: *mut btVector3,
        swingLimit: *mut btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint21computeTwistLimitInfoERK12btQuaternionRdR9btVector3"]
    pub fn btConeTwistConstraint_computeTwistLimitInfo(
        this: *mut btConeTwistConstraint,
        qTwist: *const btQuaternion,
        twistAngle: *mut btScalar,
        vTwistAxis: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint33adjustSwingAxisToUseEllipseNormalER9btVector3"]
    pub fn btConeTwistConstraint_adjustSwingAxisToUseEllipseNormal(
        this: *const btConeTwistConstraint,
        vSwingAxis: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint18getInfo1NonVirtualEPN17btTypedConstraint17btConstraintInfo1E"]
    pub fn btConeTwistConstraint_getInfo1NonVirtual(
        this: *mut btConeTwistConstraint,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint18getInfo2NonVirtualEPN17btTypedConstraint17btConstraintInfo2ERK11btTransformS5_RK11btMatrix3x3S8_"]
    pub fn btConeTwistConstraint_getInfo2NonVirtual(
        this: *mut btConeTwistConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        invInertiaWorldA: *const btMatrix3x3,
        invInertiaWorldB: *const btMatrix3x3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint9updateRHSEd"]
    pub fn btConeTwistConstraint_updateRHS(this: *mut btConeTwistConstraint, timeStep: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint13getRigidBodyAEv"]
    pub fn btConeTwistConstraint_getRigidBodyA(
        this: *const btConeTwistConstraint,
    ) -> *const btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint13getRigidBodyBEv"]
    pub fn btConeTwistConstraint_getRigidBodyB(
        this: *const btConeTwistConstraint,
    ) -> *const btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint14setAngularOnlyEb"]
    pub fn btConeTwistConstraint_setAngularOnly(
        this: *mut btConeTwistConstraint,
        angularOnly: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint14getAngularOnlyEv"]
    pub fn btConeTwistConstraint_getAngularOnly(this: *const btConeTwistConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint8setLimitEid"]
    pub fn btConeTwistConstraint_setLimit(
        this: *mut btConeTwistConstraint,
        limitIndex: ::std::os::raw::c_int,
        limitValue: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint8getLimitEi"]
    pub fn btConeTwistConstraint_getLimit(
        this: *const btConeTwistConstraint,
        limitIndex: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint8setLimitEdddddd"]
    pub fn btConeTwistConstraint_setLimit1(
        this: *mut btConeTwistConstraint,
        _swingSpan1: btScalar,
        _swingSpan2: btScalar,
        _twistSpan: btScalar,
        _softness: btScalar,
        _biasFactor: btScalar,
        _relaxationFactor: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint9getAFrameEv"]
    pub fn btConeTwistConstraint_getAFrame(
        this: *const btConeTwistConstraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint9getBFrameEv"]
    pub fn btConeTwistConstraint_getBFrame(
        this: *const btConeTwistConstraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint18getSolveTwistLimitEv"]
    pub fn btConeTwistConstraint_getSolveTwistLimit(
        this: *mut btConeTwistConstraint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint18getSolveSwingLimitEv"]
    pub fn btConeTwistConstraint_getSolveSwingLimit(
        this: *mut btConeTwistConstraint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint17getTwistLimitSignEv"]
    pub fn btConeTwistConstraint_getTwistLimitSign(this: *mut btConeTwistConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint13calcAngleInfoEv"]
    pub fn btConeTwistConstraint_calcAngleInfo(this: *mut btConeTwistConstraint);
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint14calcAngleInfo2ERK11btTransformS2_RK11btMatrix3x3S5_"]
    pub fn btConeTwistConstraint_calcAngleInfo2(
        this: *mut btConeTwistConstraint,
        transA: *const btTransform,
        transB: *const btTransform,
        invInertiaWorldA: *const btMatrix3x3,
        invInertiaWorldB: *const btMatrix3x3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint13getSwingSpan1Ev"]
    pub fn btConeTwistConstraint_getSwingSpan1(this: *const btConeTwistConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint13getSwingSpan2Ev"]
    pub fn btConeTwistConstraint_getSwingSpan2(this: *const btConeTwistConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint12getTwistSpanEv"]
    pub fn btConeTwistConstraint_getTwistSpan(this: *const btConeTwistConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint16getLimitSoftnessEv"]
    pub fn btConeTwistConstraint_getLimitSoftness(this: *const btConeTwistConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint13getBiasFactorEv"]
    pub fn btConeTwistConstraint_getBiasFactor(this: *const btConeTwistConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint19getRelaxationFactorEv"]
    pub fn btConeTwistConstraint_getRelaxationFactor(
        this: *const btConeTwistConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint13getTwistAngleEv"]
    pub fn btConeTwistConstraint_getTwistAngle(this: *const btConeTwistConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint16isPastSwingLimitEv"]
    pub fn btConeTwistConstraint_isPastSwingLimit(this: *mut btConeTwistConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint10getDampingEv"]
    pub fn btConeTwistConstraint_getDamping(this: *const btConeTwistConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint10setDampingEd"]
    pub fn btConeTwistConstraint_setDamping(this: *mut btConeTwistConstraint, damping: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint11enableMotorEb"]
    pub fn btConeTwistConstraint_enableMotor(this: *mut btConeTwistConstraint, b: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint14isMotorEnabledEv"]
    pub fn btConeTwistConstraint_isMotorEnabled(this: *const btConeTwistConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint18getMaxMotorImpulseEv"]
    pub fn btConeTwistConstraint_getMaxMotorImpulse(this: *const btConeTwistConstraint)
        -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint27isMaxMotorImpulseNormalizedEv"]
    pub fn btConeTwistConstraint_isMaxMotorImpulseNormalized(
        this: *const btConeTwistConstraint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint18setMaxMotorImpulseEd"]
    pub fn btConeTwistConstraint_setMaxMotorImpulse(
        this: *mut btConeTwistConstraint,
        maxMotorImpulse: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint28setMaxMotorImpulseNormalizedEd"]
    pub fn btConeTwistConstraint_setMaxMotorImpulseNormalized(
        this: *mut btConeTwistConstraint,
        maxMotorImpulse: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint12getFixThreshEv"]
    pub fn btConeTwistConstraint_getFixThresh(this: *mut btConeTwistConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint12setFixThreshEd"]
    pub fn btConeTwistConstraint_setFixThresh(
        this: *mut btConeTwistConstraint,
        fixThresh: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint14setMotorTargetERK12btQuaternion"]
    pub fn btConeTwistConstraint_setMotorTarget(
        this: *mut btConeTwistConstraint,
        q: *const btQuaternion,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint14getMotorTargetEv"]
    pub fn btConeTwistConstraint_getMotorTarget(
        this: *const btConeTwistConstraint,
    ) -> *const btQuaternion;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint31setMotorTargetInConstraintSpaceERK12btQuaternion"]
    pub fn btConeTwistConstraint_setMotorTargetInConstraintSpace(
        this: *mut btConeTwistConstraint,
        q: *const btQuaternion,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint16GetPointForAngleEdd"]
    pub fn btConeTwistConstraint_GetPointForAngle(
        this: *const btConeTwistConstraint,
        fAngleInRadians: btScalar,
        fLength: btScalar,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint15getFrameOffsetAEv"]
    pub fn btConeTwistConstraint_getFrameOffsetA(
        this: *const btConeTwistConstraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint15getFrameOffsetBEv"]
    pub fn btConeTwistConstraint_getFrameOffsetB(
        this: *const btConeTwistConstraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint8getFlagsEv"]
    pub fn btConeTwistConstraint_getFlags(
        this: *const btConeTwistConstraint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraintC1ER11btRigidBodyS1_RK11btTransformS4_"]
    pub fn btConeTwistConstraint_btConeTwistConstraint(
        this: *mut btConeTwistConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        rbAFrame: *const btTransform,
        rbBFrame: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraintC1ER11btRigidBodyRK11btTransform"]
    pub fn btConeTwistConstraint_btConeTwistConstraint1(
        this: *mut btConeTwistConstraint,
        rbA: *mut btRigidBody,
        rbAFrame: *const btTransform,
    );
}
impl btConeTwistConstraint {
    #[inline]
    pub unsafe fn init(&mut self) {
        btConeTwistConstraint_init(self)
    }
    #[inline]
    pub unsafe fn computeConeLimitInfo(
        &mut self,
        qCone: *const btQuaternion,
        swingAngle: *mut btScalar,
        vSwingAxis: *mut btVector3,
        swingLimit: *mut btScalar,
    ) {
        btConeTwistConstraint_computeConeLimitInfo(self, qCone, swingAngle, vSwingAxis, swingLimit)
    }
    #[inline]
    pub unsafe fn computeTwistLimitInfo(
        &mut self,
        qTwist: *const btQuaternion,
        twistAngle: *mut btScalar,
        vTwistAxis: *mut btVector3,
    ) {
        btConeTwistConstraint_computeTwistLimitInfo(self, qTwist, twistAngle, vTwistAxis)
    }
    #[inline]
    pub unsafe fn adjustSwingAxisToUseEllipseNormal(&self, vSwingAxis: *mut btVector3) {
        btConeTwistConstraint_adjustSwingAxisToUseEllipseNormal(self, vSwingAxis)
    }
    #[inline]
    pub unsafe fn getInfo1NonVirtual(&mut self, info: *mut btTypedConstraint_btConstraintInfo1) {
        btConeTwistConstraint_getInfo1NonVirtual(self, info)
    }
    #[inline]
    pub unsafe fn getInfo2NonVirtual(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        invInertiaWorldA: *const btMatrix3x3,
        invInertiaWorldB: *const btMatrix3x3,
    ) {
        btConeTwistConstraint_getInfo2NonVirtual(
            self,
            info,
            transA,
            transB,
            invInertiaWorldA,
            invInertiaWorldB,
        )
    }
    #[inline]
    pub unsafe fn updateRHS(&mut self, timeStep: btScalar) {
        btConeTwistConstraint_updateRHS(self, timeStep)
    }
    #[inline]
    pub unsafe fn getRigidBodyA(&self) -> *const btRigidBody {
        btConeTwistConstraint_getRigidBodyA(self)
    }
    #[inline]
    pub unsafe fn getRigidBodyB(&self) -> *const btRigidBody {
        btConeTwistConstraint_getRigidBodyB(self)
    }
    #[inline]
    pub unsafe fn setAngularOnly(&mut self, angularOnly: bool) {
        btConeTwistConstraint_setAngularOnly(self, angularOnly)
    }
    #[inline]
    pub unsafe fn getAngularOnly(&self) -> bool {
        btConeTwistConstraint_getAngularOnly(self)
    }
    #[inline]
    pub unsafe fn setLimit(&mut self, limitIndex: ::std::os::raw::c_int, limitValue: btScalar) {
        btConeTwistConstraint_setLimit(self, limitIndex, limitValue)
    }
    #[inline]
    pub unsafe fn getLimit(&self, limitIndex: ::std::os::raw::c_int) -> btScalar {
        btConeTwistConstraint_getLimit(self, limitIndex)
    }
    #[inline]
    pub unsafe fn setLimit1(
        &mut self,
        _swingSpan1: btScalar,
        _swingSpan2: btScalar,
        _twistSpan: btScalar,
        _softness: btScalar,
        _biasFactor: btScalar,
        _relaxationFactor: btScalar,
    ) {
        btConeTwistConstraint_setLimit1(
            self,
            _swingSpan1,
            _swingSpan2,
            _twistSpan,
            _softness,
            _biasFactor,
            _relaxationFactor,
        )
    }
    #[inline]
    pub unsafe fn getAFrame(&self) -> *const btTransform {
        btConeTwistConstraint_getAFrame(self)
    }
    #[inline]
    pub unsafe fn getBFrame(&self) -> *const btTransform {
        btConeTwistConstraint_getBFrame(self)
    }
    #[inline]
    pub unsafe fn getSolveTwistLimit(&mut self) -> ::std::os::raw::c_int {
        btConeTwistConstraint_getSolveTwistLimit(self)
    }
    #[inline]
    pub unsafe fn getSolveSwingLimit(&mut self) -> ::std::os::raw::c_int {
        btConeTwistConstraint_getSolveSwingLimit(self)
    }
    #[inline]
    pub unsafe fn getTwistLimitSign(&mut self) -> btScalar {
        btConeTwistConstraint_getTwistLimitSign(self)
    }
    #[inline]
    pub unsafe fn calcAngleInfo(&mut self) {
        btConeTwistConstraint_calcAngleInfo(self)
    }
    #[inline]
    pub unsafe fn calcAngleInfo2(
        &mut self,
        transA: *const btTransform,
        transB: *const btTransform,
        invInertiaWorldA: *const btMatrix3x3,
        invInertiaWorldB: *const btMatrix3x3,
    ) {
        btConeTwistConstraint_calcAngleInfo2(
            self,
            transA,
            transB,
            invInertiaWorldA,
            invInertiaWorldB,
        )
    }
    #[inline]
    pub unsafe fn getSwingSpan1(&self) -> btScalar {
        btConeTwistConstraint_getSwingSpan1(self)
    }
    #[inline]
    pub unsafe fn getSwingSpan2(&self) -> btScalar {
        btConeTwistConstraint_getSwingSpan2(self)
    }
    #[inline]
    pub unsafe fn getTwistSpan(&self) -> btScalar {
        btConeTwistConstraint_getTwistSpan(self)
    }
    #[inline]
    pub unsafe fn getLimitSoftness(&self) -> btScalar {
        btConeTwistConstraint_getLimitSoftness(self)
    }
    #[inline]
    pub unsafe fn getBiasFactor(&self) -> btScalar {
        btConeTwistConstraint_getBiasFactor(self)
    }
    #[inline]
    pub unsafe fn getRelaxationFactor(&self) -> btScalar {
        btConeTwistConstraint_getRelaxationFactor(self)
    }
    #[inline]
    pub unsafe fn getTwistAngle(&self) -> btScalar {
        btConeTwistConstraint_getTwistAngle(self)
    }
    #[inline]
    pub unsafe fn isPastSwingLimit(&mut self) -> bool {
        btConeTwistConstraint_isPastSwingLimit(self)
    }
    #[inline]
    pub unsafe fn getDamping(&self) -> btScalar {
        btConeTwistConstraint_getDamping(self)
    }
    #[inline]
    pub unsafe fn setDamping(&mut self, damping: btScalar) {
        btConeTwistConstraint_setDamping(self, damping)
    }
    #[inline]
    pub unsafe fn enableMotor(&mut self, b: bool) {
        btConeTwistConstraint_enableMotor(self, b)
    }
    #[inline]
    pub unsafe fn isMotorEnabled(&self) -> bool {
        btConeTwistConstraint_isMotorEnabled(self)
    }
    #[inline]
    pub unsafe fn getMaxMotorImpulse(&self) -> btScalar {
        btConeTwistConstraint_getMaxMotorImpulse(self)
    }
    #[inline]
    pub unsafe fn isMaxMotorImpulseNormalized(&self) -> bool {
        btConeTwistConstraint_isMaxMotorImpulseNormalized(self)
    }
    #[inline]
    pub unsafe fn setMaxMotorImpulse(&mut self, maxMotorImpulse: btScalar) {
        btConeTwistConstraint_setMaxMotorImpulse(self, maxMotorImpulse)
    }
    #[inline]
    pub unsafe fn setMaxMotorImpulseNormalized(&mut self, maxMotorImpulse: btScalar) {
        btConeTwistConstraint_setMaxMotorImpulseNormalized(self, maxMotorImpulse)
    }
    #[inline]
    pub unsafe fn getFixThresh(&mut self) -> btScalar {
        btConeTwistConstraint_getFixThresh(self)
    }
    #[inline]
    pub unsafe fn setFixThresh(&mut self, fixThresh: btScalar) {
        btConeTwistConstraint_setFixThresh(self, fixThresh)
    }
    #[inline]
    pub unsafe fn setMotorTarget(&mut self, q: *const btQuaternion) {
        btConeTwistConstraint_setMotorTarget(self, q)
    }
    #[inline]
    pub unsafe fn getMotorTarget(&self) -> *const btQuaternion {
        btConeTwistConstraint_getMotorTarget(self)
    }
    #[inline]
    pub unsafe fn setMotorTargetInConstraintSpace(&mut self, q: *const btQuaternion) {
        btConeTwistConstraint_setMotorTargetInConstraintSpace(self, q)
    }
    #[inline]
    pub unsafe fn GetPointForAngle(
        &self,
        fAngleInRadians: btScalar,
        fLength: btScalar,
    ) -> btVector3 {
        btConeTwistConstraint_GetPointForAngle(self, fAngleInRadians, fLength)
    }
    #[inline]
    pub unsafe fn getFrameOffsetA(&self) -> *const btTransform {
        btConeTwistConstraint_getFrameOffsetA(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetB(&self) -> *const btTransform {
        btConeTwistConstraint_getFrameOffsetB(self)
    }
    #[inline]
    pub unsafe fn getFlags(&self) -> ::std::os::raw::c_int {
        btConeTwistConstraint_getFlags(self)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        rbAFrame: *const btTransform,
        rbBFrame: *const btTransform,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConeTwistConstraint_btConeTwistConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            rbAFrame,
            rbBFrame,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(rbA: *mut btRigidBody, rbAFrame: *const btTransform) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btConeTwistConstraint_btConeTwistConstraint1(&mut __bindgen_tmp, rbA, rbAFrame);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint13buildJacobianEv"]
    pub fn btConeTwistConstraint_buildJacobian(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
    pub fn btConeTwistConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
    pub fn btConeTwistConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint23solveConstraintObsoleteER12btSolverBodyS1_d"]
    pub fn btConeTwistConstraint_solveConstraintObsolete(
        this: *mut ::std::os::raw::c_void,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        timeStep: btScalar,
    );
}
extern "C" {

    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.

    #[link_name = "\u{1}_ZN21btConeTwistConstraint8setParamEidi"]
    pub fn btConeTwistConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: btScalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btConeTwistConstraint9setFramesERK11btTransformS2_"]
    pub fn btConeTwistConstraint_setFrames(
        this: *mut ::std::os::raw::c_void,
        frameA: *const btTransform,
        frameB: *const btTransform,
    );
}
extern "C" {

    /// return the local value of parameter

    #[link_name = "\u{1}_ZNK21btConeTwistConstraint8getParamEii"]
    pub fn btConeTwistConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK21btConeTwistConstraint28calculateSerializeBufferSizeEv"]
    pub fn btConeTwistConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK21btConeTwistConstraint9serializeEPvP12btSerializer"]
    pub fn btConeTwistConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConeTwistConstraintDoubleData {
    pub m_typeConstraintData: btTypedConstraintDoubleData,
    pub m_rbAFrame: btTransformDoubleData,
    pub m_rbBFrame: btTransformDoubleData,
    pub m_swingSpan1: f64,
    pub m_swingSpan2: f64,
    pub m_twistSpan: f64,
    pub m_limitSoftness: f64,
    pub m_biasFactor: f64,
    pub m_relaxationFactor: f64,
    pub m_damping: f64,
}
#[test]
fn bindgen_test_layout_btConeTwistConstraintDoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btConeTwistConstraintDoubleData>(),
        392usize,
        concat!("Size of: ", stringify!(btConeTwistConstraintDoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btConeTwistConstraintDoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btConeTwistConstraintDoubleData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraintDoubleData)).m_typeConstraintData as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintDoubleData),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraintDoubleData)).m_rbAFrame as *const _ as usize
        },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintDoubleData),
            "::",
            stringify!(m_rbAFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraintDoubleData)).m_rbBFrame as *const _ as usize
        },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintDoubleData),
            "::",
            stringify!(m_rbBFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraintDoubleData)).m_swingSpan1 as *const _ as usize
        },
        336usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintDoubleData),
            "::",
            stringify!(m_swingSpan1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraintDoubleData)).m_swingSpan2 as *const _ as usize
        },
        344usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintDoubleData),
            "::",
            stringify!(m_swingSpan2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraintDoubleData)).m_twistSpan as *const _ as usize
        },
        352usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintDoubleData),
            "::",
            stringify!(m_twistSpan)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraintDoubleData)).m_limitSoftness as *const _ as usize
        },
        360usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintDoubleData),
            "::",
            stringify!(m_limitSoftness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraintDoubleData)).m_biasFactor as *const _ as usize
        },
        368usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintDoubleData),
            "::",
            stringify!(m_biasFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraintDoubleData)).m_relaxationFactor as *const _
                as usize
        },
        376usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintDoubleData),
            "::",
            stringify!(m_relaxationFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraintDoubleData)).m_damping as *const _ as usize },
        384usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintDoubleData),
            "::",
            stringify!(m_damping)
        )
    );
}
/// this structure is not used, except for loading pre-2.82 .bullet files
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btConeTwistConstraintData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_rbAFrame: btTransformFloatData,
    pub m_rbBFrame: btTransformFloatData,
    pub m_swingSpan1: f32,
    pub m_swingSpan2: f32,
    pub m_twistSpan: f32,
    pub m_limitSoftness: f32,
    pub m_biasFactor: f32,
    pub m_relaxationFactor: f32,
    pub m_damping: f32,
    pub m_pad: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btConeTwistConstraintData() {
    assert_eq!(
        ::std::mem::size_of::<btConeTwistConstraintData>(),
        224usize,
        concat!("Size of: ", stringify!(btConeTwistConstraintData))
    );
    assert_eq!(
        ::std::mem::align_of::<btConeTwistConstraintData>(),
        8usize,
        concat!("Alignment of ", stringify!(btConeTwistConstraintData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraintData)).m_typeConstraintData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintData),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraintData)).m_rbAFrame as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintData),
            "::",
            stringify!(m_rbAFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraintData)).m_rbBFrame as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintData),
            "::",
            stringify!(m_rbBFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraintData)).m_swingSpan1 as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintData),
            "::",
            stringify!(m_swingSpan1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraintData)).m_swingSpan2 as *const _ as usize },
        196usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintData),
            "::",
            stringify!(m_swingSpan2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraintData)).m_twistSpan as *const _ as usize },
        200usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintData),
            "::",
            stringify!(m_twistSpan)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraintData)).m_limitSoftness as *const _ as usize },
        204usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintData),
            "::",
            stringify!(m_limitSoftness)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraintData)).m_biasFactor as *const _ as usize },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintData),
            "::",
            stringify!(m_biasFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btConeTwistConstraintData)).m_relaxationFactor as *const _ as usize
        },
        212usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintData),
            "::",
            stringify!(m_relaxationFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraintData)).m_damping as *const _ as usize },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintData),
            "::",
            stringify!(m_damping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btConeTwistConstraintData)).m_pad as *const _ as usize },
        220usize,
        concat!(
            "Alignment of field: ",
            stringify!(btConeTwistConstraintData),
            "::",
            stringify!(m_pad)
        )
    );
}
/// ! Rotation Limit structure for generic joints
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btRotationalLimitMotor {
    /// !< joint limit
    pub m_loLimit: btScalar,
    /// !< joint limit
    pub m_hiLimit: btScalar,
    /// !< target motor velocity
    pub m_targetVelocity: btScalar,
    /// !< max force on motor
    pub m_maxMotorForce: btScalar,
    /// !< max force on limit
    pub m_maxLimitForce: btScalar,
    /// !< Damping.
    pub m_damping: btScalar,
    pub m_limitSoftness: btScalar,
    /// !< Constraint force mixing factor
    pub m_normalCFM: btScalar,
    /// !< Error tolerance factor when joint is at limit
    pub m_stopERP: btScalar,
    /// !< Constraint force mixing factor when joint is at limit
    pub m_stopCFM: btScalar,
    /// !< restitution factor
    pub m_bounce: btScalar,
    pub m_enableMotor: bool,
    /// ! temp_variables
    /// //!@{
    pub m_currentLimitError: btScalar,
    /// !  How much is violated this limit
    pub m_currentPosition: btScalar,
    /// !< 0=free, 1=at lo limit, 2=at hi limit
    pub m_currentLimit: ::std::os::raw::c_int,
    pub m_accumulatedImpulse: btScalar,
}
#[test]
fn bindgen_test_layout_btRotationalLimitMotor() {
    assert_eq!(
        ::std::mem::size_of::<btRotationalLimitMotor>(),
        128usize,
        concat!("Size of: ", stringify!(btRotationalLimitMotor))
    );
    assert_eq!(
        ::std::mem::align_of::<btRotationalLimitMotor>(),
        8usize,
        concat!("Alignment of ", stringify!(btRotationalLimitMotor))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor)).m_loLimit as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_loLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor)).m_hiLimit as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_hiLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor)).m_targetVelocity as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_targetVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor)).m_maxMotorForce as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_maxMotorForce)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor)).m_maxLimitForce as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_maxLimitForce)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor)).m_damping as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_damping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor)).m_limitSoftness as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_limitSoftness)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor)).m_normalCFM as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_normalCFM)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor)).m_stopERP as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_stopERP)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor)).m_stopCFM as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_stopCFM)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor)).m_bounce as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_bounce)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor)).m_enableMotor as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_enableMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRotationalLimitMotor)).m_currentLimitError as *const _ as usize
        },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_currentLimitError)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor)).m_currentPosition as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_currentPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor)).m_currentLimit as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_currentLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRotationalLimitMotor)).m_accumulatedImpulse as *const _ as usize
        },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor),
            "::",
            stringify!(m_accumulatedImpulse)
        )
    );
}
extern "C" {

    /// ! Is limited

    #[link_name = "\u{1}_ZNK22btRotationalLimitMotor9isLimitedEv"]
    pub fn btRotationalLimitMotor_isLimited(this: *const btRotationalLimitMotor) -> bool;
}
extern "C" {

    /// ! Need apply correction

    #[link_name = "\u{1}_ZNK22btRotationalLimitMotor16needApplyTorquesEv"]
    pub fn btRotationalLimitMotor_needApplyTorques(this: *const btRotationalLimitMotor) -> bool;
}
extern "C" {

    /// ! calculates  error
    /// /*!
    /// calculates m_currentLimit and m_currentLimitError.
    /// */

    #[link_name = "\u{1}_ZN22btRotationalLimitMotor14testLimitValueEd"]
    pub fn btRotationalLimitMotor_testLimitValue(
        this: *mut btRotationalLimitMotor,
        test_value: btScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// ! apply the correction impulses for two bodies

    #[link_name = "\u{1}_ZN22btRotationalLimitMotor18solveAngularLimitsEdR9btVector3dP11btRigidBodyS3_"]
    pub fn btRotationalLimitMotor_solveAngularLimits(
        this: *mut btRotationalLimitMotor,
        timeStep: btScalar,
        axis: *mut btVector3,
        jacDiagABInv: btScalar,
        body0: *mut btRigidBody,
        body1: *mut btRigidBody,
    ) -> btScalar;
}
extern "C" {

    /// !@}

    #[link_name = "\u{1}_ZN22btRotationalLimitMotorC1Ev"]
    pub fn btRotationalLimitMotor_btRotationalLimitMotor(this: *mut btRotationalLimitMotor);
}
extern "C" {
    #[link_name = "\u{1}_ZN22btRotationalLimitMotorC1ERKS_"]
    pub fn btRotationalLimitMotor_btRotationalLimitMotor1(
        this: *mut btRotationalLimitMotor,
        limot: *const btRotationalLimitMotor,
    );
}
impl btRotationalLimitMotor {
    #[inline]
    pub unsafe fn isLimited(&self) -> bool {
        btRotationalLimitMotor_isLimited(self)
    }
    #[inline]
    pub unsafe fn needApplyTorques(&self) -> bool {
        btRotationalLimitMotor_needApplyTorques(self)
    }
    #[inline]
    pub unsafe fn testLimitValue(&mut self, test_value: btScalar) -> ::std::os::raw::c_int {
        btRotationalLimitMotor_testLimitValue(self, test_value)
    }
    #[inline]
    pub unsafe fn solveAngularLimits(
        &mut self,
        timeStep: btScalar,
        axis: *mut btVector3,
        jacDiagABInv: btScalar,
        body0: *mut btRigidBody,
        body1: *mut btRigidBody,
    ) -> btScalar {
        btRotationalLimitMotor_solveAngularLimits(self, timeStep, axis, jacDiagABInv, body0, body1)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btRotationalLimitMotor_btRotationalLimitMotor(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(limot: *const btRotationalLimitMotor) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btRotationalLimitMotor_btRotationalLimitMotor1(&mut __bindgen_tmp, limot);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTranslationalLimitMotor {
    /// !< the constraint lower limits
    pub m_lowerLimit: btVector3,
    /// !< the constraint upper limits
    pub m_upperLimit: btVector3,
    pub m_accumulatedImpulse: btVector3,
    /// !< Softness for linear limit
    pub m_limitSoftness: btScalar,
    /// !< Damping for linear limit
    pub m_damping: btScalar,
    pub m_restitution: btScalar,
    /// !< Constraint force mixing factor
    pub m_normalCFM: btVector3,
    /// !< Error tolerance factor when joint is at limit
    pub m_stopERP: btVector3,
    /// !< Constraint force mixing factor when joint is at limit
    pub m_stopCFM: btVector3,
    /// !@}
    pub m_enableMotor: [bool; 3usize],
    /// !< target motor velocity
    pub m_targetVelocity: btVector3,
    /// !< max force on motor
    pub m_maxMotorForce: btVector3,
    pub m_currentLimitError: btVector3,
    /// !  How much is violated this limit
    pub m_currentLinearDiff: btVector3,
    /// !< 0=free, 1=at lower limit, 2=at upper limit
    pub m_currentLimit: [::std::os::raw::c_int; 3usize],
}
#[test]
fn bindgen_test_layout_btTranslationalLimitMotor() {
    assert_eq!(
        ::std::mem::size_of::<btTranslationalLimitMotor>(),
        368usize,
        concat!("Size of: ", stringify!(btTranslationalLimitMotor))
    );
    assert_eq!(
        ::std::mem::align_of::<btTranslationalLimitMotor>(),
        8usize,
        concat!("Alignment of ", stringify!(btTranslationalLimitMotor))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor)).m_lowerLimit as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_lowerLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor)).m_upperLimit as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_upperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTranslationalLimitMotor)).m_accumulatedImpulse as *const _ as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_accumulatedImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor)).m_limitSoftness as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_limitSoftness)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor)).m_damping as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_damping)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor)).m_restitution as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_restitution)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor)).m_normalCFM as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_normalCFM)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor)).m_stopERP as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_stopERP)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor)).m_stopCFM as *const _ as usize },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_stopCFM)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor)).m_enableMotor as *const _ as usize },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_enableMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTranslationalLimitMotor)).m_targetVelocity as *const _ as usize
        },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_targetVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor)).m_maxMotorForce as *const _ as usize },
        256usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_maxMotorForce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTranslationalLimitMotor)).m_currentLimitError as *const _ as usize
        },
        288usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_currentLimitError)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTranslationalLimitMotor)).m_currentLinearDiff as *const _ as usize
        },
        320usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_currentLinearDiff)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor)).m_currentLimit as *const _ as usize },
        352usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor),
            "::",
            stringify!(m_currentLimit)
        )
    );
}
extern "C" {

    /// ! Test limit
    /// /*!
    /// - free means upper < lower,
    /// - locked means upper == lower
    /// - limited means upper > lower
    /// - limitIndex: first 3 are linear, next 3 are angular
    /// */

    #[link_name = "\u{1}_ZNK25btTranslationalLimitMotor9isLimitedEi"]
    pub fn btTranslationalLimitMotor_isLimited(
        this: *const btTranslationalLimitMotor,
        limitIndex: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK25btTranslationalLimitMotor14needApplyForceEi"]
    pub fn btTranslationalLimitMotor_needApplyForce(
        this: *const btTranslationalLimitMotor,
        limitIndex: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN25btTranslationalLimitMotor14testLimitValueEid"]
    pub fn btTranslationalLimitMotor_testLimitValue(
        this: *mut btTranslationalLimitMotor,
        limitIndex: ::std::os::raw::c_int,
        test_value: btScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN25btTranslationalLimitMotor15solveLinearAxisEddR11btRigidBodyRK9btVector3S1_S4_iS4_S4_"]
    pub fn btTranslationalLimitMotor_solveLinearAxis(
        this: *mut btTranslationalLimitMotor,
        timeStep: btScalar,
        jacDiagABInv: btScalar,
        body1: *mut btRigidBody,
        pointInA: *const btVector3,
        body2: *mut btRigidBody,
        pointInB: *const btVector3,
        limit_index: ::std::os::raw::c_int,
        axis_normal_on_a: *const btVector3,
        anchorPos: *const btVector3,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN25btTranslationalLimitMotorC1Ev"]
    pub fn btTranslationalLimitMotor_btTranslationalLimitMotor(
        this: *mut btTranslationalLimitMotor,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN25btTranslationalLimitMotorC1ERKS_"]
    pub fn btTranslationalLimitMotor_btTranslationalLimitMotor1(
        this: *mut btTranslationalLimitMotor,
        other: *const btTranslationalLimitMotor,
    );
}
impl btTranslationalLimitMotor {
    #[inline]
    pub unsafe fn isLimited(&self, limitIndex: ::std::os::raw::c_int) -> bool {
        btTranslationalLimitMotor_isLimited(self, limitIndex)
    }
    #[inline]
    pub unsafe fn needApplyForce(&self, limitIndex: ::std::os::raw::c_int) -> bool {
        btTranslationalLimitMotor_needApplyForce(self, limitIndex)
    }
    #[inline]
    pub unsafe fn testLimitValue(
        &mut self,
        limitIndex: ::std::os::raw::c_int,
        test_value: btScalar,
    ) -> ::std::os::raw::c_int {
        btTranslationalLimitMotor_testLimitValue(self, limitIndex, test_value)
    }
    #[inline]
    pub unsafe fn solveLinearAxis(
        &mut self,
        timeStep: btScalar,
        jacDiagABInv: btScalar,
        body1: *mut btRigidBody,
        pointInA: *const btVector3,
        body2: *mut btRigidBody,
        pointInB: *const btVector3,
        limit_index: ::std::os::raw::c_int,
        axis_normal_on_a: *const btVector3,
        anchorPos: *const btVector3,
    ) -> btScalar {
        btTranslationalLimitMotor_solveLinearAxis(
            self,
            timeStep,
            jacDiagABInv,
            body1,
            pointInA,
            body2,
            pointInB,
            limit_index,
            axis_normal_on_a,
            anchorPos,
        )
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTranslationalLimitMotor_btTranslationalLimitMotor(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(other: *const btTranslationalLimitMotor) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTranslationalLimitMotor_btTranslationalLimitMotor1(&mut __bindgen_tmp, other);
        __bindgen_tmp
    }
}
pub const bt6DofFlags_BT_6DOF_FLAGS_CFM_NORM: bt6DofFlags = 1;
pub const bt6DofFlags_BT_6DOF_FLAGS_CFM_STOP: bt6DofFlags = 2;
pub const bt6DofFlags_BT_6DOF_FLAGS_ERP_STOP: bt6DofFlags = 4;
pub type bt6DofFlags = ::std::os::raw::c_uint;
/// btGeneric6DofConstraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
/// *!
/// btGeneric6DofConstraint can leave any of the 6 degree of freedom 'free' or 'locked'.
/// currently this limit supports rotational motors<br>
/// <ul>
/// <li> For Linear limits, use btGeneric6DofConstraint.setLinearUpperLimit, btGeneric6DofConstraint.setLinearLowerLimit. You can set the parameters with the btTranslationalLimitMotor structure accsesible through the btGeneric6DofConstraint.getTranslationalLimitMotor method.
/// At this moment translational motors are not supported. May be in the future. </li>
///
/// <li> For Angular limits, use the btRotationalLimitMotor structure for configuring the limit.
/// This is accessible through btGeneric6DofConstraint.getLimitMotor method,
/// This brings support for limit parameters and motors. </li>
///
/// <li> Angulars limits have these possible ranges:
/// <table border=1 >
/// <tr>
/// <td><b>AXIS</b></td>
/// <td><b>MIN ANGLE</b></td>
/// <td><b>MAX ANGLE</b></td>
/// </tr><tr>
/// <td>X</td>
/// <td>-PI</td>
/// <td>PI</td>
/// </tr><tr>
/// <td>Y</td>
/// <td>-PI/2</td>
/// <td>PI/2</td>
/// </tr><tr>
/// <td>Z</td>
/// <td>-PI</td>
/// <td>PI</td>
/// </tr>
/// </table>
/// </li>
/// </ul>
///
/// */
#[repr(C)]
pub struct btGeneric6DofConstraint {
    pub _base: btTypedConstraint,
    /// !< the constraint space w.r.t body A
    pub m_frameInA: btTransform,
    /// !< the constraint space w.r.t body B
    pub m_frameInB: btTransform,
    /// !< 3 orthogonal linear constraints
    pub m_jacLinear: [btJacobianEntry; 3usize],
    /// !< 3 orthogonal angular constraints
    pub m_jacAng: [btJacobianEntry; 3usize],
    /// ! Linear_Limit_parameters
    /// //!@{
    pub m_linearLimits: btTranslationalLimitMotor,
    /// ! hinge_parameters
    /// //!@{
    pub m_angularLimits: [btRotationalLimitMotor; 3usize],
    /// ! temporal variables
    /// //!@{
    pub m_timeStep: btScalar,
    pub m_calculatedTransformA: btTransform,
    pub m_calculatedTransformB: btTransform,
    pub m_calculatedAxisAngleDiff: btVector3,
    pub m_calculatedAxis: [btVector3; 3usize],
    pub m_calculatedLinearDiff: btVector3,
    pub m_factA: btScalar,
    pub m_factB: btScalar,
    pub m_hasStaticBody: bool,
    pub m_AnchorPos: btVector3,
    pub m_useLinearReferenceFrameA: bool,
    pub m_useOffsetForConstraintFrame: bool,
    pub m_flags: ::std::os::raw::c_int,
    /// for backwards compatibility during the transition to 'getInfo/getInfo2'
    pub m_useSolveConstraintObsolete: bool,
}
#[test]
fn bindgen_test_layout_btGeneric6DofConstraint() {
    assert_eq!(
        ::std::mem::size_of::<btGeneric6DofConstraint>(),
        2592usize,
        concat!("Size of: ", stringify!(btGeneric6DofConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<btGeneric6DofConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(btGeneric6DofConstraint))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraint)).m_frameInA as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_frameInA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraint)).m_frameInB as *const _ as usize },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_frameInB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraint)).m_jacLinear as *const _ as usize },
        336usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_jacLinear)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraint)).m_jacAng as *const _ as usize },
        840usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_jacAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraint)).m_linearLimits as *const _ as usize },
        1344usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_linearLimits)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraint)).m_angularLimits as *const _ as usize },
        1712usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_angularLimits)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraint)).m_timeStep as *const _ as usize },
        2096usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_timeStep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraint)).m_calculatedTransformA as *const _ as usize
        },
        2104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_calculatedTransformA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraint)).m_calculatedTransformB as *const _ as usize
        },
        2232usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_calculatedTransformB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraint)).m_calculatedAxisAngleDiff as *const _ as usize
        },
        2360usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_calculatedAxisAngleDiff)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraint)).m_calculatedAxis as *const _ as usize },
        2392usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_calculatedAxis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraint)).m_calculatedLinearDiff as *const _ as usize
        },
        2488usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_calculatedLinearDiff)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraint)).m_factA as *const _ as usize },
        2520usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_factA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraint)).m_factB as *const _ as usize },
        2528usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_factB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraint)).m_hasStaticBody as *const _ as usize },
        2536usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_hasStaticBody)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraint)).m_AnchorPos as *const _ as usize },
        2544usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_AnchorPos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraint)).m_useLinearReferenceFrameA as *const _
                as usize
        },
        2576usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_useLinearReferenceFrameA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraint)).m_useOffsetForConstraintFrame as *const _
                as usize
        },
        2577usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_useOffsetForConstraintFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraint)).m_flags as *const _ as usize },
        2580usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraint)).m_useSolveConstraintObsolete as *const _
                as usize
        },
        2584usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraint),
            "::",
            stringify!(m_useSolveConstraintObsolete)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint16setAngularLimitsEPN17btTypedConstraint17btConstraintInfo2EiRK11btTransformS5_RK9btVector3S8_S8_S8_"]
    pub fn btGeneric6DofConstraint_setAngularLimits(
        this: *mut btGeneric6DofConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row_offset: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint15setLinearLimitsEPN17btTypedConstraint17btConstraintInfo2EiRK11btTransformS5_RK9btVector3S8_S8_S8_"]
    pub fn btGeneric6DofConstraint_setLinearLimits(
        this: *mut btGeneric6DofConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint19buildLinearJacobianER15btJacobianEntryRK9btVector3S4_S4_"]
    pub fn btGeneric6DofConstraint_buildLinearJacobian(
        this: *mut btGeneric6DofConstraint,
        jacLinear: *mut btJacobianEntry,
        normalWorld: *const btVector3,
        pivotAInW: *const btVector3,
        pivotBInW: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint20buildAngularJacobianER15btJacobianEntryRK9btVector3"]
    pub fn btGeneric6DofConstraint_buildAngularJacobian(
        this: *mut btGeneric6DofConstraint,
        jacAngular: *mut btJacobianEntry,
        jointAxisW: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint19calculateLinearInfoEv"]
    pub fn btGeneric6DofConstraint_calculateLinearInfo(this: *mut btGeneric6DofConstraint);
}
extern "C" {

    /// ! calcs the euler angles between the two bodies.

    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint18calculateAngleInfoEv"]
    pub fn btGeneric6DofConstraint_calculateAngleInfo(this: *mut btGeneric6DofConstraint);
}
extern "C" {

    /// ! Calcs global transform of the offsets
    /// /*!
    /// Calcs the global transform for the joint offset for body A an B, and also calcs the agle differences between the bodies.
    /// \sa btGeneric6DofConstraint.getCalculatedTransformA , btGeneric6DofConstraint.getCalculatedTransformB, btGeneric6DofConstraint.calculateAngleInfo
    /// */

    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint19calculateTransformsERK11btTransformS2_"]
    pub fn btGeneric6DofConstraint_calculateTransforms(
        this: *mut btGeneric6DofConstraint,
        transA: *const btTransform,
        transB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint19calculateTransformsEv"]
    pub fn btGeneric6DofConstraint_calculateTransforms1(this: *mut btGeneric6DofConstraint);
}
extern "C" {

    /// ! Gets the global transform of the offset for body A
    /// /*!
    /// \sa btGeneric6DofConstraint.getFrameOffsetA, btGeneric6DofConstraint.getFrameOffsetB, btGeneric6DofConstraint.calculateAngleInfo.
    /// */

    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint23getCalculatedTransformAEv"]
    pub fn btGeneric6DofConstraint_getCalculatedTransformA(
        this: *const btGeneric6DofConstraint,
    ) -> *const btTransform;
}
extern "C" {

    /// ! Gets the global transform of the offset for body B
    /// /*!
    /// \sa btGeneric6DofConstraint.getFrameOffsetA, btGeneric6DofConstraint.getFrameOffsetB, btGeneric6DofConstraint.calculateAngleInfo.
    /// */

    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint23getCalculatedTransformBEv"]
    pub fn btGeneric6DofConstraint_getCalculatedTransformB(
        this: *const btGeneric6DofConstraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint15getFrameOffsetAEv"]
    pub fn btGeneric6DofConstraint_getFrameOffsetA(
        this: *const btGeneric6DofConstraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint15getFrameOffsetBEv"]
    pub fn btGeneric6DofConstraint_getFrameOffsetB(
        this: *const btGeneric6DofConstraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint15getFrameOffsetAEv"]
    pub fn btGeneric6DofConstraint_getFrameOffsetA1(
        this: *mut btGeneric6DofConstraint,
    ) -> *mut btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint15getFrameOffsetBEv"]
    pub fn btGeneric6DofConstraint_getFrameOffsetB1(
        this: *mut btGeneric6DofConstraint,
    ) -> *mut btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint18getInfo1NonVirtualEPN17btTypedConstraint17btConstraintInfo1E"]
    pub fn btGeneric6DofConstraint_getInfo1NonVirtual(
        this: *mut btGeneric6DofConstraint,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint18getInfo2NonVirtualEPN17btTypedConstraint17btConstraintInfo2ERK11btTransformS5_RK9btVector3S8_S8_S8_"]
    pub fn btGeneric6DofConstraint_getInfo2NonVirtual(
        this: *mut btGeneric6DofConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint9updateRHSEd"]
    pub fn btGeneric6DofConstraint_updateRHS(
        this: *mut btGeneric6DofConstraint,
        timeStep: btScalar,
    );
}
extern "C" {

    /// ! Get the rotation axis in global coordinates
    /// /*!
    /// \pre btGeneric6DofConstraint.buildJacobian must be called previously.
    /// */

    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint7getAxisEi"]
    pub fn btGeneric6DofConstraint_getAxis(
        this: *const btGeneric6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> btVector3;
}
extern "C" {

    /// ! Get the relative Euler angle
    /// /*!
    /// \pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
    /// */

    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint8getAngleEi"]
    pub fn btGeneric6DofConstraint_getAngle(
        this: *const btGeneric6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {

    /// ! Get the relative position of the constraint pivot
    /// /*!
    /// \pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
    /// */

    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint24getRelativePivotPositionEi"]
    pub fn btGeneric6DofConstraint_getRelativePivotPosition(
        this: *const btGeneric6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint9setFramesERK11btTransformS2_"]
    pub fn btGeneric6DofConstraint_setFrames(
        this: *mut btGeneric6DofConstraint,
        frameA: *const btTransform,
        frameB: *const btTransform,
    );
}
extern "C" {

    /// ! Test angular limit.
    /// /*!
    /// Calculates angular correction and returns true if limit needs to be corrected.
    /// \pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
    /// */

    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint21testAngularLimitMotorEi"]
    pub fn btGeneric6DofConstraint_testAngularLimitMotor(
        this: *mut btGeneric6DofConstraint,
        axis_index: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint19setLinearLowerLimitERK9btVector3"]
    pub fn btGeneric6DofConstraint_setLinearLowerLimit(
        this: *mut btGeneric6DofConstraint,
        linearLower: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint19getLinearLowerLimitER9btVector3"]
    pub fn btGeneric6DofConstraint_getLinearLowerLimit(
        this: *const btGeneric6DofConstraint,
        linearLower: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint19setLinearUpperLimitERK9btVector3"]
    pub fn btGeneric6DofConstraint_setLinearUpperLimit(
        this: *mut btGeneric6DofConstraint,
        linearUpper: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint19getLinearUpperLimitER9btVector3"]
    pub fn btGeneric6DofConstraint_getLinearUpperLimit(
        this: *const btGeneric6DofConstraint,
        linearUpper: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint20setAngularLowerLimitERK9btVector3"]
    pub fn btGeneric6DofConstraint_setAngularLowerLimit(
        this: *mut btGeneric6DofConstraint,
        angularLower: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint20getAngularLowerLimitER9btVector3"]
    pub fn btGeneric6DofConstraint_getAngularLowerLimit(
        this: *const btGeneric6DofConstraint,
        angularLower: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint20setAngularUpperLimitERK9btVector3"]
    pub fn btGeneric6DofConstraint_setAngularUpperLimit(
        this: *mut btGeneric6DofConstraint,
        angularUpper: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint20getAngularUpperLimitER9btVector3"]
    pub fn btGeneric6DofConstraint_getAngularUpperLimit(
        this: *const btGeneric6DofConstraint,
        angularUpper: *mut btVector3,
    );
}
extern "C" {

    /// ! Retrieves the angular limit informacion

    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint23getRotationalLimitMotorEi"]
    pub fn btGeneric6DofConstraint_getRotationalLimitMotor(
        this: *mut btGeneric6DofConstraint,
        index: ::std::os::raw::c_int,
    ) -> *mut btRotationalLimitMotor;
}
extern "C" {

    /// ! Retrieves the  limit informacion

    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint26getTranslationalLimitMotorEv"]
    pub fn btGeneric6DofConstraint_getTranslationalLimitMotor(
        this: *mut btGeneric6DofConstraint,
    ) -> *mut btTranslationalLimitMotor;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint8setLimitEidd"]
    pub fn btGeneric6DofConstraint_setLimit(
        this: *mut btGeneric6DofConstraint,
        axis: ::std::os::raw::c_int,
        lo: btScalar,
        hi: btScalar,
    );
}
extern "C" {

    /// ! Test limit
    /// /*!
    /// - free means upper < lower,
    /// - locked means upper == lower
    /// - limited means upper > lower
    /// - limitIndex: first 3 are linear, next 3 are angular
    /// */

    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint9isLimitedEi"]
    pub fn btGeneric6DofConstraint_isLimited(
        this: *const btGeneric6DofConstraint,
        limitIndex: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint21get_limit_motor_info2EP22btRotationalLimitMotorRK11btTransformS4_RK9btVector3S7_S7_S7_PN17btTypedConstraint17btConstraintInfo2EiRS5_ii"]
    pub fn btGeneric6DofConstraint_get_limit_motor_info2(
        this: *mut btGeneric6DofConstraint,
        limot: *mut btRotationalLimitMotor,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        ax1: *mut btVector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint17getUseFrameOffsetEv"]
    pub fn btGeneric6DofConstraint_getUseFrameOffset(this: *const btGeneric6DofConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint17setUseFrameOffsetEb"]
    pub fn btGeneric6DofConstraint_setUseFrameOffset(
        this: *mut btGeneric6DofConstraint,
        frameOffsetOnOff: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint27getUseLinearReferenceFrameAEv"]
    pub fn btGeneric6DofConstraint_getUseLinearReferenceFrameA(
        this: *const btGeneric6DofConstraint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint27setUseLinearReferenceFrameAEb"]
    pub fn btGeneric6DofConstraint_setUseLinearReferenceFrameA(
        this: *mut btGeneric6DofConstraint,
        linearReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint7setAxisERK9btVector3S2_"]
    pub fn btGeneric6DofConstraint_setAxis(
        this: *mut btGeneric6DofConstraint,
        axis1: *const btVector3,
        axis2: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b"]
    pub fn btGeneric6DofConstraint_btGeneric6DofConstraint(
        this: *mut btGeneric6DofConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraintC1ER11btRigidBodyRK11btTransformb"]
    pub fn btGeneric6DofConstraint_btGeneric6DofConstraint1(
        this: *mut btGeneric6DofConstraint,
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        useLinearReferenceFrameB: bool,
    );
}
impl btGeneric6DofConstraint {
    #[inline]
    pub unsafe fn setAngularLimits(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row_offset: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int {
        btGeneric6DofConstraint_setAngularLimits(
            self,
            info,
            row_offset,
            transA,
            transB,
            linVelA,
            linVelB,
            angVelA,
            angVelB,
        )
    }
    #[inline]
    pub unsafe fn setLinearLimits(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int {
        btGeneric6DofConstraint_setLinearLimits(
            self,
            info,
            row,
            transA,
            transB,
            linVelA,
            linVelB,
            angVelA,
            angVelB,
        )
    }
    #[inline]
    pub unsafe fn buildLinearJacobian(
        &mut self,
        jacLinear: *mut btJacobianEntry,
        normalWorld: *const btVector3,
        pivotAInW: *const btVector3,
        pivotBInW: *const btVector3,
    ) {
        btGeneric6DofConstraint_buildLinearJacobian(
            self,
            jacLinear,
            normalWorld,
            pivotAInW,
            pivotBInW,
        )
    }
    #[inline]
    pub unsafe fn buildAngularJacobian(
        &mut self,
        jacAngular: *mut btJacobianEntry,
        jointAxisW: *const btVector3,
    ) {
        btGeneric6DofConstraint_buildAngularJacobian(self, jacAngular, jointAxisW)
    }
    #[inline]
    pub unsafe fn calculateLinearInfo(&mut self) {
        btGeneric6DofConstraint_calculateLinearInfo(self)
    }
    #[inline]
    pub unsafe fn calculateAngleInfo(&mut self) {
        btGeneric6DofConstraint_calculateAngleInfo(self)
    }
    #[inline]
    pub unsafe fn calculateTransforms(
        &mut self,
        transA: *const btTransform,
        transB: *const btTransform,
    ) {
        btGeneric6DofConstraint_calculateTransforms(self, transA, transB)
    }
    #[inline]
    pub unsafe fn calculateTransforms1(&mut self) {
        btGeneric6DofConstraint_calculateTransforms1(self)
    }
    #[inline]
    pub unsafe fn getCalculatedTransformA(&self) -> *const btTransform {
        btGeneric6DofConstraint_getCalculatedTransformA(self)
    }
    #[inline]
    pub unsafe fn getCalculatedTransformB(&self) -> *const btTransform {
        btGeneric6DofConstraint_getCalculatedTransformB(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetA(&self) -> *const btTransform {
        btGeneric6DofConstraint_getFrameOffsetA(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetB(&self) -> *const btTransform {
        btGeneric6DofConstraint_getFrameOffsetB(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetA1(&mut self) -> *mut btTransform {
        btGeneric6DofConstraint_getFrameOffsetA1(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetB1(&mut self) -> *mut btTransform {
        btGeneric6DofConstraint_getFrameOffsetB1(self)
    }
    #[inline]
    pub unsafe fn getInfo1NonVirtual(&mut self, info: *mut btTypedConstraint_btConstraintInfo1) {
        btGeneric6DofConstraint_getInfo1NonVirtual(self, info)
    }
    #[inline]
    pub unsafe fn getInfo2NonVirtual(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) {
        btGeneric6DofConstraint_getInfo2NonVirtual(
            self,
            info,
            transA,
            transB,
            linVelA,
            linVelB,
            angVelA,
            angVelB,
        )
    }
    #[inline]
    pub unsafe fn updateRHS(&mut self, timeStep: btScalar) {
        btGeneric6DofConstraint_updateRHS(self, timeStep)
    }
    #[inline]
    pub unsafe fn getAxis(&self, axis_index: ::std::os::raw::c_int) -> btVector3 {
        btGeneric6DofConstraint_getAxis(self, axis_index)
    }
    #[inline]
    pub unsafe fn getAngle(&self, axis_index: ::std::os::raw::c_int) -> btScalar {
        btGeneric6DofConstraint_getAngle(self, axis_index)
    }
    #[inline]
    pub unsafe fn getRelativePivotPosition(&self, axis_index: ::std::os::raw::c_int) -> btScalar {
        btGeneric6DofConstraint_getRelativePivotPosition(self, axis_index)
    }
    #[inline]
    pub unsafe fn setFrames(&mut self, frameA: *const btTransform, frameB: *const btTransform) {
        btGeneric6DofConstraint_setFrames(self, frameA, frameB)
    }
    #[inline]
    pub unsafe fn testAngularLimitMotor(&mut self, axis_index: ::std::os::raw::c_int) -> bool {
        btGeneric6DofConstraint_testAngularLimitMotor(self, axis_index)
    }
    #[inline]
    pub unsafe fn setLinearLowerLimit(&mut self, linearLower: *const btVector3) {
        btGeneric6DofConstraint_setLinearLowerLimit(self, linearLower)
    }
    #[inline]
    pub unsafe fn getLinearLowerLimit(&self, linearLower: *mut btVector3) {
        btGeneric6DofConstraint_getLinearLowerLimit(self, linearLower)
    }
    #[inline]
    pub unsafe fn setLinearUpperLimit(&mut self, linearUpper: *const btVector3) {
        btGeneric6DofConstraint_setLinearUpperLimit(self, linearUpper)
    }
    #[inline]
    pub unsafe fn getLinearUpperLimit(&self, linearUpper: *mut btVector3) {
        btGeneric6DofConstraint_getLinearUpperLimit(self, linearUpper)
    }
    #[inline]
    pub unsafe fn setAngularLowerLimit(&mut self, angularLower: *const btVector3) {
        btGeneric6DofConstraint_setAngularLowerLimit(self, angularLower)
    }
    #[inline]
    pub unsafe fn getAngularLowerLimit(&self, angularLower: *mut btVector3) {
        btGeneric6DofConstraint_getAngularLowerLimit(self, angularLower)
    }
    #[inline]
    pub unsafe fn setAngularUpperLimit(&mut self, angularUpper: *const btVector3) {
        btGeneric6DofConstraint_setAngularUpperLimit(self, angularUpper)
    }
    #[inline]
    pub unsafe fn getAngularUpperLimit(&self, angularUpper: *mut btVector3) {
        btGeneric6DofConstraint_getAngularUpperLimit(self, angularUpper)
    }
    #[inline]
    pub unsafe fn getRotationalLimitMotor(
        &mut self,
        index: ::std::os::raw::c_int,
    ) -> *mut btRotationalLimitMotor {
        btGeneric6DofConstraint_getRotationalLimitMotor(self, index)
    }
    #[inline]
    pub unsafe fn getTranslationalLimitMotor(&mut self) -> *mut btTranslationalLimitMotor {
        btGeneric6DofConstraint_getTranslationalLimitMotor(self)
    }
    #[inline]
    pub unsafe fn setLimit(&mut self, axis: ::std::os::raw::c_int, lo: btScalar, hi: btScalar) {
        btGeneric6DofConstraint_setLimit(self, axis, lo, hi)
    }
    #[inline]
    pub unsafe fn isLimited(&self, limitIndex: ::std::os::raw::c_int) -> bool {
        btGeneric6DofConstraint_isLimited(self, limitIndex)
    }
    #[inline]
    pub unsafe fn get_limit_motor_info2(
        &mut self,
        limot: *mut btRotationalLimitMotor,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        ax1: *mut btVector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btGeneric6DofConstraint_get_limit_motor_info2(
            self,
            limot,
            transA,
            transB,
            linVelA,
            linVelB,
            angVelA,
            angVelB,
            info,
            row,
            ax1,
            rotational,
            rotAllowed,
        )
    }
    #[inline]
    pub unsafe fn getUseFrameOffset(&self) -> bool {
        btGeneric6DofConstraint_getUseFrameOffset(self)
    }
    #[inline]
    pub unsafe fn setUseFrameOffset(&mut self, frameOffsetOnOff: bool) {
        btGeneric6DofConstraint_setUseFrameOffset(self, frameOffsetOnOff)
    }
    #[inline]
    pub unsafe fn getUseLinearReferenceFrameA(&self) -> bool {
        btGeneric6DofConstraint_getUseLinearReferenceFrameA(self)
    }
    #[inline]
    pub unsafe fn setUseLinearReferenceFrameA(&mut self, linearReferenceFrameA: bool) {
        btGeneric6DofConstraint_setUseLinearReferenceFrameA(self, linearReferenceFrameA)
    }
    #[inline]
    pub unsafe fn setAxis(&mut self, axis1: *const btVector3, axis2: *const btVector3) {
        btGeneric6DofConstraint_setAxis(self, axis1, axis2)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGeneric6DofConstraint_btGeneric6DofConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            frameInA,
            frameInB,
            useLinearReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        useLinearReferenceFrameB: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGeneric6DofConstraint_btGeneric6DofConstraint1(
            &mut __bindgen_tmp,
            rbB,
            frameInB,
            useLinearReferenceFrameB,
        );
        __bindgen_tmp
    }
}
extern "C" {

    /// ! performs Jacobian calculation, and also calculates angle differences and axis

    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint13buildJacobianEv"]
    pub fn btGeneric6DofConstraint_buildJacobian(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
    pub fn btGeneric6DofConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
    pub fn btGeneric6DofConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint13calcAnchorPosEv"]
    pub fn btGeneric6DofConstraint_calcAnchorPos(this: *mut ::std::os::raw::c_void);
}
extern "C" {

    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.

    #[link_name = "\u{1}_ZN23btGeneric6DofConstraint8setParamEidi"]
    pub fn btGeneric6DofConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: btScalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// return the local value of parameter

    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint8getParamEii"]
    pub fn btGeneric6DofConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint8getFlagsEv"]
    pub fn btGeneric6DofConstraint_getFlags(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint28calculateSerializeBufferSizeEv"]
    pub fn btGeneric6DofConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK23btGeneric6DofConstraint9serializeEPvP12btSerializer"]
    pub fn btGeneric6DofConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGeneric6DofConstraintData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_rbAFrame: btTransformFloatData,
    pub m_rbBFrame: btTransformFloatData,
    pub m_linearUpperLimit: btVector3FloatData,
    pub m_linearLowerLimit: btVector3FloatData,
    pub m_angularUpperLimit: btVector3FloatData,
    pub m_angularLowerLimit: btVector3FloatData,
    pub m_useLinearReferenceFrameA: ::std::os::raw::c_int,
    pub m_useOffsetForConstraintFrame: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btGeneric6DofConstraintData() {
    assert_eq!(
        ::std::mem::size_of::<btGeneric6DofConstraintData>(),
        264usize,
        concat!("Size of: ", stringify!(btGeneric6DofConstraintData))
    );
    assert_eq!(
        ::std::mem::align_of::<btGeneric6DofConstraintData>(),
        8usize,
        concat!("Alignment of ", stringify!(btGeneric6DofConstraintData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintData)).m_typeConstraintData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintData),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraintData)).m_rbAFrame as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintData),
            "::",
            stringify!(m_rbAFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofConstraintData)).m_rbBFrame as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintData),
            "::",
            stringify!(m_rbBFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintData)).m_linearUpperLimit as *const _ as usize
        },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintData),
            "::",
            stringify!(m_linearUpperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintData)).m_linearLowerLimit as *const _ as usize
        },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintData),
            "::",
            stringify!(m_linearLowerLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintData)).m_angularUpperLimit as *const _ as usize
        },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintData),
            "::",
            stringify!(m_angularUpperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintData)).m_angularLowerLimit as *const _ as usize
        },
        240usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintData),
            "::",
            stringify!(m_angularLowerLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintData)).m_useLinearReferenceFrameA as *const _
                as usize
        },
        256usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintData),
            "::",
            stringify!(m_useLinearReferenceFrameA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintData)).m_useOffsetForConstraintFrame as *const _
                as usize
        },
        260usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintData),
            "::",
            stringify!(m_useOffsetForConstraintFrame)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGeneric6DofConstraintDoubleData2 {
    pub m_typeConstraintData: btTypedConstraintDoubleData,
    pub m_rbAFrame: btTransformDoubleData,
    pub m_rbBFrame: btTransformDoubleData,
    pub m_linearUpperLimit: btVector3DoubleData,
    pub m_linearLowerLimit: btVector3DoubleData,
    pub m_angularUpperLimit: btVector3DoubleData,
    pub m_angularLowerLimit: btVector3DoubleData,
    pub m_useLinearReferenceFrameA: ::std::os::raw::c_int,
    pub m_useOffsetForConstraintFrame: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btGeneric6DofConstraintDoubleData2() {
    assert_eq!(
        ::std::mem::size_of::<btGeneric6DofConstraintDoubleData2>(),
        472usize,
        concat!("Size of: ", stringify!(btGeneric6DofConstraintDoubleData2))
    );
    assert_eq!(
        ::std::mem::align_of::<btGeneric6DofConstraintDoubleData2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btGeneric6DofConstraintDoubleData2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintDoubleData2)).m_typeConstraintData as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintDoubleData2),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintDoubleData2)).m_rbAFrame as *const _ as usize
        },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintDoubleData2),
            "::",
            stringify!(m_rbAFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintDoubleData2)).m_rbBFrame as *const _ as usize
        },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintDoubleData2),
            "::",
            stringify!(m_rbBFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintDoubleData2)).m_linearUpperLimit as *const _
                as usize
        },
        336usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintDoubleData2),
            "::",
            stringify!(m_linearUpperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintDoubleData2)).m_linearLowerLimit as *const _
                as usize
        },
        368usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintDoubleData2),
            "::",
            stringify!(m_linearLowerLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintDoubleData2)).m_angularUpperLimit as *const _
                as usize
        },
        400usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintDoubleData2),
            "::",
            stringify!(m_angularUpperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintDoubleData2)).m_angularLowerLimit as *const _
                as usize
        },
        432usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintDoubleData2),
            "::",
            stringify!(m_angularLowerLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintDoubleData2)).m_useLinearReferenceFrameA
                as *const _ as usize
        },
        464usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintDoubleData2),
            "::",
            stringify!(m_useLinearReferenceFrameA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofConstraintDoubleData2)).m_useOffsetForConstraintFrame
                as *const _ as usize
        },
        468usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofConstraintDoubleData2),
            "::",
            stringify!(m_useOffsetForConstraintFrame)
        )
    );
}
pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_DIRLIN: btSliderFlags = 1;
pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_DIRLIN: btSliderFlags = 2;
pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_DIRANG: btSliderFlags = 4;
pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_DIRANG: btSliderFlags = 8;
pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_ORTLIN: btSliderFlags = 16;
pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_ORTLIN: btSliderFlags = 32;
pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_ORTANG: btSliderFlags = 64;
pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_ORTANG: btSliderFlags = 128;
pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_LIMLIN: btSliderFlags = 256;
pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_LIMLIN: btSliderFlags = 512;
pub const btSliderFlags_BT_SLIDER_FLAGS_CFM_LIMANG: btSliderFlags = 1024;
pub const btSliderFlags_BT_SLIDER_FLAGS_ERP_LIMANG: btSliderFlags = 2048;
pub type btSliderFlags = ::std::os::raw::c_uint;
#[repr(C)]
pub struct btSliderConstraint {
    pub _base: btTypedConstraint,
    /// for backwards compatibility during the transition to 'getInfo/getInfo2'
    pub m_useSolveConstraintObsolete: bool,
    pub m_useOffsetForConstraintFrame: bool,
    pub m_frameInA: btTransform,
    pub m_frameInB: btTransform,
    pub m_useLinearReferenceFrameA: bool,
    pub m_lowerLinLimit: btScalar,
    pub m_upperLinLimit: btScalar,
    pub m_lowerAngLimit: btScalar,
    pub m_upperAngLimit: btScalar,
    pub m_softnessDirLin: btScalar,
    pub m_restitutionDirLin: btScalar,
    pub m_dampingDirLin: btScalar,
    pub m_cfmDirLin: btScalar,
    pub m_softnessDirAng: btScalar,
    pub m_restitutionDirAng: btScalar,
    pub m_dampingDirAng: btScalar,
    pub m_cfmDirAng: btScalar,
    pub m_softnessLimLin: btScalar,
    pub m_restitutionLimLin: btScalar,
    pub m_dampingLimLin: btScalar,
    pub m_cfmLimLin: btScalar,
    pub m_softnessLimAng: btScalar,
    pub m_restitutionLimAng: btScalar,
    pub m_dampingLimAng: btScalar,
    pub m_cfmLimAng: btScalar,
    pub m_softnessOrthoLin: btScalar,
    pub m_restitutionOrthoLin: btScalar,
    pub m_dampingOrthoLin: btScalar,
    pub m_cfmOrthoLin: btScalar,
    pub m_softnessOrthoAng: btScalar,
    pub m_restitutionOrthoAng: btScalar,
    pub m_dampingOrthoAng: btScalar,
    pub m_cfmOrthoAng: btScalar,
    pub m_solveLinLim: bool,
    pub m_solveAngLim: bool,
    pub m_flags: ::std::os::raw::c_int,
    pub m_jacLin: [btJacobianEntry; 3usize],
    pub m_jacLinDiagABInv: [btScalar; 3usize],
    pub m_jacAng: [btJacobianEntry; 3usize],
    pub m_timeStep: btScalar,
    pub m_calculatedTransformA: btTransform,
    pub m_calculatedTransformB: btTransform,
    pub m_sliderAxis: btVector3,
    pub m_realPivotAInW: btVector3,
    pub m_realPivotBInW: btVector3,
    pub m_projPivotInW: btVector3,
    pub m_delta: btVector3,
    pub m_depth: btVector3,
    pub m_relPosA: btVector3,
    pub m_relPosB: btVector3,
    pub m_linPos: btScalar,
    pub m_angPos: btScalar,
    pub m_angDepth: btScalar,
    pub m_kAngle: btScalar,
    pub m_poweredLinMotor: bool,
    pub m_targetLinMotorVelocity: btScalar,
    pub m_maxLinMotorForce: btScalar,
    pub m_accumulatedLinMotorImpulse: btScalar,
    pub m_poweredAngMotor: bool,
    pub m_targetAngMotorVelocity: btScalar,
    pub m_maxAngMotorForce: btScalar,
    pub m_accumulatedAngMotorImpulse: btScalar,
}
#[test]
fn bindgen_test_layout_btSliderConstraint() {
    assert_eq!(
        ::std::mem::size_of::<btSliderConstraint>(),
        2232usize,
        concat!("Size of: ", stringify!(btSliderConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<btSliderConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(btSliderConstraint))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraint)).m_useSolveConstraintObsolete as *const _ as usize
        },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_useSolveConstraintObsolete)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraint)).m_useOffsetForConstraintFrame as *const _ as usize
        },
        81usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_useOffsetForConstraintFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_frameInA as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_frameInA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_frameInB as *const _ as usize },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_frameInB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraint)).m_useLinearReferenceFrameA as *const _ as usize
        },
        344usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_useLinearReferenceFrameA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_lowerLinLimit as *const _ as usize },
        352usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_lowerLinLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_upperLinLimit as *const _ as usize },
        360usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_upperLinLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_lowerAngLimit as *const _ as usize },
        368usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_lowerAngLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_upperAngLimit as *const _ as usize },
        376usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_upperAngLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_softnessDirLin as *const _ as usize },
        384usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_softnessDirLin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_restitutionDirLin as *const _ as usize },
        392usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_restitutionDirLin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_dampingDirLin as *const _ as usize },
        400usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_dampingDirLin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_cfmDirLin as *const _ as usize },
        408usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_cfmDirLin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_softnessDirAng as *const _ as usize },
        416usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_softnessDirAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_restitutionDirAng as *const _ as usize },
        424usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_restitutionDirAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_dampingDirAng as *const _ as usize },
        432usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_dampingDirAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_cfmDirAng as *const _ as usize },
        440usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_cfmDirAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_softnessLimLin as *const _ as usize },
        448usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_softnessLimLin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_restitutionLimLin as *const _ as usize },
        456usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_restitutionLimLin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_dampingLimLin as *const _ as usize },
        464usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_dampingLimLin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_cfmLimLin as *const _ as usize },
        472usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_cfmLimLin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_softnessLimAng as *const _ as usize },
        480usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_softnessLimAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_restitutionLimAng as *const _ as usize },
        488usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_restitutionLimAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_dampingLimAng as *const _ as usize },
        496usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_dampingLimAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_cfmLimAng as *const _ as usize },
        504usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_cfmLimAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_softnessOrthoLin as *const _ as usize },
        512usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_softnessOrthoLin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_restitutionOrthoLin as *const _ as usize },
        520usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_restitutionOrthoLin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_dampingOrthoLin as *const _ as usize },
        528usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_dampingOrthoLin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_cfmOrthoLin as *const _ as usize },
        536usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_cfmOrthoLin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_softnessOrthoAng as *const _ as usize },
        544usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_softnessOrthoAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_restitutionOrthoAng as *const _ as usize },
        552usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_restitutionOrthoAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_dampingOrthoAng as *const _ as usize },
        560usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_dampingOrthoAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_cfmOrthoAng as *const _ as usize },
        568usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_cfmOrthoAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_solveLinLim as *const _ as usize },
        576usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_solveLinLim)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_solveAngLim as *const _ as usize },
        577usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_solveAngLim)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_flags as *const _ as usize },
        580usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_jacLin as *const _ as usize },
        584usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_jacLin)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_jacLinDiagABInv as *const _ as usize },
        1088usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_jacLinDiagABInv)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_jacAng as *const _ as usize },
        1112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_jacAng)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_timeStep as *const _ as usize },
        1616usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_timeStep)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_calculatedTransformA as *const _ as usize },
        1624usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_calculatedTransformA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_calculatedTransformB as *const _ as usize },
        1752usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_calculatedTransformB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_sliderAxis as *const _ as usize },
        1880usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_sliderAxis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_realPivotAInW as *const _ as usize },
        1912usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_realPivotAInW)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_realPivotBInW as *const _ as usize },
        1944usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_realPivotBInW)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_projPivotInW as *const _ as usize },
        1976usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_projPivotInW)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_delta as *const _ as usize },
        2008usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_delta)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_depth as *const _ as usize },
        2040usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_relPosA as *const _ as usize },
        2072usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_relPosA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_relPosB as *const _ as usize },
        2104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_relPosB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_linPos as *const _ as usize },
        2136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_linPos)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_angPos as *const _ as usize },
        2144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_angPos)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_angDepth as *const _ as usize },
        2152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_angDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_kAngle as *const _ as usize },
        2160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_kAngle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_poweredLinMotor as *const _ as usize },
        2168usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_poweredLinMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraint)).m_targetLinMotorVelocity as *const _ as usize
        },
        2176usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_targetLinMotorVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_maxLinMotorForce as *const _ as usize },
        2184usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_maxLinMotorForce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraint)).m_accumulatedLinMotorImpulse as *const _ as usize
        },
        2192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_accumulatedLinMotorImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_poweredAngMotor as *const _ as usize },
        2200usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_poweredAngMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraint)).m_targetAngMotorVelocity as *const _ as usize
        },
        2208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_targetAngMotorVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraint)).m_maxAngMotorForce as *const _ as usize },
        2216usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_maxAngMotorForce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraint)).m_accumulatedAngMotorImpulse as *const _ as usize
        },
        2224usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraint),
            "::",
            stringify!(m_accumulatedAngMotorImpulse)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint10initParamsEv"]
    pub fn btSliderConstraint_initParams(this: *mut btSliderConstraint);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint18getInfo1NonVirtualEPN17btTypedConstraint17btConstraintInfo1E"]
    pub fn btSliderConstraint_getInfo1NonVirtual(
        this: *mut btSliderConstraint,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint18getInfo2NonVirtualEPN17btTypedConstraint17btConstraintInfo2ERK11btTransformS5_RK9btVector3S8_dd"]
    pub fn btSliderConstraint_getInfo2NonVirtual(
        this: *mut btSliderConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        rbAinvMass: btScalar,
        rbBinvMass: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btSliderConstraint13getRigidBodyAEv"]
    pub fn btSliderConstraint_getRigidBodyA(this: *const btSliderConstraint) -> *const btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btSliderConstraint13getRigidBodyBEv"]
    pub fn btSliderConstraint_getRigidBodyB(this: *const btSliderConstraint) -> *const btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btSliderConstraint23getCalculatedTransformAEv"]
    pub fn btSliderConstraint_getCalculatedTransformA(
        this: *const btSliderConstraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btSliderConstraint23getCalculatedTransformBEv"]
    pub fn btSliderConstraint_getCalculatedTransformB(
        this: *const btSliderConstraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btSliderConstraint15getFrameOffsetAEv"]
    pub fn btSliderConstraint_getFrameOffsetA(
        this: *const btSliderConstraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btSliderConstraint15getFrameOffsetBEv"]
    pub fn btSliderConstraint_getFrameOffsetB(
        this: *const btSliderConstraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint15getFrameOffsetAEv"]
    pub fn btSliderConstraint_getFrameOffsetA1(this: *mut btSliderConstraint) -> *mut btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint15getFrameOffsetBEv"]
    pub fn btSliderConstraint_getFrameOffsetB1(this: *mut btSliderConstraint) -> *mut btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16getLowerLinLimitEv"]
    pub fn btSliderConstraint_getLowerLinLimit(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16setLowerLinLimitEd"]
    pub fn btSliderConstraint_setLowerLinLimit(this: *mut btSliderConstraint, lowerLimit: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16getUpperLinLimitEv"]
    pub fn btSliderConstraint_getUpperLinLimit(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16setUpperLinLimitEd"]
    pub fn btSliderConstraint_setUpperLinLimit(this: *mut btSliderConstraint, upperLimit: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16getLowerAngLimitEv"]
    pub fn btSliderConstraint_getLowerAngLimit(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16setLowerAngLimitEd"]
    pub fn btSliderConstraint_setLowerAngLimit(this: *mut btSliderConstraint, lowerLimit: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16getUpperAngLimitEv"]
    pub fn btSliderConstraint_getUpperAngLimit(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16setUpperAngLimitEd"]
    pub fn btSliderConstraint_setUpperAngLimit(this: *mut btSliderConstraint, upperLimit: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint27getUseLinearReferenceFrameAEv"]
    pub fn btSliderConstraint_getUseLinearReferenceFrameA(this: *mut btSliderConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint17getSoftnessDirLinEv"]
    pub fn btSliderConstraint_getSoftnessDirLin(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint20getRestitutionDirLinEv"]
    pub fn btSliderConstraint_getRestitutionDirLin(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16getDampingDirLinEv"]
    pub fn btSliderConstraint_getDampingDirLin(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint17getSoftnessDirAngEv"]
    pub fn btSliderConstraint_getSoftnessDirAng(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint20getRestitutionDirAngEv"]
    pub fn btSliderConstraint_getRestitutionDirAng(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16getDampingDirAngEv"]
    pub fn btSliderConstraint_getDampingDirAng(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint17getSoftnessLimLinEv"]
    pub fn btSliderConstraint_getSoftnessLimLin(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint20getRestitutionLimLinEv"]
    pub fn btSliderConstraint_getRestitutionLimLin(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16getDampingLimLinEv"]
    pub fn btSliderConstraint_getDampingLimLin(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint17getSoftnessLimAngEv"]
    pub fn btSliderConstraint_getSoftnessLimAng(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint20getRestitutionLimAngEv"]
    pub fn btSliderConstraint_getRestitutionLimAng(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16getDampingLimAngEv"]
    pub fn btSliderConstraint_getDampingLimAng(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint19getSoftnessOrthoLinEv"]
    pub fn btSliderConstraint_getSoftnessOrthoLin(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint22getRestitutionOrthoLinEv"]
    pub fn btSliderConstraint_getRestitutionOrthoLin(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint18getDampingOrthoLinEv"]
    pub fn btSliderConstraint_getDampingOrthoLin(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint19getSoftnessOrthoAngEv"]
    pub fn btSliderConstraint_getSoftnessOrthoAng(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint22getRestitutionOrthoAngEv"]
    pub fn btSliderConstraint_getRestitutionOrthoAng(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint18getDampingOrthoAngEv"]
    pub fn btSliderConstraint_getDampingOrthoAng(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint17setSoftnessDirLinEd"]
    pub fn btSliderConstraint_setSoftnessDirLin(
        this: *mut btSliderConstraint,
        softnessDirLin: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint20setRestitutionDirLinEd"]
    pub fn btSliderConstraint_setRestitutionDirLin(
        this: *mut btSliderConstraint,
        restitutionDirLin: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16setDampingDirLinEd"]
    pub fn btSliderConstraint_setDampingDirLin(
        this: *mut btSliderConstraint,
        dampingDirLin: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint17setSoftnessDirAngEd"]
    pub fn btSliderConstraint_setSoftnessDirAng(
        this: *mut btSliderConstraint,
        softnessDirAng: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint20setRestitutionDirAngEd"]
    pub fn btSliderConstraint_setRestitutionDirAng(
        this: *mut btSliderConstraint,
        restitutionDirAng: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16setDampingDirAngEd"]
    pub fn btSliderConstraint_setDampingDirAng(
        this: *mut btSliderConstraint,
        dampingDirAng: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint17setSoftnessLimLinEd"]
    pub fn btSliderConstraint_setSoftnessLimLin(
        this: *mut btSliderConstraint,
        softnessLimLin: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint20setRestitutionLimLinEd"]
    pub fn btSliderConstraint_setRestitutionLimLin(
        this: *mut btSliderConstraint,
        restitutionLimLin: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16setDampingLimLinEd"]
    pub fn btSliderConstraint_setDampingLimLin(
        this: *mut btSliderConstraint,
        dampingLimLin: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint17setSoftnessLimAngEd"]
    pub fn btSliderConstraint_setSoftnessLimAng(
        this: *mut btSliderConstraint,
        softnessLimAng: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint20setRestitutionLimAngEd"]
    pub fn btSliderConstraint_setRestitutionLimAng(
        this: *mut btSliderConstraint,
        restitutionLimAng: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16setDampingLimAngEd"]
    pub fn btSliderConstraint_setDampingLimAng(
        this: *mut btSliderConstraint,
        dampingLimAng: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint19setSoftnessOrthoLinEd"]
    pub fn btSliderConstraint_setSoftnessOrthoLin(
        this: *mut btSliderConstraint,
        softnessOrthoLin: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint22setRestitutionOrthoLinEd"]
    pub fn btSliderConstraint_setRestitutionOrthoLin(
        this: *mut btSliderConstraint,
        restitutionOrthoLin: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint18setDampingOrthoLinEd"]
    pub fn btSliderConstraint_setDampingOrthoLin(
        this: *mut btSliderConstraint,
        dampingOrthoLin: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint19setSoftnessOrthoAngEd"]
    pub fn btSliderConstraint_setSoftnessOrthoAng(
        this: *mut btSliderConstraint,
        softnessOrthoAng: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint22setRestitutionOrthoAngEd"]
    pub fn btSliderConstraint_setRestitutionOrthoAng(
        this: *mut btSliderConstraint,
        restitutionOrthoAng: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint18setDampingOrthoAngEd"]
    pub fn btSliderConstraint_setDampingOrthoAng(
        this: *mut btSliderConstraint,
        dampingOrthoAng: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint18setPoweredLinMotorEb"]
    pub fn btSliderConstraint_setPoweredLinMotor(this: *mut btSliderConstraint, onOff: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint18getPoweredLinMotorEv"]
    pub fn btSliderConstraint_getPoweredLinMotor(this: *mut btSliderConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint25setTargetLinMotorVelocityEd"]
    pub fn btSliderConstraint_setTargetLinMotorVelocity(
        this: *mut btSliderConstraint,
        targetLinMotorVelocity: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint25getTargetLinMotorVelocityEv"]
    pub fn btSliderConstraint_getTargetLinMotorVelocity(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint19setMaxLinMotorForceEd"]
    pub fn btSliderConstraint_setMaxLinMotorForce(
        this: *mut btSliderConstraint,
        maxLinMotorForce: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint19getMaxLinMotorForceEv"]
    pub fn btSliderConstraint_getMaxLinMotorForce(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint18setPoweredAngMotorEb"]
    pub fn btSliderConstraint_setPoweredAngMotor(this: *mut btSliderConstraint, onOff: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint18getPoweredAngMotorEv"]
    pub fn btSliderConstraint_getPoweredAngMotor(this: *mut btSliderConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint25setTargetAngMotorVelocityEd"]
    pub fn btSliderConstraint_setTargetAngMotorVelocity(
        this: *mut btSliderConstraint,
        targetAngMotorVelocity: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint25getTargetAngMotorVelocityEv"]
    pub fn btSliderConstraint_getTargetAngMotorVelocity(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint19setMaxAngMotorForceEd"]
    pub fn btSliderConstraint_setMaxAngMotorForce(
        this: *mut btSliderConstraint,
        maxAngMotorForce: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint19getMaxAngMotorForceEv"]
    pub fn btSliderConstraint_getMaxAngMotorForce(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btSliderConstraint12getLinearPosEv"]
    pub fn btSliderConstraint_getLinearPos(this: *const btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btSliderConstraint13getAngularPosEv"]
    pub fn btSliderConstraint_getAngularPos(this: *const btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16getSolveLinLimitEv"]
    pub fn btSliderConstraint_getSolveLinLimit(this: *mut btSliderConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint11getLinDepthEv"]
    pub fn btSliderConstraint_getLinDepth(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint16getSolveAngLimitEv"]
    pub fn btSliderConstraint_getSolveAngLimit(this: *mut btSliderConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint11getAngDepthEv"]
    pub fn btSliderConstraint_getAngDepth(this: *mut btSliderConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint19calculateTransformsERK11btTransformS2_"]
    pub fn btSliderConstraint_calculateTransforms(
        this: *mut btSliderConstraint,
        transA: *const btTransform,
        transB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint13testLinLimitsEv"]
    pub fn btSliderConstraint_testLinLimits(this: *mut btSliderConstraint);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint13testAngLimitsEv"]
    pub fn btSliderConstraint_testAngLimits(this: *mut btSliderConstraint);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint11getAncorInAEv"]
    pub fn btSliderConstraint_getAncorInA(this: *mut btSliderConstraint) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint11getAncorInBEv"]
    pub fn btSliderConstraint_getAncorInB(this: *mut btSliderConstraint) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint17getUseFrameOffsetEv"]
    pub fn btSliderConstraint_getUseFrameOffset(this: *mut btSliderConstraint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint17setUseFrameOffsetEb"]
    pub fn btSliderConstraint_setUseFrameOffset(
        this: *mut btSliderConstraint,
        frameOffsetOnOff: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint9setFramesERK11btTransformS2_"]
    pub fn btSliderConstraint_setFrames(
        this: *mut btSliderConstraint,
        frameA: *const btTransform,
        frameB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b"]
    pub fn btSliderConstraint_btSliderConstraint(
        this: *mut btSliderConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraintC1ER11btRigidBodyRK11btTransformb"]
    pub fn btSliderConstraint_btSliderConstraint1(
        this: *mut btSliderConstraint,
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    );
}
impl btSliderConstraint {
    #[inline]
    pub unsafe fn initParams(&mut self) {
        btSliderConstraint_initParams(self)
    }
    #[inline]
    pub unsafe fn getInfo1NonVirtual(&mut self, info: *mut btTypedConstraint_btConstraintInfo1) {
        btSliderConstraint_getInfo1NonVirtual(self, info)
    }
    #[inline]
    pub unsafe fn getInfo2NonVirtual(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        rbAinvMass: btScalar,
        rbBinvMass: btScalar,
    ) {
        btSliderConstraint_getInfo2NonVirtual(
            self,
            info,
            transA,
            transB,
            linVelA,
            linVelB,
            rbAinvMass,
            rbBinvMass,
        )
    }
    #[inline]
    pub unsafe fn getRigidBodyA(&self) -> *const btRigidBody {
        btSliderConstraint_getRigidBodyA(self)
    }
    #[inline]
    pub unsafe fn getRigidBodyB(&self) -> *const btRigidBody {
        btSliderConstraint_getRigidBodyB(self)
    }
    #[inline]
    pub unsafe fn getCalculatedTransformA(&self) -> *const btTransform {
        btSliderConstraint_getCalculatedTransformA(self)
    }
    #[inline]
    pub unsafe fn getCalculatedTransformB(&self) -> *const btTransform {
        btSliderConstraint_getCalculatedTransformB(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetA(&self) -> *const btTransform {
        btSliderConstraint_getFrameOffsetA(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetB(&self) -> *const btTransform {
        btSliderConstraint_getFrameOffsetB(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetA1(&mut self) -> *mut btTransform {
        btSliderConstraint_getFrameOffsetA1(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetB1(&mut self) -> *mut btTransform {
        btSliderConstraint_getFrameOffsetB1(self)
    }
    #[inline]
    pub unsafe fn getLowerLinLimit(&mut self) -> btScalar {
        btSliderConstraint_getLowerLinLimit(self)
    }
    #[inline]
    pub unsafe fn setLowerLinLimit(&mut self, lowerLimit: btScalar) {
        btSliderConstraint_setLowerLinLimit(self, lowerLimit)
    }
    #[inline]
    pub unsafe fn getUpperLinLimit(&mut self) -> btScalar {
        btSliderConstraint_getUpperLinLimit(self)
    }
    #[inline]
    pub unsafe fn setUpperLinLimit(&mut self, upperLimit: btScalar) {
        btSliderConstraint_setUpperLinLimit(self, upperLimit)
    }
    #[inline]
    pub unsafe fn getLowerAngLimit(&mut self) -> btScalar {
        btSliderConstraint_getLowerAngLimit(self)
    }
    #[inline]
    pub unsafe fn setLowerAngLimit(&mut self, lowerLimit: btScalar) {
        btSliderConstraint_setLowerAngLimit(self, lowerLimit)
    }
    #[inline]
    pub unsafe fn getUpperAngLimit(&mut self) -> btScalar {
        btSliderConstraint_getUpperAngLimit(self)
    }
    #[inline]
    pub unsafe fn setUpperAngLimit(&mut self, upperLimit: btScalar) {
        btSliderConstraint_setUpperAngLimit(self, upperLimit)
    }
    #[inline]
    pub unsafe fn getUseLinearReferenceFrameA(&mut self) -> bool {
        btSliderConstraint_getUseLinearReferenceFrameA(self)
    }
    #[inline]
    pub unsafe fn getSoftnessDirLin(&mut self) -> btScalar {
        btSliderConstraint_getSoftnessDirLin(self)
    }
    #[inline]
    pub unsafe fn getRestitutionDirLin(&mut self) -> btScalar {
        btSliderConstraint_getRestitutionDirLin(self)
    }
    #[inline]
    pub unsafe fn getDampingDirLin(&mut self) -> btScalar {
        btSliderConstraint_getDampingDirLin(self)
    }
    #[inline]
    pub unsafe fn getSoftnessDirAng(&mut self) -> btScalar {
        btSliderConstraint_getSoftnessDirAng(self)
    }
    #[inline]
    pub unsafe fn getRestitutionDirAng(&mut self) -> btScalar {
        btSliderConstraint_getRestitutionDirAng(self)
    }
    #[inline]
    pub unsafe fn getDampingDirAng(&mut self) -> btScalar {
        btSliderConstraint_getDampingDirAng(self)
    }
    #[inline]
    pub unsafe fn getSoftnessLimLin(&mut self) -> btScalar {
        btSliderConstraint_getSoftnessLimLin(self)
    }
    #[inline]
    pub unsafe fn getRestitutionLimLin(&mut self) -> btScalar {
        btSliderConstraint_getRestitutionLimLin(self)
    }
    #[inline]
    pub unsafe fn getDampingLimLin(&mut self) -> btScalar {
        btSliderConstraint_getDampingLimLin(self)
    }
    #[inline]
    pub unsafe fn getSoftnessLimAng(&mut self) -> btScalar {
        btSliderConstraint_getSoftnessLimAng(self)
    }
    #[inline]
    pub unsafe fn getRestitutionLimAng(&mut self) -> btScalar {
        btSliderConstraint_getRestitutionLimAng(self)
    }
    #[inline]
    pub unsafe fn getDampingLimAng(&mut self) -> btScalar {
        btSliderConstraint_getDampingLimAng(self)
    }
    #[inline]
    pub unsafe fn getSoftnessOrthoLin(&mut self) -> btScalar {
        btSliderConstraint_getSoftnessOrthoLin(self)
    }
    #[inline]
    pub unsafe fn getRestitutionOrthoLin(&mut self) -> btScalar {
        btSliderConstraint_getRestitutionOrthoLin(self)
    }
    #[inline]
    pub unsafe fn getDampingOrthoLin(&mut self) -> btScalar {
        btSliderConstraint_getDampingOrthoLin(self)
    }
    #[inline]
    pub unsafe fn getSoftnessOrthoAng(&mut self) -> btScalar {
        btSliderConstraint_getSoftnessOrthoAng(self)
    }
    #[inline]
    pub unsafe fn getRestitutionOrthoAng(&mut self) -> btScalar {
        btSliderConstraint_getRestitutionOrthoAng(self)
    }
    #[inline]
    pub unsafe fn getDampingOrthoAng(&mut self) -> btScalar {
        btSliderConstraint_getDampingOrthoAng(self)
    }
    #[inline]
    pub unsafe fn setSoftnessDirLin(&mut self, softnessDirLin: btScalar) {
        btSliderConstraint_setSoftnessDirLin(self, softnessDirLin)
    }
    #[inline]
    pub unsafe fn setRestitutionDirLin(&mut self, restitutionDirLin: btScalar) {
        btSliderConstraint_setRestitutionDirLin(self, restitutionDirLin)
    }
    #[inline]
    pub unsafe fn setDampingDirLin(&mut self, dampingDirLin: btScalar) {
        btSliderConstraint_setDampingDirLin(self, dampingDirLin)
    }
    #[inline]
    pub unsafe fn setSoftnessDirAng(&mut self, softnessDirAng: btScalar) {
        btSliderConstraint_setSoftnessDirAng(self, softnessDirAng)
    }
    #[inline]
    pub unsafe fn setRestitutionDirAng(&mut self, restitutionDirAng: btScalar) {
        btSliderConstraint_setRestitutionDirAng(self, restitutionDirAng)
    }
    #[inline]
    pub unsafe fn setDampingDirAng(&mut self, dampingDirAng: btScalar) {
        btSliderConstraint_setDampingDirAng(self, dampingDirAng)
    }
    #[inline]
    pub unsafe fn setSoftnessLimLin(&mut self, softnessLimLin: btScalar) {
        btSliderConstraint_setSoftnessLimLin(self, softnessLimLin)
    }
    #[inline]
    pub unsafe fn setRestitutionLimLin(&mut self, restitutionLimLin: btScalar) {
        btSliderConstraint_setRestitutionLimLin(self, restitutionLimLin)
    }
    #[inline]
    pub unsafe fn setDampingLimLin(&mut self, dampingLimLin: btScalar) {
        btSliderConstraint_setDampingLimLin(self, dampingLimLin)
    }
    #[inline]
    pub unsafe fn setSoftnessLimAng(&mut self, softnessLimAng: btScalar) {
        btSliderConstraint_setSoftnessLimAng(self, softnessLimAng)
    }
    #[inline]
    pub unsafe fn setRestitutionLimAng(&mut self, restitutionLimAng: btScalar) {
        btSliderConstraint_setRestitutionLimAng(self, restitutionLimAng)
    }
    #[inline]
    pub unsafe fn setDampingLimAng(&mut self, dampingLimAng: btScalar) {
        btSliderConstraint_setDampingLimAng(self, dampingLimAng)
    }
    #[inline]
    pub unsafe fn setSoftnessOrthoLin(&mut self, softnessOrthoLin: btScalar) {
        btSliderConstraint_setSoftnessOrthoLin(self, softnessOrthoLin)
    }
    #[inline]
    pub unsafe fn setRestitutionOrthoLin(&mut self, restitutionOrthoLin: btScalar) {
        btSliderConstraint_setRestitutionOrthoLin(self, restitutionOrthoLin)
    }
    #[inline]
    pub unsafe fn setDampingOrthoLin(&mut self, dampingOrthoLin: btScalar) {
        btSliderConstraint_setDampingOrthoLin(self, dampingOrthoLin)
    }
    #[inline]
    pub unsafe fn setSoftnessOrthoAng(&mut self, softnessOrthoAng: btScalar) {
        btSliderConstraint_setSoftnessOrthoAng(self, softnessOrthoAng)
    }
    #[inline]
    pub unsafe fn setRestitutionOrthoAng(&mut self, restitutionOrthoAng: btScalar) {
        btSliderConstraint_setRestitutionOrthoAng(self, restitutionOrthoAng)
    }
    #[inline]
    pub unsafe fn setDampingOrthoAng(&mut self, dampingOrthoAng: btScalar) {
        btSliderConstraint_setDampingOrthoAng(self, dampingOrthoAng)
    }
    #[inline]
    pub unsafe fn setPoweredLinMotor(&mut self, onOff: bool) {
        btSliderConstraint_setPoweredLinMotor(self, onOff)
    }
    #[inline]
    pub unsafe fn getPoweredLinMotor(&mut self) -> bool {
        btSliderConstraint_getPoweredLinMotor(self)
    }
    #[inline]
    pub unsafe fn setTargetLinMotorVelocity(&mut self, targetLinMotorVelocity: btScalar) {
        btSliderConstraint_setTargetLinMotorVelocity(self, targetLinMotorVelocity)
    }
    #[inline]
    pub unsafe fn getTargetLinMotorVelocity(&mut self) -> btScalar {
        btSliderConstraint_getTargetLinMotorVelocity(self)
    }
    #[inline]
    pub unsafe fn setMaxLinMotorForce(&mut self, maxLinMotorForce: btScalar) {
        btSliderConstraint_setMaxLinMotorForce(self, maxLinMotorForce)
    }
    #[inline]
    pub unsafe fn getMaxLinMotorForce(&mut self) -> btScalar {
        btSliderConstraint_getMaxLinMotorForce(self)
    }
    #[inline]
    pub unsafe fn setPoweredAngMotor(&mut self, onOff: bool) {
        btSliderConstraint_setPoweredAngMotor(self, onOff)
    }
    #[inline]
    pub unsafe fn getPoweredAngMotor(&mut self) -> bool {
        btSliderConstraint_getPoweredAngMotor(self)
    }
    #[inline]
    pub unsafe fn setTargetAngMotorVelocity(&mut self, targetAngMotorVelocity: btScalar) {
        btSliderConstraint_setTargetAngMotorVelocity(self, targetAngMotorVelocity)
    }
    #[inline]
    pub unsafe fn getTargetAngMotorVelocity(&mut self) -> btScalar {
        btSliderConstraint_getTargetAngMotorVelocity(self)
    }
    #[inline]
    pub unsafe fn setMaxAngMotorForce(&mut self, maxAngMotorForce: btScalar) {
        btSliderConstraint_setMaxAngMotorForce(self, maxAngMotorForce)
    }
    #[inline]
    pub unsafe fn getMaxAngMotorForce(&mut self) -> btScalar {
        btSliderConstraint_getMaxAngMotorForce(self)
    }
    #[inline]
    pub unsafe fn getLinearPos(&self) -> btScalar {
        btSliderConstraint_getLinearPos(self)
    }
    #[inline]
    pub unsafe fn getAngularPos(&self) -> btScalar {
        btSliderConstraint_getAngularPos(self)
    }
    #[inline]
    pub unsafe fn getSolveLinLimit(&mut self) -> bool {
        btSliderConstraint_getSolveLinLimit(self)
    }
    #[inline]
    pub unsafe fn getLinDepth(&mut self) -> btScalar {
        btSliderConstraint_getLinDepth(self)
    }
    #[inline]
    pub unsafe fn getSolveAngLimit(&mut self) -> bool {
        btSliderConstraint_getSolveAngLimit(self)
    }
    #[inline]
    pub unsafe fn getAngDepth(&mut self) -> btScalar {
        btSliderConstraint_getAngDepth(self)
    }
    #[inline]
    pub unsafe fn calculateTransforms(
        &mut self,
        transA: *const btTransform,
        transB: *const btTransform,
    ) {
        btSliderConstraint_calculateTransforms(self, transA, transB)
    }
    #[inline]
    pub unsafe fn testLinLimits(&mut self) {
        btSliderConstraint_testLinLimits(self)
    }
    #[inline]
    pub unsafe fn testAngLimits(&mut self) {
        btSliderConstraint_testAngLimits(self)
    }
    #[inline]
    pub unsafe fn getAncorInA(&mut self) -> btVector3 {
        btSliderConstraint_getAncorInA(self)
    }
    #[inline]
    pub unsafe fn getAncorInB(&mut self) -> btVector3 {
        btSliderConstraint_getAncorInB(self)
    }
    #[inline]
    pub unsafe fn getUseFrameOffset(&mut self) -> bool {
        btSliderConstraint_getUseFrameOffset(self)
    }
    #[inline]
    pub unsafe fn setUseFrameOffset(&mut self, frameOffsetOnOff: bool) {
        btSliderConstraint_setUseFrameOffset(self, frameOffsetOnOff)
    }
    #[inline]
    pub unsafe fn setFrames(&mut self, frameA: *const btTransform, frameB: *const btTransform) {
        btSliderConstraint_setFrames(self, frameA, frameB)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSliderConstraint_btSliderConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            frameInA,
            frameInB,
            useLinearReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSliderConstraint_btSliderConstraint1(
            &mut __bindgen_tmp,
            rbB,
            frameInB,
            useLinearReferenceFrameA,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
    pub fn btSliderConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btSliderConstraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
    pub fn btSliderConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {

    /// override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    /// ///If no axis is provided, it uses the default axis for this constraint.

    #[link_name = "\u{1}_ZN18btSliderConstraint8setParamEidi"]
    pub fn btSliderConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: btScalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// return the local value of parameter

    #[link_name = "\u{1}_ZNK18btSliderConstraint8getParamEii"]
    pub fn btSliderConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btSliderConstraint8getFlagsEv"]
    pub fn btSliderConstraint_getFlags(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btSliderConstraint28calculateSerializeBufferSizeEv"]
    pub fn btSliderConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK18btSliderConstraint9serializeEPvP12btSerializer"]
    pub fn btSliderConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSliderConstraintData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_rbAFrame: btTransformFloatData,
    pub m_rbBFrame: btTransformFloatData,
    pub m_linearUpperLimit: f32,
    pub m_linearLowerLimit: f32,
    pub m_angularUpperLimit: f32,
    pub m_angularLowerLimit: f32,
    pub m_useLinearReferenceFrameA: ::std::os::raw::c_int,
    pub m_useOffsetForConstraintFrame: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btSliderConstraintData() {
    assert_eq!(
        ::std::mem::size_of::<btSliderConstraintData>(),
        216usize,
        concat!("Size of: ", stringify!(btSliderConstraintData))
    );
    assert_eq!(
        ::std::mem::align_of::<btSliderConstraintData>(),
        8usize,
        concat!("Alignment of ", stringify!(btSliderConstraintData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraintData)).m_typeConstraintData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintData),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraintData)).m_rbAFrame as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintData),
            "::",
            stringify!(m_rbAFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraintData)).m_rbBFrame as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintData),
            "::",
            stringify!(m_rbBFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraintData)).m_linearUpperLimit as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintData),
            "::",
            stringify!(m_linearUpperLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraintData)).m_linearLowerLimit as *const _ as usize },
        196usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintData),
            "::",
            stringify!(m_linearLowerLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraintData)).m_angularUpperLimit as *const _ as usize
        },
        200usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintData),
            "::",
            stringify!(m_angularUpperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraintData)).m_angularLowerLimit as *const _ as usize
        },
        204usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintData),
            "::",
            stringify!(m_angularLowerLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraintData)).m_useLinearReferenceFrameA as *const _ as usize
        },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintData),
            "::",
            stringify!(m_useLinearReferenceFrameA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraintData)).m_useOffsetForConstraintFrame as *const _
                as usize
        },
        212usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintData),
            "::",
            stringify!(m_useOffsetForConstraintFrame)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSliderConstraintDoubleData {
    pub m_typeConstraintData: btTypedConstraintDoubleData,
    pub m_rbAFrame: btTransformDoubleData,
    pub m_rbBFrame: btTransformDoubleData,
    pub m_linearUpperLimit: f64,
    pub m_linearLowerLimit: f64,
    pub m_angularUpperLimit: f64,
    pub m_angularLowerLimit: f64,
    pub m_useLinearReferenceFrameA: ::std::os::raw::c_int,
    pub m_useOffsetForConstraintFrame: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btSliderConstraintDoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btSliderConstraintDoubleData>(),
        376usize,
        concat!("Size of: ", stringify!(btSliderConstraintDoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btSliderConstraintDoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btSliderConstraintDoubleData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraintDoubleData)).m_typeConstraintData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintDoubleData),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraintDoubleData)).m_rbAFrame as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintDoubleData),
            "::",
            stringify!(m_rbAFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btSliderConstraintDoubleData)).m_rbBFrame as *const _ as usize },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintDoubleData),
            "::",
            stringify!(m_rbBFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraintDoubleData)).m_linearUpperLimit as *const _ as usize
        },
        336usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintDoubleData),
            "::",
            stringify!(m_linearUpperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraintDoubleData)).m_linearLowerLimit as *const _ as usize
        },
        344usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintDoubleData),
            "::",
            stringify!(m_linearLowerLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraintDoubleData)).m_angularUpperLimit as *const _ as usize
        },
        352usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintDoubleData),
            "::",
            stringify!(m_angularUpperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraintDoubleData)).m_angularLowerLimit as *const _ as usize
        },
        360usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintDoubleData),
            "::",
            stringify!(m_angularLowerLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraintDoubleData)).m_useLinearReferenceFrameA as *const _
                as usize
        },
        368usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintDoubleData),
            "::",
            stringify!(m_useLinearReferenceFrameA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSliderConstraintDoubleData)).m_useOffsetForConstraintFrame as *const _
                as usize
        },
        372usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSliderConstraintDoubleData),
            "::",
            stringify!(m_useOffsetForConstraintFrame)
        )
    );
}
/// DOF index used in enableSpring() and setStiffness() means:
/// 0 : translation X
/// 1 : translation Y
/// 2 : translation Z
/// 3 : rotation X (3rd Euler rotational around new position of X axis, range [-PI+epsilon, PI-epsilon] )
/// 4 : rotation Y (2nd Euler rotational around new position of Y axis, range [-PI/2+epsilon, PI/2-epsilon] )
/// 5 : rotation Z (1st Euler rotational around Z axis, range [-PI+epsilon, PI-epsilon] )
#[repr(C)]
pub struct btGeneric6DofSpringConstraint {
    pub _base: btTypedConstraint,
    /// !< the constraint space w.r.t body A
    pub m_frameInA: btTransform,
    /// !< the constraint space w.r.t body B
    pub m_frameInB: btTransform,
    /// !< 3 orthogonal linear constraints
    pub m_jacLinear: [btJacobianEntry; 3usize],
    /// !< 3 orthogonal angular constraints
    pub m_jacAng: [btJacobianEntry; 3usize],
    /// ! Linear_Limit_parameters
    /// //!@{
    pub m_linearLimits: btTranslationalLimitMotor,
    /// ! hinge_parameters
    /// //!@{
    pub m_angularLimits: [btRotationalLimitMotor; 3usize],
    /// ! temporal variables
    /// //!@{
    pub m_timeStep: btScalar,
    pub m_calculatedTransformA: btTransform,
    pub m_calculatedTransformB: btTransform,
    pub m_calculatedAxisAngleDiff: btVector3,
    pub m_calculatedAxis: [btVector3; 3usize],
    pub m_calculatedLinearDiff: btVector3,
    pub m_factA: btScalar,
    pub m_factB: btScalar,
    pub m_hasStaticBody: bool,
    pub m_AnchorPos: btVector3,
    pub m_useLinearReferenceFrameA: bool,
    pub m_useOffsetForConstraintFrame: bool,
    pub m_flags: ::std::os::raw::c_int,
    /// for backwards compatibility during the transition to 'getInfo/getInfo2'
    pub m_useSolveConstraintObsolete: bool,

    pub m_springEnabled: [bool; 6usize],
    pub m_equilibriumPoint: [btScalar; 6usize],
    pub m_springStiffness: [btScalar; 6usize],
    pub m_springDamping: [btScalar; 6usize],
}
#[test]
fn bindgen_test_layout_btGeneric6DofSpringConstraint() {
    assert_eq!(
        ::std::mem::size_of::<btGeneric6DofSpringConstraint>(),
        2736usize,
        concat!("Size of: ", stringify!(btGeneric6DofSpringConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<btGeneric6DofSpringConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(btGeneric6DofSpringConstraint))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpringConstraint)).m_springEnabled as *const _ as usize
        },
        2585usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpringConstraint),
            "::",
            stringify!(m_springEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpringConstraint)).m_equilibriumPoint as *const _ as usize
        },
        2592usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpringConstraint),
            "::",
            stringify!(m_equilibriumPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpringConstraint)).m_springStiffness as *const _ as usize
        },
        2640usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpringConstraint),
            "::",
            stringify!(m_springStiffness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpringConstraint)).m_springDamping as *const _ as usize
        },
        2688usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpringConstraint),
            "::",
            stringify!(m_springDamping)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint4initEv"]
    pub fn btGeneric6DofSpringConstraint_init(this: *mut btGeneric6DofSpringConstraint);
}
extern "C" {
    #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint21internalUpdateSpringsEPN17btTypedConstraint17btConstraintInfo2E"]
    pub fn btGeneric6DofSpringConstraint_internalUpdateSprings(
        this: *mut btGeneric6DofSpringConstraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint12enableSpringEib"]
    pub fn btGeneric6DofSpringConstraint_enableSpring(
        this: *mut btGeneric6DofSpringConstraint,
        index: ::std::os::raw::c_int,
        onOff: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint12setStiffnessEid"]
    pub fn btGeneric6DofSpringConstraint_setStiffness(
        this: *mut btGeneric6DofSpringConstraint,
        index: ::std::os::raw::c_int,
        stiffness: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint10setDampingEid"]
    pub fn btGeneric6DofSpringConstraint_setDamping(
        this: *mut btGeneric6DofSpringConstraint,
        index: ::std::os::raw::c_int,
        damping: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint19setEquilibriumPointEv"]
    pub fn btGeneric6DofSpringConstraint_setEquilibriumPoint(
        this: *mut btGeneric6DofSpringConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint19setEquilibriumPointEi"]
    pub fn btGeneric6DofSpringConstraint_setEquilibriumPoint1(
        this: *mut btGeneric6DofSpringConstraint,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint19setEquilibriumPointEid"]
    pub fn btGeneric6DofSpringConstraint_setEquilibriumPoint2(
        this: *mut btGeneric6DofSpringConstraint,
        index: ::std::os::raw::c_int,
        val: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK29btGeneric6DofSpringConstraint15isSpringEnabledEi"]
    pub fn btGeneric6DofSpringConstraint_isSpringEnabled(
        this: *const btGeneric6DofSpringConstraint,
        index: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK29btGeneric6DofSpringConstraint12getStiffnessEi"]
    pub fn btGeneric6DofSpringConstraint_getStiffness(
        this: *const btGeneric6DofSpringConstraint,
        index: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK29btGeneric6DofSpringConstraint10getDampingEi"]
    pub fn btGeneric6DofSpringConstraint_getDamping(
        this: *const btGeneric6DofSpringConstraint,
        index: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK29btGeneric6DofSpringConstraint19getEquilibriumPointEi"]
    pub fn btGeneric6DofSpringConstraint_getEquilibriumPoint(
        this: *const btGeneric6DofSpringConstraint,
        index: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b"]
    pub fn btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint(
        this: *mut btGeneric6DofSpringConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraintC1ER11btRigidBodyRK11btTransformb"]
    pub fn btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint1(
        this: *mut btGeneric6DofSpringConstraint,
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        useLinearReferenceFrameB: bool,
    );
}
impl btGeneric6DofSpringConstraint {
    #[inline]
    pub unsafe fn init(&mut self) {
        btGeneric6DofSpringConstraint_init(self)
    }
    #[inline]
    pub unsafe fn internalUpdateSprings(&mut self, info: *mut btTypedConstraint_btConstraintInfo2) {
        btGeneric6DofSpringConstraint_internalUpdateSprings(self, info)
    }
    #[inline]
    pub unsafe fn enableSpring(&mut self, index: ::std::os::raw::c_int, onOff: bool) {
        btGeneric6DofSpringConstraint_enableSpring(self, index, onOff)
    }
    #[inline]
    pub unsafe fn setStiffness(&mut self, index: ::std::os::raw::c_int, stiffness: btScalar) {
        btGeneric6DofSpringConstraint_setStiffness(self, index, stiffness)
    }
    #[inline]
    pub unsafe fn setDamping(&mut self, index: ::std::os::raw::c_int, damping: btScalar) {
        btGeneric6DofSpringConstraint_setDamping(self, index, damping)
    }
    #[inline]
    pub unsafe fn setEquilibriumPoint(&mut self) {
        btGeneric6DofSpringConstraint_setEquilibriumPoint(self)
    }
    #[inline]
    pub unsafe fn setEquilibriumPoint1(&mut self, index: ::std::os::raw::c_int) {
        btGeneric6DofSpringConstraint_setEquilibriumPoint1(self, index)
    }
    #[inline]
    pub unsafe fn setEquilibriumPoint2(&mut self, index: ::std::os::raw::c_int, val: btScalar) {
        btGeneric6DofSpringConstraint_setEquilibriumPoint2(self, index, val)
    }
    #[inline]
    pub unsafe fn isSpringEnabled(&self, index: ::std::os::raw::c_int) -> bool {
        btGeneric6DofSpringConstraint_isSpringEnabled(self, index)
    }
    #[inline]
    pub unsafe fn getStiffness(&self, index: ::std::os::raw::c_int) -> btScalar {
        btGeneric6DofSpringConstraint_getStiffness(self, index)
    }
    #[inline]
    pub unsafe fn getDamping(&self, index: ::std::os::raw::c_int) -> btScalar {
        btGeneric6DofSpringConstraint_getDamping(self, index)
    }
    #[inline]
    pub unsafe fn getEquilibriumPoint(&self, index: ::std::os::raw::c_int) -> btScalar {
        btGeneric6DofSpringConstraint_getEquilibriumPoint(self, index)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        useLinearReferenceFrameA: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            frameInA,
            frameInB,
            useLinearReferenceFrameA,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        useLinearReferenceFrameB: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint1(
            &mut __bindgen_tmp,
            rbB,
            frameInB,
            useLinearReferenceFrameB,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint7setAxisERK9btVector3S2_"]
    pub fn btGeneric6DofSpringConstraint_setAxis(
        this: *mut ::std::os::raw::c_void,
        axis1: *const btVector3,
        axis2: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN29btGeneric6DofSpringConstraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
    pub fn btGeneric6DofSpringConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK29btGeneric6DofSpringConstraint28calculateSerializeBufferSizeEv"]
    pub fn btGeneric6DofSpringConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK29btGeneric6DofSpringConstraint9serializeEPvP12btSerializer"]
    pub fn btGeneric6DofSpringConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGeneric6DofSpringConstraintData {
    pub m_6dofData: btGeneric6DofConstraintData,
    pub m_springEnabled: [::std::os::raw::c_int; 6usize],
    pub m_equilibriumPoint: [f32; 6usize],
    pub m_springStiffness: [f32; 6usize],
    pub m_springDamping: [f32; 6usize],
}
#[test]
fn bindgen_test_layout_btGeneric6DofSpringConstraintData() {
    assert_eq!(
        ::std::mem::size_of::<btGeneric6DofSpringConstraintData>(),
        360usize,
        concat!("Size of: ", stringify!(btGeneric6DofSpringConstraintData))
    );
    assert_eq!(
        ::std::mem::align_of::<btGeneric6DofSpringConstraintData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btGeneric6DofSpringConstraintData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpringConstraintData)).m_6dofData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpringConstraintData),
            "::",
            stringify!(m_6dofData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpringConstraintData)).m_springEnabled as *const _ as usize
        },
        264usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpringConstraintData),
            "::",
            stringify!(m_springEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpringConstraintData)).m_equilibriumPoint as *const _
                as usize
        },
        288usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpringConstraintData),
            "::",
            stringify!(m_equilibriumPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpringConstraintData)).m_springStiffness as *const _
                as usize
        },
        312usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpringConstraintData),
            "::",
            stringify!(m_springStiffness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpringConstraintData)).m_springDamping as *const _ as usize
        },
        336usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpringConstraintData),
            "::",
            stringify!(m_springDamping)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGeneric6DofSpringConstraintDoubleData2 {
    pub m_6dofData: btGeneric6DofConstraintDoubleData2,
    pub m_springEnabled: [::std::os::raw::c_int; 6usize],
    pub m_equilibriumPoint: [f64; 6usize],
    pub m_springStiffness: [f64; 6usize],
    pub m_springDamping: [f64; 6usize],
}
#[test]
fn bindgen_test_layout_btGeneric6DofSpringConstraintDoubleData2() {
    assert_eq!(
        ::std::mem::size_of::<btGeneric6DofSpringConstraintDoubleData2>(),
        640usize,
        concat!(
            "Size of: ",
            stringify!(btGeneric6DofSpringConstraintDoubleData2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btGeneric6DofSpringConstraintDoubleData2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btGeneric6DofSpringConstraintDoubleData2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpringConstraintDoubleData2)).m_6dofData as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpringConstraintDoubleData2),
            "::",
            stringify!(m_6dofData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpringConstraintDoubleData2)).m_springEnabled as *const _
                as usize
        },
        472usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpringConstraintDoubleData2),
            "::",
            stringify!(m_springEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpringConstraintDoubleData2)).m_equilibriumPoint
                as *const _ as usize
        },
        496usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpringConstraintDoubleData2),
            "::",
            stringify!(m_equilibriumPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpringConstraintDoubleData2)).m_springStiffness as *const _
                as usize
        },
        544usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpringConstraintDoubleData2),
            "::",
            stringify!(m_springStiffness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpringConstraintDoubleData2)).m_springDamping as *const _
                as usize
        },
        592usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpringConstraintDoubleData2),
            "::",
            stringify!(m_springDamping)
        )
    );
}
/// Constraint similar to ODE Universal Joint
/// has 2 rotatioonal degrees of freedom, similar to Euler rotations around Z (axis 1)
/// and Y (axis 2)
/// Description from ODE manual :
/// "Given axis 1 on body 1, and axis 2 on body 2 that is perpendicular to axis 1, it keeps them perpendicular.
/// In other words, rotation of the two bodies about the direction perpendicular to the two axes will be equal."
#[repr(C)]
pub struct btUniversalConstraint {
    pub _base: btGeneric6DofConstraint,
    pub m_anchor: btVector3,
    pub m_axis1: btVector3,
    pub m_axis2: btVector3,
}
#[test]
fn bindgen_test_layout_btUniversalConstraint() {
    assert_eq!(
        ::std::mem::size_of::<btUniversalConstraint>(),
        2688usize,
        concat!("Size of: ", stringify!(btUniversalConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<btUniversalConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(btUniversalConstraint))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btUniversalConstraint)).m_anchor as *const _ as usize },
        2592usize,
        concat!(
            "Alignment of field: ",
            stringify!(btUniversalConstraint),
            "::",
            stringify!(m_anchor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btUniversalConstraint)).m_axis1 as *const _ as usize },
        2624usize,
        concat!(
            "Alignment of field: ",
            stringify!(btUniversalConstraint),
            "::",
            stringify!(m_axis1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btUniversalConstraint)).m_axis2 as *const _ as usize },
        2656usize,
        concat!(
            "Alignment of field: ",
            stringify!(btUniversalConstraint),
            "::",
            stringify!(m_axis2)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniversalConstraint9getAnchorEv"]
    pub fn btUniversalConstraint_getAnchor(this: *mut btUniversalConstraint) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniversalConstraint10getAnchor2Ev"]
    pub fn btUniversalConstraint_getAnchor2(this: *mut btUniversalConstraint) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniversalConstraint8getAxis1Ev"]
    pub fn btUniversalConstraint_getAxis1(this: *mut btUniversalConstraint) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniversalConstraint8getAxis2Ev"]
    pub fn btUniversalConstraint_getAxis2(this: *mut btUniversalConstraint) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniversalConstraint9getAngle1Ev"]
    pub fn btUniversalConstraint_getAngle1(this: *mut btUniversalConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniversalConstraint9getAngle2Ev"]
    pub fn btUniversalConstraint_getAngle2(this: *mut btUniversalConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniversalConstraint13setUpperLimitEdd"]
    pub fn btUniversalConstraint_setUpperLimit(
        this: *mut btUniversalConstraint,
        ang1max: btScalar,
        ang2max: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniversalConstraint13setLowerLimitEdd"]
    pub fn btUniversalConstraint_setLowerLimit(
        this: *mut btUniversalConstraint,
        ang1min: btScalar,
        ang2min: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniversalConstraint7setAxisERK9btVector3S2_"]
    pub fn btUniversalConstraint_setAxis(
        this: *mut btUniversalConstraint,
        axis1: *const btVector3,
        axis2: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN21btUniversalConstraintC1ER11btRigidBodyS1_RK9btVector3S4_S4_"]
    pub fn btUniversalConstraint_btUniversalConstraint(
        this: *mut btUniversalConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        anchor: *const btVector3,
        axis1: *const btVector3,
        axis2: *const btVector3,
    );
}
impl btUniversalConstraint {
    #[inline]
    pub unsafe fn getAnchor(&mut self) -> *const btVector3 {
        btUniversalConstraint_getAnchor(self)
    }
    #[inline]
    pub unsafe fn getAnchor2(&mut self) -> *const btVector3 {
        btUniversalConstraint_getAnchor2(self)
    }
    #[inline]
    pub unsafe fn getAxis1(&mut self) -> *const btVector3 {
        btUniversalConstraint_getAxis1(self)
    }
    #[inline]
    pub unsafe fn getAxis2(&mut self) -> *const btVector3 {
        btUniversalConstraint_getAxis2(self)
    }
    #[inline]
    pub unsafe fn getAngle1(&mut self) -> btScalar {
        btUniversalConstraint_getAngle1(self)
    }
    #[inline]
    pub unsafe fn getAngle2(&mut self) -> btScalar {
        btUniversalConstraint_getAngle2(self)
    }
    #[inline]
    pub unsafe fn setUpperLimit(&mut self, ang1max: btScalar, ang2max: btScalar) {
        btUniversalConstraint_setUpperLimit(self, ang1max, ang2max)
    }
    #[inline]
    pub unsafe fn setLowerLimit(&mut self, ang1min: btScalar, ang2min: btScalar) {
        btUniversalConstraint_setLowerLimit(self, ang1min, ang2min)
    }
    #[inline]
    pub unsafe fn setAxis(&mut self, axis1: *const btVector3, axis2: *const btVector3) {
        btUniversalConstraint_setAxis(self, axis1, axis2)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        anchor: *const btVector3,
        axis1: *const btVector3,
        axis2: *const btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btUniversalConstraint_btUniversalConstraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            anchor,
            axis1,
            axis2,
        );
        __bindgen_tmp
    }
}
pub const RotateOrder_RO_XYZ: RotateOrder = 0;
pub const RotateOrder_RO_XZY: RotateOrder = 1;
pub const RotateOrder_RO_YXZ: RotateOrder = 2;
pub const RotateOrder_RO_YZX: RotateOrder = 3;
pub const RotateOrder_RO_ZXY: RotateOrder = 4;
pub const RotateOrder_RO_ZYX: RotateOrder = 5;
pub type RotateOrder = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btRotationalLimitMotor2 {
    pub m_loLimit: btScalar,
    pub m_hiLimit: btScalar,
    pub m_bounce: btScalar,
    pub m_stopERP: btScalar,
    pub m_stopCFM: btScalar,
    pub m_motorERP: btScalar,
    pub m_motorCFM: btScalar,
    pub m_enableMotor: bool,
    pub m_targetVelocity: btScalar,
    pub m_maxMotorForce: btScalar,
    pub m_servoMotor: bool,
    pub m_servoTarget: btScalar,
    pub m_enableSpring: bool,
    pub m_springStiffness: btScalar,
    pub m_springStiffnessLimited: bool,
    pub m_springDamping: btScalar,
    pub m_springDampingLimited: bool,
    pub m_equilibriumPoint: btScalar,
    pub m_currentLimitError: btScalar,
    pub m_currentLimitErrorHi: btScalar,
    pub m_currentPosition: btScalar,
    pub m_currentLimit: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btRotationalLimitMotor2() {
    assert_eq!(
        ::std::mem::size_of::<btRotationalLimitMotor2>(),
        176usize,
        concat!("Size of: ", stringify!(btRotationalLimitMotor2))
    );
    assert_eq!(
        ::std::mem::align_of::<btRotationalLimitMotor2>(),
        8usize,
        concat!("Alignment of ", stringify!(btRotationalLimitMotor2))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_loLimit as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_loLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_hiLimit as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_hiLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_bounce as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_bounce)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_stopERP as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_stopERP)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_stopCFM as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_stopCFM)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_motorERP as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_motorERP)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_motorCFM as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_motorCFM)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_enableMotor as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_enableMotor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_targetVelocity as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_targetVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_maxMotorForce as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_maxMotorForce)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_servoMotor as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_servoMotor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_servoTarget as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_servoTarget)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_enableSpring as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_enableSpring)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_springStiffness as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_springStiffness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRotationalLimitMotor2)).m_springStiffnessLimited as *const _ as usize
        },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_springStiffnessLimited)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_springDamping as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_springDamping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRotationalLimitMotor2)).m_springDampingLimited as *const _ as usize
        },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_springDampingLimited)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRotationalLimitMotor2)).m_equilibriumPoint as *const _ as usize
        },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_equilibriumPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRotationalLimitMotor2)).m_currentLimitError as *const _ as usize
        },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_currentLimitError)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRotationalLimitMotor2)).m_currentLimitErrorHi as *const _ as usize
        },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_currentLimitErrorHi)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_currentPosition as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_currentPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRotationalLimitMotor2)).m_currentLimit as *const _ as usize },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRotationalLimitMotor2),
            "::",
            stringify!(m_currentLimit)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btRotationalLimitMotor29isLimitedEv"]
    pub fn btRotationalLimitMotor2_isLimited(this: *mut btRotationalLimitMotor2) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN23btRotationalLimitMotor214testLimitValueEd"]
    pub fn btRotationalLimitMotor2_testLimitValue(
        this: *mut btRotationalLimitMotor2,
        test_value: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN23btRotationalLimitMotor2C1Ev"]
    pub fn btRotationalLimitMotor2_btRotationalLimitMotor2(this: *mut btRotationalLimitMotor2);
}
extern "C" {
    #[link_name = "\u{1}_ZN23btRotationalLimitMotor2C1ERKS_"]
    pub fn btRotationalLimitMotor2_btRotationalLimitMotor21(
        this: *mut btRotationalLimitMotor2,
        limot: *const btRotationalLimitMotor2,
    );
}
impl btRotationalLimitMotor2 {
    #[inline]
    pub unsafe fn isLimited(&mut self) -> bool {
        btRotationalLimitMotor2_isLimited(self)
    }
    #[inline]
    pub unsafe fn testLimitValue(&mut self, test_value: btScalar) {
        btRotationalLimitMotor2_testLimitValue(self, test_value)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btRotationalLimitMotor2_btRotationalLimitMotor2(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(limot: *const btRotationalLimitMotor2) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btRotationalLimitMotor2_btRotationalLimitMotor21(&mut __bindgen_tmp, limot);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btTranslationalLimitMotor2 {
    pub m_lowerLimit: btVector3,
    pub m_upperLimit: btVector3,
    pub m_bounce: btVector3,
    pub m_stopERP: btVector3,
    pub m_stopCFM: btVector3,
    pub m_motorERP: btVector3,
    pub m_motorCFM: btVector3,
    pub m_enableMotor: [bool; 3usize],
    pub m_servoMotor: [bool; 3usize],
    pub m_enableSpring: [bool; 3usize],
    pub m_servoTarget: btVector3,
    pub m_springStiffness: btVector3,
    pub m_springStiffnessLimited: [bool; 3usize],
    pub m_springDamping: btVector3,
    pub m_springDampingLimited: [bool; 3usize],
    pub m_equilibriumPoint: btVector3,
    pub m_targetVelocity: btVector3,
    pub m_maxMotorForce: btVector3,
    pub m_currentLimitError: btVector3,
    pub m_currentLimitErrorHi: btVector3,
    pub m_currentLinearDiff: btVector3,
    pub m_currentLimit: [::std::os::raw::c_int; 3usize],
}
#[test]
fn bindgen_test_layout_btTranslationalLimitMotor2() {
    assert_eq!(
        ::std::mem::size_of::<btTranslationalLimitMotor2>(),
        560usize,
        concat!("Size of: ", stringify!(btTranslationalLimitMotor2))
    );
    assert_eq!(
        ::std::mem::align_of::<btTranslationalLimitMotor2>(),
        8usize,
        concat!("Alignment of ", stringify!(btTranslationalLimitMotor2))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor2)).m_lowerLimit as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_lowerLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor2)).m_upperLimit as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_upperLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor2)).m_bounce as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_bounce)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor2)).m_stopERP as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_stopERP)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor2)).m_stopCFM as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_stopCFM)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor2)).m_motorERP as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_motorERP)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor2)).m_motorCFM as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_motorCFM)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor2)).m_enableMotor as *const _ as usize },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_enableMotor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor2)).m_servoMotor as *const _ as usize },
        227usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_servoMotor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor2)).m_enableSpring as *const _ as usize },
        230usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_enableSpring)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor2)).m_servoTarget as *const _ as usize },
        240usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_servoTarget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTranslationalLimitMotor2)).m_springStiffness as *const _ as usize
        },
        272usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_springStiffness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTranslationalLimitMotor2)).m_springStiffnessLimited as *const _
                as usize
        },
        304usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_springStiffnessLimited)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTranslationalLimitMotor2)).m_springDamping as *const _ as usize
        },
        312usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_springDamping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTranslationalLimitMotor2)).m_springDampingLimited as *const _ as usize
        },
        344usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_springDampingLimited)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTranslationalLimitMotor2)).m_equilibriumPoint as *const _ as usize
        },
        352usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_equilibriumPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTranslationalLimitMotor2)).m_targetVelocity as *const _ as usize
        },
        384usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_targetVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTranslationalLimitMotor2)).m_maxMotorForce as *const _ as usize
        },
        416usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_maxMotorForce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTranslationalLimitMotor2)).m_currentLimitError as *const _ as usize
        },
        448usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_currentLimitError)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTranslationalLimitMotor2)).m_currentLimitErrorHi as *const _ as usize
        },
        480usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_currentLimitErrorHi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btTranslationalLimitMotor2)).m_currentLinearDiff as *const _ as usize
        },
        512usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_currentLinearDiff)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btTranslationalLimitMotor2)).m_currentLimit as *const _ as usize },
        544usize,
        concat!(
            "Alignment of field: ",
            stringify!(btTranslationalLimitMotor2),
            "::",
            stringify!(m_currentLimit)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN26btTranslationalLimitMotor29isLimitedEi"]
    pub fn btTranslationalLimitMotor2_isLimited(
        this: *mut btTranslationalLimitMotor2,
        limitIndex: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN26btTranslationalLimitMotor214testLimitValueEid"]
    pub fn btTranslationalLimitMotor2_testLimitValue(
        this: *mut btTranslationalLimitMotor2,
        limitIndex: ::std::os::raw::c_int,
        test_value: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN26btTranslationalLimitMotor2C1Ev"]
    pub fn btTranslationalLimitMotor2_btTranslationalLimitMotor2(
        this: *mut btTranslationalLimitMotor2,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN26btTranslationalLimitMotor2C1ERKS_"]
    pub fn btTranslationalLimitMotor2_btTranslationalLimitMotor21(
        this: *mut btTranslationalLimitMotor2,
        other: *const btTranslationalLimitMotor2,
    );
}
impl btTranslationalLimitMotor2 {
    #[inline]
    pub unsafe fn isLimited(&mut self, limitIndex: ::std::os::raw::c_int) -> bool {
        btTranslationalLimitMotor2_isLimited(self, limitIndex)
    }
    #[inline]
    pub unsafe fn testLimitValue(
        &mut self,
        limitIndex: ::std::os::raw::c_int,
        test_value: btScalar,
    ) {
        btTranslationalLimitMotor2_testLimitValue(self, limitIndex, test_value)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTranslationalLimitMotor2_btTranslationalLimitMotor2(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(other: *const btTranslationalLimitMotor2) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btTranslationalLimitMotor2_btTranslationalLimitMotor21(&mut __bindgen_tmp, other);
        __bindgen_tmp
    }
}
pub const bt6DofFlags2_BT_6DOF_FLAGS_CFM_STOP2: bt6DofFlags2 = 1;
pub const bt6DofFlags2_BT_6DOF_FLAGS_ERP_STOP2: bt6DofFlags2 = 2;
pub const bt6DofFlags2_BT_6DOF_FLAGS_CFM_MOTO2: bt6DofFlags2 = 4;
pub const bt6DofFlags2_BT_6DOF_FLAGS_ERP_MOTO2: bt6DofFlags2 = 8;
pub type bt6DofFlags2 = ::std::os::raw::c_uint;
#[repr(C)]
pub struct btGeneric6DofSpring2Constraint {
    pub _base: btTypedConstraint,
    pub m_frameInA: btTransform,
    pub m_frameInB: btTransform,
    pub m_jacLinear: [btJacobianEntry; 3usize],
    pub m_jacAng: [btJacobianEntry; 3usize],
    pub m_linearLimits: btTranslationalLimitMotor2,
    pub m_angularLimits: [btRotationalLimitMotor2; 3usize],
    pub m_rotateOrder: RotateOrder,
    pub m_calculatedTransformA: btTransform,
    pub m_calculatedTransformB: btTransform,
    pub m_calculatedAxisAngleDiff: btVector3,
    pub m_calculatedAxis: [btVector3; 3usize],
    pub m_calculatedLinearDiff: btVector3,
    pub m_factA: btScalar,
    pub m_factB: btScalar,
    pub m_hasStaticBody: bool,
    pub m_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btGeneric6DofSpring2Constraint() {
    assert_eq!(
        ::std::mem::size_of::<btGeneric6DofSpring2Constraint>(),
        2880usize,
        concat!("Size of: ", stringify!(btGeneric6DofSpring2Constraint))
    );
    assert_eq!(
        ::std::mem::align_of::<btGeneric6DofSpring2Constraint>(),
        8usize,
        concat!("Alignment of ", stringify!(btGeneric6DofSpring2Constraint))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofSpring2Constraint)).m_frameInA as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_frameInA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofSpring2Constraint)).m_frameInB as *const _ as usize },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_frameInB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2Constraint)).m_jacLinear as *const _ as usize
        },
        336usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_jacLinear)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofSpring2Constraint)).m_jacAng as *const _ as usize },
        840usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_jacAng)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2Constraint)).m_linearLimits as *const _ as usize
        },
        1344usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_linearLimits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2Constraint)).m_angularLimits as *const _ as usize
        },
        1904usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_angularLimits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2Constraint)).m_rotateOrder as *const _ as usize
        },
        2432usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_rotateOrder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2Constraint)).m_calculatedTransformA as *const _
                as usize
        },
        2440usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_calculatedTransformA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2Constraint)).m_calculatedTransformB as *const _
                as usize
        },
        2568usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_calculatedTransformB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2Constraint)).m_calculatedAxisAngleDiff as *const _
                as usize
        },
        2696usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_calculatedAxisAngleDiff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2Constraint)).m_calculatedAxis as *const _ as usize
        },
        2728usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_calculatedAxis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2Constraint)).m_calculatedLinearDiff as *const _
                as usize
        },
        2824usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_calculatedLinearDiff)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofSpring2Constraint)).m_factA as *const _ as usize },
        2856usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_factA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofSpring2Constraint)).m_factB as *const _ as usize },
        2864usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_factB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2Constraint)).m_hasStaticBody as *const _ as usize
        },
        2872usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_hasStaticBody)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGeneric6DofSpring2Constraint)).m_flags as *const _ as usize },
        2876usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2Constraint),
            "::",
            stringify!(m_flags)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16setAngularLimitsEPN17btTypedConstraint17btConstraintInfo2EiRK11btTransformS5_RK9btVector3S8_S8_S8_"]
    pub fn btGeneric6DofSpring2Constraint_setAngularLimits(
        this: *mut btGeneric6DofSpring2Constraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row_offset: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint15setLinearLimitsEPN17btTypedConstraint17btConstraintInfo2EiRK11btTransformS5_RK9btVector3S8_S8_S8_"]
    pub fn btGeneric6DofSpring2Constraint_setLinearLimits(
        this: *mut btGeneric6DofSpring2Constraint,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19calculateLinearInfoEv"]
    pub fn btGeneric6DofSpring2Constraint_calculateLinearInfo(
        this: *mut btGeneric6DofSpring2Constraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint18calculateAngleInfoEv"]
    pub fn btGeneric6DofSpring2Constraint_calculateAngleInfo(
        this: *mut btGeneric6DofSpring2Constraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint21testAngularLimitMotorEi"]
    pub fn btGeneric6DofSpring2Constraint_testAngularLimitMotor(
        this: *mut btGeneric6DofSpring2Constraint,
        axis_index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint15calculateJacobiEP23btRotationalLimitMotor2RK11btTransformS4_PN17btTypedConstraint17btConstraintInfo2EiR9btVector3ii"]
    pub fn btGeneric6DofSpring2Constraint_calculateJacobi(
        this: *mut btGeneric6DofSpring2Constraint,
        limot: *mut btRotationalLimitMotor2,
        transA: *const btTransform,
        transB: *const btTransform,
        info: *mut btTypedConstraint_btConstraintInfo2,
        srow: ::std::os::raw::c_int,
        ax1: *mut btVector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint21get_limit_motor_info2EP23btRotationalLimitMotor2RK11btTransformS4_RK9btVector3S7_S7_S7_PN17btTypedConstraint17btConstraintInfo2EiRS5_ii"]
    pub fn btGeneric6DofSpring2Constraint_get_limit_motor_info2(
        this: *mut btGeneric6DofSpring2Constraint,
        limot: *mut btRotationalLimitMotor2,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        ax1: *mut btVector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint23getRotationalLimitMotorEi"]
    pub fn btGeneric6DofSpring2Constraint_getRotationalLimitMotor(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
    ) -> *mut btRotationalLimitMotor2;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint26getTranslationalLimitMotorEv"]
    pub fn btGeneric6DofSpring2Constraint_getTranslationalLimitMotor(
        this: *mut btGeneric6DofSpring2Constraint,
    ) -> *mut btTranslationalLimitMotor2;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19calculateTransformsERK11btTransformS2_"]
    pub fn btGeneric6DofSpring2Constraint_calculateTransforms(
        this: *mut btGeneric6DofSpring2Constraint,
        transA: *const btTransform,
        transB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19calculateTransformsEv"]
    pub fn btGeneric6DofSpring2Constraint_calculateTransforms1(
        this: *mut btGeneric6DofSpring2Constraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK30btGeneric6DofSpring2Constraint23getCalculatedTransformAEv"]
    pub fn btGeneric6DofSpring2Constraint_getCalculatedTransformA(
        this: *const btGeneric6DofSpring2Constraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK30btGeneric6DofSpring2Constraint23getCalculatedTransformBEv"]
    pub fn btGeneric6DofSpring2Constraint_getCalculatedTransformB(
        this: *const btGeneric6DofSpring2Constraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK30btGeneric6DofSpring2Constraint15getFrameOffsetAEv"]
    pub fn btGeneric6DofSpring2Constraint_getFrameOffsetA(
        this: *const btGeneric6DofSpring2Constraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK30btGeneric6DofSpring2Constraint15getFrameOffsetBEv"]
    pub fn btGeneric6DofSpring2Constraint_getFrameOffsetB(
        this: *const btGeneric6DofSpring2Constraint,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint15getFrameOffsetAEv"]
    pub fn btGeneric6DofSpring2Constraint_getFrameOffsetA1(
        this: *mut btGeneric6DofSpring2Constraint,
    ) -> *mut btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint15getFrameOffsetBEv"]
    pub fn btGeneric6DofSpring2Constraint_getFrameOffsetB1(
        this: *mut btGeneric6DofSpring2Constraint,
    ) -> *mut btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZNK30btGeneric6DofSpring2Constraint7getAxisEi"]
    pub fn btGeneric6DofSpring2Constraint_getAxis(
        this: *const btGeneric6DofSpring2Constraint,
        axis_index: ::std::os::raw::c_int,
    ) -> btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK30btGeneric6DofSpring2Constraint8getAngleEi"]
    pub fn btGeneric6DofSpring2Constraint_getAngle(
        this: *const btGeneric6DofSpring2Constraint,
        axis_index: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK30btGeneric6DofSpring2Constraint24getRelativePivotPositionEi"]
    pub fn btGeneric6DofSpring2Constraint_getRelativePivotPosition(
        this: *const btGeneric6DofSpring2Constraint,
        axis_index: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint9setFramesERK11btTransformS2_"]
    pub fn btGeneric6DofSpring2Constraint_setFrames(
        this: *mut btGeneric6DofSpring2Constraint,
        frameA: *const btTransform,
        frameB: *const btTransform,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19setLinearLowerLimitERK9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_setLinearLowerLimit(
        this: *mut btGeneric6DofSpring2Constraint,
        linearLower: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19getLinearLowerLimitER9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_getLinearLowerLimit(
        this: *mut btGeneric6DofSpring2Constraint,
        linearLower: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19setLinearUpperLimitERK9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_setLinearUpperLimit(
        this: *mut btGeneric6DofSpring2Constraint,
        linearUpper: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19getLinearUpperLimitER9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_getLinearUpperLimit(
        this: *mut btGeneric6DofSpring2Constraint,
        linearUpper: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint20setAngularLowerLimitERK9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_setAngularLowerLimit(
        this: *mut btGeneric6DofSpring2Constraint,
        angularLower: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint28setAngularLowerLimitReversedERK9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_setAngularLowerLimitReversed(
        this: *mut btGeneric6DofSpring2Constraint,
        angularLower: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint20getAngularLowerLimitER9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_getAngularLowerLimit(
        this: *mut btGeneric6DofSpring2Constraint,
        angularLower: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint28getAngularLowerLimitReversedER9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_getAngularLowerLimitReversed(
        this: *mut btGeneric6DofSpring2Constraint,
        angularLower: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint20setAngularUpperLimitERK9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_setAngularUpperLimit(
        this: *mut btGeneric6DofSpring2Constraint,
        angularUpper: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint28setAngularUpperLimitReversedERK9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_setAngularUpperLimitReversed(
        this: *mut btGeneric6DofSpring2Constraint,
        angularUpper: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint20getAngularUpperLimitER9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_getAngularUpperLimit(
        this: *mut btGeneric6DofSpring2Constraint,
        angularUpper: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint28getAngularUpperLimitReversedER9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_getAngularUpperLimitReversed(
        this: *mut btGeneric6DofSpring2Constraint,
        angularUpper: *mut btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint8setLimitEidd"]
    pub fn btGeneric6DofSpring2Constraint_setLimit(
        this: *mut btGeneric6DofSpring2Constraint,
        axis: ::std::os::raw::c_int,
        lo: btScalar,
        hi: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16setLimitReversedEidd"]
    pub fn btGeneric6DofSpring2Constraint_setLimitReversed(
        this: *mut btGeneric6DofSpring2Constraint,
        axis: ::std::os::raw::c_int,
        lo: btScalar,
        hi: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint9isLimitedEi"]
    pub fn btGeneric6DofSpring2Constraint_isLimited(
        this: *mut btGeneric6DofSpring2Constraint,
        limitIndex: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16setRotationOrderE11RotateOrder"]
    pub fn btGeneric6DofSpring2Constraint_setRotationOrder(
        this: *mut btGeneric6DofSpring2Constraint,
        order: RotateOrder,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16getRotationOrderEv"]
    pub fn btGeneric6DofSpring2Constraint_getRotationOrder(
        this: *mut btGeneric6DofSpring2Constraint,
    ) -> RotateOrder;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint7setAxisERK9btVector3S2_"]
    pub fn btGeneric6DofSpring2Constraint_setAxis(
        this: *mut btGeneric6DofSpring2Constraint,
        axis1: *const btVector3,
        axis2: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint9setBounceEid"]
    pub fn btGeneric6DofSpring2Constraint_setBounce(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        bounce: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint11enableMotorEib"]
    pub fn btGeneric6DofSpring2Constraint_enableMotor(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        onOff: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint8setServoEib"]
    pub fn btGeneric6DofSpring2Constraint_setServo(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        onOff: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint17setTargetVelocityEid"]
    pub fn btGeneric6DofSpring2Constraint_setTargetVelocity(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        velocity: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint14setServoTargetEid"]
    pub fn btGeneric6DofSpring2Constraint_setServoTarget(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        target: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16setMaxMotorForceEid"]
    pub fn btGeneric6DofSpring2Constraint_setMaxMotorForce(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        force: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint12enableSpringEib"]
    pub fn btGeneric6DofSpring2Constraint_enableSpring(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        onOff: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint12setStiffnessEidb"]
    pub fn btGeneric6DofSpring2Constraint_setStiffness(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        stiffness: btScalar,
        limitIfNeeded: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint10setDampingEidb"]
    pub fn btGeneric6DofSpring2Constraint_setDamping(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        damping: btScalar,
        limitIfNeeded: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19setEquilibriumPointEv"]
    pub fn btGeneric6DofSpring2Constraint_setEquilibriumPoint(
        this: *mut btGeneric6DofSpring2Constraint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19setEquilibriumPointEi"]
    pub fn btGeneric6DofSpring2Constraint_setEquilibriumPoint1(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint19setEquilibriumPointEid"]
    pub fn btGeneric6DofSpring2Constraint_setEquilibriumPoint2(
        this: *mut btGeneric6DofSpring2Constraint,
        index: ::std::os::raw::c_int,
        val: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint15btGetMatrixElemERK11btMatrix3x3i"]
    pub fn btGeneric6DofSpring2Constraint_btGetMatrixElem(
        mat: *const btMatrix3x3,
        index: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16matrixToEulerXYZERK11btMatrix3x3R9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_matrixToEulerXYZ(
        mat: *const btMatrix3x3,
        xyz: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16matrixToEulerXZYERK11btMatrix3x3R9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_matrixToEulerXZY(
        mat: *const btMatrix3x3,
        xyz: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16matrixToEulerYXZERK11btMatrix3x3R9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_matrixToEulerYXZ(
        mat: *const btMatrix3x3,
        xyz: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16matrixToEulerYZXERK11btMatrix3x3R9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_matrixToEulerYZX(
        mat: *const btMatrix3x3,
        xyz: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16matrixToEulerZXYERK11btMatrix3x3R9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_matrixToEulerZXY(
        mat: *const btMatrix3x3,
        xyz: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint16matrixToEulerZYXERK11btMatrix3x3R9btVector3"]
    pub fn btGeneric6DofSpring2Constraint_matrixToEulerZYX(
        mat: *const btMatrix3x3,
        xyz: *mut btVector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2ConstraintC1ER11btRigidBodyS1_RK11btTransformS4_11RotateOrder"]
    pub fn btGeneric6DofSpring2Constraint_btGeneric6DofSpring2Constraint(
        this: *mut btGeneric6DofSpring2Constraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        rotOrder: RotateOrder,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2ConstraintC1ER11btRigidBodyRK11btTransform11RotateOrder"]
    pub fn btGeneric6DofSpring2Constraint_btGeneric6DofSpring2Constraint1(
        this: *mut btGeneric6DofSpring2Constraint,
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        rotOrder: RotateOrder,
    );
}
impl btGeneric6DofSpring2Constraint {
    #[inline]
    pub unsafe fn setAngularLimits(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row_offset: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int {
        btGeneric6DofSpring2Constraint_setAngularLimits(
            self,
            info,
            row_offset,
            transA,
            transB,
            linVelA,
            linVelB,
            angVelA,
            angVelB,
        )
    }
    #[inline]
    pub unsafe fn setLinearLimits(
        &mut self,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
    ) -> ::std::os::raw::c_int {
        btGeneric6DofSpring2Constraint_setLinearLimits(
            self,
            info,
            row,
            transA,
            transB,
            linVelA,
            linVelB,
            angVelA,
            angVelB,
        )
    }
    #[inline]
    pub unsafe fn calculateLinearInfo(&mut self) {
        btGeneric6DofSpring2Constraint_calculateLinearInfo(self)
    }
    #[inline]
    pub unsafe fn calculateAngleInfo(&mut self) {
        btGeneric6DofSpring2Constraint_calculateAngleInfo(self)
    }
    #[inline]
    pub unsafe fn testAngularLimitMotor(&mut self, axis_index: ::std::os::raw::c_int) {
        btGeneric6DofSpring2Constraint_testAngularLimitMotor(self, axis_index)
    }
    #[inline]
    pub unsafe fn calculateJacobi(
        &mut self,
        limot: *mut btRotationalLimitMotor2,
        transA: *const btTransform,
        transB: *const btTransform,
        info: *mut btTypedConstraint_btConstraintInfo2,
        srow: ::std::os::raw::c_int,
        ax1: *mut btVector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    ) {
        btGeneric6DofSpring2Constraint_calculateJacobi(
            self,
            limot,
            transA,
            transB,
            info,
            srow,
            ax1,
            rotational,
            rotAllowed,
        )
    }
    #[inline]
    pub unsafe fn get_limit_motor_info2(
        &mut self,
        limot: *mut btRotationalLimitMotor2,
        transA: *const btTransform,
        transB: *const btTransform,
        linVelA: *const btVector3,
        linVelB: *const btVector3,
        angVelA: *const btVector3,
        angVelB: *const btVector3,
        info: *mut btTypedConstraint_btConstraintInfo2,
        row: ::std::os::raw::c_int,
        ax1: *mut btVector3,
        rotational: ::std::os::raw::c_int,
        rotAllowed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        btGeneric6DofSpring2Constraint_get_limit_motor_info2(
            self,
            limot,
            transA,
            transB,
            linVelA,
            linVelB,
            angVelA,
            angVelB,
            info,
            row,
            ax1,
            rotational,
            rotAllowed,
        )
    }
    #[inline]
    pub unsafe fn getRotationalLimitMotor(
        &mut self,
        index: ::std::os::raw::c_int,
    ) -> *mut btRotationalLimitMotor2 {
        btGeneric6DofSpring2Constraint_getRotationalLimitMotor(self, index)
    }
    #[inline]
    pub unsafe fn getTranslationalLimitMotor(&mut self) -> *mut btTranslationalLimitMotor2 {
        btGeneric6DofSpring2Constraint_getTranslationalLimitMotor(self)
    }
    #[inline]
    pub unsafe fn calculateTransforms(
        &mut self,
        transA: *const btTransform,
        transB: *const btTransform,
    ) {
        btGeneric6DofSpring2Constraint_calculateTransforms(self, transA, transB)
    }
    #[inline]
    pub unsafe fn calculateTransforms1(&mut self) {
        btGeneric6DofSpring2Constraint_calculateTransforms1(self)
    }
    #[inline]
    pub unsafe fn getCalculatedTransformA(&self) -> *const btTransform {
        btGeneric6DofSpring2Constraint_getCalculatedTransformA(self)
    }
    #[inline]
    pub unsafe fn getCalculatedTransformB(&self) -> *const btTransform {
        btGeneric6DofSpring2Constraint_getCalculatedTransformB(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetA(&self) -> *const btTransform {
        btGeneric6DofSpring2Constraint_getFrameOffsetA(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetB(&self) -> *const btTransform {
        btGeneric6DofSpring2Constraint_getFrameOffsetB(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetA1(&mut self) -> *mut btTransform {
        btGeneric6DofSpring2Constraint_getFrameOffsetA1(self)
    }
    #[inline]
    pub unsafe fn getFrameOffsetB1(&mut self) -> *mut btTransform {
        btGeneric6DofSpring2Constraint_getFrameOffsetB1(self)
    }
    #[inline]
    pub unsafe fn getAxis(&self, axis_index: ::std::os::raw::c_int) -> btVector3 {
        btGeneric6DofSpring2Constraint_getAxis(self, axis_index)
    }
    #[inline]
    pub unsafe fn getAngle(&self, axis_index: ::std::os::raw::c_int) -> btScalar {
        btGeneric6DofSpring2Constraint_getAngle(self, axis_index)
    }
    #[inline]
    pub unsafe fn getRelativePivotPosition(&self, axis_index: ::std::os::raw::c_int) -> btScalar {
        btGeneric6DofSpring2Constraint_getRelativePivotPosition(self, axis_index)
    }
    #[inline]
    pub unsafe fn setFrames(&mut self, frameA: *const btTransform, frameB: *const btTransform) {
        btGeneric6DofSpring2Constraint_setFrames(self, frameA, frameB)
    }
    #[inline]
    pub unsafe fn setLinearLowerLimit(&mut self, linearLower: *const btVector3) {
        btGeneric6DofSpring2Constraint_setLinearLowerLimit(self, linearLower)
    }
    #[inline]
    pub unsafe fn getLinearLowerLimit(&mut self, linearLower: *mut btVector3) {
        btGeneric6DofSpring2Constraint_getLinearLowerLimit(self, linearLower)
    }
    #[inline]
    pub unsafe fn setLinearUpperLimit(&mut self, linearUpper: *const btVector3) {
        btGeneric6DofSpring2Constraint_setLinearUpperLimit(self, linearUpper)
    }
    #[inline]
    pub unsafe fn getLinearUpperLimit(&mut self, linearUpper: *mut btVector3) {
        btGeneric6DofSpring2Constraint_getLinearUpperLimit(self, linearUpper)
    }
    #[inline]
    pub unsafe fn setAngularLowerLimit(&mut self, angularLower: *const btVector3) {
        btGeneric6DofSpring2Constraint_setAngularLowerLimit(self, angularLower)
    }
    #[inline]
    pub unsafe fn setAngularLowerLimitReversed(&mut self, angularLower: *const btVector3) {
        btGeneric6DofSpring2Constraint_setAngularLowerLimitReversed(self, angularLower)
    }
    #[inline]
    pub unsafe fn getAngularLowerLimit(&mut self, angularLower: *mut btVector3) {
        btGeneric6DofSpring2Constraint_getAngularLowerLimit(self, angularLower)
    }
    #[inline]
    pub unsafe fn getAngularLowerLimitReversed(&mut self, angularLower: *mut btVector3) {
        btGeneric6DofSpring2Constraint_getAngularLowerLimitReversed(self, angularLower)
    }
    #[inline]
    pub unsafe fn setAngularUpperLimit(&mut self, angularUpper: *const btVector3) {
        btGeneric6DofSpring2Constraint_setAngularUpperLimit(self, angularUpper)
    }
    #[inline]
    pub unsafe fn setAngularUpperLimitReversed(&mut self, angularUpper: *const btVector3) {
        btGeneric6DofSpring2Constraint_setAngularUpperLimitReversed(self, angularUpper)
    }
    #[inline]
    pub unsafe fn getAngularUpperLimit(&mut self, angularUpper: *mut btVector3) {
        btGeneric6DofSpring2Constraint_getAngularUpperLimit(self, angularUpper)
    }
    #[inline]
    pub unsafe fn getAngularUpperLimitReversed(&mut self, angularUpper: *mut btVector3) {
        btGeneric6DofSpring2Constraint_getAngularUpperLimitReversed(self, angularUpper)
    }
    #[inline]
    pub unsafe fn setLimit(&mut self, axis: ::std::os::raw::c_int, lo: btScalar, hi: btScalar) {
        btGeneric6DofSpring2Constraint_setLimit(self, axis, lo, hi)
    }
    #[inline]
    pub unsafe fn setLimitReversed(
        &mut self,
        axis: ::std::os::raw::c_int,
        lo: btScalar,
        hi: btScalar,
    ) {
        btGeneric6DofSpring2Constraint_setLimitReversed(self, axis, lo, hi)
    }
    #[inline]
    pub unsafe fn isLimited(&mut self, limitIndex: ::std::os::raw::c_int) -> bool {
        btGeneric6DofSpring2Constraint_isLimited(self, limitIndex)
    }
    #[inline]
    pub unsafe fn setRotationOrder(&mut self, order: RotateOrder) {
        btGeneric6DofSpring2Constraint_setRotationOrder(self, order)
    }
    #[inline]
    pub unsafe fn getRotationOrder(&mut self) -> RotateOrder {
        btGeneric6DofSpring2Constraint_getRotationOrder(self)
    }
    #[inline]
    pub unsafe fn setAxis(&mut self, axis1: *const btVector3, axis2: *const btVector3) {
        btGeneric6DofSpring2Constraint_setAxis(self, axis1, axis2)
    }
    #[inline]
    pub unsafe fn setBounce(&mut self, index: ::std::os::raw::c_int, bounce: btScalar) {
        btGeneric6DofSpring2Constraint_setBounce(self, index, bounce)
    }
    #[inline]
    pub unsafe fn enableMotor(&mut self, index: ::std::os::raw::c_int, onOff: bool) {
        btGeneric6DofSpring2Constraint_enableMotor(self, index, onOff)
    }
    #[inline]
    pub unsafe fn setServo(&mut self, index: ::std::os::raw::c_int, onOff: bool) {
        btGeneric6DofSpring2Constraint_setServo(self, index, onOff)
    }
    #[inline]
    pub unsafe fn setTargetVelocity(&mut self, index: ::std::os::raw::c_int, velocity: btScalar) {
        btGeneric6DofSpring2Constraint_setTargetVelocity(self, index, velocity)
    }
    #[inline]
    pub unsafe fn setServoTarget(&mut self, index: ::std::os::raw::c_int, target: btScalar) {
        btGeneric6DofSpring2Constraint_setServoTarget(self, index, target)
    }
    #[inline]
    pub unsafe fn setMaxMotorForce(&mut self, index: ::std::os::raw::c_int, force: btScalar) {
        btGeneric6DofSpring2Constraint_setMaxMotorForce(self, index, force)
    }
    #[inline]
    pub unsafe fn enableSpring(&mut self, index: ::std::os::raw::c_int, onOff: bool) {
        btGeneric6DofSpring2Constraint_enableSpring(self, index, onOff)
    }
    #[inline]
    pub unsafe fn setStiffness(
        &mut self,
        index: ::std::os::raw::c_int,
        stiffness: btScalar,
        limitIfNeeded: bool,
    ) {
        btGeneric6DofSpring2Constraint_setStiffness(self, index, stiffness, limitIfNeeded)
    }
    #[inline]
    pub unsafe fn setDamping(
        &mut self,
        index: ::std::os::raw::c_int,
        damping: btScalar,
        limitIfNeeded: bool,
    ) {
        btGeneric6DofSpring2Constraint_setDamping(self, index, damping, limitIfNeeded)
    }
    #[inline]
    pub unsafe fn setEquilibriumPoint(&mut self) {
        btGeneric6DofSpring2Constraint_setEquilibriumPoint(self)
    }
    #[inline]
    pub unsafe fn setEquilibriumPoint1(&mut self, index: ::std::os::raw::c_int) {
        btGeneric6DofSpring2Constraint_setEquilibriumPoint1(self, index)
    }
    #[inline]
    pub unsafe fn setEquilibriumPoint2(&mut self, index: ::std::os::raw::c_int, val: btScalar) {
        btGeneric6DofSpring2Constraint_setEquilibriumPoint2(self, index, val)
    }
    #[inline]
    pub unsafe fn btGetMatrixElem(
        mat: *const btMatrix3x3,
        index: ::std::os::raw::c_int,
    ) -> btScalar {
        btGeneric6DofSpring2Constraint_btGetMatrixElem(mat, index)
    }
    #[inline]
    pub unsafe fn matrixToEulerXYZ(mat: *const btMatrix3x3, xyz: *mut btVector3) -> bool {
        btGeneric6DofSpring2Constraint_matrixToEulerXYZ(mat, xyz)
    }
    #[inline]
    pub unsafe fn matrixToEulerXZY(mat: *const btMatrix3x3, xyz: *mut btVector3) -> bool {
        btGeneric6DofSpring2Constraint_matrixToEulerXZY(mat, xyz)
    }
    #[inline]
    pub unsafe fn matrixToEulerYXZ(mat: *const btMatrix3x3, xyz: *mut btVector3) -> bool {
        btGeneric6DofSpring2Constraint_matrixToEulerYXZ(mat, xyz)
    }
    #[inline]
    pub unsafe fn matrixToEulerYZX(mat: *const btMatrix3x3, xyz: *mut btVector3) -> bool {
        btGeneric6DofSpring2Constraint_matrixToEulerYZX(mat, xyz)
    }
    #[inline]
    pub unsafe fn matrixToEulerZXY(mat: *const btMatrix3x3, xyz: *mut btVector3) -> bool {
        btGeneric6DofSpring2Constraint_matrixToEulerZXY(mat, xyz)
    }
    #[inline]
    pub unsafe fn matrixToEulerZYX(mat: *const btMatrix3x3, xyz: *mut btVector3) -> bool {
        btGeneric6DofSpring2Constraint_matrixToEulerZYX(mat, xyz)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
        rotOrder: RotateOrder,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGeneric6DofSpring2Constraint_btGeneric6DofSpring2Constraint(
            &mut __bindgen_tmp,
            rbA,
            rbB,
            frameInA,
            frameInB,
            rotOrder,
        );
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        rbB: *mut btRigidBody,
        frameInB: *const btTransform,
        rotOrder: RotateOrder,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGeneric6DofSpring2Constraint_btGeneric6DofSpring2Constraint1(
            &mut __bindgen_tmp,
            rbB,
            frameInB,
            rotOrder,
        );
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint13buildJacobianEv"]
    pub fn btGeneric6DofSpring2Constraint_buildJacobian(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
    pub fn btGeneric6DofSpring2Constraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
    pub fn btGeneric6DofSpring2Constraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK30btGeneric6DofSpring2Constraint28calculateSerializeBufferSizeEv"]
    pub fn btGeneric6DofSpring2Constraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK30btGeneric6DofSpring2Constraint9serializeEPvP12btSerializer"]
    pub fn btGeneric6DofSpring2Constraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN30btGeneric6DofSpring2Constraint8setParamEidi"]
    pub fn btGeneric6DofSpring2Constraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: btScalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK30btGeneric6DofSpring2Constraint8getParamEii"]
    pub fn btGeneric6DofSpring2Constraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> btScalar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGeneric6DofSpring2ConstraintData {
    pub m_typeConstraintData: btTypedConstraintData,
    pub m_rbAFrame: btTransformFloatData,
    pub m_rbBFrame: btTransformFloatData,
    pub m_linearUpperLimit: btVector3FloatData,
    pub m_linearLowerLimit: btVector3FloatData,
    pub m_linearBounce: btVector3FloatData,
    pub m_linearStopERP: btVector3FloatData,
    pub m_linearStopCFM: btVector3FloatData,
    pub m_linearMotorERP: btVector3FloatData,
    pub m_linearMotorCFM: btVector3FloatData,
    pub m_linearTargetVelocity: btVector3FloatData,
    pub m_linearMaxMotorForce: btVector3FloatData,
    pub m_linearServoTarget: btVector3FloatData,
    pub m_linearSpringStiffness: btVector3FloatData,
    pub m_linearSpringDamping: btVector3FloatData,
    pub m_linearEquilibriumPoint: btVector3FloatData,
    pub m_linearEnableMotor: [::std::os::raw::c_char; 4usize],
    pub m_linearServoMotor: [::std::os::raw::c_char; 4usize],
    pub m_linearEnableSpring: [::std::os::raw::c_char; 4usize],
    pub m_linearSpringStiffnessLimited: [::std::os::raw::c_char; 4usize],
    pub m_linearSpringDampingLimited: [::std::os::raw::c_char; 4usize],
    pub m_padding1: [::std::os::raw::c_char; 4usize],
    pub m_angularUpperLimit: btVector3FloatData,
    pub m_angularLowerLimit: btVector3FloatData,
    pub m_angularBounce: btVector3FloatData,
    pub m_angularStopERP: btVector3FloatData,
    pub m_angularStopCFM: btVector3FloatData,
    pub m_angularMotorERP: btVector3FloatData,
    pub m_angularMotorCFM: btVector3FloatData,
    pub m_angularTargetVelocity: btVector3FloatData,
    pub m_angularMaxMotorForce: btVector3FloatData,
    pub m_angularServoTarget: btVector3FloatData,
    pub m_angularSpringStiffness: btVector3FloatData,
    pub m_angularSpringDamping: btVector3FloatData,
    pub m_angularEquilibriumPoint: btVector3FloatData,
    pub m_angularEnableMotor: [::std::os::raw::c_char; 4usize],
    pub m_angularServoMotor: [::std::os::raw::c_char; 4usize],
    pub m_angularEnableSpring: [::std::os::raw::c_char; 4usize],
    pub m_angularSpringStiffnessLimited: [::std::os::raw::c_char; 4usize],
    pub m_angularSpringDampingLimited: [::std::os::raw::c_char; 4usize],
    pub m_rotateOrder: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btGeneric6DofSpring2ConstraintData() {
    assert_eq!(
        ::std::mem::size_of::<btGeneric6DofSpring2ConstraintData>(),
        656usize,
        concat!("Size of: ", stringify!(btGeneric6DofSpring2ConstraintData))
    );
    assert_eq!(
        ::std::mem::align_of::<btGeneric6DofSpring2ConstraintData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btGeneric6DofSpring2ConstraintData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_typeConstraintData as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_rbAFrame as *const _ as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_rbAFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_rbBFrame as *const _ as usize
        },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_rbBFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearUpperLimit as *const _
                as usize
        },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearUpperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearLowerLimit as *const _
                as usize
        },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearLowerLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearBounce as *const _ as usize
        },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearBounce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearStopERP as *const _
                as usize
        },
        240usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearStopERP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearStopCFM as *const _
                as usize
        },
        256usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearStopCFM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearMotorERP as *const _
                as usize
        },
        272usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearMotorERP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearMotorCFM as *const _
                as usize
        },
        288usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearMotorCFM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearTargetVelocity as *const _
                as usize
        },
        304usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearTargetVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearMaxMotorForce as *const _
                as usize
        },
        320usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearMaxMotorForce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearServoTarget as *const _
                as usize
        },
        336usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearServoTarget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearSpringStiffness as *const _
                as usize
        },
        352usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearSpringStiffness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearSpringDamping as *const _
                as usize
        },
        368usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearSpringDamping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearEquilibriumPoint
                as *const _ as usize
        },
        384usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearEquilibriumPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearEnableMotor as *const _
                as usize
        },
        400usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearEnableMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearServoMotor as *const _
                as usize
        },
        404usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearServoMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearEnableSpring as *const _
                as usize
        },
        408usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearEnableSpring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearSpringStiffnessLimited
                as *const _ as usize
        },
        412usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearSpringStiffnessLimited)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_linearSpringDampingLimited
                as *const _ as usize
        },
        416usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_linearSpringDampingLimited)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_padding1 as *const _ as usize
        },
        420usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularUpperLimit as *const _
                as usize
        },
        424usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularUpperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularLowerLimit as *const _
                as usize
        },
        440usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularLowerLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularBounce as *const _
                as usize
        },
        456usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularBounce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularStopERP as *const _
                as usize
        },
        472usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularStopERP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularStopCFM as *const _
                as usize
        },
        488usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularStopCFM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularMotorERP as *const _
                as usize
        },
        504usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularMotorERP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularMotorCFM as *const _
                as usize
        },
        520usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularMotorCFM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularTargetVelocity as *const _
                as usize
        },
        536usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularTargetVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularMaxMotorForce as *const _
                as usize
        },
        552usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularMaxMotorForce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularServoTarget as *const _
                as usize
        },
        568usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularServoTarget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularSpringStiffness
                as *const _ as usize
        },
        584usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularSpringStiffness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularSpringDamping as *const _
                as usize
        },
        600usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularSpringDamping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularEquilibriumPoint
                as *const _ as usize
        },
        616usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularEquilibriumPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularEnableMotor as *const _
                as usize
        },
        632usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularEnableMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularServoMotor as *const _
                as usize
        },
        636usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularServoMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularEnableSpring as *const _
                as usize
        },
        640usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularEnableSpring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularSpringStiffnessLimited
                as *const _ as usize
        },
        644usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularSpringStiffnessLimited)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_angularSpringDampingLimited
                as *const _ as usize
        },
        648usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_angularSpringDampingLimited)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintData)).m_rotateOrder as *const _ as usize
        },
        652usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintData),
            "::",
            stringify!(m_rotateOrder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGeneric6DofSpring2ConstraintDoubleData2 {
    pub m_typeConstraintData: btTypedConstraintDoubleData,
    pub m_rbAFrame: btTransformDoubleData,
    pub m_rbBFrame: btTransformDoubleData,
    pub m_linearUpperLimit: btVector3DoubleData,
    pub m_linearLowerLimit: btVector3DoubleData,
    pub m_linearBounce: btVector3DoubleData,
    pub m_linearStopERP: btVector3DoubleData,
    pub m_linearStopCFM: btVector3DoubleData,
    pub m_linearMotorERP: btVector3DoubleData,
    pub m_linearMotorCFM: btVector3DoubleData,
    pub m_linearTargetVelocity: btVector3DoubleData,
    pub m_linearMaxMotorForce: btVector3DoubleData,
    pub m_linearServoTarget: btVector3DoubleData,
    pub m_linearSpringStiffness: btVector3DoubleData,
    pub m_linearSpringDamping: btVector3DoubleData,
    pub m_linearEquilibriumPoint: btVector3DoubleData,
    pub m_linearEnableMotor: [::std::os::raw::c_char; 4usize],
    pub m_linearServoMotor: [::std::os::raw::c_char; 4usize],
    pub m_linearEnableSpring: [::std::os::raw::c_char; 4usize],
    pub m_linearSpringStiffnessLimited: [::std::os::raw::c_char; 4usize],
    pub m_linearSpringDampingLimited: [::std::os::raw::c_char; 4usize],
    pub m_padding1: [::std::os::raw::c_char; 4usize],
    pub m_angularUpperLimit: btVector3DoubleData,
    pub m_angularLowerLimit: btVector3DoubleData,
    pub m_angularBounce: btVector3DoubleData,
    pub m_angularStopERP: btVector3DoubleData,
    pub m_angularStopCFM: btVector3DoubleData,
    pub m_angularMotorERP: btVector3DoubleData,
    pub m_angularMotorCFM: btVector3DoubleData,
    pub m_angularTargetVelocity: btVector3DoubleData,
    pub m_angularMaxMotorForce: btVector3DoubleData,
    pub m_angularServoTarget: btVector3DoubleData,
    pub m_angularSpringStiffness: btVector3DoubleData,
    pub m_angularSpringDamping: btVector3DoubleData,
    pub m_angularEquilibriumPoint: btVector3DoubleData,
    pub m_angularEnableMotor: [::std::os::raw::c_char; 4usize],
    pub m_angularServoMotor: [::std::os::raw::c_char; 4usize],
    pub m_angularEnableSpring: [::std::os::raw::c_char; 4usize],
    pub m_angularSpringStiffnessLimited: [::std::os::raw::c_char; 4usize],
    pub m_angularSpringDampingLimited: [::std::os::raw::c_char; 4usize],
    pub m_rotateOrder: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_btGeneric6DofSpring2ConstraintDoubleData2() {
    assert_eq!(
        ::std::mem::size_of::<btGeneric6DofSpring2ConstraintDoubleData2>(),
        1216usize,
        concat!(
            "Size of: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btGeneric6DofSpring2ConstraintDoubleData2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_typeConstraintData
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_rbAFrame as *const _
                as usize
        },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_rbAFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_rbBFrame as *const _
                as usize
        },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_rbBFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearUpperLimit
                as *const _ as usize
        },
        336usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearUpperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearLowerLimit
                as *const _ as usize
        },
        368usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearLowerLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearBounce as *const _
                as usize
        },
        400usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearBounce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearStopERP as *const _
                as usize
        },
        432usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearStopERP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearStopCFM as *const _
                as usize
        },
        464usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearStopCFM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearMotorERP as *const _
                as usize
        },
        496usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearMotorERP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearMotorCFM as *const _
                as usize
        },
        528usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearMotorCFM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearTargetVelocity
                as *const _ as usize
        },
        560usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearTargetVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearMaxMotorForce
                as *const _ as usize
        },
        592usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearMaxMotorForce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearServoTarget
                as *const _ as usize
        },
        624usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearServoTarget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearSpringStiffness
                as *const _ as usize
        },
        656usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearSpringStiffness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearSpringDamping
                as *const _ as usize
        },
        688usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearSpringDamping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearEquilibriumPoint
                as *const _ as usize
        },
        720usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearEquilibriumPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearEnableMotor
                as *const _ as usize
        },
        752usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearEnableMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearServoMotor
                as *const _ as usize
        },
        756usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearServoMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearEnableSpring
                as *const _ as usize
        },
        760usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearEnableSpring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2))
                .m_linearSpringStiffnessLimited as *const _ as usize
        },
        764usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearSpringStiffnessLimited)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_linearSpringDampingLimited
                as *const _ as usize
        },
        768usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_linearSpringDampingLimited)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_padding1 as *const _
                as usize
        },
        772usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularUpperLimit
                as *const _ as usize
        },
        776usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularUpperLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularLowerLimit
                as *const _ as usize
        },
        808usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularLowerLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularBounce as *const _
                as usize
        },
        840usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularBounce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularStopERP as *const _
                as usize
        },
        872usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularStopERP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularStopCFM as *const _
                as usize
        },
        904usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularStopCFM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularMotorERP
                as *const _ as usize
        },
        936usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularMotorERP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularMotorCFM
                as *const _ as usize
        },
        968usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularMotorCFM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularTargetVelocity
                as *const _ as usize
        },
        1000usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularTargetVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularMaxMotorForce
                as *const _ as usize
        },
        1032usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularMaxMotorForce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularServoTarget
                as *const _ as usize
        },
        1064usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularServoTarget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularSpringStiffness
                as *const _ as usize
        },
        1096usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularSpringStiffness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularSpringDamping
                as *const _ as usize
        },
        1128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularSpringDamping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularEquilibriumPoint
                as *const _ as usize
        },
        1160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularEquilibriumPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularEnableMotor
                as *const _ as usize
        },
        1192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularEnableMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularServoMotor
                as *const _ as usize
        },
        1196usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularServoMotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_angularEnableSpring
                as *const _ as usize
        },
        1200usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularEnableSpring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2))
                .m_angularSpringStiffnessLimited as *const _ as usize
        },
        1204usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularSpringStiffnessLimited)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2))
                .m_angularSpringDampingLimited as *const _ as usize
        },
        1208usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_angularSpringDampingLimited)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGeneric6DofSpring2ConstraintDoubleData2)).m_rotateOrder as *const _
                as usize
        },
        1212usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGeneric6DofSpring2ConstraintDoubleData2),
            "::",
            stringify!(m_rotateOrder)
        )
    );
}
#[repr(C)]
pub struct btHinge2Constraint {
    pub _base: btGeneric6DofSpring2Constraint,
    pub m_anchor: btVector3,
    pub m_axis1: btVector3,
    pub m_axis2: btVector3,
}
#[test]
fn bindgen_test_layout_btHinge2Constraint() {
    assert_eq!(
        ::std::mem::size_of::<btHinge2Constraint>(),
        2976usize,
        concat!("Size of: ", stringify!(btHinge2Constraint))
    );
    assert_eq!(
        ::std::mem::align_of::<btHinge2Constraint>(),
        8usize,
        concat!("Alignment of ", stringify!(btHinge2Constraint))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHinge2Constraint)).m_anchor as *const _ as usize },
        2880usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHinge2Constraint),
            "::",
            stringify!(m_anchor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHinge2Constraint)).m_axis1 as *const _ as usize },
        2912usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHinge2Constraint),
            "::",
            stringify!(m_axis1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btHinge2Constraint)).m_axis2 as *const _ as usize },
        2944usize,
        concat!(
            "Alignment of field: ",
            stringify!(btHinge2Constraint),
            "::",
            stringify!(m_axis2)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btHinge2Constraint9getAnchorEv"]
    pub fn btHinge2Constraint_getAnchor(this: *mut btHinge2Constraint) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btHinge2Constraint10getAnchor2Ev"]
    pub fn btHinge2Constraint_getAnchor2(this: *mut btHinge2Constraint) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btHinge2Constraint8getAxis1Ev"]
    pub fn btHinge2Constraint_getAxis1(this: *mut btHinge2Constraint) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btHinge2Constraint8getAxis2Ev"]
    pub fn btHinge2Constraint_getAxis2(this: *mut btHinge2Constraint) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btHinge2Constraint9getAngle1Ev"]
    pub fn btHinge2Constraint_getAngle1(this: *mut btHinge2Constraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btHinge2Constraint9getAngle2Ev"]
    pub fn btHinge2Constraint_getAngle2(this: *mut btHinge2Constraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btHinge2Constraint13setUpperLimitEd"]
    pub fn btHinge2Constraint_setUpperLimit(this: *mut btHinge2Constraint, ang1max: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btHinge2Constraint13setLowerLimitEd"]
    pub fn btHinge2Constraint_setLowerLimit(this: *mut btHinge2Constraint, ang1min: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btHinge2ConstraintC1ER11btRigidBodyS1_R9btVector3S3_S3_"]
    pub fn btHinge2Constraint_btHinge2Constraint(
        this: *mut btHinge2Constraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        anchor: *mut btVector3,
        axis1: *mut btVector3,
        axis2: *mut btVector3,
    );
}
impl btHinge2Constraint {
    #[inline]
    pub unsafe fn getAnchor(&mut self) -> *const btVector3 {
        btHinge2Constraint_getAnchor(self)
    }
    #[inline]
    pub unsafe fn getAnchor2(&mut self) -> *const btVector3 {
        btHinge2Constraint_getAnchor2(self)
    }
    #[inline]
    pub unsafe fn getAxis1(&mut self) -> *const btVector3 {
        btHinge2Constraint_getAxis1(self)
    }
    #[inline]
    pub unsafe fn getAxis2(&mut self) -> *const btVector3 {
        btHinge2Constraint_getAxis2(self)
    }
    #[inline]
    pub unsafe fn getAngle1(&mut self) -> btScalar {
        btHinge2Constraint_getAngle1(self)
    }
    #[inline]
    pub unsafe fn getAngle2(&mut self) -> btScalar {
        btHinge2Constraint_getAngle2(self)
    }
    #[inline]
    pub unsafe fn setUpperLimit(&mut self, ang1max: btScalar) {
        btHinge2Constraint_setUpperLimit(self, ang1max)
    }
    #[inline]
    pub unsafe fn setLowerLimit(&mut self, ang1min: btScalar) {
        btHinge2Constraint_setLowerLimit(self, ang1min)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        anchor: *mut btVector3,
        axis1: *mut btVector3,
        axis2: *mut btVector3,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btHinge2Constraint_btHinge2Constraint(&mut __bindgen_tmp, rbA, rbB, anchor, axis1, axis2);
        __bindgen_tmp
    }
}
/// The btGeatConstraint will couple the angular velocity for two bodies around given local axis and ratio.
/// See Bullet/Demos/ConstraintDemo for an example use.
#[repr(C)]
pub struct btGearConstraint {
    pub _base: btTypedConstraint,
    pub m_axisInA: btVector3,
    pub m_axisInB: btVector3,
    pub m_useFrameA: bool,
    pub m_ratio: btScalar,
}
#[test]
fn bindgen_test_layout_btGearConstraint() {
    assert_eq!(
        ::std::mem::size_of::<btGearConstraint>(),
        160usize,
        concat!("Size of: ", stringify!(btGearConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<btGearConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(btGearConstraint))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGearConstraint)).m_axisInA as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGearConstraint),
            "::",
            stringify!(m_axisInA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGearConstraint)).m_axisInB as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGearConstraint),
            "::",
            stringify!(m_axisInB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGearConstraint)).m_useFrameA as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGearConstraint),
            "::",
            stringify!(m_useFrameA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGearConstraint)).m_ratio as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGearConstraint),
            "::",
            stringify!(m_ratio)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btGearConstraint8setAxisAER9btVector3"]
    pub fn btGearConstraint_setAxisA(this: *mut btGearConstraint, axisA: *mut btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btGearConstraint8setAxisBER9btVector3"]
    pub fn btGearConstraint_setAxisB(this: *mut btGearConstraint, axisB: *mut btVector3);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btGearConstraint8setRatioEd"]
    pub fn btGearConstraint_setRatio(this: *mut btGearConstraint, ratio: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btGearConstraint8getAxisAEv"]
    pub fn btGearConstraint_getAxisA(this: *const btGearConstraint) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btGearConstraint8getAxisBEv"]
    pub fn btGearConstraint_getAxisB(this: *const btGearConstraint) -> *const btVector3;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btGearConstraint8getRatioEv"]
    pub fn btGearConstraint_getRatio(this: *const btGearConstraint) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btGearConstraintC1ER11btRigidBodyS1_RK9btVector3S4_d"]
    pub fn btGearConstraint_btGearConstraint(
        this: *mut btGearConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        axisInA: *const btVector3,
        axisInB: *const btVector3,
        ratio: btScalar,
    );
}
impl btGearConstraint {
    #[inline]
    pub unsafe fn setAxisA(&mut self, axisA: *mut btVector3) {
        btGearConstraint_setAxisA(self, axisA)
    }
    #[inline]
    pub unsafe fn setAxisB(&mut self, axisB: *mut btVector3) {
        btGearConstraint_setAxisB(self, axisB)
    }
    #[inline]
    pub unsafe fn setRatio(&mut self, ratio: btScalar) {
        btGearConstraint_setRatio(self, ratio)
    }
    #[inline]
    pub unsafe fn getAxisA(&self) -> *const btVector3 {
        btGearConstraint_getAxisA(self)
    }
    #[inline]
    pub unsafe fn getAxisB(&self) -> *const btVector3 {
        btGearConstraint_getAxisB(self)
    }
    #[inline]
    pub unsafe fn getRatio(&self) -> btScalar {
        btGearConstraint_getRatio(self)
    }
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        axisInA: *const btVector3,
        axisInB: *const btVector3,
        ratio: btScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btGearConstraint_btGearConstraint(&mut __bindgen_tmp, rbA, rbB, axisInA, axisInB, ratio);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN16btGearConstraintD0Ev"]
    pub fn btGearConstraint_btGearConstraint_destructor(this: *mut btGearConstraint);
}
extern "C" {

    /// internal method used by the constraint solver, don't use them directly

    #[link_name = "\u{1}_ZN16btGearConstraint8getInfo1EPN17btTypedConstraint17btConstraintInfo1E"]
    pub fn btGearConstraint_getInfo1(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo1,
    );
}
extern "C" {

    /// internal method used by the constraint solver, don't use them directly

    #[link_name = "\u{1}_ZN16btGearConstraint8getInfo2EPN17btTypedConstraint17btConstraintInfo2E"]
    pub fn btGearConstraint_getInfo2(
        this: *mut ::std::os::raw::c_void,
        info: *mut btTypedConstraint_btConstraintInfo2,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btGearConstraint8setParamEidi"]
    pub fn btGearConstraint_setParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        value: btScalar,
        axis: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// return the local value of parameter

    #[link_name = "\u{1}_ZNK16btGearConstraint8getParamEii"]
    pub fn btGearConstraint_getParam(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btGearConstraint28calculateSerializeBufferSizeEv"]
    pub fn btGearConstraint_calculateSerializeBufferSize(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// fills the dataBuffer and returns the struct name (and 0 on failure)

    #[link_name = "\u{1}_ZNK16btGearConstraint9serializeEPvP12btSerializer"]
    pub fn btGearConstraint_serialize(
        this: *mut ::std::os::raw::c_void,
        dataBuffer: *mut ::std::os::raw::c_void,
        serializer: *mut btSerializer,
    ) -> *const ::std::os::raw::c_char;
}
/// do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGearConstraintFloatData {
    pub m_typeConstraintData: btTypedConstraintFloatData,
    pub m_axisInA: btVector3FloatData,
    pub m_axisInB: btVector3FloatData,
    pub m_ratio: f32,
    pub m_padding: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_btGearConstraintFloatData() {
    assert_eq!(
        ::std::mem::size_of::<btGearConstraintFloatData>(),
        104usize,
        concat!("Size of: ", stringify!(btGearConstraintFloatData))
    );
    assert_eq!(
        ::std::mem::align_of::<btGearConstraintFloatData>(),
        8usize,
        concat!("Alignment of ", stringify!(btGearConstraintFloatData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGearConstraintFloatData)).m_typeConstraintData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGearConstraintFloatData),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGearConstraintFloatData)).m_axisInA as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGearConstraintFloatData),
            "::",
            stringify!(m_axisInA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGearConstraintFloatData)).m_axisInB as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGearConstraintFloatData),
            "::",
            stringify!(m_axisInB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGearConstraintFloatData)).m_ratio as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGearConstraintFloatData),
            "::",
            stringify!(m_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGearConstraintFloatData)).m_padding as *const _ as usize },
        100usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGearConstraintFloatData),
            "::",
            stringify!(m_padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btGearConstraintDoubleData {
    pub m_typeConstraintData: btTypedConstraintDoubleData,
    pub m_axisInA: btVector3DoubleData,
    pub m_axisInB: btVector3DoubleData,
    pub m_ratio: f64,
}
#[test]
fn bindgen_test_layout_btGearConstraintDoubleData() {
    assert_eq!(
        ::std::mem::size_of::<btGearConstraintDoubleData>(),
        152usize,
        concat!("Size of: ", stringify!(btGearConstraintDoubleData))
    );
    assert_eq!(
        ::std::mem::align_of::<btGearConstraintDoubleData>(),
        8usize,
        concat!("Alignment of ", stringify!(btGearConstraintDoubleData))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btGearConstraintDoubleData)).m_typeConstraintData as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGearConstraintDoubleData),
            "::",
            stringify!(m_typeConstraintData)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGearConstraintDoubleData)).m_axisInA as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGearConstraintDoubleData),
            "::",
            stringify!(m_axisInA)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGearConstraintDoubleData)).m_axisInB as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGearConstraintDoubleData),
            "::",
            stringify!(m_axisInB)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btGearConstraintDoubleData)).m_ratio as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btGearConstraintDoubleData),
            "::",
            stringify!(m_ratio)
        )
    );
}
#[repr(C)]
pub struct btFixedConstraint {
    pub _base: btGeneric6DofSpring2Constraint,
}
#[test]
fn bindgen_test_layout_btFixedConstraint() {
    assert_eq!(
        ::std::mem::size_of::<btFixedConstraint>(),
        2880usize,
        concat!("Size of: ", stringify!(btFixedConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<btFixedConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(btFixedConstraint))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btFixedConstraintC1ER11btRigidBodyS1_RK11btTransformS4_"]
    pub fn btFixedConstraint_btFixedConstraint(
        this: *mut btFixedConstraint,
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
    );
}
impl btFixedConstraint {
    #[inline]
    pub unsafe fn new(
        rbA: *mut btRigidBody,
        rbB: *mut btRigidBody,
        frameInA: *const btTransform,
        frameInB: *const btTransform,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btFixedConstraint_btFixedConstraint(&mut __bindgen_tmp, rbA, rbB, frameInA, frameInB);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN17btFixedConstraintD0Ev"]
    pub fn btFixedConstraint_btFixedConstraint_destructor(this: *mut btFixedConstraint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btStackAlloc {
    _unused: [u8; 0],
}
pub const btConstraintSolverType_BT_SEQUENTIAL_IMPULSE_SOLVER: btConstraintSolverType = 1;
pub const btConstraintSolverType_BT_MLCP_SOLVER: btConstraintSolverType = 2;
pub const btConstraintSolverType_BT_NNCG_SOLVER: btConstraintSolverType = 4;
pub type btConstraintSolverType = ::std::os::raw::c_uint;
#[repr(C)]
pub struct btConstraintSolver__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct btConstraintSolver {
    pub vtable_: *const btConstraintSolver__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btConstraintSolver() {
    assert_eq!(
        ::std::mem::size_of::<btConstraintSolver>(),
        8usize,
        concat!("Size of: ", stringify!(btConstraintSolver))
    );
    assert_eq!(
        ::std::mem::align_of::<btConstraintSolver>(),
        8usize,
        concat!("Alignment of ", stringify!(btConstraintSolver))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btConstraintSolverD0Ev"]
    pub fn btConstraintSolver_btConstraintSolver_destructor(this: *mut btConstraintSolver);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btConstraintSolver12prepareSolveEii"]
    pub fn btConstraintSolver_prepareSolve(
        this: *mut ::std::os::raw::c_void,
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// solve a group of constraints

    #[link_name = "\u{1}_ZN18btConstraintSolver10solveGroupEPP17btCollisionObjectiPP20btPersistentManifoldiPP17btTypedConstraintiRK19btContactSolverInfoP12btIDebugDrawP12btDispatcher"]
    pub fn btConstraintSolver_solveGroup(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifold: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        info: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
        dispatcher: *mut btDispatcher,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN18btConstraintSolver9allSolvedERK19btContactSolverInfoP12btIDebugDraw"]
    pub fn btConstraintSolver_allSolved(
        this: *mut ::std::os::raw::c_void,
        arg1: *const btContactSolverInfo,
        arg2: *mut btIDebugDraw,
    );
}
extern "C" {

    /// clear internal cached data and reset random seed

    #[link_name = "\u{1}_ZN18btConstraintSolver5resetEv"]
    pub fn btConstraintSolver_reset(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZNK18btConstraintSolver13getSolverTypeEv"]
    pub fn btConstraintSolver_getSolverType(
        this: *mut ::std::os::raw::c_void,
    ) -> btConstraintSolverType;
}
pub type btSingleConstraintRowSolver = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut btSolverBody,
        arg2: *mut btSolverBody,
        arg3: *const btSolverConstraint,
    ) -> btScalar,
>;
/// The btSequentialImpulseConstraintSolver is a fast SIMD implementation of the Projected Gauss Seidel (iterative LCP) method.
#[repr(C)]
pub struct btSequentialImpulseConstraintSolver {
    pub _base: btConstraintSolver,
    pub m_tmpSolverBodyPool: btAlignedObjectArray<btSolverBody>,
    pub m_tmpSolverContactConstraintPool: btConstraintArray,
    pub m_tmpSolverNonContactConstraintPool: btConstraintArray,
    pub m_tmpSolverContactFrictionConstraintPool: btConstraintArray,
    pub m_tmpSolverContactRollingFrictionConstraintPool: btConstraintArray,
    pub m_orderTmpConstraintPool: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_orderNonContactConstraintPool: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_orderFrictionConstraintPool: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_tmpConstraintSizesPool: btAlignedObjectArray<btTypedConstraint_btConstraintInfo1>,
    pub m_maxOverrideNumSolverIterations: ::std::os::raw::c_int,
    pub m_fixedBodyId: ::std::os::raw::c_int,
    pub m_kinematicBodyUniqueIdToSolverBodyTable: btAlignedObjectArray<::std::os::raw::c_int>,
    pub m_resolveSingleConstraintRowGeneric: btSingleConstraintRowSolver,
    pub m_resolveSingleConstraintRowLowerLimit: btSingleConstraintRowSolver,
    pub m_resolveSplitPenetrationImpulse: btSingleConstraintRowSolver,
    pub m_cachedSolverMode: ::std::os::raw::c_int,
    pub m_leastSquaresResidual: btScalar,
    /// m_btSeed2 is used for re-arranging the constraint rows. improves convergence/quality of friction
    pub m_btSeed2: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_btSequentialImpulseConstraintSolver() {
    assert_eq!(
        ::std::mem::size_of::<btSequentialImpulseConstraintSolver>(),
        384usize,
        concat!("Size of: ", stringify!(btSequentialImpulseConstraintSolver))
    );
    assert_eq!(
        ::std::mem::align_of::<btSequentialImpulseConstraintSolver>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btSequentialImpulseConstraintSolver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver)).m_tmpSolverBodyPool as *const _
                as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_tmpSolverBodyPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver)).m_tmpSolverContactConstraintPool
                as *const _ as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_tmpSolverContactConstraintPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver))
                .m_tmpSolverNonContactConstraintPool as *const _ as usize
        },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_tmpSolverNonContactConstraintPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver))
                .m_tmpSolverContactFrictionConstraintPool as *const _ as usize
        },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_tmpSolverContactFrictionConstraintPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver))
                .m_tmpSolverContactRollingFrictionConstraintPool as *const _ as usize
        },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_tmpSolverContactRollingFrictionConstraintPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver)).m_orderTmpConstraintPool
                as *const _ as usize
        },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_orderTmpConstraintPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver)).m_orderNonContactConstraintPool
                as *const _ as usize
        },
        200usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_orderNonContactConstraintPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver)).m_orderFrictionConstraintPool
                as *const _ as usize
        },
        232usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_orderFrictionConstraintPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver)).m_tmpConstraintSizesPool
                as *const _ as usize
        },
        264usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_tmpConstraintSizesPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver)).m_maxOverrideNumSolverIterations
                as *const _ as usize
        },
        296usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_maxOverrideNumSolverIterations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver)).m_fixedBodyId as *const _ as usize
        },
        300usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_fixedBodyId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver))
                .m_kinematicBodyUniqueIdToSolverBodyTable as *const _ as usize
        },
        304usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_kinematicBodyUniqueIdToSolverBodyTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver))
                .m_resolveSingleConstraintRowGeneric as *const _ as usize
        },
        336usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_resolveSingleConstraintRowGeneric)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver))
                .m_resolveSingleConstraintRowLowerLimit as *const _ as usize
        },
        344usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_resolveSingleConstraintRowLowerLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver)).m_resolveSplitPenetrationImpulse
                as *const _ as usize
        },
        352usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_resolveSplitPenetrationImpulse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver)).m_cachedSolverMode as *const _
                as usize
        },
        360usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_cachedSolverMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver)).m_leastSquaresResidual as *const _
                as usize
        },
        368usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_leastSquaresResidual)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btSequentialImpulseConstraintSolver)).m_btSeed2 as *const _ as usize
        },
        376usize,
        concat!(
            "Alignment of field: ",
            stringify!(btSequentialImpulseConstraintSolver),
            "::",
            stringify!(m_btSeed2)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver20setupSolverFunctionsEb"]
    pub fn btSequentialImpulseConstraintSolver_setupSolverFunctions(
        this: *mut btSequentialImpulseConstraintSolver,
        useSimd: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver23setupFrictionConstraintER18btSolverConstraintRK9btVector3iiR15btManifoldPointS4_S4_P17btCollisionObjectS8_dRK19btContactSolverInfodd"]
    pub fn btSequentialImpulseConstraintSolver_setupFrictionConstraint(
        this: *mut btSequentialImpulseConstraintSolver,
        solverConstraint: *mut btSolverConstraint,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        infoGlobal: *const btContactSolverInfo,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver32setupTorsionalFrictionConstraintER18btSolverConstraintRK9btVector3iiR15btManifoldPointdS4_S4_P17btCollisionObjectS8_ddd"]
    pub fn btSequentialImpulseConstraintSolver_setupTorsionalFrictionConstraint(
        this: *mut btSequentialImpulseConstraintSolver,
        solverConstraint: *mut btSolverConstraint,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        combinedTorsionalFriction: btScalar,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver21addFrictionConstraintERK9btVector3iiiR15btManifoldPointS2_S2_P17btCollisionObjectS6_dRK19btContactSolverInfodd"]
    pub fn btSequentialImpulseConstraintSolver_addFrictionConstraint(
        this: *mut btSequentialImpulseConstraintSolver,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        infoGlobal: *const btContactSolverInfo,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) -> *mut btSolverConstraint;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver30addTorsionalFrictionConstraintERK9btVector3iiiR15btManifoldPointdS2_S2_P17btCollisionObjectS6_ddd"]
    pub fn btSequentialImpulseConstraintSolver_addTorsionalFrictionConstraint(
        this: *mut btSequentialImpulseConstraintSolver,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        torsionalFriction: btScalar,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) -> *mut btSolverConstraint;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver22setupContactConstraintER18btSolverConstraintiiR15btManifoldPointRK19btContactSolverInfoRdRK9btVector3SA_"]
    pub fn btSequentialImpulseConstraintSolver_setupContactConstraint(
        this: *mut btSequentialImpulseConstraintSolver,
        solverConstraint: *mut btSolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        infoGlobal: *const btContactSolverInfo,
        relaxation: *mut btScalar,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver24applyAnisotropicFrictionEP17btCollisionObjectR9btVector3i"]
    pub fn btSequentialImpulseConstraintSolver_applyAnisotropicFriction(
        colObj: *mut btCollisionObject,
        frictionDirection: *mut btVector3,
        frictionMode: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver28setFrictionConstraintImpulseER18btSolverConstraintiiR15btManifoldPointRK19btContactSolverInfo"]
    pub fn btSequentialImpulseConstraintSolver_setFrictionConstraintImpulse(
        this: *mut btSequentialImpulseConstraintSolver,
        solverConstraint: *mut btSolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver16restitutionCurveEddd"]
    pub fn btSequentialImpulseConstraintSolver_restitutionCurve(
        this: *mut btSequentialImpulseConstraintSolver,
        rel_vel: btScalar,
        restitution: btScalar,
        velocityThreshold: btScalar,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver14convertContactEP20btPersistentManifoldRK19btContactSolverInfo"]
    pub fn btSequentialImpulseConstraintSolver_convertContact(
        this: *mut btSequentialImpulseConstraintSolver,
        manifold: *mut btPersistentManifold,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver27resolveSplitPenetrationSIMDER12btSolverBodyS1_RK18btSolverConstraint"]
    pub fn btSequentialImpulseConstraintSolver_resolveSplitPenetrationSIMD(
        this: *mut btSequentialImpulseConstraintSolver,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver43resolveSplitPenetrationImpulseCacheFriendlyER12btSolverBodyS1_RK18btSolverConstraint"]
    pub fn btSequentialImpulseConstraintSolver_resolveSplitPenetrationImpulseCacheFriendly(
        this: *mut btSequentialImpulseConstraintSolver,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver19getOrInitSolverBodyER17btCollisionObjectd"]
    pub fn btSequentialImpulseConstraintSolver_getOrInitSolverBody(
        this: *mut btSequentialImpulseConstraintSolver,
        body: *mut btCollisionObject,
        timeStep: btScalar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver14initSolverBodyEP12btSolverBodyP17btCollisionObjectd"]
    pub fn btSequentialImpulseConstraintSolver_initSolverBody(
        this: *mut btSequentialImpulseConstraintSolver,
        solverBody: *mut btSolverBody,
        collisionObject: *mut btCollisionObject,
        timeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver33resolveSingleConstraintRowGenericER12btSolverBodyS1_RK18btSolverConstraint"]
    pub fn btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGeneric(
        this: *mut btSequentialImpulseConstraintSolver,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver37resolveSingleConstraintRowGenericSIMDER12btSolverBodyS1_RK18btSolverConstraint"]
    pub fn btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGenericSIMD(
        this: *mut btSequentialImpulseConstraintSolver,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver36resolveSingleConstraintRowLowerLimitER12btSolverBodyS1_RK18btSolverConstraint"]
    pub fn btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimit(
        this: *mut btSequentialImpulseConstraintSolver,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver40resolveSingleConstraintRowLowerLimitSIMDER12btSolverBodyS1_RK18btSolverConstraint"]
    pub fn btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimitSIMD(
        this: *mut btSequentialImpulseConstraintSolver,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver30resolveSplitPenetrationImpulseER12btSolverBodyS1_RK18btSolverConstraint"]
    pub fn btSequentialImpulseConstraintSolver_resolveSplitPenetrationImpulse(
        this: *mut btSequentialImpulseConstraintSolver,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver7btRand2Ev"]
    pub fn btSequentialImpulseConstraintSolver_btRand2(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver10btRandInt2Ei"]
    pub fn btSequentialImpulseConstraintSolver_btRandInt2(
        this: *mut btSequentialImpulseConstraintSolver,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver11setRandSeedEm"]
    pub fn btSequentialImpulseConstraintSolver_setRandSeed(
        this: *mut btSequentialImpulseConstraintSolver,
        seed: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK35btSequentialImpulseConstraintSolver11getRandSeedEv"]
    pub fn btSequentialImpulseConstraintSolver_getRandSeed(
        this: *const btSequentialImpulseConstraintSolver,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver35getActiveConstraintRowSolverGenericEv"]
    pub fn btSequentialImpulseConstraintSolver_getActiveConstraintRowSolverGeneric(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> btSingleConstraintRowSolver;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver29setConstraintRowSolverGenericEPFdR12btSolverBodyS1_RK18btSolverConstraintE"]
    pub fn btSequentialImpulseConstraintSolver_setConstraintRowSolverGeneric(
        this: *mut btSequentialImpulseConstraintSolver,
        rowSolver: btSingleConstraintRowSolver,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver38getActiveConstraintRowSolverLowerLimitEv"]
    pub fn btSequentialImpulseConstraintSolver_getActiveConstraintRowSolverLowerLimit(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> btSingleConstraintRowSolver;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver32setConstraintRowSolverLowerLimitEPFdR12btSolverBodyS1_RK18btSolverConstraintE"]
    pub fn btSequentialImpulseConstraintSolver_setConstraintRowSolverLowerLimit(
        this: *mut btSequentialImpulseConstraintSolver,
        rowSolver: btSingleConstraintRowSolver,
    );
}
extern "C" {

    /// Various implementations of solving a single constraint row using a generic equality constraint, using scalar reference, SSE2 or SSE4

    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver35getScalarConstraintRowSolverGenericEv"]
    pub fn btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverGeneric(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> btSingleConstraintRowSolver;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver33getSSE2ConstraintRowSolverGenericEv"]
    pub fn btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverGeneric(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> btSingleConstraintRowSolver;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver35getSSE4_1ConstraintRowSolverGenericEv"]
    pub fn btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverGeneric(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> btSingleConstraintRowSolver;
}
extern "C" {

    /// Various implementations of solving a single constraint row using an inequality (lower limit) constraint, using scalar reference, SSE2 or SSE4

    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver38getScalarConstraintRowSolverLowerLimitEv"]
    pub fn btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverLowerLimit(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> btSingleConstraintRowSolver;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver36getSSE2ConstraintRowSolverLowerLimitEv"]
    pub fn btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverLowerLimit(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> btSingleConstraintRowSolver;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver38getSSE4_1ConstraintRowSolverLowerLimitEv"]
    pub fn btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverLowerLimit(
        this: *mut btSequentialImpulseConstraintSolver,
    ) -> btSingleConstraintRowSolver;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolverC1Ev"]
    pub fn btSequentialImpulseConstraintSolver_btSequentialImpulseConstraintSolver(
        this: *mut btSequentialImpulseConstraintSolver,
    );
}
impl btSequentialImpulseConstraintSolver {
    #[inline]
    pub unsafe fn setupSolverFunctions(&mut self, useSimd: bool) {
        btSequentialImpulseConstraintSolver_setupSolverFunctions(self, useSimd)
    }
    #[inline]
    pub unsafe fn setupFrictionConstraint(
        &mut self,
        solverConstraint: *mut btSolverConstraint,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        infoGlobal: *const btContactSolverInfo,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) {
        btSequentialImpulseConstraintSolver_setupFrictionConstraint(
            self,
            solverConstraint,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            infoGlobal,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn setupTorsionalFrictionConstraint(
        &mut self,
        solverConstraint: *mut btSolverConstraint,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        combinedTorsionalFriction: btScalar,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) {
        btSequentialImpulseConstraintSolver_setupTorsionalFrictionConstraint(
            self,
            solverConstraint,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            combinedTorsionalFriction,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn addFrictionConstraint(
        &mut self,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        infoGlobal: *const btContactSolverInfo,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) -> *mut btSolverConstraint {
        btSequentialImpulseConstraintSolver_addFrictionConstraint(
            self,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            frictionIndex,
            cp,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            infoGlobal,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn addTorsionalFrictionConstraint(
        &mut self,
        normalAxis: *const btVector3,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        frictionIndex: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        torsionalFriction: btScalar,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
        colObj0: *mut btCollisionObject,
        colObj1: *mut btCollisionObject,
        relaxation: btScalar,
        desiredVelocity: btScalar,
        cfmSlip: btScalar,
    ) -> *mut btSolverConstraint {
        btSequentialImpulseConstraintSolver_addTorsionalFrictionConstraint(
            self,
            normalAxis,
            solverBodyIdA,
            solverBodyIdB,
            frictionIndex,
            cp,
            torsionalFriction,
            rel_pos1,
            rel_pos2,
            colObj0,
            colObj1,
            relaxation,
            desiredVelocity,
            cfmSlip,
        )
    }
    #[inline]
    pub unsafe fn setupContactConstraint(
        &mut self,
        solverConstraint: *mut btSolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        infoGlobal: *const btContactSolverInfo,
        relaxation: *mut btScalar,
        rel_pos1: *const btVector3,
        rel_pos2: *const btVector3,
    ) {
        btSequentialImpulseConstraintSolver_setupContactConstraint(
            self,
            solverConstraint,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            infoGlobal,
            relaxation,
            rel_pos1,
            rel_pos2,
        )
    }
    #[inline]
    pub unsafe fn applyAnisotropicFriction(
        colObj: *mut btCollisionObject,
        frictionDirection: *mut btVector3,
        frictionMode: ::std::os::raw::c_int,
    ) {
        btSequentialImpulseConstraintSolver_applyAnisotropicFriction(
            colObj,
            frictionDirection,
            frictionMode,
        )
    }
    #[inline]
    pub unsafe fn setFrictionConstraintImpulse(
        &mut self,
        solverConstraint: *mut btSolverConstraint,
        solverBodyIdA: ::std::os::raw::c_int,
        solverBodyIdB: ::std::os::raw::c_int,
        cp: *mut btManifoldPoint,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolver_setFrictionConstraintImpulse(
            self,
            solverConstraint,
            solverBodyIdA,
            solverBodyIdB,
            cp,
            infoGlobal,
        )
    }
    #[inline]
    pub unsafe fn restitutionCurve(
        &mut self,
        rel_vel: btScalar,
        restitution: btScalar,
        velocityThreshold: btScalar,
    ) -> btScalar {
        btSequentialImpulseConstraintSolver_restitutionCurve(
            self,
            rel_vel,
            restitution,
            velocityThreshold,
        )
    }
    #[inline]
    pub unsafe fn convertContact(
        &mut self,
        manifold: *mut btPersistentManifold,
        infoGlobal: *const btContactSolverInfo,
    ) {
        btSequentialImpulseConstraintSolver_convertContact(self, manifold, infoGlobal)
    }
    #[inline]
    pub unsafe fn resolveSplitPenetrationSIMD(
        &mut self,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar {
        btSequentialImpulseConstraintSolver_resolveSplitPenetrationSIMD(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn resolveSplitPenetrationImpulseCacheFriendly(
        &mut self,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar {
        btSequentialImpulseConstraintSolver_resolveSplitPenetrationImpulseCacheFriendly(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn getOrInitSolverBody(
        &mut self,
        body: *mut btCollisionObject,
        timeStep: btScalar,
    ) -> ::std::os::raw::c_int {
        btSequentialImpulseConstraintSolver_getOrInitSolverBody(self, body, timeStep)
    }
    #[inline]
    pub unsafe fn initSolverBody(
        &mut self,
        solverBody: *mut btSolverBody,
        collisionObject: *mut btCollisionObject,
        timeStep: btScalar,
    ) {
        btSequentialImpulseConstraintSolver_initSolverBody(
            self,
            solverBody,
            collisionObject,
            timeStep,
        )
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowGeneric(
        &mut self,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar {
        btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGeneric(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowGenericSIMD(
        &mut self,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar {
        btSequentialImpulseConstraintSolver_resolveSingleConstraintRowGenericSIMD(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowLowerLimit(
        &mut self,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar {
        btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimit(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn resolveSingleConstraintRowLowerLimitSIMD(
        &mut self,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar {
        btSequentialImpulseConstraintSolver_resolveSingleConstraintRowLowerLimitSIMD(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn resolveSplitPenetrationImpulse(
        &mut self,
        bodyA: *mut btSolverBody,
        bodyB: *mut btSolverBody,
        contactConstraint: *const btSolverConstraint,
    ) -> btScalar {
        btSequentialImpulseConstraintSolver_resolveSplitPenetrationImpulse(
            self,
            bodyA,
            bodyB,
            contactConstraint,
        )
    }
    #[inline]
    pub unsafe fn btRand2(&mut self) -> ::std::os::raw::c_ulong {
        btSequentialImpulseConstraintSolver_btRand2(self)
    }
    #[inline]
    pub unsafe fn btRandInt2(&mut self, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        btSequentialImpulseConstraintSolver_btRandInt2(self, n)
    }
    #[inline]
    pub unsafe fn setRandSeed(&mut self, seed: ::std::os::raw::c_ulong) {
        btSequentialImpulseConstraintSolver_setRandSeed(self, seed)
    }
    #[inline]
    pub unsafe fn getRandSeed(&self) -> ::std::os::raw::c_ulong {
        btSequentialImpulseConstraintSolver_getRandSeed(self)
    }
    #[inline]
    pub unsafe fn getActiveConstraintRowSolverGeneric(&mut self) -> btSingleConstraintRowSolver {
        btSequentialImpulseConstraintSolver_getActiveConstraintRowSolverGeneric(self)
    }
    #[inline]
    pub unsafe fn setConstraintRowSolverGeneric(&mut self, rowSolver: btSingleConstraintRowSolver) {
        btSequentialImpulseConstraintSolver_setConstraintRowSolverGeneric(self, rowSolver)
    }
    #[inline]
    pub unsafe fn getActiveConstraintRowSolverLowerLimit(&mut self) -> btSingleConstraintRowSolver {
        btSequentialImpulseConstraintSolver_getActiveConstraintRowSolverLowerLimit(self)
    }
    #[inline]
    pub unsafe fn setConstraintRowSolverLowerLimit(
        &mut self,
        rowSolver: btSingleConstraintRowSolver,
    ) {
        btSequentialImpulseConstraintSolver_setConstraintRowSolverLowerLimit(self, rowSolver)
    }
    #[inline]
    pub unsafe fn getScalarConstraintRowSolverGeneric(&mut self) -> btSingleConstraintRowSolver {
        btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverGeneric(self)
    }
    #[inline]
    pub unsafe fn getSSE2ConstraintRowSolverGeneric(&mut self) -> btSingleConstraintRowSolver {
        btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverGeneric(self)
    }
    #[inline]
    pub unsafe fn getSSE4_1ConstraintRowSolverGeneric(&mut self) -> btSingleConstraintRowSolver {
        btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverGeneric(self)
    }
    #[inline]
    pub unsafe fn getScalarConstraintRowSolverLowerLimit(&mut self) -> btSingleConstraintRowSolver {
        btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverLowerLimit(self)
    }
    #[inline]
    pub unsafe fn getSSE2ConstraintRowSolverLowerLimit(&mut self) -> btSingleConstraintRowSolver {
        btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverLowerLimit(self)
    }
    #[inline]
    pub unsafe fn getSSE4_1ConstraintRowSolverLowerLimit(&mut self) -> btSingleConstraintRowSolver {
        btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverLowerLimit(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btSequentialImpulseConstraintSolver_btSequentialImpulseConstraintSolver(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver15convertContactsEPP20btPersistentManifoldiRK19btContactSolverInfo"]
    pub fn btSequentialImpulseConstraintSolver_convertContacts(
        this: *mut ::std::os::raw::c_void,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver45solveGroupCacheFriendlySplitImpulseIterationsEPP17btCollisionObjectiPP20btPersistentManifoldiPP17btTypedConstraintiRK19btContactSolverInfoP12btIDebugDraw"]
    pub fn btSequentialImpulseConstraintSolver_solveGroupCacheFriendlySplitImpulseIterations(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver29solveGroupCacheFriendlyFinishEPP17btCollisionObjectiRK19btContactSolverInfo"]
    pub fn btSequentialImpulseConstraintSolver_solveGroupCacheFriendlyFinish(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver20solveSingleIterationEiPP17btCollisionObjectiPP20btPersistentManifoldiPP17btTypedConstraintiRK19btContactSolverInfoP12btIDebugDraw"]
    pub fn btSequentialImpulseConstraintSolver_solveSingleIteration(
        this: *mut ::std::os::raw::c_void,
        iteration: ::std::os::raw::c_int,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver28solveGroupCacheFriendlySetupEPP17btCollisionObjectiPP20btPersistentManifoldiPP17btTypedConstraintiRK19btContactSolverInfoP12btIDebugDraw"]
    pub fn btSequentialImpulseConstraintSolver_solveGroupCacheFriendlySetup(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver33solveGroupCacheFriendlyIterationsEPP17btCollisionObjectiPP20btPersistentManifoldiPP17btTypedConstraintiRK19btContactSolverInfoP12btIDebugDraw"]
    pub fn btSequentialImpulseConstraintSolver_solveGroupCacheFriendlyIterations(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifoldPtr: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        infoGlobal: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolverD1Ev"]
    pub fn btSequentialImpulseConstraintSolver_btSequentialImpulseConstraintSolver_destructor(
        this: *mut btSequentialImpulseConstraintSolver,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver10solveGroupEPP17btCollisionObjectiPP20btPersistentManifoldiPP17btTypedConstraintiRK19btContactSolverInfoP12btIDebugDrawP12btDispatcher"]
    pub fn btSequentialImpulseConstraintSolver_solveGroup(
        this: *mut ::std::os::raw::c_void,
        bodies: *mut *mut btCollisionObject,
        numBodies: ::std::os::raw::c_int,
        manifold: *mut *mut btPersistentManifold,
        numManifolds: ::std::os::raw::c_int,
        constraints: *mut *mut btTypedConstraint,
        numConstraints: ::std::os::raw::c_int,
        info: *const btContactSolverInfo,
        debugDrawer: *mut btIDebugDraw,
        dispatcher: *mut btDispatcher,
    ) -> btScalar;
}
extern "C" {

    /// clear internal cached data and reset random seed

    #[link_name = "\u{1}_ZN35btSequentialImpulseConstraintSolver5resetEv"]
    pub fn btSequentialImpulseConstraintSolver_reset(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZNK35btSequentialImpulseConstraintSolver13getSolverTypeEv"]
    pub fn btSequentialImpulseConstraintSolver_getSolverType(
        this: *mut ::std::os::raw::c_void,
    ) -> btConstraintSolverType;
}
#[repr(C)]
pub struct btVehicleRaycaster__bindgen_vtable(::std::os::raw::c_void);
/// btVehicleRaycaster is provides interface for between vehicle simulation and raycasting
#[repr(C)]
#[derive(Debug)]
pub struct btVehicleRaycaster {
    pub vtable_: *const btVehicleRaycaster__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btVehicleRaycaster_btVehicleRaycasterResult {
    pub m_hitPointInWorld: btVector3,
    pub m_hitNormalInWorld: btVector3,
    pub m_distFraction: btScalar,
}
#[test]
fn bindgen_test_layout_btVehicleRaycaster_btVehicleRaycasterResult() {
    assert_eq!(
        ::std::mem::size_of::<btVehicleRaycaster_btVehicleRaycasterResult>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(btVehicleRaycaster_btVehicleRaycasterResult)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btVehicleRaycaster_btVehicleRaycasterResult>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btVehicleRaycaster_btVehicleRaycasterResult)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btVehicleRaycaster_btVehicleRaycasterResult)).m_hitPointInWorld
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btVehicleRaycaster_btVehicleRaycasterResult),
            "::",
            stringify!(m_hitPointInWorld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btVehicleRaycaster_btVehicleRaycasterResult)).m_hitNormalInWorld
                as *const _ as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btVehicleRaycaster_btVehicleRaycasterResult),
            "::",
            stringify!(m_hitNormalInWorld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btVehicleRaycaster_btVehicleRaycasterResult)).m_distFraction as *const _
                as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btVehicleRaycaster_btVehicleRaycasterResult),
            "::",
            stringify!(m_distFraction)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btVehicleRaycaster24btVehicleRaycasterResultC1Ev"]
    pub fn btVehicleRaycaster_btVehicleRaycasterResult_btVehicleRaycasterResult(
        this: *mut btVehicleRaycaster_btVehicleRaycasterResult,
    );
}
impl btVehicleRaycaster_btVehicleRaycasterResult {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btVehicleRaycaster_btVehicleRaycasterResult_btVehicleRaycasterResult(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[test]
fn bindgen_test_layout_btVehicleRaycaster() {
    assert_eq!(
        ::std::mem::size_of::<btVehicleRaycaster>(),
        8usize,
        concat!("Size of: ", stringify!(btVehicleRaycaster))
    );
    assert_eq!(
        ::std::mem::align_of::<btVehicleRaycaster>(),
        8usize,
        concat!("Alignment of ", stringify!(btVehicleRaycaster))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN18btVehicleRaycasterD0Ev"]
    pub fn btVehicleRaycaster_btVehicleRaycaster_destructor(this: *mut btVehicleRaycaster);
}
extern "C" {
    #[link_name = "\u{1}_ZN18btVehicleRaycaster7castRayERK9btVector3S2_RNS_24btVehicleRaycasterResultE"]
    pub fn btVehicleRaycaster_castRay(
        this: *mut ::std::os::raw::c_void,
        from: *const btVector3,
        to: *const btVector3,
        result: *mut btVehicleRaycaster_btVehicleRaycasterResult,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btWheelInfoConstructionInfo {
    pub m_chassisConnectionCS: btVector3,
    pub m_wheelDirectionCS: btVector3,
    pub m_wheelAxleCS: btVector3,
    pub m_suspensionRestLength: btScalar,
    pub m_maxSuspensionTravelCm: btScalar,
    pub m_wheelRadius: btScalar,
    pub m_suspensionStiffness: btScalar,
    pub m_wheelsDampingCompression: btScalar,
    pub m_wheelsDampingRelaxation: btScalar,
    pub m_frictionSlip: btScalar,
    pub m_maxSuspensionForce: btScalar,
    pub m_bIsFrontWheel: bool,
}
#[test]
fn bindgen_test_layout_btWheelInfoConstructionInfo() {
    assert_eq!(
        ::std::mem::size_of::<btWheelInfoConstructionInfo>(),
        168usize,
        concat!("Size of: ", stringify!(btWheelInfoConstructionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<btWheelInfoConstructionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(btWheelInfoConstructionInfo))
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btWheelInfoConstructionInfo)).m_chassisConnectionCS as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfoConstructionInfo),
            "::",
            stringify!(m_chassisConnectionCS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btWheelInfoConstructionInfo)).m_wheelDirectionCS as *const _ as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfoConstructionInfo),
            "::",
            stringify!(m_wheelDirectionCS)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfoConstructionInfo)).m_wheelAxleCS as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfoConstructionInfo),
            "::",
            stringify!(m_wheelAxleCS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btWheelInfoConstructionInfo)).m_suspensionRestLength as *const _
                as usize
        },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfoConstructionInfo),
            "::",
            stringify!(m_suspensionRestLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btWheelInfoConstructionInfo)).m_maxSuspensionTravelCm as *const _
                as usize
        },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfoConstructionInfo),
            "::",
            stringify!(m_maxSuspensionTravelCm)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfoConstructionInfo)).m_wheelRadius as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfoConstructionInfo),
            "::",
            stringify!(m_wheelRadius)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btWheelInfoConstructionInfo)).m_suspensionStiffness as *const _ as usize
        },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfoConstructionInfo),
            "::",
            stringify!(m_suspensionStiffness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btWheelInfoConstructionInfo)).m_wheelsDampingCompression as *const _
                as usize
        },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfoConstructionInfo),
            "::",
            stringify!(m_wheelsDampingCompression)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btWheelInfoConstructionInfo)).m_wheelsDampingRelaxation as *const _
                as usize
        },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfoConstructionInfo),
            "::",
            stringify!(m_wheelsDampingRelaxation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btWheelInfoConstructionInfo)).m_frictionSlip as *const _ as usize
        },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfoConstructionInfo),
            "::",
            stringify!(m_frictionSlip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btWheelInfoConstructionInfo)).m_maxSuspensionForce as *const _ as usize
        },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfoConstructionInfo),
            "::",
            stringify!(m_maxSuspensionForce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btWheelInfoConstructionInfo)).m_bIsFrontWheel as *const _ as usize
        },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfoConstructionInfo),
            "::",
            stringify!(m_bIsFrontWheel)
        )
    );
}
/// btWheelInfo contains information per wheel about friction and suspension.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btWheelInfo {
    pub m_raycastInfo: btWheelInfo_RaycastInfo,
    pub m_worldTransform: btTransform,
    pub m_chassisConnectionPointCS: btVector3,
    pub m_wheelDirectionCS: btVector3,
    pub m_wheelAxleCS: btVector3,
    pub m_suspensionRestLength1: btScalar,
    pub m_maxSuspensionTravelCm: btScalar,
    pub m_wheelsRadius: btScalar,
    pub m_suspensionStiffness: btScalar,
    pub m_wheelsDampingCompression: btScalar,
    pub m_wheelsDampingRelaxation: btScalar,
    pub m_frictionSlip: btScalar,
    pub m_steering: btScalar,
    pub m_rotation: btScalar,
    pub m_deltaRotation: btScalar,
    pub m_rollInfluence: btScalar,
    pub m_maxSuspensionForce: btScalar,
    pub m_engineForce: btScalar,
    pub m_brake: btScalar,
    pub m_bIsFrontWheel: bool,
    pub m_clientInfo: *mut ::std::os::raw::c_void,
    pub m_clippedInvContactDotSuspension: btScalar,
    pub m_suspensionRelativeVelocity: btScalar,
    pub m_wheelsSuspensionForce: btScalar,
    pub m_skidInfo: btScalar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btWheelInfo_RaycastInfo {
    pub m_contactNormalWS: btVector3,
    pub m_contactPointWS: btVector3,
    pub m_suspensionLength: btScalar,
    pub m_hardPointWS: btVector3,
    pub m_wheelDirectionWS: btVector3,
    pub m_wheelAxleWS: btVector3,
    pub m_isInContact: bool,
    pub m_groundObject: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_btWheelInfo_RaycastInfo() {
    assert_eq!(
        ::std::mem::size_of::<btWheelInfo_RaycastInfo>(),
        184usize,
        concat!("Size of: ", stringify!(btWheelInfo_RaycastInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<btWheelInfo_RaycastInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(btWheelInfo_RaycastInfo))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo_RaycastInfo)).m_contactNormalWS as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo_RaycastInfo),
            "::",
            stringify!(m_contactNormalWS)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo_RaycastInfo)).m_contactPointWS as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo_RaycastInfo),
            "::",
            stringify!(m_contactPointWS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btWheelInfo_RaycastInfo)).m_suspensionLength as *const _ as usize
        },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo_RaycastInfo),
            "::",
            stringify!(m_suspensionLength)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo_RaycastInfo)).m_hardPointWS as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo_RaycastInfo),
            "::",
            stringify!(m_hardPointWS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btWheelInfo_RaycastInfo)).m_wheelDirectionWS as *const _ as usize
        },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo_RaycastInfo),
            "::",
            stringify!(m_wheelDirectionWS)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo_RaycastInfo)).m_wheelAxleWS as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo_RaycastInfo),
            "::",
            stringify!(m_wheelAxleWS)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo_RaycastInfo)).m_isInContact as *const _ as usize },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo_RaycastInfo),
            "::",
            stringify!(m_isInContact)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo_RaycastInfo)).m_groundObject as *const _ as usize },
        176usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo_RaycastInfo),
            "::",
            stringify!(m_groundObject)
        )
    );
}
#[test]
fn bindgen_test_layout_btWheelInfo() {
    assert_eq!(
        ::std::mem::size_of::<btWheelInfo>(),
        568usize,
        concat!("Size of: ", stringify!(btWheelInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<btWheelInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(btWheelInfo))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_raycastInfo as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_raycastInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_worldTransform as *const _ as usize },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_worldTransform)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_chassisConnectionPointCS as *const _ as usize },
        312usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_chassisConnectionPointCS)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_wheelDirectionCS as *const _ as usize },
        344usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_wheelDirectionCS)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_wheelAxleCS as *const _ as usize },
        376usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_wheelAxleCS)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_suspensionRestLength1 as *const _ as usize },
        408usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_suspensionRestLength1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_maxSuspensionTravelCm as *const _ as usize },
        416usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_maxSuspensionTravelCm)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_wheelsRadius as *const _ as usize },
        424usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_wheelsRadius)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_suspensionStiffness as *const _ as usize },
        432usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_suspensionStiffness)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_wheelsDampingCompression as *const _ as usize },
        440usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_wheelsDampingCompression)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_wheelsDampingRelaxation as *const _ as usize },
        448usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_wheelsDampingRelaxation)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_frictionSlip as *const _ as usize },
        456usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_frictionSlip)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_steering as *const _ as usize },
        464usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_steering)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_rotation as *const _ as usize },
        472usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_rotation)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_deltaRotation as *const _ as usize },
        480usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_deltaRotation)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_rollInfluence as *const _ as usize },
        488usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_rollInfluence)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_maxSuspensionForce as *const _ as usize },
        496usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_maxSuspensionForce)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_engineForce as *const _ as usize },
        504usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_engineForce)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_brake as *const _ as usize },
        512usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_brake)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_bIsFrontWheel as *const _ as usize },
        520usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_bIsFrontWheel)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_clientInfo as *const _ as usize },
        528usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_clientInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btWheelInfo)).m_clippedInvContactDotSuspension as *const _ as usize
        },
        536usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_clippedInvContactDotSuspension)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_suspensionRelativeVelocity as *const _ as usize },
        544usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_suspensionRelativeVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_wheelsSuspensionForce as *const _ as usize },
        552usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_wheelsSuspensionForce)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btWheelInfo)).m_skidInfo as *const _ as usize },
        560usize,
        concat!(
            "Alignment of field: ",
            stringify!(btWheelInfo),
            "::",
            stringify!(m_skidInfo)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK11btWheelInfo23getSuspensionRestLengthEv"]
    pub fn btWheelInfo_getSuspensionRestLength(this: *const btWheelInfo) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN11btWheelInfo11updateWheelERK11btRigidBodyRNS_11RaycastInfoE"]
    pub fn btWheelInfo_updateWheel(
        this: *mut btWheelInfo,
        chassis: *const btRigidBody,
        raycastInfo: *mut btWheelInfo_RaycastInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11btWheelInfoC1Ev"]
    pub fn btWheelInfo_btWheelInfo(this: *mut btWheelInfo);
}
extern "C" {
    #[link_name = "\u{1}_ZN11btWheelInfoC1ER27btWheelInfoConstructionInfo"]
    pub fn btWheelInfo_btWheelInfo1(this: *mut btWheelInfo, ci: *mut btWheelInfoConstructionInfo);
}
impl btWheelInfo {
    #[inline]
    pub unsafe fn getSuspensionRestLength(&self) -> btScalar {
        btWheelInfo_getSuspensionRestLength(self)
    }
    #[inline]
    pub unsafe fn updateWheel(
        &mut self,
        chassis: *const btRigidBody,
        raycastInfo: *mut btWheelInfo_RaycastInfo,
    ) {
        btWheelInfo_updateWheel(self, chassis, raycastInfo)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btWheelInfo_btWheelInfo(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(ci: *mut btWheelInfoConstructionInfo) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btWheelInfo_btWheelInfo1(&mut __bindgen_tmp, ci);
        __bindgen_tmp
    }
}
#[repr(C)]
pub struct btActionInterface__bindgen_vtable(::std::os::raw::c_void);
/// Basic interface to allow actions such as vehicles and characters to be updated inside a btDynamicsWorld
#[repr(C)]
#[derive(Debug)]
pub struct btActionInterface {
    pub vtable_: *const btActionInterface__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_btActionInterface() {
    assert_eq!(
        ::std::mem::size_of::<btActionInterface>(),
        8usize,
        concat!("Size of: ", stringify!(btActionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<btActionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(btActionInterface))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btActionInterface12getFixedBodyEv"]
    pub fn btActionInterface_getFixedBody() -> *mut btRigidBody;
}
impl btActionInterface {
    #[inline]
    pub unsafe fn getFixedBody() -> *mut btRigidBody {
        btActionInterface_getFixedBody()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN17btActionInterfaceD0Ev"]
    pub fn btActionInterface_btActionInterface_destructor(this: *mut btActionInterface);
}
extern "C" {
    #[link_name = "\u{1}_ZN17btActionInterface12updateActionEP16btCollisionWorldd"]
    pub fn btActionInterface_updateAction(
        this: *mut ::std::os::raw::c_void,
        collisionWorld: *mut btCollisionWorld,
        deltaTimeStep: btScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17btActionInterface9debugDrawEP12btIDebugDraw"]
    pub fn btActionInterface_debugDraw(
        this: *mut ::std::os::raw::c_void,
        debugDrawer: *mut btIDebugDraw,
    );
}
/// rayCast vehicle, very special constraint that turn a rigidbody into a vehicle.
#[repr(C)]
#[derive(Debug)]
pub struct btRaycastVehicle {
    pub _base: btActionInterface,
    pub m_forwardWS: btAlignedObjectArray<btVector3>,
    pub m_axle: btAlignedObjectArray<btVector3>,
    pub m_forwardImpulse: btAlignedObjectArray<btScalar>,
    pub m_sideImpulse: btAlignedObjectArray<btScalar>,
    /// backwards compatibility
    pub m_userConstraintType: ::std::os::raw::c_int,
    pub m_userConstraintId: ::std::os::raw::c_int,
    pub m_vehicleRaycaster: *mut btVehicleRaycaster,
    pub m_pitchControl: btScalar,
    pub m_steeringValue: btScalar,
    pub m_currentVehicleSpeedKmHour: btScalar,
    pub m_chassisBody: *mut btRigidBody,
    pub m_indexRightAxis: ::std::os::raw::c_int,
    pub m_indexUpAxis: ::std::os::raw::c_int,
    pub m_indexForwardAxis: ::std::os::raw::c_int,
    pub m_wheelInfo: btAlignedObjectArray<btWheelInfo>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btRaycastVehicle_btVehicleTuning {
    pub m_suspensionStiffness: btScalar,
    pub m_suspensionCompression: btScalar,
    pub m_suspensionDamping: btScalar,
    pub m_maxSuspensionTravelCm: btScalar,
    pub m_frictionSlip: btScalar,
    pub m_maxSuspensionForce: btScalar,
}
#[test]
fn bindgen_test_layout_btRaycastVehicle_btVehicleTuning() {
    assert_eq!(
        ::std::mem::size_of::<btRaycastVehicle_btVehicleTuning>(),
        48usize,
        concat!("Size of: ", stringify!(btRaycastVehicle_btVehicleTuning))
    );
    assert_eq!(
        ::std::mem::align_of::<btRaycastVehicle_btVehicleTuning>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(btRaycastVehicle_btVehicleTuning)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRaycastVehicle_btVehicleTuning)).m_suspensionStiffness as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle_btVehicleTuning),
            "::",
            stringify!(m_suspensionStiffness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRaycastVehicle_btVehicleTuning)).m_suspensionCompression as *const _
                as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle_btVehicleTuning),
            "::",
            stringify!(m_suspensionCompression)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRaycastVehicle_btVehicleTuning)).m_suspensionDamping as *const _
                as usize
        },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle_btVehicleTuning),
            "::",
            stringify!(m_suspensionDamping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRaycastVehicle_btVehicleTuning)).m_maxSuspensionTravelCm as *const _
                as usize
        },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle_btVehicleTuning),
            "::",
            stringify!(m_maxSuspensionTravelCm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRaycastVehicle_btVehicleTuning)).m_frictionSlip as *const _ as usize
        },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle_btVehicleTuning),
            "::",
            stringify!(m_frictionSlip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRaycastVehicle_btVehicleTuning)).m_maxSuspensionForce as *const _
                as usize
        },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle_btVehicleTuning),
            "::",
            stringify!(m_maxSuspensionForce)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle15btVehicleTuningC1Ev"]
    pub fn btRaycastVehicle_btVehicleTuning_btVehicleTuning(
        this: *mut btRaycastVehicle_btVehicleTuning,
    );
}
impl btRaycastVehicle_btVehicleTuning {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btRaycastVehicle_btVehicleTuning_btVehicleTuning(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[test]
fn bindgen_test_layout_btRaycastVehicle() {
    assert_eq!(
        ::std::mem::size_of::<btRaycastVehicle>(),
        232usize,
        concat!("Size of: ", stringify!(btRaycastVehicle))
    );
    assert_eq!(
        ::std::mem::align_of::<btRaycastVehicle>(),
        8usize,
        concat!("Alignment of ", stringify!(btRaycastVehicle))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRaycastVehicle)).m_forwardWS as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_forwardWS)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRaycastVehicle)).m_axle as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_axle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRaycastVehicle)).m_forwardImpulse as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_forwardImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRaycastVehicle)).m_sideImpulse as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_sideImpulse)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRaycastVehicle)).m_userConstraintType as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_userConstraintType)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRaycastVehicle)).m_userConstraintId as *const _ as usize },
        140usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_userConstraintId)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRaycastVehicle)).m_vehicleRaycaster as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_vehicleRaycaster)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRaycastVehicle)).m_pitchControl as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_pitchControl)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRaycastVehicle)).m_steeringValue as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_steeringValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const btRaycastVehicle)).m_currentVehicleSpeedKmHour as *const _ as usize
        },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_currentVehicleSpeedKmHour)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRaycastVehicle)).m_chassisBody as *const _ as usize },
        176usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_chassisBody)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRaycastVehicle)).m_indexRightAxis as *const _ as usize },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_indexRightAxis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRaycastVehicle)).m_indexUpAxis as *const _ as usize },
        188usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_indexUpAxis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRaycastVehicle)).m_indexForwardAxis as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_indexForwardAxis)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const btRaycastVehicle)).m_wheelInfo as *const _ as usize },
        200usize,
        concat!(
            "Alignment of field: ",
            stringify!(btRaycastVehicle),
            "::",
            stringify!(m_wheelInfo)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btRaycastVehicle24getChassisWorldTransformEv"]
    pub fn btRaycastVehicle_getChassisWorldTransform(
        this: *const btRaycastVehicle,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle7rayCastER11btWheelInfo"]
    pub fn btRaycastVehicle_rayCast(
        this: *mut btRaycastVehicle,
        wheel: *mut btWheelInfo,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle15resetSuspensionEv"]
    pub fn btRaycastVehicle_resetSuspension(this: *mut btRaycastVehicle);
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btRaycastVehicle16getSteeringValueEi"]
    pub fn btRaycastVehicle_getSteeringValue(
        this: *const btRaycastVehicle,
        wheel: ::std::os::raw::c_int,
    ) -> btScalar;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle16setSteeringValueEdi"]
    pub fn btRaycastVehicle_setSteeringValue(
        this: *mut btRaycastVehicle,
        steering: btScalar,
        wheel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle16applyEngineForceEdi"]
    pub fn btRaycastVehicle_applyEngineForce(
        this: *mut btRaycastVehicle,
        force: btScalar,
        wheel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btRaycastVehicle19getWheelTransformWSEi"]
    pub fn btRaycastVehicle_getWheelTransformWS(
        this: *const btRaycastVehicle,
        wheelIndex: ::std::os::raw::c_int,
    ) -> *const btTransform;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle20updateWheelTransformEib"]
    pub fn btRaycastVehicle_updateWheelTransform(
        this: *mut btRaycastVehicle,
        wheelIndex: ::std::os::raw::c_int,
        interpolatedTransform: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle8addWheelERK9btVector3S2_S2_ddRKNS_15btVehicleTuningEb"]
    pub fn btRaycastVehicle_addWheel(
        this: *mut btRaycastVehicle,
        connectionPointCS0: *const btVector3,
        wheelDirectionCS0: *const btVector3,
        wheelAxleCS: *const btVector3,
        suspensionRestLength: btScalar,
        wheelRadius: btScalar,
        tuning: *const btRaycastVehicle_btVehicleTuning,
        isFrontWheel: bool,
    ) -> *mut btWheelInfo;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btRaycastVehicle12getNumWheelsEv"]
    pub fn btRaycastVehicle_getNumWheels(this: *const btRaycastVehicle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btRaycastVehicle12getWheelInfoEi"]
    pub fn btRaycastVehicle_getWheelInfo(
        this: *const btRaycastVehicle,
        index: ::std::os::raw::c_int,
    ) -> *const btWheelInfo;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle12getWheelInfoEi"]
    pub fn btRaycastVehicle_getWheelInfo1(
        this: *mut btRaycastVehicle,
        index: ::std::os::raw::c_int,
    ) -> *mut btWheelInfo;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle23updateWheelTransformsWSER11btWheelInfob"]
    pub fn btRaycastVehicle_updateWheelTransformsWS(
        this: *mut btRaycastVehicle,
        wheel: *mut btWheelInfo,
        interpolatedTransform: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle8setBrakeEdi"]
    pub fn btRaycastVehicle_setBrake(
        this: *mut btRaycastVehicle,
        brake: btScalar,
        wheelIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle15setPitchControlEd"]
    pub fn btRaycastVehicle_setPitchControl(this: *mut btRaycastVehicle, pitch: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle16updateSuspensionEd"]
    pub fn btRaycastVehicle_updateSuspension(this: *mut btRaycastVehicle, deltaTime: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle12getRigidBodyEv"]
    pub fn btRaycastVehicle_getRigidBody(this: *mut btRaycastVehicle) -> *mut btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btRaycastVehicle12getRigidBodyEv"]
    pub fn btRaycastVehicle_getRigidBody1(this: *const btRaycastVehicle) -> *const btRigidBody;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btRaycastVehicle12getRightAxisEv"]
    pub fn btRaycastVehicle_getRightAxis(this: *const btRaycastVehicle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btRaycastVehicle9getUpAxisEv"]
    pub fn btRaycastVehicle_getUpAxis(this: *const btRaycastVehicle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btRaycastVehicle14getForwardAxisEv"]
    pub fn btRaycastVehicle_getForwardAxis(this: *const btRaycastVehicle) -> ::std::os::raw::c_int;
}
extern "C" {

    /// Worldspace forward vector

    #[link_name = "\u{1}_ZNK16btRaycastVehicle16getForwardVectorEv"]
    pub fn btRaycastVehicle_getForwardVector(this: *const btRaycastVehicle) -> btVector3;
}
extern "C" {

    /// Velocity of vehicle (positive if velocity vector has same direction as foward vector)

    #[link_name = "\u{1}_ZNK16btRaycastVehicle21getCurrentSpeedKmHourEv"]
    pub fn btRaycastVehicle_getCurrentSpeedKmHour(this: *const btRaycastVehicle) -> btScalar;
}
extern "C" {

    /// backwards compatibility

    #[link_name = "\u{1}_ZNK16btRaycastVehicle21getUserConstraintTypeEv"]
    pub fn btRaycastVehicle_getUserConstraintType(
        this: *const btRaycastVehicle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle21setUserConstraintTypeEi"]
    pub fn btRaycastVehicle_setUserConstraintType(
        this: *mut btRaycastVehicle,
        userConstraintType: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle19setUserConstraintIdEi"]
    pub fn btRaycastVehicle_setUserConstraintId(
        this: *mut btRaycastVehicle,
        uid: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK16btRaycastVehicle19getUserConstraintIdEv"]
    pub fn btRaycastVehicle_getUserConstraintId(
        this: *const btRaycastVehicle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicleC1ERKNS_15btVehicleTuningEP11btRigidBodyP18btVehicleRaycaster"]
    pub fn btRaycastVehicle_btRaycastVehicle(
        this: *mut btRaycastVehicle,
        tuning: *const btRaycastVehicle_btVehicleTuning,
        chassis: *mut btRigidBody,
        raycaster: *mut btVehicleRaycaster,
    );
}
impl btRaycastVehicle {
    #[inline]
    pub unsafe fn getChassisWorldTransform(&self) -> *const btTransform {
        btRaycastVehicle_getChassisWorldTransform(self)
    }
    #[inline]
    pub unsafe fn rayCast(&mut self, wheel: *mut btWheelInfo) -> btScalar {
        btRaycastVehicle_rayCast(self, wheel)
    }
    #[inline]
    pub unsafe fn resetSuspension(&mut self) {
        btRaycastVehicle_resetSuspension(self)
    }
    #[inline]
    pub unsafe fn getSteeringValue(&self, wheel: ::std::os::raw::c_int) -> btScalar {
        btRaycastVehicle_getSteeringValue(self, wheel)
    }
    #[inline]
    pub unsafe fn setSteeringValue(&mut self, steering: btScalar, wheel: ::std::os::raw::c_int) {
        btRaycastVehicle_setSteeringValue(self, steering, wheel)
    }
    #[inline]
    pub unsafe fn applyEngineForce(&mut self, force: btScalar, wheel: ::std::os::raw::c_int) {
        btRaycastVehicle_applyEngineForce(self, force, wheel)
    }
    #[inline]
    pub unsafe fn getWheelTransformWS(
        &self,
        wheelIndex: ::std::os::raw::c_int,
    ) -> *const btTransform {
        btRaycastVehicle_getWheelTransformWS(self, wheelIndex)
    }
    #[inline]
    pub unsafe fn updateWheelTransform(
        &mut self,
        wheelIndex: ::std::os::raw::c_int,
        interpolatedTransform: bool,
    ) {
        btRaycastVehicle_updateWheelTransform(self, wheelIndex, interpolatedTransform)
    }
    #[inline]
    pub unsafe fn addWheel(
        &mut self,
        connectionPointCS0: *const btVector3,
        wheelDirectionCS0: *const btVector3,
        wheelAxleCS: *const btVector3,
        suspensionRestLength: btScalar,
        wheelRadius: btScalar,
        tuning: *const btRaycastVehicle_btVehicleTuning,
        isFrontWheel: bool,
    ) -> *mut btWheelInfo {
        btRaycastVehicle_addWheel(
            self,
            connectionPointCS0,
            wheelDirectionCS0,
            wheelAxleCS,
            suspensionRestLength,
            wheelRadius,
            tuning,
            isFrontWheel,
        )
    }
    #[inline]
    pub unsafe fn getNumWheels(&self) -> ::std::os::raw::c_int {
        btRaycastVehicle_getNumWheels(self)
    }
    #[inline]
    pub unsafe fn getWheelInfo(&self, index: ::std::os::raw::c_int) -> *const btWheelInfo {
        btRaycastVehicle_getWheelInfo(self, index)
    }
    #[inline]
    pub unsafe fn getWheelInfo1(&mut self, index: ::std::os::raw::c_int) -> *mut btWheelInfo {
        btRaycastVehicle_getWheelInfo1(self, index)
    }
    #[inline]
    pub unsafe fn updateWheelTransformsWS(
        &mut self,
        wheel: *mut btWheelInfo,
        interpolatedTransform: bool,
    ) {
        btRaycastVehicle_updateWheelTransformsWS(self, wheel, interpolatedTransform)
    }
    #[inline]
    pub unsafe fn setBrake(&mut self, brake: btScalar, wheelIndex: ::std::os::raw::c_int) {
        btRaycastVehicle_setBrake(self, brake, wheelIndex)
    }
    #[inline]
    pub unsafe fn setPitchControl(&mut self, pitch: btScalar) {
        btRaycastVehicle_setPitchControl(self, pitch)
    }
    #[inline]
    pub unsafe fn updateSuspension(&mut self, deltaTime: btScalar) {
        btRaycastVehicle_updateSuspension(self, deltaTime)
    }
    #[inline]
    pub unsafe fn getRigidBody(&mut self) -> *mut btRigidBody {
        btRaycastVehicle_getRigidBody(self)
    }
    #[inline]
    pub unsafe fn getRigidBody1(&self) -> *const btRigidBody {
        btRaycastVehicle_getRigidBody1(self)
    }
    #[inline]
    pub unsafe fn getRightAxis(&self) -> ::std::os::raw::c_int {
        btRaycastVehicle_getRightAxis(self)
    }
    #[inline]
    pub unsafe fn getUpAxis(&self) -> ::std::os::raw::c_int {
        btRaycastVehicle_getUpAxis(self)
    }
    #[inline]
    pub unsafe fn getForwardAxis(&self) -> ::std::os::raw::c_int {
        btRaycastVehicle_getForwardAxis(self)
    }
    #[inline]
    pub unsafe fn getForwardVector(&self) -> btVector3 {
        btRaycastVehicle_getForwardVector(self)
    }
    #[inline]
    pub unsafe fn getCurrentSpeedKmHour(&self) -> btScalar {
        btRaycastVehicle_getCurrentSpeedKmHour(self)
    }
    #[inline]
    pub unsafe fn getUserConstraintType(&self) -> ::std::os::raw::c_int {
        btRaycastVehicle_getUserConstraintType(self)
    }
    #[inline]
    pub unsafe fn setUserConstraintType(&mut self, userConstraintType: ::std::os::raw::c_int) {
        btRaycastVehicle_setUserConstraintType(self, userConstraintType)
    }
    #[inline]
    pub unsafe fn setUserConstraintId(&mut self, uid: ::std::os::raw::c_int) {
        btRaycastVehicle_setUserConstraintId(self, uid)
    }
    #[inline]
    pub unsafe fn getUserConstraintId(&self) -> ::std::os::raw::c_int {
        btRaycastVehicle_getUserConstraintId(self)
    }
    #[inline]
    pub unsafe fn new(
        tuning: *const btRaycastVehicle_btVehicleTuning,
        chassis: *mut btRigidBody,
        raycaster: *mut btVehicleRaycaster,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btRaycastVehicle_btRaycastVehicle(&mut __bindgen_tmp, tuning, chassis, raycaster);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicleD0Ev"]
    pub fn btRaycastVehicle_btRaycastVehicle_destructor(this: *mut btRaycastVehicle);
}
extern "C" {

    /// btActionInterface interface

    #[link_name = "\u{1}_ZN16btRaycastVehicle12updateActionEP16btCollisionWorldd"]
    pub fn btRaycastVehicle_updateAction(
        this: *mut ::std::os::raw::c_void,
        collisionWorld: *mut btCollisionWorld,
        step: btScalar,
    );
}
extern "C" {

    /// btActionInterface interface

    #[link_name = "\u{1}_ZN16btRaycastVehicle9debugDrawEP12btIDebugDraw"]
    pub fn btRaycastVehicle_debugDraw(
        this: *mut ::std::os::raw::c_void,
        debugDrawer: *mut btIDebugDraw,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle13updateVehicleEd"]
    pub fn btRaycastVehicle_updateVehicle(this: *mut ::std::os::raw::c_void, step: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle14updateFrictionEd"]
    pub fn btRaycastVehicle_updateFriction(this: *mut ::std::os::raw::c_void, timeStep: btScalar);
}
extern "C" {
    #[link_name = "\u{1}_ZN16btRaycastVehicle19setCoordinateSystemEiii"]
    pub fn btRaycastVehicle_setCoordinateSystem(
        this: *mut ::std::os::raw::c_void,
        rightIndex: ::std::os::raw::c_int,
        upIndex: ::std::os::raw::c_int,
        forwardIndex: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct btDefaultVehicleRaycaster {
    pub _base: btVehicleRaycaster,
    pub m_dynamicsWorld: *mut btDynamicsWorld,
}
#[test]
fn bindgen_test_layout_btDefaultVehicleRaycaster() {
    assert_eq!(
        ::std::mem::size_of::<btDefaultVehicleRaycaster>(),
        16usize,
        concat!("Size of: ", stringify!(btDefaultVehicleRaycaster))
    );
    assert_eq!(
        ::std::mem::align_of::<btDefaultVehicleRaycaster>(),
        8usize,
        concat!("Alignment of ", stringify!(btDefaultVehicleRaycaster))
    );
    assert_eq!(
        unsafe { &(*(0 as *const btDefaultVehicleRaycaster)).m_dynamicsWorld as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(btDefaultVehicleRaycaster),
            "::",
            stringify!(m_dynamicsWorld)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN25btDefaultVehicleRaycasterC1EP15btDynamicsWorld"]
    pub fn btDefaultVehicleRaycaster_btDefaultVehicleRaycaster(
        this: *mut btDefaultVehicleRaycaster,
        world: *mut btDynamicsWorld,
    );
}
impl btDefaultVehicleRaycaster {
    #[inline]
    pub unsafe fn new(world: *mut btDynamicsWorld) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        btDefaultVehicleRaycaster_btDefaultVehicleRaycaster(&mut __bindgen_tmp, world);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN25btDefaultVehicleRaycaster7castRayERK9btVector3S2_RN18btVehicleRaycaster24btVehicleRaycasterResultE"]
    pub fn btDefaultVehicleRaycaster_castRay(
        this: *mut ::std::os::raw::c_void,
        from: *const btVector3,
        to: *const btVector3,
        result: *mut btVehicleRaycaster_btVehicleRaycasterResult,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __va_list_tag)).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __va_list_tag)).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __va_list_tag)).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __va_list_tag)).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_class_btCollisionObject_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btCollisionObject>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btCollisionObject>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btCollisionObject>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btCollisionObject>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_const_btCollisionObject_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*const btCollisionObject>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*const btCollisionObject>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*const btCollisionObject>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*const btCollisionObject>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_btPersistentManifold_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btPersistentManifold>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btPersistentManifold>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btPersistentManifold>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btPersistentManifold>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btBroadphasePair_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btBroadphasePair>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btBroadphasePair>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btBroadphasePair>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btBroadphasePair>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_int_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_btCollisionObject_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btCollisionObject>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btCollisionObject>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btCollisionObject>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btCollisionObject>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_const_btCollisionObject_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*const btCollisionObject>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*const btCollisionObject>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*const btCollisionObject>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*const btCollisionObject>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btVector3_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btVector3>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btVector3>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btVector3>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btVector3>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btVector3_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btVector3>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btVector3>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btVector3>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btVector3>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btScalar_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btScalar>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btScalar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btScalar>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btScalar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btVector3_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btVector3>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btVector3>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btVector3>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btVector3>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btIndexedMesh_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btIndexedMesh>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btIndexedMesh>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btIndexedMesh>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btIndexedMesh>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btVector3_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btVector3>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btVector3>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btVector3>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btVector3>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btScalar_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btScalar>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btScalar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btScalar>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btScalar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<::std::os::raw::c_uint>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<::std::os::raw::c_ushort>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_ushort>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<::std::os::raw::c_ushort>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_ushort>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btOptimizedBvhNode_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btOptimizedBvhNode>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btOptimizedBvhNode>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btOptimizedBvhNode>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btOptimizedBvhNode>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btQuantizedBvhNode_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btQuantizedBvhNode>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btQuantizedBvhNode>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btQuantizedBvhNode>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btQuantizedBvhNode>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btBvhSubtreeInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btBvhSubtreeInfo>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btBvhSubtreeInfo>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btBvhSubtreeInfo>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btBvhSubtreeInfo>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_int_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_int_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_struct_btQuantizedBvhDoubleData_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btQuantizedBvhDoubleData>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btQuantizedBvhDoubleData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btQuantizedBvhDoubleData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btQuantizedBvhDoubleData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_struct_btQuantizedBvhFloatData_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btQuantizedBvhFloatData>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btQuantizedBvhFloatData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btQuantizedBvhFloatData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btQuantizedBvhFloatData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_struct_btCollisionShapeData_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btCollisionShapeData>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btCollisionShapeData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btCollisionShapeData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btCollisionShapeData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_struct_btDynamicsWorldDoubleData_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btDynamicsWorldDoubleData>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btDynamicsWorldDoubleData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btDynamicsWorldDoubleData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btDynamicsWorldDoubleData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_struct_btDynamicsWorldFloatData_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btDynamicsWorldFloatData>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btDynamicsWorldFloatData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btDynamicsWorldFloatData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btDynamicsWorldFloatData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_struct_btRigidBodyDoubleData_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btRigidBodyDoubleData>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btRigidBodyDoubleData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btRigidBodyDoubleData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btRigidBodyDoubleData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_struct_btRigidBodyFloatData_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btRigidBodyFloatData>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btRigidBodyFloatData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btRigidBodyFloatData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btRigidBodyFloatData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_struct_btCollisionObjectDoubleData_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btCollisionObjectDoubleData>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btCollisionObjectDoubleData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btCollisionObjectDoubleData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btCollisionObjectDoubleData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_struct_btCollisionObjectFloatData_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btCollisionObjectFloatData>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btCollisionObjectFloatData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btCollisionObjectFloatData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btCollisionObjectFloatData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_struct_btTypedConstraintFloatData_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btTypedConstraintFloatData>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btTypedConstraintFloatData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btTypedConstraintFloatData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btTypedConstraintFloatData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_struct_btTypedConstraintDoubleData_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btTypedConstraintDoubleData>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btTypedConstraintDoubleData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btTypedConstraintDoubleData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btTypedConstraintDoubleData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_struct_btTypedConstraintData_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btTypedConstraintData>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btTypedConstraintData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btTypedConstraintData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btTypedConstraintData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_btSoftBodyFloatData_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btSoftBodyFloatData>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btSoftBodyFloatData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btSoftBodyFloatData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btSoftBodyFloatData>)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBodyFloatData {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_btSoftBodyDoubleData_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btSoftBodyDoubleData>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btSoftBodyDoubleData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btSoftBodyDoubleData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btSoftBodyDoubleData>)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btSoftBodyDoubleData {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut ::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut ::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut ::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut ::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut ::std::os::raw::c_short>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut ::std::os::raw::c_short>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut ::std::os::raw::c_short>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut ::std::os::raw::c_short>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<::std::os::raw::c_short>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_short>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<::std::os::raw::c_short>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_short>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btHashMap_open0_btHashInt_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btHashMap<btHashInt, ::std::os::raw::c_int>>(),
        128usize,
        concat!(
            "Size of template specialization: ",
            stringify ! ( btHashMap < btHashInt , :: std :: os :: raw :: c_int > )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btHashMap<btHashInt, ::std::os::raw::c_int>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! ( btHashMap < btHashInt , :: std :: os :: raw :: c_int > )
        )
    );
}
#[test]
fn __bindgen_test_layout_btHashMap_open0_btHashString_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btHashMap<btHashString, ::std::os::raw::c_int>>(),
        128usize,
        concat!(
            "Size of template specialization: ",
            stringify ! ( btHashMap < btHashString , :: std :: os :: raw :: c_int > )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btHashMap<btHashString, ::std::os::raw::c_int>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! ( btHashMap < btHashString , :: std :: os :: raw :: c_int > )
        )
    );
}
#[test]
fn __bindgen_test_layout_btHashMap_open0_btHashPtr_ptr_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btHashMap<btHashPtr, *mut ::std::os::raw::c_void>>(),
        128usize,
        concat!(
            "Size of template specialization: ",
            stringify ! ( btHashMap < btHashPtr , * mut :: std :: os :: raw :: c_void > )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btHashMap<btHashPtr, *mut ::std::os::raw::c_void>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! ( btHashMap < btHashPtr , * mut :: std :: os :: raw :: c_void > )
        )
    );
}
#[test]
fn __bindgen_test_layout_btHashMap_open0_btHashPtr_ptr_const_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btHashMap<btHashPtr, *const ::std::os::raw::c_char>>(),
        128usize,
        concat!(
            "Size of template specialization: ",
            stringify ! ( btHashMap < btHashPtr , * const :: std :: os :: raw :: c_char > )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btHashMap<btHashPtr, *const ::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! ( btHashMap < btHashPtr , * const :: std :: os :: raw :: c_char > )
        )
    );
}
#[test]
fn __bindgen_test_layout_btHashMap_open0_btHashPtr_btPointerUid_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btHashMap<btHashPtr, btPointerUid>>(),
        128usize,
        concat!(
            "Size of template specialization: ",
            stringify ! ( btHashMap < btHashPtr , btPointerUid > )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btHashMap<btHashPtr, btPointerUid>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! ( btHashMap < btHashPtr , btPointerUid > )
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_btChunk_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btChunk>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btChunk>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btChunk>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btChunk>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btHashMap_open0_btHashPtr_ptr_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<btHashMap<btHashPtr, *mut ::std::os::raw::c_void>>(),
        128usize,
        concat!(
            "Size of template specialization: ",
            stringify ! ( btHashMap < btHashPtr , * mut :: std :: os :: raw :: c_void > )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btHashMap<btHashPtr, *mut ::std::os::raw::c_void>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! ( btHashMap < btHashPtr , * mut :: std :: os :: raw :: c_void > )
        )
    );
}
#[test]
fn __bindgen_test_layout_btHashMap_open0_btHashInt_btTriangleInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btHashMap<btHashInt, btTriangleInfo>>(),
        128usize,
        concat!(
            "Size of template specialization: ",
            stringify ! ( btHashMap < btHashInt , btTriangleInfo > )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btHashMap<btHashInt, btTriangleInfo>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! ( btHashMap < btHashInt , btTriangleInfo > )
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btCompoundShapeChild_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btCompoundShapeChild>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btCompoundShapeChild>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btCompoundShapeChild>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btCompoundShapeChild>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btVector3_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btVector3>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btVector3>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btVector3>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btVector3>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btScalar_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btScalar>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btScalar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btScalar>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btScalar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_btPersistentManifold_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btPersistentManifold>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btPersistentManifold>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btPersistentManifold>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btPersistentManifold>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_const_btDbvtNode_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*const btDbvtNode>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*const btDbvtNode>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*const btDbvtNode>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*const btDbvtNode>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btDbvt_sStkNN_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btDbvt_sStkNN>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btDbvt_sStkNN>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btDbvt_sStkNN>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btDbvt_sStkNN>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_const_btDbvtNode_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*const btDbvtNode>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*const btDbvtNode>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*const btDbvtNode>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*const btDbvtNode>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_const_btDbvtNode_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*const btDbvtNode>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*const btDbvtNode>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*const btDbvtNode>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*const btDbvtNode>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_int_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btDbvt_sStkNPS_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btDbvt_sStkNPS>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btDbvt_sStkNPS>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btDbvt_sStkNPS>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btDbvt_sStkNPS>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_const_btDbvtNode_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*const btDbvtNode>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*const btDbvtNode>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*const btDbvtNode>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*const btDbvtNode>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_const_btDbvtNode_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*const btDbvtNode>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*const btDbvtNode>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*const btDbvtNode>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*const btDbvtNode>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btAlignedObjectArray_open1_ptr_const_btDbvtNode_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btAlignedObjectArray<*const btDbvtNode>>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<
                btAlignedObjectArray<*const btDbvtNode>,
            >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btAlignedObjectArray<*const btDbvtNode>>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<
                btAlignedObjectArray<*const btDbvtNode>,
            >)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_const_btDbvtNode_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*const btDbvtNode>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*const btDbvtNode>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*const btDbvtNode>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*const btDbvtNode>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAxisSweep3Internal_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAxisSweep3Internal<::std::os::raw::c_ushort>>(),
        224usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAxisSweep3Internal<::std::os::raw::c_ushort>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAxisSweep3Internal<::std::os::raw::c_ushort>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAxisSweep3Internal<::std::os::raw::c_ushort>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAxisSweep3Internal_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAxisSweep3Internal<::std::os::raw::c_uint>>(),
        224usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAxisSweep3Internal<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAxisSweep3Internal<::std::os::raw::c_uint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAxisSweep3Internal<::std::os::raw::c_uint>)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btClockData {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_btTypedConstraint_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btTypedConstraint>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btTypedConstraint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btTypedConstraint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btTypedConstraint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_btTypedConstraint_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btTypedConstraint>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btTypedConstraint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btTypedConstraint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btTypedConstraint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_btRigidBody_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btRigidBody>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btRigidBody>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btRigidBody>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btRigidBody>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_btActionInterface_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btActionInterface>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btActionInterface>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btActionInterface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btActionInterface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_btPersistentManifold_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btPersistentManifold>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btPersistentManifold>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btPersistentManifold>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btPersistentManifold>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_ptr_btTypedConstraint_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<*mut btTypedConstraint>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btTypedConstraint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<*mut btTypedConstraint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<*mut btTypedConstraint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btSolverConstraint_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btSolverConstraint>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btSolverConstraint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btSolverConstraint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btSolverConstraint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btSolverBody_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btSolverBody>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btSolverBody>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btSolverBody>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btSolverBody>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_int_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_int_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_int_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btTypedConstraint_btConstraintInfo1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btTypedConstraint_btConstraintInfo1>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btTypedConstraint_btConstraintInfo1>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btTypedConstraint_btConstraintInfo1>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btTypedConstraint_btConstraintInfo1>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_int_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<::std::os::raw::c_int>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<::std::os::raw::c_int>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btVector3_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btVector3>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btVector3>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btVector3>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btVector3>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btVector3_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btVector3>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btVector3>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btVector3>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btVector3>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btScalar_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btScalar>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btScalar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btScalar>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btScalar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btScalar_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btScalar>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btScalar>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btScalar>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btScalar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_btAlignedObjectArray_open0_btWheelInfo_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<btAlignedObjectArray<btWheelInfo>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(btAlignedObjectArray<btWheelInfo>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<btAlignedObjectArray<btWheelInfo>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(btAlignedObjectArray<btWheelInfo>)
        )
    );
}
